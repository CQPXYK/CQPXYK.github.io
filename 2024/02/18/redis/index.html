<!DOCTYPE html>
<html>
  <head>
  <meta http-equiv="content-type" content="text/html; charset=utf-8">
  <!--<meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport">-->
  <meta name="description" content="要有一个从输入到输出的过程">
  <meta name="keyword" content="">
  
    <link rel="shortcut icon" href="/css/images/logo.png">
  
  <title>
    
      Redis | CQ&#39;s Blog
    
  </title>
  <link href="//cdnjs.cloudflare.com/ajax/libs/font-awesome/4.7.0/css/font-awesome.min.css" rel="stylesheet">
  <link href="//cdnjs.cloudflare.com/ajax/libs/nprogress/0.2.0/nprogress.min.css" rel="stylesheet">
  <link href="//cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/tomorrow.min.css" rel="stylesheet">
  
<link rel="stylesheet" href="/css/style.css">

  
  <script src="//cdnjs.cloudflare.com/ajax/libs/jquery/3.2.1/jquery.min.js"></script>
  <script src="//cdnjs.cloudflare.com/ajax/libs/geopattern/1.2.3/js/geopattern.min.js"></script>
  <script src="//cdnjs.cloudflare.com/ajax/libs/nprogress/0.2.0/nprogress.min.js"></script>
  
  
  
  


  
  
    
<script src="/js/local-search.js"></script>


<meta name="generator" content="Hexo 5.4.2"></head>
<div class="wechat-share">
  <img src="/css/images/logo.png" />
</div>
  <body>
    <header class="header fixed-header">
  <div class="header-container">
    <a class="home-link" href="/">
      <div class="logo"></div>
      <span>CQ's Blog</span>
    </a>
    <ul class="right-list">
      
        <li class="list-item">
          
            <a href="/" class="item-link">Home</a>
          
        </li>
      
        <li class="list-item">
          
            <a href="/categories/" class="item-link">Categories</a>
          
        </li>
      
        <li class="list-item">
          
            <a href="/records" class="item-link">Records</a>
          
        </li>
      
        <li class="list-item">
          
            <a href="/scratches/" class="item-link">Scratches</a>
          
        </li>
      
        <li class="list-item">
          
            <a href="/archives/" class="item-link">Archives</a>
          
        </li>
      
      
        <li class="menu-item menu-item-search right-list">
    <a role="button" class="popup-trigger">
        <i class="fa fa-search fa-fw"></i>
    </a>
</li>
      
    </ul>
    <div class="menu">
      <span class="icon-bar"></span>
      <span class="icon-bar"></span>
      <span class="icon-bar"></span>
    </div>
    <div class="menu-mask">
      <ul class="menu-list">
        
          <li class="menu-item">
            
              <a href="/" class="menu-link">Home</a>
            
          </li>
        
          <li class="menu-item">
            
              <a href="/categories/" class="menu-link">Categories</a>
            
          </li>
        
          <li class="menu-item">
            
              <a href="/records" class="menu-link">Records</a>
            
          </li>
        
          <li class="menu-item">
            
              <a href="/scratches/" class="menu-link">Scratches</a>
            
          </li>
        
          <li class="menu-item">
            
              <a href="/archives/" class="menu-link">Archives</a>
            
          </li>
        
      </ul>
    </div>
    
      <div class="search-pop-overlay">
    <div class="popup search-popup">
        <div class="search-header">
            <span class="search-icon">
                <i class="fa fa-search"></i>
            </span>
            <div class="search-input-container">
                <input autocomplete="off" autocapitalize="off"
                    placeholder="Please enter your keyword(s) to search." spellcheck="false"
                    type="search" class="search-input">
            </div>
            <span class="popup-btn-close">
                <i class="fa fa-times-circle"></i>
            </span>
        </div>
        <div id="search-result">
            <div id="no-result">
                <i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i>
            </div>
        </div>
    </div>
</div>
    
  </div>
</header>

    <div id="article-banner">
  <h2>Redis</h2>
  <!--<p class="post-date">2024-02-18</p>
  <div class="arrow-down">
    <a href="javascript:;"></a>
  </div>-->
</div>
<main class="app-body flex-box">
  <!-- Article START -->
  <article class="post-article">
    <section class="markdown-content"><h1 id="特性概述"><a href="#特性概述" class="headerlink" title="特性概述"></a>特性概述</h1><p>Redis 是一个内存数据库，设计目标是高性能、高可用、高可扩展性以及最终一致性。</p>
<ul>
<li>通信协议<ul>
<li>Redis 采用自己设计的一种基于 TCP 协议的文本协议（Redis Serialization Protocol, RESP）进行客户端与服务端之间的通信</li>
<li>RESP 的每条请求命令由多个参数组成，命令名称就是第一个参数，RESP 的请求和响应都以<code>\r\n</code>作为分隔符，简单、高效、易于解析</li>
<li>除了基本的 GET、SET 命令操作，Redis 还支持事务、Lua 脚本、管道等高级功能，这些功能都是基于 RESP 实现的</li>
</ul>
</li>
<li>并发模型<ul>
<li>Redis 操作基本都是基于内存的，基本不存在磁盘 I/O，几乎不存在 CPU 资源浪费，无需通过多线程技术来提升 CPU 利用率，因此 Redis 使用复杂度更低的单线程处理数据请求即可，单线程是指 Redis 只有网络请求模块和数据操作模块是单线程的，其他的诸如持久化模块、集群支撑模块等是多线程的）</li>
<li>在单线程的基础上，Redis 还采用 I/O 多路复用来通过单个线程同时处理多个客户端连接，提升了 I/O 利用率，随着业务 QPS 增大，由于 I/O 多路复用本质上是同步阻塞型 I/O，此时，限制 Redis 的性能瓶颈就是网络 I/O</li>
<li>在 Redis 6.0 中，引入了多线程机制来减少了网络 I/O 等待，也更加充分地利用了 CPU 多核优势，该多线程机制仅针对网络请求和网络响应，数据的读写操作仍然是单线程处理的，因此并不会存在并发问题</li>
</ul>
</li>
<li>事务机制<ul>
<li>Redis 事务的主要目的是保证多个命令执行的并发原子性，即多个命令操作不可拆分，不会被打断</li>
<li>Redis 事务不支持回滚，在事务执行过程中发生错误会继续执行剩下的命令，因此无法保证数据库事务原子性</li>
</ul>
</li>
<li>原子性执行 Lua 脚本<ul>
<li>Lua 是一种高效、轻量、小巧、可扩展的脚本语言，可以在多种操作系统上运行，设计目的是嵌入应用程序中，为应用程序提供灵活的扩展和定制功能，在功能上完全可以取代 Shell、Perl</li>
<li>Redis 会将 Lua 脚本封装成一个单独的事务，这个单独的事务在 Redis 服务器运行过程中，新的客户端请求会被暂存起来直到 Lua 脚本处理完毕后才会恢复请求，也就是说 Lua 脚本的执行不可拆分，执行中间不会被其他命令插入</li>
<li>如果 Lua 脚本中的命令产生错误，事务不会回滚，即 Redis 仅保证 Lua 脚本执行的并发原子性，但不保证事务原子性</li>
</ul>
</li>
<li>原子性执行命令<ul>
<li>Redis 中的所有命令都是在主线程中顺序执行的，每个命令在执行时不会被其他命令打断，因此所有命令的执行都可以保证并发原子性</li>
<li>虽然单个命令本身是原子性的，但是在实际应用中，多个命令组合可能会导致数据一致性问题，这种情况下需要通过 Redis 事务或分布式锁来保证数据的一致性</li>
</ul>
</li>
<li>数据持久化<ul>
<li>Redis 通过一些持久化方式（RDB、AOF、混合）来将数据持久化到磁盘上，从而尽可能避免数据丢失</li>
<li>RDB 是将 Redis 的内存中的数据定期保存到磁盘上，以防止数据在 Redis 进程异常退出等情况下丢失，快照文件小、恢复速度快，适合做备份和灾难恢复，但依旧可能会丢数据（最后一次快照之后的数据）</li>
<li>AOF 是将 Redis 所有的写操作追加到 AOF (Append Only File) 文件的末尾，从而记录 Redis 服务器运行期间所有的修改，当 Redis 重启时可以通过执行 AOF 文件中保存的写操作来恢复数据，可以实现更高的数据可靠性，支持更细粒度的数据恢复，适合做数据存档和备份，但文件大占用空间多，每次写操作都需要写磁盘，即写操作负载高</li>
<li>AOF 有三种数据写回策略，分别是 Always（每个写命令执行完立马同步地将日志写回到磁盘）、Everysec（每个写命令执行完先把日志写到 AOF 文件的内存缓冲区，每隔一秒把缓冲区内容写回磁盘）、No（每个写命令执行完先把日志写到 AOF 文件的内存缓冲区，由操作系统决定何时将缓冲区内容写回磁盘）</li>
<li>RDB 和 AOF 混合持久化会在开头将持久化数据以 RDB 的格式写入到 AOF 文件开头，之后的数据再以 AOF 格式化追加到文件末尾，从而结合 RDB 和 AOF 的优点，但会使得 AOF 文件的可读性变差</li>
<li>持久化机制也不是完全可靠的（即便是基于 Always 的 AOF 持久化），并不能完全保证数据不会丢失</li>
</ul>
</li>
<li>数据过期<ul>
<li>Redis 通过设置过期时间来控制键值对的生命周期，过期策略采用定期删除和惰性删除相结合的方式</li>
<li>定期删除是指 Redis 默认每隔 100 ms 就随机抽取一些设置了过期时间的 key，将已过期的 key 删除但不会立即释放内存，而是把这些 key 标记为已过期并放入一个专门的链表中，当 Redis 的内存使用率达到一定阈值时，会这些已过期的 key 进行一次内存回收，可以确保过期的 key 能够被及时删除，但是扫描 key 会占用 CPU 资源，可能会影响 Redis 性能</li>
<li>惰性删除是指一个已经过期的 key 并不会被马上删除，而是在访问这个 key 时才会触发删除操作，可以节省 CPU 资源，但是会占用更多内存空间</li>
</ul>
</li>
<li>内存管理方式<ul>
<li>Redis 将数据存储在内存中，内存的数据读写本身就比磁盘更快，Redis 还采用一些复杂的内存管理方式，也支持很多内存优化策略</li>
<li>Redis 的虚拟内存机制会在 Redis 使用的内存超过了指定阈值时，将部分不常用的键值对转移到磁盘上，而在需要访问被转移到磁盘上的数据时，又将数据读取到内存中，虚拟内存机制虽然可以节省内存，但同时也会带来一定的性能损失，在实际应用中应该根据具体的应用场景和硬件条件进行调整</li>
<li>Redis 的内存淘汰策略用于在内存满了之后决定哪些 key 被删除<ul>
<li>noeviction，不淘汰任何 key，而是直接返回错误信息</li>
<li>allkeys-lru，淘汰最近最少使用的 key</li>
<li>volatile-lru，在设置了过期时间的 keys 中，淘汰最近最少使用的 key</li>
<li>allkeys-random，随机淘汰一个 key</li>
<li>volatile-random，在设置了过期时间的 keys 中，随机淘汰一个 key</li>
<li>volatile-ttl，在设置了过期时间的 keys 中，淘汰剩余时间最短的 key</li>
<li>volatile-lfu，在设置了过期时间的 keys 中，淘汰访问频率最低的 key</li>
<li>allkeys-lfu，淘汰访问频率最低的 key</li>
</ul>
</li>
</ul>
</li>
</ul>
<h1 id="集群模式"><a href="#集群模式" class="headerlink" title="集群模式"></a>集群模式</h1><p>Redis 主要有三种集群模式</p>
<ul>
<li>主从复制模式<ul>
<li>主从复制模式是 Redis 最简单的集群模式，包括一个主节点和多个从节点，主节点会负责所有的读写操作，从节点作为主节点的数据副本只能负责读操作，当主节点发生故障时，需要手动将一个从节点升级为主节点，实现故障转移，这种模式主要是为了解决单点故障问题</li>
<li>主从复制模式提供了数据备份功能，简单易用，适用于读多写少的场景，并且具有很好的扩展性，可以通过增加更多的从节点来让集群的读能力不断提升，但是故障转移时需要人工介入，没有容错和恢复机制，任意节点的故障都会导致客户端部分读写请求失败</li>
</ul>
</li>
<li>哨兵模式<ul>
<li>哨兵模式是在主从复制的基础上增加了哨兵节点，哨兵节点是一种特殊的 Redis 节点，用于监控主节点和从节点的状态，当主节点发生故障时，哨兵节点可以自动进行故障转移，即选择一个合适的从节点升级为主节点，并通知其他从节点和应用程序进行更新，这种模式主要是为了解决自动容错和恢复问题</li>
<li>每个 Redis 实例都可以作为哨兵节点，通常需要部署多个哨兵节点来确保故障转移的可靠性，哨兵节点定期向所有主节点和从节点发送 PING 命令，如果在指定时间内未收到 PONG 响应，哨兵节点则将该节点标记为主观下线，如果一个节点被多数哨兵节点标记为主观下线，那么该节点被标记为客观下线</li>
<li>当主节点被标记为客观下线时，哨兵节点会触发故障转移过程，它会从所有健康的从节点中选举一个新的主节点，并将所有从节点切换到新的主节点，哨兵节点可以通过发布订阅功能来通知客户端有关主节点状态变化的消息，客户端收到消息后自行更新配置，将新的主节点信息应用于连接池，实现自动故障转移</li>
</ul>
</li>
<li>Redis Cluster 模式<ul>
<li>Redis Cluster 模式是 Redis 推荐的分布式集群解决方案，会将数据自动划分为多个数据分片，每个分片都有一个主节点和多个从节点，每个节点都可以单独对外提供读写服务，采用主从复制模式来提供高可用性，采用哨兵模式来提供故障转移</li>
<li>数据分片是将整个数据集划分为固定数量（2^14 = 16384）个槽，每个数据都能唯一地被映射到一个槽位上，心跳数据包含了所有的原始槽配置，16384 个槽位大约需要 2K 的空间，Redis Cluster 会将主节点控制在 1000 个以下，并将所有槽位尽量均匀地分给这些主节点（一个主节点可能会负责多个槽）</li>
<li>Redis Cluster 模式是适用于大规模应用的解决方案，能够自动管理数据分片和故障转移，不存在单点故障，减少了运维负担，提供了更好的横向扩展和容错能力，具备高性能、高吞吐量、高可用性以及高数据冗余</li>
</ul>
</li>
</ul>
<p>分布式 Redis 集群默认采用异步复制，即便可以使用 WAIT 命令对特定数据进行同步复制，但 WAIT 仅能确保数据在 Redis 实例中有指定数量的副本被确认，依旧不能将一组 Redis 实例转变为强一致性的分布式系统，因此 Redis 集群无法保证强一致性。</p>
<h1 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h1><p>Redis 提供多个数据结构，比如字符串、哈希表、列表、集合、有序集合、地理坐标、Stream 等，这些数据结构都被实现得非常高效，能够在 O(1) 的时间复杂度内完成数据读写</p>
<ul>
<li>字符串<ul>
<li>Redis 本身是通过 C 语言实现的，C 语言中的字符串以<code>\0</code>结尾，这意味着起码无法存储<code>\0</code>字符，C 语言的字符串操作都需要从头开始遍历直到找到<code>\0</code>，操作效率低</li>
<li>考虑到字符串在 Redis 中使用非常广泛，并且需要非常高效地支持任意字符的存储，Redis 并没有直接使用 C 语言中的字符数组的方式来实现字符串，而是自己实现了一个 Simple Dynamic Strings (SDS)</li>
<li>为了解决 C 语言中的字符串的问题，Redis 在字符串中增加一个表示分配给该字符数组的总长度的<code>alloc</code>字段和一个表示字符串现有长度的<code>len</code>字段，在做追加操作时如果<code>len</code>超过<code>alloc</code>则重新再申请新空间</li>
</ul>
</li>
<li>有序集合<ul>
<li>ZSet（也称为 Sorted Set）内部维护了一个有序字典，这个字典的元素中既包括了一个成员，也包括了一个分值，这种结果可以帮助用户实现记分类型的排行榜数据</li>
<li>ZSet 的实现有压缩列表 ZipList 和跳跃表 SkipList，在 Redis 5.0 中新增了一个紧凑列表 ListPack，ListPack 通过连续存储元素来节约内存空间，ListPack 就是为了代替 ZipList，在 Redis 7.0 中已经彻底不再使用 ZipList</li>
<li>SkipList 使用了跳表（带多级索引的有序链表）和字典（哈希表），每个元素按照其分值大小在跳表中进行排序，跳表的插入、删除和查找的时间复杂度都是 O(logn)，哈希表用来实现元素到分值的映射关系（元素作为键，分值作为值），哈希表的插入、删除和查找的时间复杂度都是 O(1)，可以保证比较好的性能</li>
<li>当 ZSet 的元素数据比较少时（元素数量少于 128，每个元素长度都小于 64 字节），Redis 会采用 ListPack 来存储，当 ZSet 的元素增多时，Redis 会自动将 ListPack 转换为 SkipList，以保持元素的有序性并支持范围查询，这个过程中 Redis 会遍历 ListPack 中所有元素，按照元素的分数值依次将它们插入到 SkipList 中</li>
</ul>
</li>
<li>Stream<ul>
<li>Redis Stream 是 Redis 5.0 中新增的数据结构，可以被视为一个日志或者消息队列（在 Redis 5.0 之前，可以通过 Redis 的发布订阅（pub/sub）实现消息队列，但是这种方式无法进行消息持久化，一旦出现网路断开、Redis 宕机等，消息就会被丢弃）</li>
<li>Stream 底层采用类似于日志的数据结构，每个 Stream 都是由一个或多个日志实现的，每个日志包含多个消息，每个消息都有一个唯一 ID 和一些附加字段（消息体、时间戳等），并且按照添加的顺序进行排序，可以向 Stream 中添加消息、读取消息、删除消息以及订阅消息</li>
<li>Stream 主要用于处理有序的、可追溯的消息流，提供了消息的持久化、主备复制、消息分组以及消费者分组等功能，可以让多个消费者并发地处理消息流，支持竞争式消费和共享式消费</li>
</ul>
</li>
</ul>
<h1 id="问题解决"><a href="#问题解决" class="headerlink" title="问题解决"></a>问题解决</h1><h2 id="热-Key-问题"><a href="#热-Key-问题" class="headerlink" title="热 Key 问题"></a>热 Key 问题</h2><p>当使用 Redis 作为存储时，如果在某个时间段内，突发大量针对某一个 key 的访问，就会使得流量集中在一些极少数的物理资源上，这就是热 key 问题，针对这一问题的主要处理方式如下</p>
<ul>
<li>事前预测一些可能性热 key，在客户端、服务端或者代理层实时的统计一些可能性热 key</li>
<li>针对热 key 加分片或者加后缀来将一个热 key 拆分成多个 key，令请求尽可能分散到不同机器上</li>
<li>针对热 key 加缓存，令用户请求尽可能提前返回，减少系统交互，减少用户的访问链路长度</li>
<li>缓存多了就成为了多级缓存，注意不要使用单个缓存服务器，而是使用缓存服务器集群</li>
</ul>
<h2 id="大-Key-问题"><a href="#大-Key-问题" class="headerlink" title="大 Key 问题"></a>大 Key 问题</h2><p>大 key 是指 Redis 中存储了大量数据的 key，这个 key 对应的 value 占用空间很多，通常在字符串、列表、集合等类型出现的比较多，大 key 不仅占用内存，影响性能，还会使得多个服务节点实例的内存使用不均匀，影响 Redis 备份呢和恢复，搜索更加困难，过期删除也比较耗时，针对大 key 问题的主要处理方式如下</p>
<ul>
<li></li>
</ul>
</section>
    <!-- Tags START -->
    
    <!-- Tags END -->
    <!-- NAV START -->
    
  <div class="nav-container">
    <!-- reverse left and right to put prev and next in a more logic postition -->
    
      <a class="nav-left" href="/2024/02/06/distributed-system/">
        <span class="nav-arrow">← </span>
        
          Distributed System
        
      </a>
    
    
      <a class="nav-right" href="/2024/02/18/week-75/">
        
          2024.2.5 - 2024.2.9
        
        <span class="nav-arrow"> →</span>
      </a>
    
  </div>

    <!-- NAV END -->
    <!-- 打赏 START -->
    
    <!-- 打赏 END -->
    <!-- 二维码 START -->
    
    <!-- 二维码 END -->
    
      <!-- Utterances START -->
      <div id="utterances"></div>
      <script src="https://utteranc.es/client.js"
        repo=""
        issue-term="pathname"
        theme="github-light"
        crossorigin="anonymous"
        async></script>    
      <!-- Utterances END -->
    
  </article>
  <!-- Article END -->
  <!-- Content START -->
  
    <aside class="content-container">
  <div class="toc-main">
  
      
          <strong class="toc-title">CONTENT</strong>
          <ol class="toc-nav"><li class="toc-nav-item toc-nav-level-1"><a class="toc-nav-link" href="#%E7%89%B9%E6%80%A7%E6%A6%82%E8%BF%B0"><span class="toc-nav-text">特性概述</span></a></li><li class="toc-nav-item toc-nav-level-1"><a class="toc-nav-link" href="#%E9%9B%86%E7%BE%A4%E6%A8%A1%E5%BC%8F"><span class="toc-nav-text">集群模式</span></a></li><li class="toc-nav-item toc-nav-level-1"><a class="toc-nav-link" href="#%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84"><span class="toc-nav-text">数据结构</span></a></li><li class="toc-nav-item toc-nav-level-1"><a class="toc-nav-link" href="#%E9%97%AE%E9%A2%98%E8%A7%A3%E5%86%B3"><span class="toc-nav-text">问题解决</span></a><ol class="toc-nav-child"><li class="toc-nav-item toc-nav-level-2"><a class="toc-nav-link" href="#%E7%83%AD-Key-%E9%97%AE%E9%A2%98"><span class="toc-nav-text">热 Key 问题</span></a></li><li class="toc-nav-item toc-nav-level-2"><a class="toc-nav-link" href="#%E5%A4%A7-Key-%E9%97%AE%E9%A2%98"><span class="toc-nav-text">大 Key 问题</span></a></li></ol></li></ol>
      
  
  </div>
</aside>
  
  <!-- Content END -->
</main>

<script>
  (function () {
    var url = 'http://example.com/2024/02/18/redis/';
    var banner = ''
    if (banner !== '' && banner !== 'undefined' && banner !== 'null') {
      $('#article-banner').css({
        'background-image': 'url(' + banner + ')'
      })
    } else {
      $('#article-banner').geopattern(url)
    }
    $('.header').removeClass('fixed-header')

    // error image
    $(".markdown-content img").on('error', function() {
      $(this).attr('src', '/css/images/error_icon.png')
      $(this).css({
        'cursor': 'default'
      })
    })

    // zoom image
    $(".markdown-content img").on('click', function() {
      var src = $(this).attr('src')
      if (src !== '/css/images/error_icon.png') {
        var imageW = $(this).width()
        var imageH = $(this).height()

        var zoom = ($(window).width() * 0.95 / imageW).toFixed(2)
        zoom = zoom < 1 ? 1 : zoom
        zoom = zoom > 2 ? 2 : zoom
        var transY = (($(window).height() - imageH) / 2).toFixed(2)

        $('body').append('<div class="image-view-wrap"><div class="image-view-inner"><img src="'+ src +'" /></div></div>')
        $('.image-view-wrap').addClass('wrap-active')
        $('.image-view-wrap img').css({
          'width': `${imageW}`,
          'transform': `translate3d(0, ${transY}px, 0) scale3d(${zoom}, ${zoom}, 1)`
        })
        $('html').css('overflow', 'hidden')

        $('.image-view-wrap').on('click', function() {
          $(this).remove()
          $('html').attr('style', '')
        })
      }
    })
  })();
</script>







    <div class="scroll-top">
  <span class="arrow-icon"></span>
</div>
    <!--
<footer class="app-footer">
  <p class="copyright">
    &copy; 2024 | Proudly powered by <a href="https://hexo.io" target="_blank">Hexo</a>
    <br>
    Theme by <a target="_blank" rel="noopener" href="https://github.com/yanm1ng">yanm1ng</a>
    
  </p>
</footer>
-->

<script>
  function async(u, c) {
    var d = document, t = 'script',
      o = d.createElement(t),
      s = d.getElementsByTagName(t)[0];
    o.src = u;
    if (c) { o.addEventListener('load', function (e) { c(null, e); }, false); }
    s.parentNode.insertBefore(o, s);
  }
</script>
<script>
  async("//cdnjs.cloudflare.com/ajax/libs/fastclick/1.0.6/fastclick.min.js", function(){
    FastClick.attach(document.body);
  })
</script>

<script>
  var hasLine = 'true';
  async("//cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/highlight.min.js", function(){
    $('figure pre').each(function(i, block) {
      var figure = $(this).parents('figure');
      if (hasLine === 'false') {
        figure.find('.gutter').hide();
      }
      hljs.configure({useBR: true});
      var lang = figure.attr('class').split(' ')[1] || 'code';
      var codeHtml = $(this).html();
      var codeTag = document.createElement('code');
      codeTag.className = lang;
      codeTag.innerHTML = codeHtml;
      $(this).attr('class', '').empty().html(codeTag);
      figure.attr('data-lang', lang.toUpperCase());
      hljs.highlightBlock(block);
    });
  })
</script>
<!-- Baidu Tongji -->


<script src="/js/script.js"></script>


  </body>
</html>
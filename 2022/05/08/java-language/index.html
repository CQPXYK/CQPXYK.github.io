<!DOCTYPE html>
<html>
  <head>
  <meta http-equiv="content-type" content="text/html; charset=utf-8">
  <meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport">
  <meta name="description" content="要有一个从输入到输出的过程">
  <meta name="keyword" content="hexo-theme, vuejs">
  
    <link rel="shortcut icon" href="/css/images/logo.png">
  
  <title>
    
      Java Language | CQ&#39;s Blog
    
  </title>
  <link href="//cdnjs.cloudflare.com/ajax/libs/font-awesome/4.7.0/css/font-awesome.min.css" rel="stylesheet">
  <link href="//cdnjs.cloudflare.com/ajax/libs/nprogress/0.2.0/nprogress.min.css" rel="stylesheet">
  <link href="//cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/tomorrow.min.css" rel="stylesheet">
  
<link rel="stylesheet" href="/css/style.css">

  
  <script src="//cdnjs.cloudflare.com/ajax/libs/jquery/3.2.1/jquery.min.js"></script>
  <script src="//cdnjs.cloudflare.com/ajax/libs/geopattern/1.2.3/js/geopattern.min.js"></script>
  <script src="//cdnjs.cloudflare.com/ajax/libs/nprogress/0.2.0/nprogress.min.js"></script>
  
  
  
  
    <!-- MathJax support START -->
    <script type="text/x-mathjax-config">
      MathJax.Hub.Config({
        tex2jax: {
          inlineMath: [ ['$','$'], ["\\(","\\)"]  ],
          processEscapes: true,
          skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
        }
      });
    </script>

    <script type="text/x-mathjax-config">
      MathJax.Hub.Queue(function() {
        var all = MathJax.Hub.getAllJax(), i;
        for (i=0; i < all.length; i += 1) {
          all[i].SourceElement().parentNode.className += ' has-jax';
        }
      });
    </script>
    <script type="text/javascript" src="//cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
    <!-- MathJax support END -->
  


  
  
    
<script src="/js/local-search.js"></script>


<meta name="generator" content="Hexo 5.4.2"></head>
<div class="wechat-share">
  <img src="/css/images/logo.png" />
</div>
  <body>
    <header class="header fixed-header">
  <div class="header-container">
    <a class="home-link" href="/">
      <div class="logo"></div>
      <span>CQ's Blog</span>
    </a>
    <ul class="right-list">
      
        <li class="list-item">
          
            <a href="/categories/" class="item-link">Home</a>
          
        </li>
      
        <li class="list-item">
          
            <a href="/categories/" class="item-link">Categories</a>
          
        </li>
      
        <li class="list-item">
          
            <a href="/records" class="item-link">Records</a>
          
        </li>
      
        <li class="list-item">
          
            <a href="/scratches/" class="item-link">Scratches</a>
          
        </li>
      
        <li class="list-item">
          
            <a href="/archives/" class="item-link">Archives</a>
          
        </li>
      
      
        <li class="menu-item menu-item-search right-list">
    <a role="button" class="popup-trigger">
        <i class="fa fa-search fa-fw"></i>
    </a>
</li>
      
    </ul>
    <div class="menu">
      <span class="icon-bar"></span>
      <span class="icon-bar"></span>
      <span class="icon-bar"></span>
    </div>
    <div class="menu-mask">
      <ul class="menu-list">
        
          <li class="menu-item">
            
              <a href="/categories/" class="menu-link">Home</a>
            
          </li>
        
          <li class="menu-item">
            
              <a href="/categories/" class="menu-link">Categories</a>
            
          </li>
        
          <li class="menu-item">
            
              <a href="/records" class="menu-link">Records</a>
            
          </li>
        
          <li class="menu-item">
            
              <a href="/scratches/" class="menu-link">Scratches</a>
            
          </li>
        
          <li class="menu-item">
            
              <a href="/archives/" class="menu-link">Archives</a>
            
          </li>
        
      </ul>
    </div>
    
      <div class="search-pop-overlay">
    <div class="popup search-popup">
        <div class="search-header">
            <span class="search-icon">
                <i class="fa fa-search"></i>
            </span>
            <div class="search-input-container">
                <input autocomplete="off" autocapitalize="off"
                    placeholder="Please enter your keyword(s) to search." spellcheck="false"
                    type="search" class="search-input">
            </div>
            <span class="popup-btn-close">
                <i class="fa fa-times-circle"></i>
            </span>
        </div>
        <div id="search-result">
            <div id="no-result">
                <i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i>
            </div>
        </div>
    </div>
</div>
    
  </div>
</header>

    <div id="article-banner">
  <h2>Java Language</h2>
  <!--<p class="post-date">2022-05-08</p>
  <div class="arrow-down">
    <a href="javascript:;"></a>
  </div>-->
</div>
<main class="app-body flex-box">
  <!-- Article START -->
  <article class="post-article">
    <section class="markdown-content"><h1 id="1、面向对象"><a href="#1、面向对象" class="headerlink" title="1、面向对象"></a>1、面向对象</h1><p>Java 是一种面向对象的编程语言（C++ 既可以面向对象，也可以面向过程）。面向对象方式通过对象来提供对某个问题的描述，通过对象的状态和行为来提供对某个问题的解决，对象的状态可以包含其他对象，对象的行为可以包含对其他对象的调用。</p>
<h2 id="1-1-对象的基本特征"><a href="#1-1-对象的基本特征" class="headerlink" title="1.1 对象的基本特征"></a>1.1 对象的基本特征</h2><p>对象具有的一些基本特征是状态、行为、标识和类型</p>
<ul>
<li>状态和行为分别意味着对象都可以拥有内部数据域（field）和方法（method），方法签名（signature）由方法名称和所有参数类型组成，不包括方法的返回类型</li>
<li>标识意味着每一个对象都可以唯一地与其他所有对象区分开来</li>
<li>类型则决定了这个对象可以具备什么样的状态和行为，对象的类型有类（包括枚举）、接口、数组这三种，通常被称为引用数据类型（与之相对的是基本数据类型）</li>
</ul>
<p>面向对象具有的三大特征是封装、继承和多态</p>
<ul>
<li><strong>封装</strong>：当开发一个东西供别人使用时，这个东西可以是一个方法、一个类、接口、甚至一个系统等，可以将这个东西封装起来，通过文档约定告知别人如何使用，那么别人在使用我开发的东西，或者我使用别人开发的东西时，可以不用去深究具体的实现细节，从而能够更加专注于自身开发工作，实现相对独立的开发、测试、优化、使用、理解和修改，降低代码的耦合性</li>
</ul>
<table>
<thead>
<tr>
<th align="center"></th>
<th align="center"></th>
<th align="center"></th>
<th align="center"></th>
<th align="center"></th>
</tr>
</thead>
<tbody><tr>
<td align="center">访问权限控制符</td>
<td align="center">本类</td>
<td align="center">包内</td>
<td align="center">包外子类</td>
<td align="center">任何地方</td>
</tr>
<tr>
<td align="center">public</td>
<td align="center">√</td>
<td align="center">√</td>
<td align="center">√</td>
<td align="center">√</td>
</tr>
<tr>
<td align="center">protected</td>
<td align="center">√</td>
<td align="center">√</td>
<td align="center">√</td>
<td align="center">×</td>
</tr>
<tr>
<td align="center">default</td>
<td align="center">√</td>
<td align="center">√</td>
<td align="center">×</td>
<td align="center">×</td>
</tr>
<tr>
<td align="center">private</td>
<td align="center">√</td>
<td align="center">×</td>
<td align="center">×</td>
<td align="center">×</td>
</tr>
</tbody></table>
<ul>
<li><p><strong>继承</strong>：当我们在继承某个类，获得了这个类的属性和方法时，可以在现有类的基础上，去继续拓展新的属性和方法，去进一步的开发更加细致更加个性化的功能，这可以增加代码的可重用性（类之间只能单继承，接口之间可以多继承），除了继承（is-a），组合（has-a）同样也能够增加代码的可重用性</p>
<p>继承：</p>
<ul>
<li>继承是一种白盒式的复用，父类的内部细节对于子类是可见的，如果父类的实现发生了改变，那么子类也将随之改变，这就导致了子类行为的不可预知性，且子类不能改变父类的接口，依赖于父类的实现，缺乏独立性</li>
<li>Java 的单继承结构保证所有对象都具备某些功能，可以执行某些基本操作，所有的对象都可以很容易地在堆上创建，参数传递得到了极大的简化，垃圾回收器的实现也变得容易得多</li>
<li>可重用性并不是并不是继承技术最重要的方面，其最重要的方面是用来表现新类和基类之间的关系，这种关系可以用“新类是现有类的一种类型”这句话来加以概括，从而实现向上转型，也就是说，继承应当仅仅用在必须使用的场合（需要进行向上转型的场合），这样会使得设计更加清晰</li>
<li>Java 不支持多继承一方面是由于上一点所述，另一方面是为了避免多继承导致子类过于庞大不便维护以及棱形继承这种歧义问题（假如一个类实现了多个接口，且多个接口中有相同的方法，那么这个类就必须重写这个方法，避免了多实现引发的棱形实现问题）</li>
</ul>
<p>组合：</p>
<ul>
<li>组合是一种黑盒式的复用，组合对象之间各自的内部细节是不可见的，不破坏封装，具有较好的可扩展性，一般用于想在新类中使用现有类的功能而非它的接口的情形，更加简单灵活，在建立新类时，应该首先考虑组合</li>
<li>动态组合使得整体对象可以在运行期间动态使用不同类型的局部对象，整体类还可以对局部类进行包装，封装局部类的接口，提供新的接口，但是整体类不能直接自动获得局部类的接口功能，在创建整体类的对象时需要创建所有局部对象</li>
</ul>
</li>
<li><p><strong>多态</strong>：多态指同一个行为在不同情况下可以有不同的实现细节，但可以通过共通的方式进行调用，可以分为重载实现的多态和重写实现的多态，这可以增加代码的灵活性</p>
<p>重载：</p>
<ul>
<li>是在一个类中的多态性的体现；</li>
<li>在一个类中定义多个相同方法名但参数列表不同的方法就称为方法的重载，参数列表不同包括参数类型、个数或者顺序不同；</li>
<li>重载方法之间可以有不同的返回类型，不同的访问修饰符，抛出不同的异常，这些都没有硬性要求；</li>
<li>在编译期就能根据确定调用函数的参数来确定是调用哪一个重载方法，体现了编译多态性；</li>
</ul>
<p>重写：</p>
<ul>
<li>是在父类和子类之间的多态性的体现；</li>
<li>在子类中定义与父类方法签名一致的方法就称为方法的重写（<strong>方法签名就由方法名+参数列表构成</strong>）；</li>
<li>子类的重写的方法除了方法签名之外，方法的返回类型也必须和父类一致，方法访问修饰符的限制一定要大于父类方法的访问修饰（public&gt;protected&gt;default&gt;private），还不能抛出新的检查异常或者比被父类方法申明更加宽泛的检查型异常；</li>
<li>在运行期才能确定是调用父类的方法还是子类重写的方法，体现了运行多态性；</li>
<li>不要在构造器中调用可能被子类重写的方法，可能会使用还未被初始化的变量；</li>
</ul>
</li>
</ul>
<p>当试图开发或理解一个程序设计时，最好的方法之一就是将对象想象为“服务提供者”，程序本身向用户提供服务，它将通过调用其他对象的服务来实现这一目的，开发人员的目标就是去创建（或者是在现有代码库中寻找）能够提供理想服务来解决问题的一系列对象。</p>
<h2 id="1-2-创建、存储、销毁对象"><a href="#1-2-创建、存储、销毁对象" class="headerlink" title="1.2 创建、存储、销毁对象"></a>1.2 创建、存储、销毁对象</h2><p>创建类就是在描述这个类的对象的外观与行为，创建对象则通常用<code>new</code>操作符来创建（此时数据存储空间才被分配），而对于一些比较小的、简单的变量，不用<code>new</code>来创建，而是创建一个并非是引用的基本类型变量，这个变量直接存储“值”，Java 对所有的基本类型都有平台无关的标准的范围限制和字节长度（C++ 对所有的数字类型有标准的范围限制，但其字节长度是跟具体实现相关的，同一个类型在不同操作系统可能长度不一样），Java 基本类型如下</p>
<table>
<thead>
<tr>
<th align="center"></th>
<th align="center"></th>
<th align="center"></th>
<th align="center"></th>
<th align="center"></th>
<th align="center"></th>
<th align="center"></th>
<th align="center"></th>
<th align="center"></th>
</tr>
</thead>
<tbody><tr>
<td align="center">基本类型</td>
<td align="center">boolean</td>
<td align="center">char</td>
<td align="center">byte</td>
<td align="center">short</td>
<td align="center">int</td>
<td align="center">long</td>
<td align="center">float</td>
<td align="center">double</td>
</tr>
<tr>
<td align="center">大小</td>
<td align="center">-</td>
<td align="center">16 bits</td>
<td align="center">8 bits</td>
<td align="center">16 bits</td>
<td align="center">32 bits</td>
<td align="center">64 bits</td>
<td align="center">32 bits</td>
<td align="center">64 bits</td>
</tr>
<tr>
<td align="center">取值范围</td>
<td align="center"></td>
<td align="center">0~2^16-1</td>
<td align="center">-2^7~2^7 - 1</td>
<td align="center">-2^15~2^15 - 1</td>
<td align="center">-2^31~2^31 - 1</td>
<td align="center">-2^63~2^63 - 1</td>
<td align="center">-2^128~2^128</td>
<td align="center">-2^1024~2^1024</td>
</tr>
</tbody></table>
<p>注：</p>
<ul>
<li><p>单个<code>boolean</code>型长度为 32 bit，<code>boolean</code>数组中的每个<code>boolean</code>值的长度为 8 bit</p>
</li>
<li><p><code>boolean</code>型无法转换为其他基本类型，也无法进行加减等任何算术运算以及位运算，除<code>boolean</code>以外的任何一种基本类型都可以通过类型转换变为其他基本类型，但有可能丢失信息</p>
</li>
<li><p>浮点数由符号位、指数位以及尾数位组成，指数位决定范围，尾数位决定精度，<code>float</code>的符号位、指数位以及尾数位分别是 1 bit、8 bits、23 bits，<code>double</code>的符号位、指数位以及尾数位分别是 1 bit、11 bits、52 bits，浮点数并不能把表示范围中的所有的数都表示出来</p>
</li>
<li><p>有的小数无法用二进制精确表示（比如 0.1 的二进制形式是无限循环的），因此<code>float</code>和<code>double</code>都可能只是近似值而非精确值，存在精度丢失，所以在需要进行高精度运算时使用<code>BigDecimal</code>（比如金额运算）</p>
</li>
<li><p>由于<code>float</code>和<code>double</code>都是不精确的，所以不应使用<code>float</code>和<code>double</code>作为入参来<code>new</code>一个<code>BigDecimal</code>（只会得到更加不精确的数字），而是应该使用<code>String</code>作为入参</p>
</li>
<li><p><code>BigDecimal</code>内部使用一个无标度值和一个标度来表示一个数，<code>BigDecimal</code>的等值比较应使用忽略标度的<code>compareTo</code>而不是同时比较值和标度的<code>equals</code>（1.0 与 1.00 使用<code>equals</code>的返回结果为 <code>false</code>）</p>
</li>
</ul>
<p>从概念上讲，对象的“初始化”和“创建”是彼此独立的，在 Java 中，对象的“初始化”和“创建”捆绑在一起，由构造器来完成。编写构造器时有一条准则：用尽可能简单的方法使对象进入正常状态，此外，构造器应当避免调用其他方法，尤其是可能被子类重写的方法（这种方法可能会使用还未被初始化的变量），构造器内唯一能够安全调用的方法是基类中的<code>final</code>方法。</p>
<p>Java 中可以通过调用构造器、调用<code>clone</code>方法（并不调用构造器）、反序列化（基于反射和<code>Unsafe</code>类，并不调用构造器）的方式来创建对象，构造器可以通过<code>new</code>关键字、反射机制、工厂方法以及构造函数的方法句柄来调用，Java 鼓励使用构造器（尤其是工厂方法）来创建对象，以确保对象的正确初始化，并维护对象的不变性。</p>
<p>Java 通过编译错误来保证局部变量在使用前都能得到恰当的初始化；Java 不会通过编译错误来保证类的成员变量（或数组的元素）在使用前得到初始化，如果该成员变量（或元素）是基本类型，那么在未初始化时会被赋一个初值，如果是对象引用，那么在未初始化时会获得一个特殊值<code>null</code>；Java 只有在必要时刻才会进行静态变量的初始化，必要时刻指第一次访问静态数据的时候（或者首次创建静态数据所在的类的一个对象时），静态变量的初始化动作只进行一次。</p>
<p>程序运行时，有五个不同的地方可以存储数据</p>
<ul>
<li>寄存器<ul>
<li>位于处理器的内部，数量及其有限，是最快的存储区</li>
<li>寄存器根据需求进行分配，无法在 Java 程序中直接控制（C 和 C++ 允许程序员向编译器建议寄存器的分配方式）</li>
</ul>
</li>
<li>堆栈<ul>
<li>位于 RAM 区，通过堆栈指针可以从处理器那里获得直接支持，堆栈指针向下移动则分配新的内存，向上移动则释放那些内存</li>
<li>是一种快速有效额分配存储方法，仅次于寄存器，Java 基本类型和对象引用就存储在堆栈中，但是 Java 对象并不存储于其中</li>
<li>Java 编译器系统必须知道存储在堆栈内所有项的确切的生命周期，以便上下移动指针，这一约束限制了程序的灵活性</li>
</ul>
</li>
<li>堆<ul>
<li>位于 RAM 区，是一种通用的内存池，用于存放所有的 Java 对象</li>
<li>编译器并不需要知道堆内存储的数据的生命周期，因此堆内的分配存储具有很大的灵活性，与此同时，用堆进行存储分配和清理可能比用堆栈需要更多的时间</li>
</ul>
</li>
<li>常量存储<ul>
<li>常量值通常直接存放于程序代码内部</li>
<li>在嵌入式系统中，常量本身会和其他部分分隔离开，此时可以存在在 ROM 中</li>
</ul>
</li>
<li>非 RAM 存储<ul>
<li>完全存活于程序之外的数据（例如流对象、持久化对象）通常存放与磁盘上，或者被发送给另一台机器</li>
<li>这类数据即使在程序终止时，仍然可以保持自己的状态，因此将这类数据转化成可以存放在其他媒介上的事物，在需要时，可恢复成常规的、基于 RAM 的对象</li>
<li>Java 提供了对轻量级持久化的支持，而诸如 JDBC 和 Hibernate 这样的机制提供了更加复杂的对在数据库中存储和读取对象信息的支持</li>
</ul>
</li>
</ul>
<p>Java 基本类型和对象引用的作用域由花括号的位置决定，但<code>new</code>创建出的 Java 对象具备不一样的生命周期，可以存活于花括号之外，需要通过垃圾回收器来监视用<code>new</code>创建的所有 Java 对象，辨别那些不会再被引用的对象，并释放这些对象的内存空间。</p>
<p>垃圾回收器只知道释放那些经由<code>new</code>分配的内存，而不知道如何释放对象并非使用<code>new</code>而获得的特殊内存区域，那么为了应对这种情况，Java 允许在类中定义一个<code>finalize</code>方法，<code>finalize</code>会在该对象被垃圾回收时被调用，从而在该对象被垃圾回收时附加一些释放内存的回收工作（回收该对象所含有的其他并非使用<code>new</code>创建的对象），JVM 并不鼓励定义和使用<code>finalize</code>，所有<code>finalize</code>能做的工作，都可以使用<code>try-finally</code>或者其他方式做的更好更及时。</p>
<p>一旦涉及到垃圾回收，能够信赖的事就不会很多了，不是所有的 Java 对象都一定会被垃圾回收，Java 对象可能不被垃圾回收，即使被回收，也可能以任何回收器想要的顺序来回收对象，且垃圾回收只与释放内存有关，不能依赖垃圾回收去做任何除了释放内存之外的事情，垃圾回收并不等于“析构”。</p>
<p><code>finalize</code>并不是析构函数，并且绝对不能在程序中显式调用<code>finalize</code>，如果需要进行除释放存储空间之外的清理工作（比如已经打开的文件或网络连接需要关闭），就得在程序中明确调用某个自定义的恰当的 Java 类的清理方法，这个清理方法就等同于析构函数（Java 本身并未提供析构函数），该方法必须确保得到执行，派生类必须重写基类的该方法，并在重写方法的最后调用基类的该方法。</p>
<h2 id="1-3-接口、抽象类、内部类"><a href="#1-3-接口、抽象类、内部类" class="headerlink" title="1.3 接口、抽象类、内部类"></a>1.3 接口、抽象类、内部类</h2><p>接口，抽象类和内部类提供了一种将接口与实现分离的更加结构化的方法。</p>
<ul>
<li><p>接口</p>
<ul>
<li><p>接口被用来建立类与类之间的协议规范，只要一个方法操作的是接口，那么就可以使用任何实现了该接口的类，提升代码复用性</p>
</li>
<li><p>接口中的域隐式地是<code>public</code>，<code>static</code>和<code>final</code>的（必须被初始化），接口中的方法隐式地是<code>public</code>，接口不能有构造器，接口的实现类所实现的接口方法必须被显式定义为<code>public</code></p>
</li>
<li><p>接口是一种重要的工具，但是容易被滥用（比如类的构造器几乎在任何时候，都可以替代为一个接口和一个工厂）</p>
</li>
<li><p>任何抽象性都应该是应真正的需求而产生的，恰当的原则应当是优先选择类而不是接口，当接口的必需性变得非常明确时再去重构为接口，而不是一开始就到处添加额外级别的间接性，带来额外的复杂性</p>
</li>
</ul>
</li>
<li><p>抽象类</p>
<ul>
<li><p>抽象类是普通类与接口之间的中庸，是为复用而设计的类，创建抽象类是希望通过抽象类中的通用接口操纵一系列类</p>
</li>
<li><p>抽象类的方法和变量的修饰符使用没有限制，抽象类可以有构造器（用于初始化共有变量），但不能被实例化</p>
</li>
<li><p>如果接口的多个实现类中有相同的可复用的代码，则在接口和实现类中间加一层抽象类（接口的骨架类），将可复用的代码抽出到抽象类中，骨架类的扩展类则实现接口方法的定制化实现（这就是模板方法模式）</p>
</li>
</ul>
</li>
<li><p>内部类</p>
<ul>
<li><p>将一个类的定义放在另一个类的定义内部就是内部类（但内部类和组合是完全不同的概念）</p>
</li>
<li><p>内部类不仅是一种代码隐藏机制，内部类还拥有其外围类的所有元素的访问权，也就是说内部类提供了某种进入外围类的窗口</p>
</li>
<li><p>创建内部类对象的时刻并不依赖于外围类对象的创建，但对于普通（非静态）的内部类来说，要通过外部类对象来创建内部类对象，即必须使用外部类的对象来创建内部类对象，在拥有外部类对象之前不可能创建内部类对象</p>
</li>
<li><p>如果不需要内部类对象与其外围类对象之间的联系，那么就可以将内部类声明为<code>static</code>，这通常称为嵌套类</p>
</li>
<li><p>创建嵌套类对象不需要对外部类对象的引用，嵌套类也不像普通的内部类对象那样保存外围类对象的引用，因此嵌套类无法访问非静态的外围类对象，但嵌套类可以直接在类方法中创建并操作外围类对象</p>
</li>
<li><p>在接口中定义嵌套类可以使得该嵌套类代码被接口的所有不同实现所共用，在类中定义嵌套类，并在嵌套类中定义用于测试的<code>main()</code>方法可以很方便的测试这个外部类</p>
</li>
<li><p>无论外围类是否已经继承了某个实现，内部类可以独立地继承自一个实现，因此，可以通过定义多个内部类来继承多个非接口类型，并向外围类提供实现，这某种程度上帮助外围类实现了多继承结构</p>
</li>
<li><p>内部类不仅包含外围类对象的信息，还自动拥有一个指向此外围类对象的引用，在此作用域内，内部类有权操作外围类所有的成员，包括<code>private</code>成员，因此内部类是面向对象的闭包</p>
</li>
<li><p>继承外围类时，并不意味着派生类的同名内部类隐式继承了外围类的内部类，即派生类的同名内部类和基类的内部类是完全独立的两个实体，各自在自己的命名空间里，但也可以显式的声明派生类的内部类继承了基类的内部类</p>
</li>
</ul>
</li>
</ul>
<h1 id="2、容器和泛型"><a href="#2、容器和泛型" class="headerlink" title="2、容器和泛型"></a>2、容器和泛型</h1><p>通常程序总是根据运行时才知道的某些条件去创建新对象，在此之前，不会知道所需对象的数量，甚至不知道确切的类型，除了编译器所支持的数组类型（一旦生成，其容量就不能改变），Java 实用类库还提供了一套容器类来解决这个问题。</p>
<h2 id="2-1-Collection-序列"><a href="#2-1-Collection-序列" class="headerlink" title="2.1 Collection 序列"></a>2.1 Collection 序列</h2><p><code>Collection</code>是一个独立元素的序列接口，<code>Collections</code>是一个工具类，包含有各种关于<code>Collection</code>操作的重载方法。</p>
<img src="Collection.png" alt="Collection" style="zoom:100%;"/>

<ul>
<li><p><code>Iterator</code></p>
<ul>
<li><p><code>Collection</code>扩展了<code>Iterable</code>，<code>Iterable</code>代表其实现是可以被迭代的，所有的<code>Collection</code>都可以通过<code>iterator</code>方法来获取迭代器<code>Iterator</code>，也可以用 foreach 语法遍历</p>
</li>
<li><p><code>Iterator</code>代表的是迭代的方式，其工作是遍历并选择序列中的对象，客户端程序员不必知道或关心序列底层的结构，统一了对序列的访问方式</p>
</li>
<li><p><code>Iterator</code>工作在一个独立的线程中，并且拥有一个互斥锁，<code>Iterator</code>被创建之后会建立一个指向原来对象的单链索引表，当原来的对象数量发生变化时，这个索引表的内容不会同步改变，按照 fail-fast 原则<code>Iterator</code>会立即抛出<code>CocurrentModificationException</code>，因此，<code>Iterator</code>在工作时不允许改变被迭代的对象序列，但可以使用<code>Iterator</code>本身的<code>remove</code>来删除对象，该方法会在删除当前迭代对象的同时维护索引的一致性</p>
</li>
<li><p><code>Iterator</code>通常被称为轻量级对象，其创建代价很小</p>
</li>
</ul>
</li>
<li><p><code>Queue</code></p>
<ul>
<li><p><code>Queue</code>只允许在一端插入对象，并从另外一端移出对象</p>
</li>
<li><p><code>Queue</code>常被当做一种可靠的将对象从程序的某个区域传输到另一个区域的途径</p>
</li>
<li><p><code>Deque</code>是双向队列，允许在两端插入和移出对象</p>
</li>
<li><p><code>PriorityQueue</code>是优先级队列（堆），始终移出优先级最高的元素对象，并将插入的对象按照优先级排序</p>
</li>
<li><p><code>LinkedList</code>和<code>PriorityQueue</code>之间的差异在于排序行为而不是性能</p>
</li>
</ul>
</li>
<li><p><code>List</code></p>
<ul>
<li><p><code>List</code>按照插入的顺序保存元素，确定一个元素是否属于<code>List</code>，发现某个元素的索引，以及移除元素操作都会用到<code>equals</code>方法，因此<code>List</code>的行为根据<code>equals</code>的行为而有所变化</p>
</li>
<li><p><code>ArrayList</code>和<code>LinkedList</code>都是<code>List</code>类型，两者的不同之处在于底层结构和执行某些类型的操作性能，以及<code>LinkedList</code>还实现了<code>Deque</code>，具备了<code>List</code>中未包含的额外方法，比如需要栈的行为时，应当使用<code>LinkedList</code></p>
</li>
<li><p><code>ArrayList</code>是一个可改变大小的数组，<code>LinkedList</code>是一个双向链表，在<code>List</code>中间插入和删除，对于<code>LinkedList</code>来说都是廉价操作，但对于<code>ArrayList</code>来说是昂贵的操作，<code>ArrayList</code>更适用于根据下标来随机访问元素，而<code>LinkedList</code>在随机访问时相对较慢</p>
</li>
<li><p><code>ArrayList</code>的<code>subList</code>方法返回的是用<code>SubList</code>类型（<code>ArrayList</code>的内部类）表示的原<code>List</code>的视图，对视图的所有操作其实依旧是在操作原列表，<code>SubList</code>与<code>ArrayList</code>之间没有继承关系，不能强转</p>
</li>
<li><p>为了避免在数组存在大量空位的情况下序列化大量 null 元素，<code>ArrayList</code>的底层的<code>Object</code>数组被声明成了<code>transient</code>，在默认的序列化机制中并没有序列化数组数据，而是自定义了<code>writeObject</code>和<code>readObject</code>方法来实现序列化和反序列化操作</p>
</li>
<li><p><code>Vector</code>是线程安全的，读写都加了<code>synchronized</code>锁，但只能保证单独的操作是线程安全的，无法保证复合操作的线程安全性，多线程并发时无法同时读和写，会互相阻塞，每次扩容时增加一倍，在单线程环境下<code>ArrayList</code>代替了<code>Vector</code>，<code>ArrayList</code>不是线程安全的，每次扩容时增加 50%，而并发环境下则更推荐使用<code>CopyOnWriteArrayList</code>（读写分离，可以同时读和写）</p>
</li>
</ul>
</li>
<li><p><code>Set</code></p>
<ul>
<li><p><code>Set</code>不能有重复元素，一般用于测试归属性，因此查找就成为了<code>Set</code>中最重要的操作</p>
</li>
<li><p>不同于<code>Queue</code>和<code>List</code>，<code>Set</code>并未在<code>Collection</code>的基础上添加新的接口（<code>TreeSet</code>除外），具有和<code>Collection</code>完全一样的接口，没有任何额外的功能，区别只在于行为不同</p>
</li>
<li><p><code>HashSet</code>、<code>TreeSet</code>和<code>LinkedHashSet</code>都是<code>Set</code>类型，但不同的<code>Set</code>实现存储元素的方式是不同的</p>
</li>
<li><p><code>HashSet</code>是用的是相当复杂的方式（散列函数）来存储元素的，同时也是最快的获取元素方式，是默认的选择</p>
</li>
<li><p><code>Set</code>存储的顺序一般并无实际意义，但如果存储顺序很重要，那么可以使用<code>TreeSet</code>或者<code>LinkedHashSet</code></p>
</li>
<li><p><code>TreeSet</code>将元素存储在红黑树数据结构中（元素必须实现<code>Comparable</code>接口），按照比较结果的升序保存对象</p>
</li>
<li><p><code>LinkedHashSet</code>因为查询速度的原因也使用了散列，但是还是使用了双向链表来维护元素的插入顺序，按照被添加的顺序保存对象</p>
</li>
<li><p>在迭代访问时维护了顺序的<code>TreeSet</code>和<code>LinkedHashSet</code>反而比<code>HashSet</code>更快，对于插入操作，<code>LinkedHashSet</code>的代价比<code>HashSet</code>更高，这是由维护双向链表所带来额外开销造成的</p>
</li>
<li><p><code>BitSet</code>是位集合，底层数据结构是由一个<code>long</code>型数组所表示的位数组，如果第 n 位为 1，则表明数字 n 在该数组中（只使用一个比特位就完成了数字 n 的存储），一般只用于数字的存储和去重，不适合存储一些差值比较大的数（高位和低位之间的比特位都浪费了），<code>BitSet</code>只是名字中有 Set，但其实既没有实现<code>Collection</code>接口，也没有实现<code>Iterable</code>接口</p>
</li>
</ul>
</li>
</ul>
<h2 id="2-2-Map-映射"><a href="#2-2-Map-映射" class="headerlink" title="2.2 Map 映射"></a>2.2 Map 映射</h2><p><code>Map</code>是一组成对的“键值对”对象，将键对象和值对象关联在一起。<code>Map</code>可以使用<code>entrySet</code>和<code>values</code>方法产生<code>Collection</code>。<code>Map</code>的插入操作会随着<code>Map</code>尺寸的变大而明显变慢，查找的代价通常比插入要小得多。</p>
<img src="Map.png" alt="Map" style="zoom:40%;" />

<ul>
<li><p><code>Hashtable</code></p>
<ul>
<li><p><code>Hashtable</code>是线程安全的，读写都加了<code>synchronized</code>锁，多线程并发时无法同时读和写，锁粒度太大</p>
</li>
<li><p><code>Hashtable</code>的默认初始容量为 11，默认的加载因子为 0.75，即当元素个数超过容量的 75% 时，会进行扩容，容量会扩大为原来的两倍加 1，并将原来的元素重新分配到新的桶中</p>
</li>
</ul>
</li>
<li><p><code>HashMap</code></p>
<ul>
<li><p><code>HashMap</code>不是线程安全的，单线程环境下<code>HashMap</code>代替了<code>Hashtable</code>，而并发环境下则更推荐使用<code>ConcurrentHashMap</code>（可以同时读和写）</p>
</li>
<li><p><code>HashMap</code>的默认初始容量为 16，默认的加载因子为 0.75（是在空间成本和哈希碰撞概率之间的权衡，碰撞会进一步影响到时间成本），扩容时容量会扩大为原来的两倍，并将原来的元素重新分配到新的桶中</p>
</li>
<li><p><code>HashMap</code>的键和值都允许为 null（键为 null 的键值对总是会放在第一个桶中），可以通过<code>containsKey</code>方法来区分到底是不含有某个键还是某个键映射的值是 null</p>
</li>
<li><p>与<code>HashSet</code>一样，<code>HashMap</code>也提供了最快的查找技术，也没有按照任何明显的顺序来保存其元素，是默认的选择</p>
</li>
<li><p><code>HashMap</code>的底层是哈希数组（数组是效率最高的存储和随机访问对象引用序列的方式），哈希的价值在于速度，使得查询得以快速进行，数组中每一个存放元素的位置可以看做一个桶，key 的哈希值就是其对应的桶在数组中的下标</p>
</li>
<li><p><code>HashMap</code>通过<code>(key.hashCode ^ (key.hashCode &gt;&gt; 16)) &amp; (table.length - 1)</code>来定位 key 应当位于哪个桶</p>
<ul>
<li><p>由于<code>X % 2^n = X &amp; (2^n - 1)</code>，<code>&amp;</code>是基于内存的二进制直接运算，比转换成十进制的取模运算快得多，因此使用位运算代替取模运算，这也是<code>HashMap</code>的容量一定要是 2^n 的原因</p>
</li>
<li><p>将<code>key.hashCode</code>的高 16 和低 16 进行异或而不是直接使用<code>key.hashCode</code>是为了进行扰动计算，将高位和低位的特征结合起来，尽量令任何一位的变化都能对最终的结果产生影响，降低哈希冲突的概率</p>
</li>
<li><p>在自定义生成散列码时，应当更关注生成速度而非唯一性，且必须基于对象的内容而非地址来生成尽可能均匀分布的散列码（<code>int</code>型），由于<code>enum</code>定义了固定数量的实例，所以<code>EnumMap</code>和<code>EnumSet</code>实现了完美的散列函数</p>
</li>
</ul>
</li>
<li><p>由于底层哈希数组容量固定，那么不同的键可能产生相同的下标，即可能有冲突，因此每个桶中存放的元素是<code>Entry</code>类型（<code>Map</code>的内部接口）的单个键值对/链表/包含双向链表的红黑树，当散列函数接近完美时，每个桶中存放的就是单个键值对或比较短的链表，当链表长度达到 8 时进化为红黑树，当树节点个数小于 6 时再退化为链表</p>
</li>
<li><p>进化后的树结构选择红黑树是因为红黑树可以保证任何一个节点的左右子树的高度差不会超过较矮的那一棵的一倍，既不至于极端情况下退化为链表，又不会像 AVL 树那样严格要求绝对平衡进而导致在删除和插入节点时过于频繁地左旋和右旋，因此红黑树是一个比较合适的选择，红黑树包含双向链表是为了在节点数量少时方便退化为链表</p>
</li>
<li><p>当使用自定义类作为<code>HashMap</code>的键时，一定要同时重载<code>hashCode()</code>和<code>equals()</code>方法，但不是必须实现<code>Comparable</code>接口，<code>hashCode()</code>用于定位 key 应当位于哪个桶（这一步的定位很快），<code>equals()</code>用于定位 key 位于桶中链表/红黑树的哪个节点（这一步的定位可能慢一些），如果实现了<code>Comparable</code>接口，则红黑树使用该<code>Comparable</code>接口进行比较，如果没有实现，则使用一个默认的仲裁比较方法</p>
</li>
</ul>
</li>
<li><p><code>ConcurrentHashMap</code></p>
<ul>
<li><p><code>ConcurrentHashMap</code>的默认初始容量为 16，默认的加载因子为 0.75，扩容时容量会扩大为原来的两倍，会使用节点锁（为了避免热点段废弃了分段锁，使用粒度更小的节点锁）、CAS、synchronized 将锁粒度缩小为单个桶</p>
</li>
<li><p>节点锁的锁粒度极小，大多数情况下极少出现同时修改同一个节点，因此 synchronized 基本是以偏向锁或者轻量级锁（而非重锁）的形式出现，此时 synchronized 和 ReentrantLock 的性能几乎也没有差别，因此选择使用 synchronized（而不是 ReentrantLock）来避免手动锁管理等问题，还可以受益于 JVM 的 JIT 优化，详细参见 <a href="../../../../2022/05/08/java-concurrency/">Java Concurrency</a> 的 3.1.2 小节。</p>
</li>
<li><p><code>ConcurrentHashMap</code>和<code>Hashtable</code>中的键和值都不允许为 null，这是为了避免二义性（不含有某个键还是某个键映射的值是 null），这种二义性在并发情况下无法通过<code>containsKey</code>方法进行区分</p>
</li>
<li><p><code>ConcurrentHashMap</code>在初始化时，首先判断是否有多线程在操作（通过记录当前操作线程数的<code>sizeCtl</code>变量判断），若没有其他线程则通过 CAS 修改<code>sizeCtl</code>变量后进行正常初始化，若存在多线程则通过<code>Thread.yield</code>让出 CPU 时间片，等待下一次唤醒</p>
</li>
<li><p><code>ConcurrentHashMap</code>在添加元素时，如果这个 key 所在的桶为空，则使用 CAS 操作来添加新节点，如果桶不为空，则使用<code>synchronized</code>锁住这个桶节点（而不是锁住整个哈希表）再将新节点插入链表或红黑树中</p>
</li>
<li><p><code>ConcurrentHashMap</code>在扩容时，并没有一味地通过 CAS 或锁去限制多线程，而是通过 CPU 核数为每个线程分配独立的迁移任务，多线程可以加速扩容</p>
</li>
<li><p><code>ConcurrentHashMap</code>在遍历时，提供一种弱一致性迭代器，该迭代器可以获取到迭代器创建之前被添加到<code>ConcurrentHashMap</code>中的元素，但不保证一定能获取到迭代器创建之后被添加/删除的元素</p>
</li>
</ul>
</li>
<li><p><code>LinkedHashMap</code></p>
<ul>
<li><p><code>LinkedHashMap</code>按照插入顺序或者是最少使用的顺序保存键，顺序规则可在构造器中设置</p>
</li>
<li><p><code>LinkedHashMap</code>也通过散列来提升查询速度，只比<code>HashMap</code>慢一点，但在迭代访问时反而比<code>HashMap</code>更快，这是因为它使用链表维护内部次序</p>
</li>
</ul>
</li>
<li><p><code>TreeMap</code></p>
<ul>
<li><p><code>TreeMap</code>具备<code>Map</code>中未包含的额外方法，是唯一带有<code>subMap()</code>方法的<code>Map</code>，可以返回一个子树</p>
</li>
<li><p><code>TreeMap</code>基于红黑树实现，键元素必须实现<code>Comparable</code>接口，按照比较结果的升序保存键，因此查询速度有所下降</p>
</li>
</ul>
</li>
</ul>
<h2 id="2-3-容器的使用"><a href="#2-3-容器的使用" class="headerlink" title="2.3 容器的使用"></a>2.3 容器的使用</h2><p>数组与容器的区别有三方面：效率、类型和能力</p>
<ul>
<li><p>效率：由于数组就是一个简单的线性序列，是 Java 中效率最高的存储和随机访问对象引用序列的方式（<code>ArrayList</code>的效率比数组低很多），为这种速度所付出的代价是数组对象的大小被固定，并且在其生命周期内不可改变，数组强调的是性能而非灵活性</p>
</li>
<li><p>类型：数组和泛型不能很好地结合，擦除会移除参数化类型信息，而数组必须知道它们所持有的确切类型来强制保证类型安全，因此 Java 不能实例化具有参数化类型的数组（但可以声明一个参数化类型的数组引用），而泛型可以指定容器要持有什么类型的对象，可以在编译期（而非运行期）防止将错误类型的对象放置到容器中，泛型容器几乎总是较泛型数组更好的选择；此外，数组支持协变，而泛型不支持</p>
</li>
<li><p>能力：容器即存放要使用的对象的地方，比数组更加灵活，具备更多不同的功能，Java 容器类是最具重用性的类库之一，当需要在数组上执行更加复杂的操作的，需要评估到底是使用数组还是更加灵活的容器，只有在已证明性能存在问题，并且切换到数组对性能提高有所帮助时，才应该将程序由容器重构为使用数组</p>
</li>
</ul>
<p>快速失效（fail-fast）是一种理念，在系统设计中，fail-fast 系统是一种可以立即报告任何可能表明故障的情况的系统，一旦发生故障，直接停止正常操作并以异常的方式上报故障，而不是试图继续可能存在问题的过程。在 Java 容器中有用到 fail-fast 原则进行设计，如果存在多个线程同时修改同一个容器的内容或者是在迭代过程中增加或移除元素，就会触发 fail-fast，抛出<code>CocurrentModificationException</code>。如果需要在遍历时修改集合，可以使用普通的<code>for</code>循环，或者使用迭代器本身的<code>remove</code>，或者使用<code>stream</code>的<code>filter</code>方法。fail-safe 则是为线程安全的并发集合准备的，避免了多线程并发以及迭代过程中增加或移除元素时触发 fail-fast 导致不断抛出异常，但在并发及迭代期间并不保证数据的强一致性，详细参见 <a href="../../../../2022/05/08/java-concurrency/">Java Concurrency</a> 的 3.3.1 小节。除了直接使用 JUC 包，还可以通过给非并发容器加锁、使用局部变量、使用<code>ThreadLocal</code>将容器放到单个线程内访问、使用<code>Collections.synchronizedXXX</code>方法获取线程安全的容器、使用不可变的容器类等方式来保证容器的线程安全。</p>
<p>数组和容器所存储的元素集合都可以生成<code>Stream</code>，<code>Stream</code>不是一种数据结构，只是某种数据源的一个视图，<code>Stream</code>的思想是将要处理的元素集合看作一种流，可以对流进行筛选、排序、聚合等处理，对<code>Stream</code>的任何处理都不会修改其背后的数据源，而是会产生一个新的<code>Stream</code>/新的集合/其他结果。<code>Stream</code>的中间操作（<code>filter</code>, <code>map</code>, <code>limit</code>, <code>sorted</code>, <code>distinct</code>）的结果是<code>Stream</code>，<code>Stream</code>最终操作（<code>forEach</code>, <code>count</code>, <code>collect</code>）就是在消费<code>Stream</code>，<code>Stream</code>只能被消费一次，消费之后不能再次使用流，也不能再使用任何中间操作。对于有序的<code>stream</code>，并发可能会降低性能，此时应该避免使用并发，如果无法避免使用并发，可在使用前通过<code>unorder</code>将该<code>Stream</code>转为无序的。</p>
<h2 id="2-4-类型信息和泛化"><a href="#2-4-类型信息和泛化" class="headerlink" title="2.4 类型信息和泛化"></a>2.4 类型信息和泛化</h2><p>运行时类型信息可以在程序运行时发现和使用类型信息，类型信息是由称为<code>Class</code>对象的特殊对象完成的，它包含了与类有关的信息，每一个 Java 类都有一个<code>Class</code>对象。Java 有两种方式可以在运行时识别类型信息</p>
<ul>
<li><p>一种是传统的 RTTI，它假定在编译时就已经知道了所有的类型（Java 的容器和泛型系统会确保这一点），编译器在编译时打开和检查<code>.class</code>文件</p>
</li>
<li><p>另一种是反射机制（指程序在运行时能够获取类的类型信息），对于那些<code>.class</code>文件在编译时不可获取的匿名对象来说，反射在运行时打开和检查<code>.class</code>文件，从而确定那些匿名对象类型，<code>Class</code>类和<code>java.lang.reflect</code>库一起对反射的概念进行了支持</p>
</li>
</ul>
<p>Java 类都是在第一次被使用时（创建第一个对类的静态成员的引用或者使用<code>new</code>操作符创建类的新对象），由类加载器执行以下这三个步骤来实现为使用该 Java 类而做的准备工作，在第一个步骤中会将 Java 类的<code>Class</code>对象动态加载到 JVM 中的，一旦其<code>Class</code>对象被载入内存，它就被用来创建这个类的所有对象，Java 使用<code>Class</code>对象来执行其 RTTI。</p>
<ul>
<li><p>加载：查找字节码，并从这些字节码中创建一个<code>Class</code>对象，由类加载器执行</p>
</li>
<li><p>链接：验证类中的字节码，解析这个类创建的对其他类的所有引用</p>
</li>
<li><p>初始化：如果该类具有超类，则对其初始化，执行静态初始化器和静态初始化</p>
</li>
</ul>
<p>无论何时，只要想在运行时使用类型信息，就必须首先通过反射机制获得对恰当的<code>Class</code>对象的引用，获得<code>Class</code>对象的引用有以下方式，第三种方式是最简单、安全、高效的，因为它在编译时就会受到检查，不需要置于<code>try</code>语句块中，这种方式不仅可以应用于普通的类，也可以应用于接口、数组以及基本数据类型。第一、二种方式会完整执行加载、链接和初始化这三个步骤，但第三种方式仅仅只是获得<code>Class</code>引用时，不会进行初始化。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Class</span> <span class="variable">c</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    c = Class.forName(<span class="string">&quot;User&quot;</span>);</span><br><span class="line">&#125; <span class="keyword">catch</span> (ClassNotFoundException e) &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(e);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">User</span> <span class="variable">user</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">User</span>();</span><br><span class="line">c = user.getClass();</span><br><span class="line"></span><br><span class="line">c = User.class;</span><br></pre></td></tr></table></figure>

<p>反射破坏了封装性，降低了代码可读性和可维护性，此外，由于反射涉及动态解析，因此不能执行 JVM 的 JIT 优化，在通过反射来调用对象的方法时参数需要从方法数组中遍历查找，做很多额外检查，反复在<code>Object</code>类型和真正类型之间包装和拆包，这些动作不仅消耗时间，还会产生很多需要垃圾回收的对象，因此反射会导致性能下降，在业务代码中应该尽量避免使用反射。</p>
<p>泛化的类型信息<code>Class&lt;?&gt;</code>（<code>?</code>是无限制通配符，表示任何事物）等价于普通的类型信息<code>Class</code>，但由于<code>Class&lt;?&gt;</code>可以放松声明变量时的限制，表示明确选择了一个非具体的类引用（并非是碰巧或者由于疏忽）。范围类型信息<code>Class&lt;? extends XXX&gt;</code>被限定为某种类型，或该类型的任何子类型的<code>Class</code>引用，从而提供编译期类型检查，而普通的类型信息<code>Class</code>直到运行时才能发现使用错误，就不如编译期检查方便。因此，泛化的类型信息优于普通的类型信息。</p>
<p>通过 RTTI 或者反射在 Java 程序运行时识别类型信息后，就可以使用类型信息进行类型转换时，需要注意的是任何向下的类型转换前都需要先做类型检查，除了通过查询<code>Class</code>对象获取运行时类型来进行类型检查外（明确具体类型的检查，比如派生类和基类是不同的类型），还可以使用<code>instanceof</code>关键字进行类型检查（某个范围的类型检查，比如派生类也是基类这个类型）。</p>
<p>面向对象的目的是在凡是可以使用多态的地方都使用多态机制，只在必须的时候使用 RTTI 和反射。</p>
<h2 id="2-5-泛型及其局限"><a href="#2-5-泛型及其局限" class="headerlink" title="2.5 泛型及其局限"></a>2.5 泛型及其局限</h2><p>多态是泛化机制的一种（将方法的参数类型设置为基类，该方法则可以接收该基类的任何派生类作为参数），但是泛化机制希望达到的目的是编写更通用的代码，需要通过各种途径来放松对代码将要作用的类型的限制，编写能够尽可能广泛地应用的代码，使得代码能够应用于“某种不具体的类型”，而不是一个具体的接口或者类，同时不丢失编译期的静态类型检查的好处。与其使用<code>Object</code>，不如暂时不指定类型，而是使用类型参数，然后在使用这个类时再用实际的类型替换此类型参数。</p>
<p>泛型（适用于许多许多的类型）实现了参数化类型的概念，可以用于类，也可以仅仅用于类方法，即是否拥有泛型方法与其所在的类是否是泛型没有关系，在使用参数化类型时，编译器会负责转型操作，并且保证类型正确。容器是促成泛型出现的原因之一，泛型用于指定容器要持有什么类型的对象。</p>
<p>类型化参数和它们在有用的泛型代码中的应用，通常比简单的（多态）类替换要更复杂，因此对于能使用类替换的情况就不必使用泛型，只有希望代码使用的类型参数比某个具体类型更加“泛化”（代码能够跨越多个类工作）时，使用泛型才有所帮助。比如使用泛型元组（tuple）可以一次性返回多个对象（<code>return</code>语句只允许返回单个对象），并能在编译期即确保类型安全。元组是一个容器对象，可以具有任意长度，元组中的对象可以是任意不同的类型。元组将一组对象直接打包存储于其中的一个单一对象，允许读取其中元素，但是不允许向其中存放新的对象。</p>
<p>Java 泛型是使用擦除来实现的，泛型类型只有在静态的类型检查的编译期间才出现，此时，编译器会把程序中所有的泛型类型信息都擦除替换为它的第一个非泛型边界（比如<code>T</code>会被擦除替换为<code>Object</code>，<code>X1&lt;T&gt;</code>会被擦除替换为<code>X1</code>，<code>X2&lt;T extends X3&gt;</code>会被擦除替换为<code>X2&lt;X3&gt;</code>）这是一种参数类型合并，将泛型类型实例关联到同一个份字节码上，编译器为多个泛型类型只生成一份字节码，因此这些泛型类型是不能在运行时出现的类型，在泛型代码内部，无法获得任何有关泛型参数类型的信息，无法在类型参数上执行基于类型的语言操作（比如转型、<code>instanceof</code>、<code>new</code>对象，<code>new</code>数组、反射、重载等），运行时类型不存在泛型类型，泛型类的所有静态变量都是共享同一份的。</p>
<p>为了实现泛型的迁移，每个类库和应用程序都必须与其他所有的部分是否使用了泛型无关，必须不具备探测其他类库是否使用了泛型的能力，因此，某个类库使用了泛型这样的证据必须被“擦除”，擦除使得类型参数无法具体化，但这也使得泛型代码和非泛型代码共存成为可能，在不破坏现有类库的情况下，实现了从非泛型代码到泛型代码的转变，此外，这也意味着泛型的使用并不是强制的。</p>
<p>泛型是在 Java 语言已经被广泛应用之后才添加到 Java 中的特性，而不是一开始就设计到 Java 语言中的，基于擦除实现的 Java 泛型存在局限，并未达到解耦类或方法与所用类型之间的约束这种程度，比如编写真正泛化的“持有器”类（Java 容器）相当简单（ Java 泛型远不止类型安全的容器这么简单），但编写能够操作其泛型类型的真正泛化的“操作器”类则较为复杂（可能需要配合使用反射、适配器等各种设计模式才能实现），需要理解 Java 泛型的边界在哪里，理解了边界所在，知道了某个技术不能做到什么，才能更好的做到所能做的。</p>
<h1 id="3、I-O-系统"><a href="#3、I-O-系统" class="headerlink" title="3、I/O 系统"></a>3、I/O 系统</h1><p>一个好的输入/输出（I/O）系统要涵盖所有的可能性，不仅存在各种 I/O 源端和想要与之通信的接收端（文件、控制台、网络链接等），而且还需要以各种不同的方式与它们进行通信（顺序、随机存取、缓冲、二进制、按字符、按行、按字等）。</p>
<h2 id="3-1-I-O-类库"><a href="#3-1-I-O-类库" class="headerlink" title="3.1 I/O 类库"></a>3.1 I/O 类库</h2><ul>
<li><p><code>File</code>类</p>
<ul>
<li><p><code>File</code>类的名称有一定的误导性，实际上它既能代表一个特定文件的名称，又能代表一个目录下的一组文件的名称（FilePath 对这个类来说是个更好的名字）</p>
</li>
<li><p>除了代表已经存在的文件或者目录，<code>File</code>对象还可以创建新的目录或尚不存在的整个目录路径，可以查看文件的特性（大小、修改日期、读、写），可以检查该<code>File</code>对象代表的是文件还是目录</p>
</li>
<li><p>当<code>File</code>对象值的是一个文件时，可以删除文件，当<code>File</code>对象指的是一个文件集时，可以对此集合调用<code>list()</code>方法，从而返回一个字符数组</p>
</li>
</ul>
</li>
<li><p>流</p>
<ul>
<li><p>流是代表任何有能力产出数据的数据源对象或者是有能力接收数据的接收端对象，屏蔽了实际的 I/O 设备中处理数据的细节（管道流的价值体现在多线程任务之间的通信，详细见 <a href="../../08/java-concurrency/">Java Concurrency</a>）</p>
</li>
<li><p>任何自<code>InputStream</code>或<code>Reader</code>派生而来的类都含有<code>read()</code>方法，用于读取单个字节或者字节数组，任何自<code>OutputStream</code>或<code>Writer</code>派生而来的类都含有<code>write()</code>方法，用于写单个字节或者字节数组</p>
</li>
<li><p>很少使用单一的类来创建流对象，Java 为了创建某个结果流，其实需要通过叠加多个 I/O 对象来提供所期望的功能（装饰器设计模式），装饰器模式提供灵活性的同时也增加了代码的复杂性，使得记住如何打开文件变成一件相当困难的事情，这就是 Java I/O 类库操作不便的原因所在</p>
</li>
</ul>
</li>
<li><p><code>InputStream</code>和<code>OutputStream</code>类</p>
<ul>
<li><p><code>InputStream</code>用来表示那些从不同数据源产生输入的类，这些数据源包括字节数组，<code>String</code>对象，文件，管道，由其他种类的流组成的序列，Internet 连接等</p>
</li>
<li><p>每一种数据源都有相应的<code>InputStream</code>子类，另外<code>FilterInputStream</code>是<code>InputStream</code>的抽象子类，用于为装饰器类提供基类，是装饰器的必要条件，装饰器类可以把属性或有用的接口与输入流连接在一起</p>
</li>
<li><p><code>OutputStream</code>用来决定输出所要去往的目标，这些目标包括字节数组，文件或者管道</p>
</li>
<li><p><code>FilterOutputStream</code>为装饰器类提供了一个基类，是装饰器的必要条件，装饰器类可以把属性或者有用的接口与输出流连接起来</p>
</li>
<li><p>无论读和写数据的平台多么不同，只要两个平台都有 Java，<code>DataOutputStream</code>和<code>DataInputStream</code>可以保证准确的读写数据（XML 是另一种解决不同计算平台之间移动数据的方式，且不要求平台必须有 Java）</p>
</li>
<li><p><code>InputStream</code>和<code>OutputStream</code>继承层次结构还包括支持读写压缩格式的数据流</p>
</li>
</ul>
</li>
<li><p><code>Reader</code>和<code>Writer</code>类</p>
<ul>
<li><p><code>Reader</code>和<code>Writer</code>并非是用于替代<code>InputStream</code>和<code>OutputStream</code>的类，<code>InputStream</code>和<code>OutputStream</code>在以面向8位字节流形式的 I/O 中提供极有价值的功能，而<code>Reader</code>和<code>Writer</code>则提供兼容16位 Unicode 与面向字符的 I/O 功能</p>
</li>
<li><p>一般尽量尝试使用<code>Reader</code>和<code>Writer</code>，当发现程序代码无法编译成功，就会发现不得不使用面向字节的<code>InputStream</code>和<code>OutputStream</code></p>
</li>
<li><p>当需要把来自字节层次结构中的类和字符层次结构中的类结合起来使用时，<code>InputStreamReader</code>和<code>OutputStreamWriter</code>可以作为适配器类来将<code>InputStream</code>和<code>OutputStream</code>转换为<code>Reader</code>和<code>Writer</code></p>
</li>
</ul>
</li>
</ul>
<h2 id="3-2-新-I-O-类库"><a href="#3-2-新-I-O-类库" class="headerlink" title="3.2 新 I/O 类库"></a>3.2 新 I/O 类库</h2><p>Java 在<code>java.nio.*</code>包中引入了新 I/O 类库，其目的在于提高速度，速度的提高来自于所使用的结构更接近于操作系统执行 I/O 的方式：通道、缓冲器以及内存映射文件。</p>
<p>需要读写的字节流数据只需要和缓冲器（<code>ByteBuffer</code>）进行交互，而缓冲器则与通道（<code>FileChannel</code>）进行交互。</p>
<ul>
<li><p>通道与通道可以直接相连，通道可以在文件内随处移动，通道可以锁定文件的某些区域用于独占式访问</p>
</li>
<li><p><code>ByteBuffer</code>是唯一直接与通道进行交互的缓冲器，是将数据移进移出通道的唯一方式</p>
</li>
<li><p><code>ByteBuffer</code>只能保存字节类型的数据，但是它可以从其所容纳的字节中产生出各种不同基本类型的方法</p>
</li>
<li><p>nio 的目标就是快速移动大量数据，<code>ByteBuffer</code>的大小就显得尤为重要，必须通过实际运行应用程序来找到最佳尺寸</p>
</li>
</ul>
<p>内存映射文件允许创建和修改那些因为太大而不能放入内存的文件，内存映射文件使得程序员可以假定这个文件都放在内存中，而且可以完全把它当做非常大的数组来访问极大地简化了用于修改文件的代码。</p>
<ul>
<li>注意必须指定映射文件的初始位置和映射区域的长度，这意味着可以映射某个大文件的较小的部分</li>
<li>即使建立映射文件的花费很大，但是整体受益比起 I/O 流来说还是很显著的，映射文件访问可以显著的加快速度</li>
<li>底层操作系统的文件映射工具是用来最大化地提高性能。</li>
</ul>
<p>文件加锁机制运行同步访问某个作为多进程之间或者多线程之间共享资源的文件，即文件锁对其他的操作系统进程是可见的，Java 的文件加锁直接映射到了本地操作系统的加锁工具。</p>
<ul>
<li>当底层操作系统支持时，文件锁可以设置为独占锁或者共享锁，如果操作系统不支持，那么就会使用独占锁</li>
<li>文件映射通常应用于极大的文件，那么就需要对这种巨大的文件进行部分加锁，以便其他进程可以修改文件中未被加锁的部分</li>
<li>Java 虚拟机会自动释放文件锁或者关闭加锁的通道，也可以在程序中显式地释放文件锁</li>
</ul>
<h2 id="3-3-I-O-模型"><a href="#3-3-I-O-模型" class="headerlink" title="3.3 I/O 模型"></a>3.3 I/O 模型</h2><p>程序的所有输入都可以来自于标准输入，所有输出都可以发送到标准输出，所有的错误都可以发送到标准错误，标准 I/O 的意义在于很容易地将程序串联起来，一个程序的标准输出可以成为另一个程序的标准输入。</p>
<p>按照标准 I/O 模型，Java 提供了<code>System.in</code>，<code>System.out</code>和<code>System.err</code>，其中<code>System.out</code>和<code>System.err</code>都已经事先被包装成了<code>PrintStream</code>对象，这意味着我们可以立即使用<code>System.out</code>和<code>System.err</code>，而<code>System.in</code>是一个没有被包装的未经加工的<code>InputStream</code>，这意味着使用<code>System.in</code>之前需要对其进行装饰（和大多数流一样，通常需要包装成<code>BufferedReader</code>或者<code>BufferedInputStream</code>，从而进行缓冲。</p>
<p>Java 的<code>System</code>类提供了一些静态方法运行对标准 I/O 进行重定向，当输出内容太多滚动太快以至于无法阅读时，就需要进行输出重定向，当需要重复测试某个特定用户的输入序列的命令程序时，就需要进行输入重定向。标准 I/O 重定向操纵的是字节流，而不是字符流，因此使用的是<code>InputStream</code>和<code>OutputStream</code>，而不是<code>Reader</code>和<code>Writer</code>。</p>
<p>同步和异步描述的是被调用方，同步指被调用方在接到调用后会立即执行要做的事情，异步指被调用方在接到调用后会去执行要做的事情但不保证会立即执行。阻塞和非阻塞描述的是调用方，阻塞指调用方在发出调用之后要一直等待被调用方返回，非阻塞指调用方在发出调用之后不需要等待，可以去做自己的事情。阻塞与否和同步与否之间没有必然联系。</p>
<ul>
<li>BIO（Blocking I/O）是同步阻塞 I/O，是 JDK 1.4 之前的传统 I/O 模型，线程发起 I/O 请求后会一直阻塞直到缓冲区数据就绪，再进行下一步操作，适用于连接数目比较小且固定的架构，对服务器资源要求比较高，程序直观简单易理解</li>
<li>NIO（Non-Blocking I/O）是同步非阻塞 I/O，JDK 1.4 开始支持，线程发起 I/O 请求后，不需要阻塞而是立即返回，用户线程不原地等待 I/O 缓冲区，可以先做一些其他操作，需要定时轮询检查 I/O 缓冲区数据是否就绪，适用于连接数目多且连接比较短的架构，编程比较复杂</li>
<li>AIO（Asychronous I/O）是异步非阻塞 I/O 模型， JDK 7 开始支持，线程发起 I/O 请求后，不需要阻塞而是立即返回，也不需要定时轮询检查结果，异步 I/O 操作之后会回调通知调用方，适用于连接数目多且连接比较长的架构，充分调用 OS 参与并发操作，编程比较复杂</li>
</ul>
<h2 id="3-4-持久性"><a href="#3-4-持久性" class="headerlink" title="3.4 持久性"></a>3.4 持久性</h2><p>持久性意味着一个对象的生存周期并不却取决于程序是否正在运行，它可以生存于程序的调用之间，在程序终止后仍能继续保存该对象的信息，在下次运行程序时该对象可以被重建并且拥有的信息与上次程序运行时的信息相同（这一过程可以通过网络进行），这也可以弥补不同操作系统之间的差异。一个严格的持久性机制可以考虑 Hibernate 之类的工具，而对象序列化可以视作是一种轻量级持久性，轻量级是指不能用某种持久关键字来简单的定义一个对象并让系统自动维护其他细节问题，而是需要在程序中显式地进行序列化和反序列化还原，几乎所有的商用编程语言都有序列化的能力。</p>
<p>Java 原生的对象序列化机制是基于字节的，可以将<code>String</code>、枚举以及那些实现了<code>Serializable</code>接口的对象（包含对象的类名和实例变量，不包含方法和类静态变量）转换为一个字节序列，因此需要使用<code>InputStream</code>和<code>OutputStream</code>继承层次结构（<code>ObjectInputStream</code>和<code>ObjectOutputStream</code>）。Jackson、<a target="_blank" rel="noopener" href="https://www.yuque.com/hollis666/niq4hm/sexwwk">fastjson</a>、Gson 这样的 JSON 序列化库或其他 XML 库使用反射机制来访问对象的字段，并将它们转换成 JSON 或 XML 格式，这种情况下的对象序列化与<code>Serializable</code>接口无关。对象序列化的概念加入到 Java 主要是为了支持两种特性：一是 Java 远程方法调用，当向远程对象发送消息时，需要通过对象序列化来传输参数和返回值；二是保存运行阶段的 Java Beans 的状态信息并在程序重新启动时恢复。</p>
<p>序列化接口<code>Serializable</code>本身没有方法或字段，仅用于标识可序列化的语义，实现了<code>Serializable</code>接口的类被标识为可序列化的类，可序列化的类的子类自动也被标识为可序列化的类而不需要再显式地实现<code>Serializable</code>接口。可序列化的类可以显式定义一个<code>serialVersionUID</code>变量作为该类的序列化版本（方便项目升级），如果没有显式定义该变量，JVM 会根据编译的 Class 文件信息自动生成一个<code>serialVersionUID</code>，自动生成的<code>serialVersionUID</code>会随着类的 Class 文件或 JVM 的变化而变化。在进行反序列化时，JVM 会把传进来的字节流中的<code>serialVersionUID</code>与本地类的<code>serialVersionUID</code>进行比较，只要比较结果是相同的就认为是相同的类（即便序列化属性有所变化），可以进行反序列化，否则就视作字节流中的内容被篡改，会抛出<code>InvalidClassException</code>。</p>
<p>当需要控制对象的某个部分不被序列化时，有两种解决方式，一种是使用<code>transient</code>关键字关闭被修饰字段的序列化，当对象被反序列化还原时，该字段就会变成默认值；另一种是添加（而非覆盖或者实现）名为<code>writeObject()</code>和<code>readObject()</code>的方法，这样一旦对象被序列化或者被反序列化还原，就会自动调用这两个方法，而不是使用默认的序列化机制。当程序试图序列化一个对象时，会先检查该对象是否已经被序列化，只有对象从未在此 JVM 被序列化过，才会将此对象序列化为字节序列，否则只是存储第一次序列化结果的引用，同一对象不会被多次序列化（即便对象发生了变化）。POJO 类中的任何布尔类型的变量名都不要以 is 开头，这是因为名称以 is 开头的布尔变量的 get 方法也是以 is 开头，那么在反序列化解析时就会找不到名称为去掉 is 的属性，进而抛出异常。</p>
<p>对于普通的 Java 类来说，反序列化会通过反射以及 Unsafe 直接分配内存的机制来创建类目标类的一个新实例，这个过程会递归地反序列化目标类的可序列化的父类实例直到找到一个不可序列化的父类（比如<code>Object</code>类），对于不可序列化的父类，则调用该父类的无参构造函数，整个过程并不会调用目标类的构造函数，即使目标类的构造函数是私有的，也对反序列化没有影响，因此在这种场景下，需要注意是否存在对单例的破坏。当需要确保某个对象的反序列化不破坏单例时，可以添加（而非覆盖或者实现）名为<code>readResolve()</code>的方法，在该方法中指定对象的生成策略，比如直接返回单例对象而不是生成新对象。对于枚举类型来说，反序列化是通过<code>java.lang.Enum</code>的<code>values</code>方法来根据名字查找枚举元素的，这个过程并不会使用反射，并且编译器不允许任何对这种序列化与反序列化机制的定制，禁用了<code>writeObject()</code>、<code>readObject()</code>、<code>readObjectNoData</code>、<code>writeReplace</code>和<code>readResolve</code>等方法，因此枚举的反序列化并不存在对单例的破坏。</p>
<p>上述基于<code>Serializable</code>接口的序列化是自动序列化，系统自动存储必要的信息，Java 内建原生支持，易于实现，只需要实现该接口即可，无需任何代码支持；而继承了<code>Serializable</code>接口的<code>Externalizable</code>接口是强制自定义的序列化，由程序员决定存储哪些信息，<code>Externalizable</code>接口的实现类必须实现<code>writeExternal</code>和<code>readExternal</code>方法，在这两个方法中定义序列化与反序列化的实现细节，此外还必须提供一个<code>public</code>无参构造器，在反序列化时就会调用该构造器。<code>Externalizable</code>较<code>Serializable</code>性能略好一些。</p>
<h1 id="4、日志"><a href="#4、日志" class="headerlink" title="4、日志"></a>4、日志</h1><p>日志用于没有 debug 工具时的线上应用监控，bug 的跟踪定位等，应该做到内容关键有效且便于定位。</p>
<h2 id="4-1-日志级别"><a href="#4-1-日志级别" class="headerlink" title="4.1 日志级别"></a>4.1 日志级别</h2><p>Log4j 的级别类<code>org.apache.log4j.Level</code>里面定义了日志级别，常用的级别如下：</p>
<ul>
<li><p>ERROR：系统发生了错误事件，但仍然不影响系统的继续运行</p>
</li>
<li><p>WARN： 系统在业务处理时触发了异常流程，但系统可恢复到正常态</p>
</li>
<li><p>INFO： 记录系统关键信息，旨在保留系统正常工作期间关键运行指标</p>
</li>
<li><p>DEBUG： 可以将各类详细信息记录到DEBUG里，起到调试的作用，包括参数信息，调试细节信息，返回值信息等</p>
</li>
</ul>
<p>日志优先级别标准顺序为：ALL &lt; TRACE &lt; DEBUG &lt; INFO &lt; WARN &lt; ERROR &lt; FATAL &lt; OFF，那么如果日志级别设置 INFO，就只有输出级别为 INFO 以及级别大于 INFO 的日志才会正常输出。</p>
<h2 id="4-2-记录时机"><a href="#4-2-记录时机" class="headerlink" title="4.2 记录时机"></a>4.2 记录时机</h2><p>日志的写入操作通常是一个相对耗时的 I/O 操作，一方面可以通过使用异步日志来避免每次日志记录都同步写入磁盘，主线程可以继续执行其他任务而不是因日志记录而阻塞，日志写入操作则由后台线程负责处理，可以提高应用程序的响应性和吞吐量；另一方面可以去除一些不必要的日志记录，有必要日志记录的一些时机如下：</p>
<ul>
<li><p>系统初始化：系统初始化时会依赖一些关键配置，根据参数不同会提供不一样的服务，将系统的启动参数记录INFO日志，打印出参数以及服务启动完成状态</p>
</li>
<li><p>业务流程与预期不符：常见的合适场景包括外部参数不正确，数据处理问题导致返回码不在合理范围内等等</p>
</li>
<li><p>系统核心的关键动作：系统中核心角色触发的业务动作是衡量系统正常运行的重要指标，建议记录 INFO 级别日志，比如微服务各服务节点交互等</p>
</li>
<li><p>捕获到异常：是系统告知开发人员需要加以关注的，根据实际情况使用 WARN 或者 ERROR 级别</p>
</li>
<li><p>外部接口日志：与外部系统的交互涉及到责任问题，建议将原始数据文件内容写入日志或数据库，核心处理逻辑关键业务数据也尽量写入日志；如果涉及到重发，建议将处理失败的原始数据文件日志写入数据库，以便重发执行</p>
</li>
</ul>
<h2 id="4-3-日志规范"><a href="#4-3-日志规范" class="headerlink" title="4.3 日志规范"></a>4.3 日志规范</h2><p>记录日志应该遵守的一些规范如下：</p>
<ul>
<li><p>使用 SLF4J 中的 API 进行日志打印</p>
</li>
<li><p>日志输出必须采用 UTF-8 字符集，使用英文</p>
</li>
<li><p>不允许记录日志后又抛出异常，要么只记录错误日志，要么直接抛出异常</p>
</li>
<li><p>在日志中输出打印整个异常，而不是仅仅打印错误信息或仅仅堆栈信息</p>
</li>
<li><p>禁止<code>system.out</code>用于日志记录</p>
</li>
<li><p>线上必须关闭 DEBUG 级别日志</p>
</li>
<li><p>日志输出，必须使用<code>&#123;&#125;</code>占位符的方式，字符串相加会有性能问题</p>
</li>
<li><p>日志中不允许出现计算或方法调用，防止在打印日志的时候报错</p>
</li>
<li><p>输出的 POJO 类必须重写<code>toString</code>，否则只输出对象的 hashCode 值，没有参考意义</p>
</li>
<li><p>禁止记录大量对于排查故障毫无意义的日志信息，日志信息一定要带有业务信息</p>
</li>
<li><p>不可以将敏感业务信息记录入日志文件</p>
</li>
<li><p>严防日志占满磁盘，定期检查磁盘（确定是否有磁盘告警）</p>
</li>
<li><p>不要在大循环中循环打印日志</p>
</li>
<li><p>统一使用<code>log4j2.xml</code>或<code>logback.xml</code>配置，所有的 jar 包中不建议包含日志配置文件，避免干扰实际的业务系统</p>
</li>
</ul>
<h2 id="4-4-日志框架"><a href="#4-4-日志框架" class="headerlink" title="4.4 日志框架"></a>4.4 日志框架</h2><p>SLF4J (Simple Logging Facade for Java) 是可以用于各种 Java 日志框架的广义接口 (facade/abstraction)，允许用户选择实际希望使用的日志框架 (logging, logback, log4j)。诸如库或框架之类的嵌入式组件不应该声明依赖于任何 SLF4J 所绑定/提供的日志框架，而应该只声明依赖于 SLF4J。</p>
<p>启用 SLF4J 的库意味着只需要添加一个强制依赖项，即 slf4j-api.jar，此外，需将一个且仅一个选择的日志框架绑定放到适当的类路径位置上（slf4j-api.jar的版本与绑定框架的版本需要相匹配），不要在类路径上放置多个绑定。要切换日志框架，只需替换类路径上的日志框架绑定。如果在类路径上没有找到绑定/提供程序，那么 SLF4J 将默认为无操作实现。</p>
<p>Log4j 是 Apache 的一个开源日志框架，也是市场占有率最多的一个框架，Logback 被开发为 Log4j 的更强大的替代品，Logback 和 SLF4J 是互补的，可以一起使用，也可以不一起使用。Log4j 2是 Log4j 的升级版，修复了 Logback 架构中的一些固有问题。Log4j 2有点类似于Logback+SLF4J，因为它提供了一个 facade API（Log4j - API，与 SLF4J 相媲美）和一个实现（Log4j -core，与 Logback 相媲美）。</p>
<p>推荐使用 SLF4J + Logback 或者使用 Log4j 2。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> org.slf4j.Logger;</span><br><span class="line"><span class="keyword">import</span> org.slf4j.LoggerFactory;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">HelloWorld</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Logger</span> <span class="variable">logger</span> <span class="operator">=</span> LoggerFactory.getLogger(HelloWorld.class);</span><br><span class="line">        logger.info(<span class="string">&quot;Hello World&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="4-5-分布式日志系统"><a href="#4-5-分布式日志系统" class="headerlink" title="4.5 分布式日志系统"></a>4.5 分布式日志系统</h2><p>分布式日志系统可以对集群中的各个机器上的日志做统一收集、存储和管理，避免在分析日志时需要要去各个机器分别查看日志，可以通过自建 ELK 来实现分布式日志系统。</p>
<p>ELK 指 Elasticsearch、Logstash 和 Kibana，其中，Elasticsearch 提供分析、查询、存储数据等功能，Logstash 提供日志的采集和过滤，Kibana 提供友好的图形化界面，帮助信息汇总。</p>
<p>有时候还是避免不了去服务器上查看日志，<code>tail -f 日志文件名</code>可以滚动输出日志，适用于实时观察日志的场景；<code>less 日志文件名</code>可以查看整个日志文件，按空格向下翻页，按<code>Ctrl+B</code>向上翻页，按<code>/</code>并输入关键词向下搜索，按<code>?</code>并输入关键词向上搜索，按<code>Q</code>退出，适用于通篇查看日志的场景。</p>
<h1 id="5、其他补充"><a href="#5、其他补充" class="headerlink" title="5、其他补充"></a>5、其他补充</h1><h2 id="5-1-final"><a href="#5-1-final" class="headerlink" title="5.1 final"></a>5.1 final</h2><p><code>final</code>通常指无法改变，不想做改变可能出于设计或者效率的考虑，应当尽可能从设计的角度来决定是否使用<code>final</code>，而不是出于试图提高性能的目的来使用<code>final</code></p>
<ul>
<li><p><code>final</code>数据</p>
<p>通常是基本数据类型，使数值恒定不变，而对于对象引用，使引用恒定不变，但对象自身是可以修改的（Java 并未提供任何使对象恒定不变的途径，但可以自己编写类以取得使对象恒定不变的效果）</p>
<p>Java 允许生成被声明为<code>final</code>但又未给定初值的域，但编译器都确保这种<code>final</code>域在使用前必须被初始化</p>
</li>
<li><p><code>final</code>方法</p>
<p>确保任何继承类都无法重写该方法</p>
<p>类中所有的<code>private</code>方法都隐式地指定为<code>final</code></p>
</li>
<li><p><code>final</code>类</p>
<p>确保无法继承该类</p>
<p><code>final</code>类的域可以根据个人的意愿选择为是或者不是<code>final</code>，相同的规则适用于定义为<code>final</code>的域，但<code>final</code>类的中所有的方法都隐式指定为<code>final</code></p>
</li>
</ul>
<h2 id="5-2-异常"><a href="#5-2-异常" class="headerlink" title="5.2 异常"></a>5.2 异常</h2><p>异常的一些好处：</p>
<ul>
<li>Java 用异常来提供一致的错误报告模型，使得程序构件能够与客户端代码可靠地沟通问题</li>
<li>异常使得问题发生时强制程序停止运行，告知出现了什么问题，然后强制程序处理问题，并返回到稳定状态</li>
<li>如果在当前的环境中还没有足够的信息来解决某个问题，可以通过异常来将这个问题提交到一个更高级别的别的环境中，期望在那里做出正确的决定，即将正常主干代码和错误处理代码分开</li>
<li>异常往往能够降低错误处理代码的复杂度，只需在异常处理程序这一个地方进行错误处理，如果不使用异常，那么就必须在程序的许多地方去进行特定的错误处理</li>
</ul>
<p><code>Throwable</code>是 Java 中最顶级的异常类，被用来表示任何可以作为异常被抛出的类，<code>Throwable</code>可分为<code>Error</code>和<code>Exception</code>，<code>Error</code>用来表示运行期间的系统错误（比如<code>OutOfMemoryError</code>、<code>StackOverflowError</code>等），不能指望程序自身来处理这类问题，除了退出运行别无选择，程序中需要关心的基类型是<code>Exception</code>，<code>Exception</code>可分为受检异常和非受检异常。</p>
<p>如果一个方法可能抛出受检异常（比如 I/O 操作时找不到文件等），就代表该方法的调用者需要明确处理一些特殊情况（throw 或者 catch），否则代码无法通过编译。非受检异常则是运行时异常，继承自<code>RuntimeException</code>，针对非受检异常的显式处理不是必须的，如果代码中没有 catch 非受检异常，JVM 会自动将其抛出并中断程序的执行，究其根本，<code>RuntimeException</code>代表的是编程错误，是程序员在编写代码时就要进行检查的不应在运行期间发生的错误（比如空指针、数组越界等）。</p>
<p>不必拘泥于 Java 中已有的异常类型，可以自定义继承自<code>Exception</code>的异常类，也可以给异常类增加更多方法来得到更强的功能，但是使用程序包的客户端程序员可能仅仅只是查看一个抛出的异常类型，也不进行其他操作，所以对异常添加的其他功能一般也用不上，异常对象中有意义的信息通常也就是异常类型和类名，除此之外不包含任何有意义的内容。</p>
<p>在捕获异常时，可以通过直接捕获<code>Exception</code>来捕获所有的编程活动相关的异常，但最好把它放在处理程序列表的末尾，以防它抢在其他处理程序之前先把类型更加明确的异常子类捕获了。一旦捕获了异常，绝对不能什么都不做，也不能只是使用<code>e.printStacktrace</code>，如果不明确应当如何处理，则不应捕获，而是向上抛出。如果在捕获异常之后抛出了另外一种异常，那么有关原来异常发生点的信息回丢失，剩下的是与新的异常抛出点有关的信息。</p>
<p><code>finally</code>块用于进行一些确保一定要执行的除释放存储空间之外的清理工作，甚至在异常没有被当前的异常处理程序捕获的情况下，异常处理机制也会在跳到更高一层的异常处理程序之前执行当前层级的<code>finally</code>块，但是守护线程的<code>finally</code>块并不保证执行，详细参见 <a href="../../../../2022/05/08/java-concurrency/">Java Concurrency</a>。在涉及<code>break</code>和<code>continue</code>时，搭配<code>finally</code>使用即可实现<code>goto</code>功能，因此 Java 里就没有必要使用<code>goto</code>语句了。此外，如果<code>try</code>块中发生异常，那么<code>catch</code>中的<code>return</code>语句会覆盖<code>try</code>中的<code>return</code>语句，无论是否发生异常，<code>finally</code>块中的<code>return</code>语句将覆盖<code>try</code>和<code>catch</code>块中的<code>return</code>语句。</p>
<p>在覆盖方法时，派生类方法只能抛出基类方法的异常声明里列出的那些异常，不过基类方法的异常声明无需出现在派生类的异常声明中。但这个异常限制对构造器则有所不同，派生类构造器可以抛出任何异常，但不能捕获基类构造器抛出的异常，派生类构造器的异常说明里必须包含基类构造器的异常说明。 </p>
<p>不建议使用异常来进行业务流程控制，异常的生成和处理涉及到栈跟踪信息，是昂贵的操作，频繁地抛出和捕获异常会导致性能下降，异常的职责应当是处理非预期的错误情况，而使用异常控制的业务流程会使得代码的意图变得不清晰，有时还会影响事务的提交或回滚</p>
<h2 id="5-3-字符串"><a href="#5-3-字符串" class="headerlink" title="5.3 字符串"></a>5.3 字符串</h2><p><code>String</code>是使用最广泛的数据结构，为了降低大量<code>String</code>创建的资源耗费，所以 Java 提供了对<code>String</code>的缓存功能（字符串池）来节省内存空间资源，那么两个内容相同的<code>String</code>变量可以指向字符串常量池中的同一个<code>String</code>对象，这也就要求<code>String</code>必须具备不可变性，此外，<code>String</code>在 Java 应用程序中广泛用于存储敏感信息，因此保护<code>String</code>不被修改对于提升整个应用程序的安全性也至关重要。</p>
<p><code>String</code>类被声明为<code>final</code>，这意味着它不能被继承，<code>String</code>类中用<code>final</code>修饰<code>byte[]</code>类型的字符串值，一旦值被初始化就不能再指向其他数组，<code>String</code>没有提供用于修改字符串值的公共方法，那些涉及到所谓的字符串修改的公共方法都是通过创建一个新的<code>String</code>对象并返回来实现的，综上所述，<code>String</code>对象是不可变的。此外，<code>String</code>有长度限制，编译期的长度限制是 2^16 -1，运行期的长度限制是 2^31 - 1。</p>
<p>不可变对象在完全创建后其内部状态保持不变，指向它的任何引用都不可能改变它的值，具有只读特性，可以安全地在多个线程之间共享，但不可变性也会带来一定的效率问题，例如对<code>String</code>对象使用<code>+</code>运算符时可能需要创建很多需要垃圾回收的中间<code>StingBuilder</code>对象（如果是简单的字符串常量间的静态拼接，就不存在这个问题，因为编译器在编译阶段会直接计算出结果）。</p>
<p>因此，在进行字符串变量间的动态拼接（尤其是在循环体中）时，多线程并发情况下使用<code>StringBuffer</code>，非线程并发的情况下一般使用<code>StringBuilder</code>，<code>StringBuffer</code>和<code>StingBuilder</code>类似，区别在于<code>StringBuffer</code>的操作方法使用<code>synchronized</code>进行声明，是线程安全的方法，而<code>StingBuilder</code>则不是线程安全的，在引入了偏向锁和锁升级后，无锁竞争时的<code>StringBuffer</code>和<code>StringBuilder</code>的性能是一致的，所以非线程并发时使用<code>StringBuffer</code>其实也可以，并不会带来性能上的下降。</p>
<p>在 JDK 9 之前，<code>String</code>内部使用字符数组<code>char[]</code>来表示，为了避免有些只需要占据一个字节的字符由于使用<code>char</code>而占据了两个字节，JDK 9 引入了字符串压缩的概念，在<code>String</code>内部使用字节数组<code>byte[]</code>来表示字符，当字符串中所有字符都可以用单个字节表示时，内部使用字节数组来保存一半所需的空间，但如果存在一个字符需要超过一个字节来表示时，将继续使用 UTF-16 的字符数组，<code>String</code>内部还通过一个名为<code>coder</code>的变量来标识这两种情况。</p>
<p><code>String.intern</code>方法会把字符串池中没有的字符串实例的引用放入字符串池中，并返回该引用，如果在这之前字符串池中已经存在一个等于该字符串的实例，<code>String.intern</code>方法则会直接返回这个已存在的实例的引用，这就确保了一般情况下相同内容的字符串在内存中只有一个实例，例外情况是使用<code>new</code>在堆中创建与字符串常量池中已有字符串实例内容相同的新实例。</p>
<p>Java 字符串常量有两种进入字符串池的途径，一种是作为字面量（字面量是源码中用于表达一个固定值的表示法，指由字母、数字等构成的字符串或者数值，只可以右值出现），先在编译期进入 Class 文件常量池表，再在运行期类加载后（具体是在第一次被调用时，JVM 开始对 Class 文件进行解析）被存放到字符串池中，另一种是在运行期间通过<code>String.intern</code>方法被放入字符串池中，详细参见 <a href="../../../../2023/12/09/java-virtual-machine/">Java Virtual Machine</a> 中的 2.1 和 3.2.1 小节。</p>
<p>最后再补充一个关于<code>toString</code>方法使用的错误示例：希望打印对象的内存地址时，调用以下代码会产生异常，这是因为在将<code>InfiniteRecursion</code>对象自动转换为<code>String</code>类型时，会调用<code>this</code>上的<code>toString</code>方法，于是就发生了递归调用。为了避免这个问题，应当将<code>this</code>修改为<code>super</code>。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">InfiniteRecursion</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">toString</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;InfiniteRecursion address&quot;</span> + <span class="built_in">this</span> + <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">        <span class="comment">// 应当修改为</span></span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;InfiniteRecursion address&quot;</span> + <span class="built_in">super</span>.toString() + <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>UUID 是全局唯一标识符，是指在一台机器上生成的数字，目标是保证在同一时空中的所有机器上都是唯一的。UUID 的生成通常是在本地基于随机数生成器、时间戳、MAC 地址等生成算法，生成的 UUID 由 32 位 16 进制数表示，共 128 bit，具有极高的唯一性，几乎不可能重复。由于随机生成的 UUID 具备不可预测性，无任何含义，不适合页面展示，适用于需要保密的应用场景。由于可以在不同的机器上生成 UUID，因此可以用于分布式系统中。</p>
<p>正则表达式是一种强大而灵活的文本处理工具，提供了一种完全通用的方式来解决各种字符串处理相关的问题，比如匹配、选择、编辑以及验证（参考<code>java.util.regex.Pattern</code>），正则表达式是昂贵的操作，不应在循环中大量执行。</p>
<h2 id="5-4-字符编码"><a href="#5-4-字符编码" class="headerlink" title="5.4 字符编码"></a>5.4 字符编码</h2><p>字符编码是一套法则，使用该法则能够对自然语言的字符集合进行配对。</p>
<p>ASCII 码对英语字符与二进制之间的关系做了统一的规定，一共 128 个字符。</p>
<p>Unicode 字符集是计算机科学领域里的一项业界标准，对世界上大部分的文字系统（包括中文）进行了整理、编码，使得计算机可以用更为简单的方式来呈现和处理文字。可扩展置标语言（XML）、Java 编程语言以及现代操作系统都采用 Unicode 编码。Unicode 虽然统一了编码，但没有规定如何存储（考虑到字符集合太大，如果规定则每个字符需要用很多个字节进行编码和存储，是极大的空间浪费），因此产生了一些编码长度不同的中间格式的字符集（称为 Unicode Transformation Format），常见的有 UTF-7、UTF-7.5、UTF-8、UTF-16 以及 UTF-32，这些字符集都是 Unicode 的一种实现方式。</p>
<p>此外，还有一些常见的中文编码有 GBK、GB2312、GB18030，这些编码与 Unicode 相比，都是针对更小的字符集合，从而采用更短的编码方式，单个字符占据更小的存储空间。</p>
<p>Java 中的<code>char</code>类型表示一个占据两个字节的 Unicode 字符，因此<code>char</code>类型可以存储 Unicode 字符集中的所有字符，但是在使用时需要注意确保 Java 源码文件本身、编译器以及运行时环境都支持 Unicode 字符集，还需要注意字符编码以及字符串长度问题。</p>
<h2 id="5-5-注解"><a href="#5-5-注解" class="headerlink" title="5.5 注解"></a>5.5 注解</h2><p>注解也被称为元数据，提供了一种形式化的在代码中添加信息的方法（比注释性文字更优），这些元数据信息保存在 Java 源代码中，而不是保存在外部文档中，这使得可以在稍后某个时刻非常方便地使用这些数据。</p>
<p>元注解是 Java 提供的可以用于定义注解的基本注解，通过元注解，可以自定义其他功能的注解，常用的元注解如下</p>
<ul>
<li><p><code>@Target</code></p>
<ul>
<li><p>用于告知Java将自定义的注解放在何处，比如类、方法、构造器、变量上等，是一个枚举类型，有如下属性值；</p>
</li>
<li><p><code>ElementType.CONSTRUCTOR</code>代表用于描述构造器；</p>
</li>
<li><p><code>ElementType.FIELD</code>代表用于描述成员变量、对象、属性（包括<code>enum</code>实例）；</p>
</li>
<li><p><code>ElementType.LOCAL_VARIABLE</code>代表用于描述局部变量；</p>
</li>
<li><p><code>ElementType.METHOD</code>代表用于描述万法；</p>
</li>
<li><p><code>ElementType.PACKAGE</code>代表用于描述包；</p>
</li>
<li><p><code>ElementType.PARAMETER</code>代表用于描述参数；</p>
</li>
<li><p><code>ElementType.TYPE</code>代表用于描述类、接口（包括注解类型）或<code>enum</code>声明。</p>
</li>
</ul>
</li>
<li><p><code>@Retention</code></p>
<ul>
<li><p>用于说明自定义注解的生命周期，在注解中有三种生命周期，是一个枚举类型，有如下属性值；</p>
</li>
<li><p><code>RetentionPolicy.RUNTIME</code> 代表始终不会丢弃，运行期也保留该注解，通常使用这种方式；</p>
</li>
<li><p><code>RetentionPolicy.CLASS</code>代表类加载时丢弃，默认使用这种方式；</p>
</li>
<li><p><code>RetentionPolicy.SOURCE</code>代表编译阶段丢弃，所以不会写入字节码，<code>＠Override</code>、<code>＠SuppressWarnings</code>都属于这类注解。</p>
</li>
</ul>
</li>
<li><p><code>@Inherited</code></p>
<ul>
<li><p>用于标记被标注的类型的注解是可以被继承的（默认情况下父类的注解不会被子类继承）；</p>
</li>
<li><p>如果一个使用了<code>＠lnherited</code>修饰的注解类型被用于一个类，则这个注解将继续被用于该类的子类。</p>
</li>
</ul>
</li>
<li><p><code>@Documented</code></p>
<ul>
<li>用于标记是否将信息添加到 Java 文档当中。</li>
</ul>
</li>
<li><p><code>@interface</code></p>
<ul>
<li><p>用于声明一个注解；</p>
</li>
<li><p>其中的每一个方法实际上是声明了一个配置参数;</p>
</li>
<li><p>方法的名称就是参数的名称，返回类型就是参数的类型;</p>
</li>
<li><p>返回值类型只能是基本类型、<code>Class</code>、<code>String</code>、<code>enum</code>。</p>
</li>
</ul>
</li>
</ul>
<p>注解一般户包含一些元素以表示某些值，没有元素的注解称为标记注解，注解元素可用的类型有基本类型、<code>String</code>、<code>Class</code>、<code>enum</code>、<code>Annotation</code>、前面这些类型的数组。注解元素不能有不确定的值，要么必须具有默认值，要么在使用注解时提供元素的值，对于非基本类型的注解元素，不能以<code>null</code>作为值。</p>
<h2 id="5-6-枚举"><a href="#5-6-枚举" class="headerlink" title="5.6 枚举"></a>5.6 枚举</h2><p>枚举类型是由一组固定常量（解语法糖得到的是<code>public static final</code>修饰的枚举类成员字段）组成合法的类型，创建枚举时，编译器会生成一个相关的类并在该类中自动插入静态的<code>values()</code>方法，这个类继承自<code>Enum</code>类（Java 的单继承结构使得该类不能再继承其他类），同时该类是一个不可子类化的<code>final</code>类。枚举类型除了不能继承其他类也不能被继承以外，可以看作是一个常规的类，即可以在枚举中添加变量和方法。</p>
<p><code>Enum</code>类实现了<code>Comparable</code>和<code>Serializable</code>接口，具备<code>compareTo()</code>方法，枚举实例可以使用==来比较，编译器会自动提供<code>equals()</code>和<code>hashCode()</code>方法。枚举实例虽然可以具有不同的行为，但它们不是类型，不能将其作为方法签名中的参数类型来使用，最好的办法是将枚举用在<code>switch</code>语句中，或者使用<code>EnumMap</code>来实现多路分发，<code>EnumMap</code>是专门为枚举类型设计的一种性能非常好的<code>Map</code>，详细介绍见 2.2 小节。</p>
<p>对一个枚举实例进行反序列化是通过<code>java.lang.Enum</code>的<code>values</code>方法来根据名字查找枚举元素的，这个过程并不会使用反射，并且编译器不允许任何对这种深拷贝、序列化与反序列化机制的定制，禁用了<code>clone</code>、<code>writeObject()</code>、<code>readObject()</code>、<code>readObjectNoData</code>、<code>writeReplace</code>和<code>readResolve</code>等方法，因此枚举的拷贝和反序列化并不存在对单例的破坏。</p>
<p>对于枚举而言，实现接口是使其子类化的唯一办法，可以在一个接口内部，创建实现该接口的枚举，那么枚举元素依旧保持接口的特性，可以向上转型为接口，因此可以进一步实现枚举的枚举，实现某种程度上的枚举子类化。</p>
<h2 id="5-7-新特性"><a href="#5-7-新特性" class="headerlink" title="5.7 新特性"></a>5.7 新特性</h2><p>JDK 6/7 中对<code>synchronized</code>锁进行了很多优化，锁消除、锁粗化、锁升级（偏向锁、轻量级锁、适应性自旋）等。</p>
<p>JDK 8 中提供了 Lambda 表达式（思想是传递运算，而非传递数据，是一种语法糖）、Stream、Optional、线程安全的 DateTimeFormatter等新特性，还对 HashMap 进行了一些<a target="_blank" rel="noopener" href="https://www.yuque.com/hollis666/niq4hm/cgben69hc08cpng7">改变</a>。</p>
<p>JDK 10 中提供了本地变量类型推断，可以通过<code>var</code>声明变量并在赋值的右边提供实现类型，不需要显式地规范变量的类型，是一种语法糖。</p>
<p>JDK 13 中提供了<code>yield</code>语句来返回一个值并跳出当前<code>switch case</code>块（区别于<code>return</code>跳出当前方法）， 提供了 Text Blocks 文本块预览特性，避免了对大多数转义序列的需要，以可预测的方式自动格式化字符串。</p>
<p>JDK 14 中提供了<code>instanceOf</code>模式匹配、<code>Records</code>。<code>instanceOf</code>模式匹配允许同时进行类型判断和类型转换，省略了判断之后再显式强制转换的步骤。<code>Records</code>为声明类提供了一种紧凑的语法，用于创建一种只有字段的类，编译器会自动创建所有的方法并让所有字段参与<code>hashCode</code>等方法，使得纯数据类从几行代码简化为一行代码。</p>
<p>JDK 15 中提供了封闭类/接口，使用<code>sealed</code>修饰符声明并通过<code>permit</code>子句指定允许扩展/实现封闭类/接口的类。</p>
<p>JDK 19 中提供了协程。</p>
<p>JDK 21 中提供了虚拟线程，详细参见 <a href="../../../../2022/05/08/java-concurrency/">Java Concurrency</a>。</p>
<h2 id="5-8-SPI"><a href="#5-8-SPI" class="headerlink" title="5.8 SPI"></a>5.8 SPI</h2><p>应用开发人员使用 API 定义软件组件之间交互的规则和约定的接口，API 提供方制定接口并完成对接口的不同实现，API 调用方只需调用即可；框架扩展人员使用 SPI 定义应用程序中可拔插的服务实现，SPI 提供方制定服务并提供可拔插的实现方式，SPI 调用方可以选择使用提供方提供的内置实现，也可以自己实现。</p>
<p>SPI 适用于调用者需要根据实际使用需要来启用、扩展、或者替换框架的实现策略的场景，比如数据库驱动加载接口实现类的加载、JDBC 加载不同类型数据库的驱动、日志门面接口实现类加载、SLF4J 加载不同提供商的日志实现类等，Spring 中也大量使用了 SPI。</p>
<h2 id="5-9-Unsafe"><a href="#5-9-Unsafe" class="headerlink" title="5.9 Unsafe"></a>5.9 Unsafe</h2><p><code>sun.misc.Unsafe</code>类是 Java 中的一个底层类，提供了硬件级别的原子操作，可以对堆外内存进行直接的内存操作（是 JVM 开的后门），包括内存分配和对象实例化。</p>
<ul>
<li><p><code>Unsafe</code>是 Java 的内部 API，并不属于 Java 标准库的一部分，<code>Unsafe</code>的行为在不同的 JDK 版本和不同 JVM 实现中可能会有差异，会引发代码的不可移植性</p>
</li>
<li><p><code>Unsafe</code>包含了很多基础操作，比如数组操作、对象操作、内存操作、CAS 操作、线程操作（park/unpark）、栅栏操作，JUC 包等一些三方框架都使用<code>Unsafe</code>来保证并发安全</p>
</li>
<li><p><code>Unsafe</code>的功能是强大而危险的，可以绕过 Java 的安全机制，它所分配的内存需要手动 free 而不被 GC 回收，可能会导致内存泄漏、非法访问、数据损坏等安全问题</p>
</li>
<li><p><code>Unsafe</code>被设计的初衷并不是希望被一般开发者使用，它的构造方法是私有的，所以不能通过<code>new</code>或工厂方法去得到<code>Unsafe</code>实例，可以采用反射获取<code>Unsafe</code>实例</p>
</li>
<li><p>Java 鼓励使用构造函数和工厂方法来创建对象，以确保对象的正确初始化，并维护对象的不变性，使用<code>Unsafe</code>创建对象并不符合 Java 面向对象的原则</p>
</li>
</ul>
<p>综上所述，不建议直接在生产环境中使用<code>Unsafe</code>。</p>
<h2 id="5-10-拷贝"><a href="#5-10-拷贝" class="headerlink" title="5.10 拷贝"></a>5.10 拷贝</h2><p>拷贝对象时，浅拷贝是指只复制对象的地址，而不是对象本身，原始对象和浅拷贝得到的对象实际上是共享同一个内存地址的；深拷贝是指将对象及其所有属性都复制到另一个全新的对象中，原始对象和深拷贝得到对象位于不同的内存地址，互不影响。深拷贝有两种实现方法，一个是实现<code>Cloneable</code>接口并重写<code>clone</code>方法，另一个是序列化与反序列化。</p>
<p>调用一个对象的<code>clone</code>方法时，JVM 就会创建一个新的对象，将前面对象的内容全部拷贝进去（并不会调用构造函数，可以破坏单例），如果只实现了<code>Cloneable</code>接口而没有重写<code>clone</code>方法，则会默认使用<code>Object</code>类中的<code>clone</code>方法（这是一个 Native 方法），此时只能实现浅拷贝，要实现深拷贝就必须重写<code>clone</code>方法，要重写<code>clone</code>方法就必须实现<code>Cloneable</code>接口。</p>
<p>先把对象序列化成某种格式流，再从该格式流中反序列化对象，默认就会得到新的对象，序列化的方法可以 Java 原生的序列化机制、各种 JSON 工具等。</p>
<h2 id="5-11-文件处理"><a href="#5-11-文件处理" class="headerlink" title="5.11 文件处理"></a>5.11 文件处理</h2><p>通常看到的 xlsx 文件其实是一个将若干个 XML 格式的纯文本文件压缩到一起的高度压缩文件，解压后的 xlsx 文件包含的内容可能会扩大为好几倍，Excel 就是读取这些压缩文件的信息，最后展现出一个完全图形化的电子表格。</p>
<p>Apache POI 是一个非常流行的文档处理工具，通常被用于处理 Excel，当 POI 在处理 xlsx 文件时，会把整个内容都加载到内存中，实际处理的大小并不是看到的 xlsx 文件大小，因此会很容易出现内存溢出。</p>
<p>POI 中提供了如下<code>WorkBook</code>来操作 Excel</p>
<ul>
<li><p><code>SSFWorkbook</code>用于处理 Excel 的 .xls 格式</p>
</li>
<li><p><code>XSSFWorkbook</code>用于处理 Excel 的 .xlsx 格式，支持更大的数据集和更多的功能，如更好地样式和公式支持，也会占据比<code>SSFWorkbook</code>更多的内存</p>
</li>
<li><p><code>SXSSFWorkbook</code>用于处理 Excel 的 .xlsx 格式，是<code>XSSFWorkbook</code>的流式版本，专门设计用于处理大数据集，通过将数据写入临时文件而非全部保留在内存中，显著减少内存消耗，避免内存溢出</p>
</li>
</ul>
<h2 id="5-12-定时任务"><a href="#5-12-定时任务" class="headerlink" title="5.12 定时任务"></a>5.12 定时任务</h2><p>定时任务可以定时执行的原理是通过操作系统提供的定时器实现的，定时器可以周期性地发出中断信号，以便操作系统或其他应用程序可以在指定的时间间隔内执行某些任务，操作系统中常见的定时任务管理工具有 crontab（Linux 系统）、Windows Task Scheduler（Windows 系统）。</p>
<p>Java 提供如下方式来实现定时任务</p>
<ul>
<li><p>原生特性，使用简单，不需要依赖第三方调度框架和类库，非常轻量级，但依赖 JVM 进程，一般需要配合数据库的持久化一起使用，不便于集群多节点配合</p>
<ul>
<li><p><code>Timer</code>类和<code>TimerTask</code>类，精度不高，单线程执行，某个任务执行时间长或者抛出未捕获异常都会影响到后续任务的执行</p>
</li>
<li><p><code>ScheduleExecutorService</code>类，比<code>Timer</code>更精准，支持多个任务并发执行</p>
</li>
<li><p><code>DelayQueue</code>类，本质是一个带有延迟时间的无界阻塞队列，元素必须实现<code>Delayed</code>接口，当从<code>DelayQueue</code>中取出一个元素时，如果其延迟时间还未到达，则会阻塞等待直到延迟时间到达</p>
</li>
</ul>
</li>
<li><p>Spring 类库的<code>@Scheduled</code>注解</p>
</li>
<li><p>Quartz 任务调度框架的<code>JobDetail</code>和<code>Trigger</code>对象，支持任务的并发执行和动态调度</p>
</li>
<li><p>xxl-job 是一个分布式定时任务调度平台，支持集群部署，可以满足高并发、大数据量的任务调度需求</p>
</li>
<li><p>Elastic-Job 是一个分布式任务调度框架，支持分布式部署，提供高并发、高可用性、高可扩展性、大数据量的任务调度需求</p>
</li>
</ul>
<p>此外，也可以自定义算法来实现定时任务</p>
<ul>
<li><p>小顶堆</p>
<ul>
<li>可以作为管理定时事件的数据结构，每个事件包含触发时间戳和要执行的任务信息，最紧要触发的任务一直位于堆的根部，从而高效地触发最近需要触发的定时事件，Java 中的<code>Timer</code>类和<code>DelayQueue</code>类都是基于小顶堆实现的</li>
</ul>
</li>
<li><p>链表</p>
<ul>
<li>可以作为管理定时事件的数据结构，每个节点包含触发时间戳和任务信息，链表中的节点按照触发时间戳从小到大排列，通过遍历链表可以找到最近触发的定时事件</li>
</ul>
</li>
<li><p>时间轮</p>
<ul>
<li><p>是一种用于处理定时任务和调度的常见算法，算法需要定义一个时间轮盘，在轮盘中划分出槽位，每个槽位表示一个时间段（秒级、分钟级、小时级等），将需要定时执行的任务挂到这些槽位中，随着轮盘指针随着时间推移而不断旋转，指针指向的槽位中的任务就会定时触发，会在线程池中执行被触发的任务，常见的应用时间轮算法的框架和库如下</p>
</li>
<li><p>Netty，使用时间轮算法来处理定时任务和超时检测，时间轮用于管理通道的超时和重连机制</p>
</li>
<li><p>Akka，使用时间轮算法来管理和触发并发任务，使得 Akka 能够支持高并发和复杂的任务调度需求</p>
</li>
<li><p>Kafka，使用时间轮算法来管理消息的过期和删除，以释放存储空间</p>
</li>
<li><p>Hystrix，使用时间轮算法来管理命令执行和熔断状态的转换</p>
</li>
<li><p>Disruptor，使用时间轮算法来管理任务的并发执行，以提高处理大量事件的性能</p>
</li>
</ul>
</li>
</ul>
<h2 id="5-13-随机数"><a href="#5-13-随机数" class="headerlink" title="5.13 随机数"></a>5.13 随机数</h2><p>随机数分为真随机数和伪随机数，真随机数通过物理实验得出，比如掷钱币、筛子等，需要满足随机性、不可预测性、不可重现性，一些基于经典热噪声的随机数芯片读取当前物理环境中的噪声，并据此获得真随机数；伪随机数通过一定算法和种子得出，现代计算机中，无法通过一个纯算法来实现真随机数，有限状态机也不能产生真正的随机数，只要通过确定算法生成的都是伪随机数，因此程序中使用的基本都是伪随机数。</p>
<p>强随机数发生器依赖于操作系统底层提供的随机事件，强随机数生成器的初始化速度和生成速度都较慢，而且由于需要一定的熵累计才能生成足够强度的随机数，所以可能造成阻塞。熵累计通常来源于多个随机事件源，比如敲击键盘的时间间隔，移动鼠标的距离和间隔，特定中断的时间间隔等。</p>
<p>Java 提供的强随机数发生器是<code>java.security.SecureRandom</code>类，是一个线程安全的类（内部使用<code>synchronize</code>保证线程安全），同<code>Random</code>一样，在高并发的多线程环境中可能会有性能问题。</p>
<h1 id="6、参考资料"><a href="#6、参考资料" class="headerlink" title="6、参考资料"></a>6、参考资料</h1><ul>
<li>《Thinking in Java (Fourth Edition)》</li>
<li><a target="_blank" rel="noopener" href="https://www.slf4j.org/manual.html">https://www.slf4j.org/manual.html</a></li>
<li><a target="_blank" rel="noopener" href="https://developer.aliyun.com/article/694075">https://developer.aliyun.com/article/694075</a></li>
<li><a target="_blank" rel="noopener" href="https://www.cnblogs.com/9dragon/p/10901448.html">https://www.cnblogs.com/9dragon/p/10901448.html</a></li>
<li><a target="_blank" rel="noopener" href="https://juejin.cn/post/6973664796709404708">https://juejin.cn/post/6973664796709404708</a></li>
<li><a target="_blank" rel="noopener" href="https://tech.meituan.com/2014/03/06/in-depth-understanding-string-intern.html">https://tech.meituan.com/2014/03/06/in-depth-understanding-string-intern.html</a></li>
</ul>
</section>
    <!-- Tags START -->
    
    <!-- Tags END -->
    <!-- NAV START -->
    
  <div class="nav-container">
    <!-- reverse left and right to put prev and next in a more logic postition -->
    
      <a class="nav-left" href="/2022/05/07/maven/">
        <span class="nav-arrow">← </span>
        
          Maven
        
      </a>
    
    
      <a class="nav-right" href="/2022/05/08/java-concurrency/">
        
          Java Concurrency
        
        <span class="nav-arrow"> →</span>
      </a>
    
  </div>

    <!-- NAV END -->
    <!-- 打赏 START -->
    
    <!-- 打赏 END -->
    <!-- 二维码 START -->
    
    <!-- 二维码 END -->
    
      <!-- Utterances START -->
      <div id="utterances"></div>
      <script src="https://utteranc.es/client.js"
        repo=""
        issue-term="pathname"
        theme="github-light"
        crossorigin="anonymous"
        async></script>    
      <!-- Utterances END -->
    
  </article>
  <!-- Article END -->
  <!-- Catalog START -->
  
    <aside class="catalog-container">
  <div class="toc-main">
  
      
          <strong class="toc-title">OUTLINE</strong>
          <ol class="toc-nav"><li class="toc-nav-item toc-nav-level-1"><a class="toc-nav-link" href="#1%E3%80%81%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1"><span class="toc-nav-text">1、面向对象</span></a><ol class="toc-nav-child"><li class="toc-nav-item toc-nav-level-2"><a class="toc-nav-link" href="#1-1-%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%9F%BA%E6%9C%AC%E7%89%B9%E5%BE%81"><span class="toc-nav-text">1.1 对象的基本特征</span></a></li><li class="toc-nav-item toc-nav-level-2"><a class="toc-nav-link" href="#1-2-%E5%88%9B%E5%BB%BA%E3%80%81%E5%AD%98%E5%82%A8%E3%80%81%E9%94%80%E6%AF%81%E5%AF%B9%E8%B1%A1"><span class="toc-nav-text">1.2 创建、存储、销毁对象</span></a></li><li class="toc-nav-item toc-nav-level-2"><a class="toc-nav-link" href="#1-3-%E6%8E%A5%E5%8F%A3%E3%80%81%E6%8A%BD%E8%B1%A1%E7%B1%BB%E3%80%81%E5%86%85%E9%83%A8%E7%B1%BB"><span class="toc-nav-text">1.3 接口、抽象类、内部类</span></a></li></ol></li><li class="toc-nav-item toc-nav-level-1"><a class="toc-nav-link" href="#2%E3%80%81%E5%AE%B9%E5%99%A8%E5%92%8C%E6%B3%9B%E5%9E%8B"><span class="toc-nav-text">2、容器和泛型</span></a><ol class="toc-nav-child"><li class="toc-nav-item toc-nav-level-2"><a class="toc-nav-link" href="#2-1-Collection-%E5%BA%8F%E5%88%97"><span class="toc-nav-text">2.1 Collection 序列</span></a></li><li class="toc-nav-item toc-nav-level-2"><a class="toc-nav-link" href="#2-2-Map-%E6%98%A0%E5%B0%84"><span class="toc-nav-text">2.2 Map 映射</span></a></li><li class="toc-nav-item toc-nav-level-2"><a class="toc-nav-link" href="#2-3-%E5%AE%B9%E5%99%A8%E7%9A%84%E4%BD%BF%E7%94%A8"><span class="toc-nav-text">2.3 容器的使用</span></a></li><li class="toc-nav-item toc-nav-level-2"><a class="toc-nav-link" href="#2-4-%E7%B1%BB%E5%9E%8B%E4%BF%A1%E6%81%AF%E5%92%8C%E6%B3%9B%E5%8C%96"><span class="toc-nav-text">2.4 类型信息和泛化</span></a></li><li class="toc-nav-item toc-nav-level-2"><a class="toc-nav-link" href="#2-5-%E6%B3%9B%E5%9E%8B%E5%8F%8A%E5%85%B6%E5%B1%80%E9%99%90"><span class="toc-nav-text">2.5 泛型及其局限</span></a></li></ol></li><li class="toc-nav-item toc-nav-level-1"><a class="toc-nav-link" href="#3%E3%80%81I-O-%E7%B3%BB%E7%BB%9F"><span class="toc-nav-text">3、I&#x2F;O 系统</span></a><ol class="toc-nav-child"><li class="toc-nav-item toc-nav-level-2"><a class="toc-nav-link" href="#3-1-I-O-%E7%B1%BB%E5%BA%93"><span class="toc-nav-text">3.1 I&#x2F;O 类库</span></a></li><li class="toc-nav-item toc-nav-level-2"><a class="toc-nav-link" href="#3-2-%E6%96%B0-I-O-%E7%B1%BB%E5%BA%93"><span class="toc-nav-text">3.2 新 I&#x2F;O 类库</span></a></li><li class="toc-nav-item toc-nav-level-2"><a class="toc-nav-link" href="#3-3-I-O-%E6%A8%A1%E5%9E%8B"><span class="toc-nav-text">3.3 I&#x2F;O 模型</span></a></li><li class="toc-nav-item toc-nav-level-2"><a class="toc-nav-link" href="#3-4-%E6%8C%81%E4%B9%85%E6%80%A7"><span class="toc-nav-text">3.4 持久性</span></a></li></ol></li><li class="toc-nav-item toc-nav-level-1"><a class="toc-nav-link" href="#4%E3%80%81%E6%97%A5%E5%BF%97"><span class="toc-nav-text">4、日志</span></a><ol class="toc-nav-child"><li class="toc-nav-item toc-nav-level-2"><a class="toc-nav-link" href="#4-1-%E6%97%A5%E5%BF%97%E7%BA%A7%E5%88%AB"><span class="toc-nav-text">4.1 日志级别</span></a></li><li class="toc-nav-item toc-nav-level-2"><a class="toc-nav-link" href="#4-2-%E8%AE%B0%E5%BD%95%E6%97%B6%E6%9C%BA"><span class="toc-nav-text">4.2 记录时机</span></a></li><li class="toc-nav-item toc-nav-level-2"><a class="toc-nav-link" href="#4-3-%E6%97%A5%E5%BF%97%E8%A7%84%E8%8C%83"><span class="toc-nav-text">4.3 日志规范</span></a></li><li class="toc-nav-item toc-nav-level-2"><a class="toc-nav-link" href="#4-4-%E6%97%A5%E5%BF%97%E6%A1%86%E6%9E%B6"><span class="toc-nav-text">4.4 日志框架</span></a></li><li class="toc-nav-item toc-nav-level-2"><a class="toc-nav-link" href="#4-5-%E5%88%86%E5%B8%83%E5%BC%8F%E6%97%A5%E5%BF%97%E7%B3%BB%E7%BB%9F"><span class="toc-nav-text">4.5 分布式日志系统</span></a></li></ol></li><li class="toc-nav-item toc-nav-level-1"><a class="toc-nav-link" href="#5%E3%80%81%E5%85%B6%E4%BB%96%E8%A1%A5%E5%85%85"><span class="toc-nav-text">5、其他补充</span></a><ol class="toc-nav-child"><li class="toc-nav-item toc-nav-level-2"><a class="toc-nav-link" href="#5-1-final"><span class="toc-nav-text">5.1 final</span></a></li><li class="toc-nav-item toc-nav-level-2"><a class="toc-nav-link" href="#5-2-%E5%BC%82%E5%B8%B8"><span class="toc-nav-text">5.2 异常</span></a></li><li class="toc-nav-item toc-nav-level-2"><a class="toc-nav-link" href="#5-3-%E5%AD%97%E7%AC%A6%E4%B8%B2"><span class="toc-nav-text">5.3 字符串</span></a></li><li class="toc-nav-item toc-nav-level-2"><a class="toc-nav-link" href="#5-4-%E5%AD%97%E7%AC%A6%E7%BC%96%E7%A0%81"><span class="toc-nav-text">5.4 字符编码</span></a></li><li class="toc-nav-item toc-nav-level-2"><a class="toc-nav-link" href="#5-5-%E6%B3%A8%E8%A7%A3"><span class="toc-nav-text">5.5 注解</span></a></li><li class="toc-nav-item toc-nav-level-2"><a class="toc-nav-link" href="#5-6-%E6%9E%9A%E4%B8%BE"><span class="toc-nav-text">5.6 枚举</span></a></li><li class="toc-nav-item toc-nav-level-2"><a class="toc-nav-link" href="#5-7-%E6%96%B0%E7%89%B9%E6%80%A7"><span class="toc-nav-text">5.7 新特性</span></a></li><li class="toc-nav-item toc-nav-level-2"><a class="toc-nav-link" href="#5-8-SPI"><span class="toc-nav-text">5.8 SPI</span></a></li><li class="toc-nav-item toc-nav-level-2"><a class="toc-nav-link" href="#5-9-Unsafe"><span class="toc-nav-text">5.9 Unsafe</span></a></li><li class="toc-nav-item toc-nav-level-2"><a class="toc-nav-link" href="#5-10-%E6%8B%B7%E8%B4%9D"><span class="toc-nav-text">5.10 拷贝</span></a></li><li class="toc-nav-item toc-nav-level-2"><a class="toc-nav-link" href="#5-11-%E6%96%87%E4%BB%B6%E5%A4%84%E7%90%86"><span class="toc-nav-text">5.11 文件处理</span></a></li><li class="toc-nav-item toc-nav-level-2"><a class="toc-nav-link" href="#5-12-%E5%AE%9A%E6%97%B6%E4%BB%BB%E5%8A%A1"><span class="toc-nav-text">5.12 定时任务</span></a></li><li class="toc-nav-item toc-nav-level-2"><a class="toc-nav-link" href="#5-13-%E9%9A%8F%E6%9C%BA%E6%95%B0"><span class="toc-nav-text">5.13 随机数</span></a></li></ol></li><li class="toc-nav-item toc-nav-level-1"><a class="toc-nav-link" href="#6%E3%80%81%E5%8F%82%E8%80%83%E8%B5%84%E6%96%99"><span class="toc-nav-text">6、参考资料</span></a></li></ol>
      
  
  </div>
</aside>
  
  <!-- Catalog END -->
</main>

<script>
  (function () {
    var url = 'http://example.com/2022/05/08/java-language/';
    var banner = ''
    if (banner !== '' && banner !== 'undefined' && banner !== 'null') {
      $('#article-banner').css({
        'background-image': 'url(' + banner + ')'
      })
    } else {
      $('#article-banner').geopattern(url)
    }
    $('.header').removeClass('fixed-header')

    // error image
    $(".markdown-content img").on('error', function() {
      $(this).attr('src', '/css/images/error_icon.png')
      $(this).css({
        'cursor': 'default'
      })
    })

    // zoom image
    $(".markdown-content img").on('click', function() {
      var src = $(this).attr('src')
      if (src !== '/css/images/error_icon.png') {
        var imageW = $(this).width()
        var imageH = $(this).height()

        var zoom = ($(window).width() * 0.95 / imageW).toFixed(2)
        zoom = zoom < 1 ? 1 : zoom
        zoom = zoom > 2 ? 2 : zoom
        var transY = (($(window).height() - imageH) / 2).toFixed(2)

        $('body').append('<div class="image-view-wrap"><div class="image-view-inner"><img src="'+ src +'" /></div></div>')
        $('.image-view-wrap').addClass('wrap-active')
        $('.image-view-wrap img').css({
          'width': `${imageW}`,
          'transform': `translate3d(0, ${transY}px, 0) scale3d(${zoom}, ${zoom}, 1)`
        })
        $('html').css('overflow', 'hidden')

        $('.image-view-wrap').on('click', function() {
          $(this).remove()
          $('html').attr('style', '')
        })
      }
    })
  })();
</script>







    <div class="scroll-top">
  <span class="arrow-icon"></span>
</div>
    <footer class="app-footer">
  <p class="copyright">
    &copy; 2024 | Proudly powered by <a href="https://hexo.io" target="_blank">Hexo</a>
    <br>
    Theme by <a target="_blank" rel="noopener" href="https://github.com/yanm1ng">yanm1ng</a>
    
  </p>
</footer>

<script>
  function async(u, c) {
    var d = document, t = 'script',
      o = d.createElement(t),
      s = d.getElementsByTagName(t)[0];
    o.src = u;
    if (c) { o.addEventListener('load', function (e) { c(null, e); }, false); }
    s.parentNode.insertBefore(o, s);
  }
</script>
<script>
  async("//cdnjs.cloudflare.com/ajax/libs/fastclick/1.0.6/fastclick.min.js", function(){
    FastClick.attach(document.body);
  })
</script>

<script>
  var hasLine = 'true';
  async("//cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/highlight.min.js", function(){
    $('figure pre').each(function(i, block) {
      var figure = $(this).parents('figure');
      if (hasLine === 'false') {
        figure.find('.gutter').hide();
      }
      hljs.configure({useBR: true});
      var lang = figure.attr('class').split(' ')[1] || 'code';
      var codeHtml = $(this).html();
      var codeTag = document.createElement('code');
      codeTag.className = lang;
      codeTag.innerHTML = codeHtml;
      $(this).attr('class', '').empty().html(codeTag);
      figure.attr('data-lang', lang.toUpperCase());
      hljs.highlightBlock(block);
    });
  })
</script>
<!-- Baidu Tongji -->


<script src="/js/script.js"></script>


  </body>
</html>
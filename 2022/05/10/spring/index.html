<!DOCTYPE html>
<html>
  <head>
  <meta http-equiv="content-type" content="text/html; charset=utf-8">
  <meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport">
  <meta name="description" content="要有一个从输入到输出的过程">
  <meta name="keyword" content="hexo-theme, vuejs">
  
    <link rel="shortcut icon" href="/css/images/logo.png">
  
  <title>
    
      Spring Framework | CQ&#39;s Blog
    
  </title>
  <link href="//cdnjs.cloudflare.com/ajax/libs/font-awesome/4.7.0/css/font-awesome.min.css" rel="stylesheet">
  <link href="//cdnjs.cloudflare.com/ajax/libs/nprogress/0.2.0/nprogress.min.css" rel="stylesheet">
  <link href="//cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/tomorrow.min.css" rel="stylesheet">
  
<link rel="stylesheet" href="/css/style.css">

  
  <script src="//cdnjs.cloudflare.com/ajax/libs/jquery/3.2.1/jquery.min.js"></script>
  <script src="//cdnjs.cloudflare.com/ajax/libs/geopattern/1.2.3/js/geopattern.min.js"></script>
  <script src="//cdnjs.cloudflare.com/ajax/libs/nprogress/0.2.0/nprogress.min.js"></script>
  
  
  
  
    <!-- MathJax support START -->
    <script type="text/x-mathjax-config">
      MathJax.Hub.Config({
        tex2jax: {
          inlineMath: [ ['$','$'], ["\\(","\\)"]  ],
          processEscapes: true,
          skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
        }
      });
    </script>

    <script type="text/x-mathjax-config">
      MathJax.Hub.Queue(function() {
        var all = MathJax.Hub.getAllJax(), i;
        for (i=0; i < all.length; i += 1) {
          all[i].SourceElement().parentNode.className += ' has-jax';
        }
      });
    </script>
    <script type="text/javascript" src="//cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
    <!-- MathJax support END -->
  


  
  
    
<script src="/js/local-search.js"></script>


<meta name="generator" content="Hexo 5.4.2"></head>
<div class="wechat-share">
  <img src="/css/images/logo.png" />
</div>
  <body>
    <header class="header fixed-header">
  <div class="header-container">
    <a class="home-link" href="/">
      <div class="logo"></div>
      <span>CQ's Blog</span>
    </a>
    <ul class="right-list">
      
        <li class="list-item">
          
            <a href="/" class="item-link">Home</a>
          
        </li>
      
        <li class="list-item">
          
            <a href="/" class="item-link">Categories</a>
          
        </li>
      
        <li class="list-item">
          
            <a href="/records" class="item-link">Records</a>
          
        </li>
      
        <li class="list-item">
          
            <a href="/scratches/" class="item-link">Scratches</a>
          
        </li>
      
        <li class="list-item">
          
            <a href="/archives/" class="item-link">Archives</a>
          
        </li>
      
      
        <li class="menu-item menu-item-search right-list">
    <a role="button" class="popup-trigger">
        <i class="fa fa-search fa-fw"></i>
    </a>
</li>
      
    </ul>
    <div class="menu">
      <span class="icon-bar"></span>
      <span class="icon-bar"></span>
      <span class="icon-bar"></span>
    </div>
    <div class="menu-mask">
      <ul class="menu-list">
        
          <li class="menu-item">
            
              <a href="/" class="menu-link">Home</a>
            
          </li>
        
          <li class="menu-item">
            
              <a href="/" class="menu-link">Categories</a>
            
          </li>
        
          <li class="menu-item">
            
              <a href="/records" class="menu-link">Records</a>
            
          </li>
        
          <li class="menu-item">
            
              <a href="/scratches/" class="menu-link">Scratches</a>
            
          </li>
        
          <li class="menu-item">
            
              <a href="/archives/" class="menu-link">Archives</a>
            
          </li>
        
      </ul>
    </div>
    
      <div class="search-pop-overlay">
    <div class="popup search-popup">
        <div class="search-header">
            <span class="search-icon">
                <i class="fa fa-search"></i>
            </span>
            <div class="search-input-container">
                <input autocomplete="off" autocapitalize="off"
                    placeholder="Please enter your keyword(s) to search." spellcheck="false"
                    type="search" class="search-input">
            </div>
            <span class="popup-btn-close">
                <i class="fa fa-times-circle"></i>
            </span>
        </div>
        <div id="search-result">
            <div id="no-result">
                <i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i>
            </div>
        </div>
    </div>
</div>
    
  </div>
</header>

    <div id="article-banner">
  <h2>Spring Framework</h2>
  <!--<p class="post-date">2022-05-10</p>
  <div class="arrow-down">
    <a href="javascript:;"></a>
  </div>-->
</div>
<main class="app-body flex-box">
  <!-- Article START -->
  <article class="post-article">
    <section class="markdown-content"><h1 id="1、总概"><a href="#1、总概" class="headerlink" title="1、总概"></a>1、总概</h1><p>Spring 是一个取代了 EJB 的轻量级框架，它提供了一系列底层和基础设施，是以<strong>简化 Java EE 应用程序的开发</strong>为目标而创建的。</p>
<p>Spring Framework 主要包括几个模块：</p>
<ul>
<li>核心容器：Spring 最核心的部分，支持 IoC，所有 Spring 模块都构建于核心容器之上；</li>
<li>面向切面编程：是开发切面的基础；</li>
<li>Web 模块：提供了 SpringMVC 框架给 Web 应用；</li>
<li>数据访问与集成：支持 JDBC 和 ORM 的数据访问模块；</li>
<li>Test 模块：提供了⼀系列的 mock 对象实现，使得开发者能够很方便的进行测试。</li>
</ul>
<p>注：IoC 和 AOP 不是 Spring 提出的，但 Spring 很好的实现了这两个思想</p>
<p>通过这些模块，Spring 可以实现：</p>
<ul>
<li>基于 POJO 的轻量级和最小入侵性编程；</li>
<li>基于依赖注入和面向接口实现松耦合；</li>
<li>基于切面和惯例进行声明式编程；</li>
<li>基于切面和模板减少样板式代码。</li>
</ul>
<h1 id="2、IoC"><a href="#2、IoC" class="headerlink" title="2、IoC"></a>2、IoC</h1><h2 id="2-1-问题与解决"><a href="#2-1-问题与解决" class="headerlink" title="2.1 问题与解决"></a>2.1 问题与解决</h2><p>Java 组件在协助工作时，可能会反复实例化一些很复杂的组件，为了避免重复工作，考虑共享一些组件，但组件的共享会导致组件之间的依赖关系逐渐复杂，组件的创建、共享以及销毁也变得不好管理，即难以根据依赖关系创建、组装、获取和销毁组件，也很难进行单元测试。</p>
<p>传统应用程序中，组件的控制权在应用程序本身，即应用程序通过<code>new XXX</code>来创建<code>xxx</code>实例然后使用，在 IoC (Inversion of Control) 模式下，组件控制权发生了反转（从应用程序转移到 IoC 容器），IoC 容器负责创建和管理组件，应用程序只需要<strong>直接使用</strong>（通过<code>setXXX</code>方法或者带<code>XXX</code>参数的构造方法来注入<code>XXX</code>实例）由 IoC 容器已经创建好的组件。</p>
<p>IoC 和 DI 是从两个不同的角度来描述了同一件事情，IoC 是从对象的角度，对象的控制权转移（反转）给了容器；DI 是从容器的角度，容器将对象所依赖的其他对象注入进去。</p>
<p>Spring 的核心就是提供了一个<strong>可扩展的无侵入</strong>的 IoC 容器（容器是一种为特定组件的运行提供必要支持的一个软件环境，无侵入指应用程序的组件无需实现 Spring 的特定接口，对 Spring 的 IoC 容器无感知）， IoC 容器是 Spring 用来实现 IoC 的载体， IoC 容器实际上就是个 Map（key，value），Map 中存放的是各种对象。</p>
<p>在 Spring 的 IoC 容器中，所有的组件又称为 JavaBean，配置一个组件就是在配置一个 JavaBean。IoC 容器可以管理所有轻量级的 JavaBean 的生命周期，从而将JavaBean 的创建配置与使用相分离。IoC 容器在创建和装配 Bean 时需要知道 Bean 间的依赖关系，依赖关系可以通过 XML 文件或者注解这两种方式来进行配置，这种创建应用对象之间的依赖协作关系的行为通常被称为<strong>装配（wiring）</strong>。</p>
<h2 id="2-2-XML-配置"><a href="#2-2-XML-配置" class="headerlink" title="2.2 XML 配置"></a>2.2 XML 配置</h2><p>在后期维护时，XML 配置看起来非常清晰，但系统越大，配置内容就越大。</p>
<h3 id="2-2-1-使用步骤"><a href="#2-2-1-使用步骤" class="headerlink" title="2.2.1 使用步骤"></a>2.2.1 使用步骤</h3><p>1）通过 Maven 创建工程并引入<code>spring-context</code>依赖；</p>
<p>2）通过属性注入或者依赖注入编写组件；</p>
<p>3）根据组件间的依赖关系编写<code>application.xml</code>配置文件，定义需要实例化对象的类的全限定类名以及类之间依赖关系描述；</p>
<p>4）创建 IoC 容器实例，并加载配置文件，使得 Spring 的 IoC 容器创建并装配好配置文件中指定的所有 Bean，接着就可以从 Spring 的 IoC 容器中获取装配好的 Bean；</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">ApplicationContext</span> <span class="variable">context</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ClassPathXmlApplicationContext</span>(<span class="string">&quot;application.xml&quot;</span>);</span><br><span class="line"><span class="type">Product</span> <span class="variable">product</span> <span class="operator">=</span> (Product) context.getBean(Product.class);</span><br></pre></td></tr></table></figure>

<p>Spring 容器有两种，一种是<code>BeanFactory</code>接口（Bean 工厂），另一种是<code>ApplicationContext</code>接口（应用上下文）。通常情况下都会使用应用上下文，很少使用Bean 工厂。常用的<code>ApplicationContext</code>接口的实现类有以下三种：</p>
<ul>
<li><p><code>ClassPathXmlApplicationContext</code>：从类路径下的XML配置文件中加载上下文定义，把和上下文定义文件当做资源；</p>
</li>
<li><p><code>FileSystemXmlapplicationContext</code>：读取文件系统下的XML配置文件并加载上下文定义；</p>
</li>
<li><p><code>AnnotationConfigApplicationContext</code>：在纯注解模式下自动装配并加载上下文定义；</p>
</li>
<li><p><code>XmlWebApplicationContext</code>：读取Web应用下的XML配置文件并装载上下文定义。</p>
</li>
</ul>
<h3 id="2-2-2-静态装配"><a href="#2-2-2-静态装配" class="headerlink" title="2.2.2 静态装配"></a>2.2.2 静态装配</h3><ul>
<li><p>每个Bean都有一个<code>id</code>属性，<code>id</code>属性定义了Bean的唯一标识；</p>
</li>
<li><p><code>class</code>属性定义Bean的类的全限定类名（这会通过反射调用无参构造器）或者工厂类的全限定类名（和<code>factory-method</code>属性一起使用）来创建对象；</p>
</li>
<li><p><code>scope</code>属性指定了Bean的作用域，默认是<code>singleton</code>，Spring 官方提供的作用域如下，此外也可以自定义作用域；</p>
<table>
<thead>
<tr>
<th align="left">作用域</th>
<th>定义</th>
</tr>
</thead>
<tbody><tr>
<td align="left">singleton</td>
<td>一个 Bean 定义只有一个对象实例（默认）</td>
</tr>
<tr>
<td align="left">prototype</td>
<td>每次调用都创建一个实例，允许 Bean 的定义可以被实例化任意次</td>
</tr>
<tr>
<td align="left">request</td>
<td>用于一次 HTTP 请求，该 Bean 仅在当前 HTTP request 内有效</td>
</tr>
<tr>
<td align="left">session</td>
<td>用于一个 HTTP Session，该 Bean 仅在当前 HTTP session 内有效</td>
</tr>
<tr>
<td align="left">application</td>
<td>用于一个全局 HTTP Session，该 Bean 仅在当前应用启动时间内有效</td>
</tr>
</tbody></table>
</li>
<li><p><code>factory-bean</code>属性指定创建当前Bean的工厂Bean的唯⼀标识，当指定了此属性之后，<code>class</code>属性失效；</p>
</li>
<li><p><code>factory-method</code>属性指定创建Bean的工厂方法，从而能够代替构造方法创建Bean，如果和<code>class</code>属性搭配使用，则方法必须是<code>static</code>的；</p>
</li>
<li><p><code>init-method</code>和<code>destory-method</code>属性分别指定Bean的初始化和销毁方法，<code>init-method</code>属性要求是无参方法，<code>destory-method</code>属性只能对单例Bean起作用；</p>
</li>
<li><p><code>default-init-method</code>和<code>default-destory-method</code>属性为上下文中所有的Bean都分别指定默认了初始化和销毁方法；</p>
</li>
<li><p><code>lazy-init</code>属性默认为<code>false</code>，代表会立即加载Bean，也就是在Bean初始化后提前进行实例化；</p>
<ul>
<li><p>可以通过将<code>lazy-init</code>属性设为<code>true</code>来实现延迟初始化，也就是在第一次向容器<br>通过 getBean 索取 Bean 时才进行实例化；</p>
</li>
<li><p>对于<code>scope</code>属性设为<code>pototype</code>的Bean，<code>lazy-init</code>属性设置不起作用，即始终保持延迟初始化；</p>
</li>
</ul>
</li>
<li><p>通过<code>&lt;property name = &quot;…&quot; value = &quot;…&quot; /&gt;</code>或者<code>p:xxx = &quot;...&quot;</code>来注入数据类型；</p>
</li>
<li><p>通过<code>&lt;property name = &quot;…&quot; ref = &quot;…&quot; /&gt;</code>或者<code>p:xxx-ref = &quot;...&quot;</code>来注入另一个Bean；</p>
</li>
<li><p>通过<code>&lt;property name = &quot;…&quot;&gt; &lt;bean class = &quot;...&quot; /&gt; &lt;/property&gt;</code>来注入内部Bean，内部Bean无<code>id</code>属性；</p>
</li>
<li><p>通过<code>&lt;property name = &quot;...&quot;&gt; &lt;null/&gt; &lt;/property&gt;</code>来注入空值；</p>
</li>
<li><p>通过<code>&lt;property name = &quot;...&quot; &lt;list&gt; &lt;ref bean = &quot;...&quot; /&gt; &lt;/list&gt; &lt;/property&gt;</code>或者<code>&lt;property name = &quot;...&quot; &lt;set&gt; &lt;ref bean = &quot;...&quot; /&gt; &lt;/set&gt; &lt;/property&gt;</code>来注入数组类型或者Collection接口的实现类型；</p>
</li>
<li><p>通过<code>&lt;property name = &quot;...&quot; &lt;map&gt; &lt;entry key = &quot;...&quot; value = &quot;...&quot; /&gt; &lt;/map&gt; &lt;/property&gt;</code>来注入Map类型，其中<code>key</code>和<code>value</code>可以根据需要改为<code>key-ref</code>和<code>value-ref</code>；</p>
</li>
<li><p>通过<code>&lt;constructor-arg values = &quot;...&quot; /&gt;</code>或者<code>&lt;constructor-arg ref= &quot;...&quot; /&gt;</code>或者<code>&lt;constructor-arg&gt; &lt;bean class = &quot;...&quot; /&gt; &lt;/constructor-arg&gt;</code>来注入构造器参数（默认的无参构造器不需要这样注入参数。</p>
</li>
</ul>
<h3 id="2-2-3-动态装配"><a href="#2-2-3-动态装配" class="headerlink" title="2.2.3 动态装配"></a>2.2.3 动态装配</h3><p>在 XML 配置文件中除了静态定义依赖关系之外，还可以通过 Spring 表达式语言（Spring Expression Language, SpEL）在运行期将值动态装配到 Bean 的属性或者构造器参数中。比如<code>&lt;property name = &quot;...&quot; value = &quot;#&#123;SpEL表达式&#125;&quot; /&gt;</code>可以将<code>#&#123;&#125;</code>界定符中的 SpEL 表达式所计算得到的值装配到 Bean 属性中。</p>
<ul>
<li><p>SpEL表达式提供了多种运算符；</p>
<table>
<thead>
<tr>
<th align="left">作用域</th>
<th>定义</th>
</tr>
</thead>
<tbody><tr>
<td align="left">算术运算</td>
<td><code>+</code>、<code>-</code>、<code>*</code>、<code>/</code>、<code>%</code>、<code>^</code></td>
</tr>
<tr>
<td align="left">关系运算</td>
<td><code>&lt;</code>、<code>&gt;</code>、<code>==</code>、<code>&lt;=</code>、<code>&gt;=</code>、<code>lt</code>、<code>gt</code>、<code>eq</code>、<code>le</code>、<code>ge</code></td>
</tr>
<tr>
<td align="left">逻辑运算</td>
<td><code>and</code>、<code>or</code>、<code>not</code>、<code>！</code></td>
</tr>
<tr>
<td align="left">条件运算</td>
<td><code>？：</code></td>
</tr>
<tr>
<td align="left">正则表达式</td>
<td><code>matches</code></td>
</tr>
</tbody></table>
</li>
<li><p><code>+</code>运算符除了进行算法运算外，还可以用于进行字符串连接；</p>
</li>
<li><p>在XML配置文件中使用<code>&lt;=</code>和<code>&gt;=</code>符号时会报错，最好使用文本替代方式</p>
</li>
<li><p><code>?.</code>运算符可以代替<code>.</code>运算符来调用方法，并确保访问右边方法前，左边项的值不会为<code>null</code>；</p>
</li>
<li><p><code>T()</code>运算符可以用于调用类作用域的方法和常量，但该运算符的真正价值在于访问指定类的静态方法和常量；</p>
</li>
<li><p><code>x ? x : y</code>形式的三元运算符可以简写为<code>x ?: y</code>；</p>
</li>
<li><p><code>matches</code>运算符对<code>String</code>类型的文本（作为左边参数）应用正则表达式（作为右边参数）；</p>
</li>
<li><p><code>[]</code>运算符可以从用来获取<code>Map</code>、<code>Properties</code>中的成员以及字符串中的某个字符；</p>
</li>
<li><p><code>systemEnvironment</code>包含了应用程序所在的机器上的所有环境变量，<code>systemProperties</code>包含了Java应用程序启动时所设置的所有属性，都可以与<code>[]</code>运算符搭配使用；</p>
</li>
<li><p><code>.?[]</code>是一个查询运算符，用于从集合中创建出一个新的集合，新的集合中只存放原集合中符合中括号内的表达式的成员；</p>
</li>
<li><p><code>.^[]</code>和<code>.$[]</code>也是查询运算符，分别用于从集合中查询出符合中括号内的表达式的第一个匹配项和最后一个匹配项；</p>
</li>
<li><p><code>.![]</code>是投影运算符，用于从集合中的每个成员中选定特定的属性放入一个新的集合中；</p>
</li>
</ul>
<p>SpEL表达式虽然功能强大，但是终究是一个字符串，不易于测试，也没有IDE的语法检查的支持，只有在使用传统方式很难甚至不可能但使用SpEL却很简单的情况下才使用SpEL进行装配，尽量不要把过多逻辑放入SpEL。</p>
<h3 id="2-2-4-自动装配"><a href="#2-2-4-自动装配" class="headerlink" title="2.2.4 自动装配"></a>2.2.4 自动装配</h3><ul>
<li><p>通过<code>autowire = &quot;byName&quot; /&gt;</code>可以为属性自动装配ID与该属性的名字相同的Bean；</p>
</li>
<li><p>通过<code>autowire = &quot;byType&quot; /&gt;</code>可以为属性自动装配类型与该属性的类型相同的Bean；</p>
</li>
<li><p>通过<code>autowire = &quot;constructor&quot; /&gt;</code>可以为构造器自动装配类型与构造器入参类型相同的Bean，此时不需要再声明注入构造器参数；</p>
</li>
<li><p><code>byType</code>和<code>constructor</code>自动装配都具有一个局限性：如果存在多个与该属性的类型相同的Bean，Spring会抛出异常，因此，要么只允许存在一个Bean与需要自动装配的属性类型相匹配，要么将其他需要被排除的Bean的<code>autowire-candidate</code>属性设为<code>false</code>；</p>
</li>
<li><p>通过<code>autowire = &quot;autodetect&quot; /&gt;</code>可以首先尝试使用<code>constructor</code>自动匹配，如果没有发现与构造器相匹配的Bean时，将尝试使用<code>byType</code>自动匹配；</p>
</li>
<li><p>默认情况下，XML文件的<code>default-autowire</code>属性被设置为<code>none</code>，标示XML中所有的Bean都不使用自动装配，除非Bean自己配置了<code>autowire</code>属性；</p>
</li>
<li><p>通过将<code>default-autowire</code>属性设置为<code>byName</code>、<code>byType</code>、<code>constructor</code>、<code>autodetect</code>中的任意一个，则可以令每一个Bean的所有属性都使用所设置的自动装配方式；</p>
</li>
<li><p>即便设置了默认的自动装配方式，依旧可以在每个Bean中重新设置自动装配方式来覆盖默认设置，即便使用了自动装配，依旧可以混合使用显示的装配来覆盖自动装配；</p>
</li>
<li><p>当使用<code>constructor</code>自动装配时，必须自动装配构造器的所有入参，不能混合使用<code>constructor</code>自动装配和<code>&lt;constructor-arg</code>元素。</p>
</li>
</ul>
<h2 id="2-3-注解配置"><a href="#2-3-注解配置" class="headerlink" title="2.3 注解配置"></a>2.3 注解配置</h2><p>使用注解自动装配与在XML中使用<code>autowire</code>属性自动装配并没有太大差别，但使用注解方式允许更细粒度的自动装配，可以选择性地标注某一个属性来对其应用自动装配，使用也更加方便。但当需要修改一个Bean时，无法很好的确定到底有多少个其他的 Bean 依赖于这个被修改的 Bean。</p>
<p>可以通过 XML 来配置第三方 jar 中的 Bean，通过注解来配置自身开发的 Bean，此时是 XML +注解的配置模式，XML 文件依旧存在，因此 Spring IoC 容器的启动依旧是从加载XML开始的。</p>
<h3 id="2-3-1-使用步骤"><a href="#2-3-1-使用步骤" class="headerlink" title="2.3.1 使用步骤"></a>2.3.1 使用步骤</h3><p>1）通过Maven创建工程并引入<code>spring-context</code>依赖；</p>
<p>2）在XML文件中进行配置；</p>
<ul>
<li><p>配置<code>&lt;context:annotation-config&gt;</code>元素，可以告知Spring使用基于注解的自动装配；</p>
</li>
<li><p>配置<code>&lt;context:component-scan&gt;</code>元素（除了完成与<code>&lt;context:annotation-config&gt;</code>元素一样的工作，还允许Spring自动检测Bean和定义Bean，此时不再需要<code>&lt;bean&gt;</code>元素）；</p>
</li>
<li><p>会扫描<code>base-package</code>属性所指定的包及其所有子包，并查找出能够自动注册为 Spring Bean的类；</p>
</li>
</ul>
<p>3）定义配置类</p>
<ul>
<li><p>通过<code>@Configuration</code>和<code>@ComponentScan</code>注解编写<code>AppConfig</code>配置类；</p>
</li>
<li><p>通常将<code>AppConfig</code>配置类位于自定义的顶层包，其他 Bean 按类别放入子包；</p>
</li>
</ul>
<p>4）通过<code>@Component</code>和<code>@Autowired</code>等注解编写组件；</p>
<p>5）在<code>AppConfig</code>配置类的<code>main</code>函数中创建 IoC 容器实例，容器创建并装配好所有 Bean，接着就可以从 Spring 的 IoC 容器中获取装配好的 Bean。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">ApplicationContext</span> <span class="variable">context</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AnnotationConfigApplicationContext</span>(AppConfig.class);</span><br><span class="line"><span class="type">Product</span> <span class="variable">product</span> <span class="operator">=</span> (Product) context.getBean(Product.class);</span><br></pre></td></tr></table></figure>

<h3 id="2-3-2-自动装配"><a href="#2-3-2-自动装配" class="headerlink" title="2.3.2 自动装配"></a>2.3.2 自动装配</h3><p>Spring 支持字段注入、构造器注入、<code>setter</code>注入，但是 Spring 不建议使用基于字段的依赖注入，这是因为这种方式使得 Spring 作为外部容器却感知到一个被封装 Bean 内部的私有成员变量，破坏了封装性。以下注解均用于在类初始化之后注入 Bean，实现自动装配</p>
<ul>
<li><p><code>@Autowired</code></p>
<ul>
<li><p>是 Spring 容器提供的，作用于类的构造器、字段以及<code>setter</code>方法，相当于把指定类型（先是<code>byType</code>方式，再是<code>byName</code>方法）的 Bean 注入到指定字段，且不受限于<code>private</code>关键字；</p>
</li>
<li><p><code>@Autowired</code>默认在指定类型的 Bean 不存在时报错，而<code>@Autowired(required = false)</code>则不会报错，即找到指定类型时注入，没找到时注入<code>null</code>；</p>
</li>
<li><p><code>required</code>属性可以用于<code>@Autowired</code>所使用的任意地方，但当用于构造器装配时，只有一个构造器可以将<code>@Autowired</code>的<code>required</code>属性设置为<code>true</code>，其他构造器的<code>@Autowired</code>的<code>required</code>属性只能设置为<code>false</code>;</p>
</li>
<li><p>当使用<code>@Autowired</code>标注多个构造器时，Spring 会从满足装配条件的构造器中选择入参最多的那个构造器。</p>
</li>
</ul>
</li>
<li><p><code>@Qualifier(&quot;beanName&quot;)</code></p>
<ul>
<li><p>在存在多个相同类型的Bean的情况下，用于指定注入的Bean的别名，与<code>@Autowired</code>搭配使用，相当于把<code>byType</code>自动装配转换为<code>byName</code>；</p>
</li>
<li><p>通过<code>@Qualifier</code>可以创建自定义的限定器注解，然后通过自定义的限定器注解来代替<code>@Qualifier</code>来标注指定注入的Bean的范围。</p>
</li>
</ul>
</li>
<li><p><code>@Inject</code></p>
<ul>
<li><p>Java 的<code>@Inject</code>几乎可以完全替代 Spring 的<code>@Autowired</code>；</p>
</li>
<li><p>与<code>@Autowired</code>不同的是，<code>@Inject</code>没有<code>required</code>属性，因此<code>@Inject</code>标注的依赖关系必须存在，如果不存在则会抛出异常。</p>
</li>
</ul>
</li>
<li><p><code>@Named</code></p>
<ul>
<li><p>相对于<code>@Autowired</code>所对应的<code>@Qualiflier</code>，<code>@Inject</code>所对应的是<code>@Named</code>；</p>
</li>
<li><p><code>javax.inject</code>包里有自己的<code>@Qualiflier</code>注解，但不建议使用该包中的<code>@Qualiflier</code>注解，而是鼓励使用该注解来创建自定义的限定器注解；</p>
</li>
<li><p>实际上，<code>@Named</code>就是使用<code>javax.inject</code>包中的<code>@Qualiflier</code>注解所创建的限定器注解。</p>
</li>
</ul>
</li>
<li><p><code>@Value</code></p>
<ul>
<li><p>用于某个属性、方法或者方法参数，并传入一个基本类型或者<code>String</code>类型的值来装配属性，<code>String</code>类型还可以是一个 SpEL 表达式，表达式的计算结果可以是任意类型；</p>
</li>
<li><p>用于注入资源，Spring提供了一个<code>org.springframework.core.io.Resource</code>（注意不是<code>javax.annotation.Resource</code>），它可以像<code>String</code>、<code>int</code>一样使用<code>@Value</code>注入；</p>
</li>
<li><p>当程序需要读取一个资源文件（比如配置文件等）中的内容时，可以在<code>Resource</code>类型的数据成员<code>resource</code>上标注<code>@Value(&quot;classpath:/logo.txt&quot;)</code>，然后直接调用<code>resource.getInputStream()</code>就可以获取到classpath中的<code>logo.txt</code>文件的输入流，避免了自己搜索文件的代码。</p>
</li>
</ul>
</li>
<li><p><code>@Resource</code></p>
<ul>
<li><p>由<code>javax.annotation.Resource</code>包提供，适用于包括 Spring 在内的所有IoC 容器，但在 Jdk 11 中已经移除，此时使用需要单独引入 jar 包</p>
</li>
<li><p>和<code>@Autowired</code>作用基本等价，区别在于只能作用于字段和<code>setter</code>方法，把指定类型（先是<code>byName</code>方式，再是<code>byType</code>方法）的 Bean 注入到指定字段；</p>
</li>
<li><p>指定 name 时找不到则抛出异常，指定 type 时找不到或是找到多个，都会抛出异常，既没有指定 name，又没有指定 type 时，自动按照<code>byName</code>自动装配。</p>
</li>
</ul>
</li>
</ul>
<h3 id="2-3-3-自动检测"><a href="#2-3-3-自动检测" class="headerlink" title="2.3.3 自动检测"></a>2.3.3 自动检测</h3><p>以下四个注解均用于声明Bean，实现自动检测。</p>
<ul>
<li><p><code>@Component</code></p>
<ul>
<li><p>默认定义了一个<code>id</code>为小写开头的类名的Bean，<code>@Component(&quot;...&quot;)</code>则显式定义了一个指定<code>id</code>的Bean；</p>
</li>
<li><p>如果一个 Bean 不知道属于哪个层，可以使用<code>@Component</code> 注解标注。</p>
</li>
</ul>
</li>
<li><p><code>@Controller</code> : 对应 Spring MVC 控制层，主要用于接受用户请求并调用 Service 层返回数据给前端页面。</p>
</li>
<li><p><code>@Service</code> : 对应服务层，主要涉及一些复杂的逻辑，需要用到 Dao 层。</p>
</li>
<li><p><code>@Repository</code>：对应持久层即 Dao 层，主要用于数据库相关操作。</p>
</li>
</ul>
<p>这四个注解的用法完全一样，只是为了更清晰的区分不同层次的 Bean。</p>
<p>在令 Spring 自动检测组件的过程中，也可以配置相关的过滤器来过滤组件扫描。</p>
<ul>
<li><p>在配置<code>&lt;context:component-scan&gt;</code>元素时，可以通过配置<code>&lt;context:include-filter</code>和<code>&lt;context:exclude-filter</code>子元素来设置过滤器，分别调整要扫描和不要扫描的类型；</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">context:component-scan</span></span></span><br><span class="line"><span class="tag">			<span class="attr">base-package</span> = <span class="string">&quot;...&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">context:include-filter</span> <span class="attr">type</span> = <span class="string">&quot;...&quot;</span> <span class="attr">expression</span> = <span class="string">&quot;...&quot;</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">context:exclude-filter</span> <span class="attr">type</span> = <span class="string">&quot;...&quot;</span> <span class="attr">expression</span> = <span class="string">&quot;...&quot;</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">context:component-scan</span>&gt;</span></span><br></pre></td></tr></table></figure></li>
<li><p>其中，<code>type</code>属性用于指定要使用的过滤器类型；</p>
<table>
<thead>
<tr>
<th align="left">过滤器类型</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><code>annotation</code></td>
<td>扫描使用指定注解所标注的类，由<code>expression</code>属性指定要扫描的注解</td>
</tr>
<tr>
<td align="left"><code>assignable</code></td>
<td>扫描派生于<code>expression</code>属性所指定类型的类</td>
</tr>
<tr>
<td align="left"><code>aspectj</code></td>
<td>扫描与<code>expression</code>属性所指定的AspectJ表达式所匹配的类</td>
</tr>
<tr>
<td align="left"><code>regex</code></td>
<td>扫描类名称与<code>expression</code>属性所指定的正则表达式所匹配的类</td>
</tr>
</tbody></table>
</li>
</ul>
<h3 id="2-3-4-基于-Java-的配置"><a href="#2-3-4-基于-Java-的配置" class="headerlink" title="2.3.4 基于 Java 的配置"></a>2.3.4 基于 Java 的配置</h3><p>在基于 XML 文件的配置中，Bean 的类型和 ID 都是由字符串来标示的，这就导致它们无法进行编译期检查，写起来也很繁琐，而<strong>在基于 Java 的配置中，则可以进行编译期检查来确保 Bean 的类型是合法类型</strong>。Spring Boot 偏向使用基于 Java 的配置。</p>
<ul>
<li><p><code>@Configuration</code></p>
<ul>
<li><p>通过在XML文件中配置<code>&lt;context:component-scan&gt;</code>元素，还可以告知Spring在包内自动加载使用<code>@Configuration</code>注解所标注的所有类；</p>
</li>
<li><p><code>@Configuration</code>注解等同于XML文件中的<code>&lt;beans&gt;</code>元素，它所标注的类是一个配置类；</p>
</li>
<li><p>配置类会包含一个或多个Spring Bean的定义，这些Bean的定义是使用<code>@Bean</code>注解所标注的方法。</p>
</li>
</ul>
</li>
<li><p><code>@Bean</code></p>
<ul>
<li><p>用于方法，当一个Bean不在<code>AppConfig</code>配置类所在的包中时，可以在<code>AppConfig</code>配置类中编写标注了<code>@Bean</code>的方法来创建并返回该Bean，方法名将作为该Bean的ID；</p>
</li>
<li><p>也可以通过<code>@Bean(&quot;...&quot;)</code>或者<code>@Bean</code>+<code>@Qualifier(&quot;...&quot;)</code>指定别名；</p>
</li>
<li><p>通过声明方法引用一个Bean并不等同于调用该方法，区别在于每次调用该方法都会得到一个新的实例，而通过<code>@Bean</code>标注时，Spring会拦截该方法的调用，并尝试在应用上下文中查找该Bean，这意味着该Bean是Singleton。</p>
</li>
</ul>
</li>
<li><p><code>@ComponentScan</code></p>
<ul>
<li><p>用于类，告知容器自动搜索当前类所在的包以及子包，可代替<code>&lt;context:component-scan&gt;</code>元素；</p>
</li>
<li><p>将所有标注为<code>@Component</code>、<code>@Controller</code>、<code>@Service</code>、<code>@Repository</code>的Bean自动创建出来，并根据<code>@Autowired</code>进行装配。</p>
</li>
</ul>
</li>
<li><p><code>@Import</code></p>
<ul>
<li><p>不需要把所有的配置都放到一个配置类中；</p>
</li>
<li><p><code>@Configuration</code>标注的配置类可以通过<code>@Import</code>来导入其他的配置类，把多个分开的容器配置合并在一个配置中。</p>
</li>
</ul>
</li>
<li><p><code>@ImportResource</code></p>
<ul>
<li><p>用于导入Spring的配置文件，让配置文件里面的内容生效；</p>
</li>
<li><p>如果必须要使用基于XML的配置，依旧定义一个<code>@Configuration</code>配置类，然后通过<code>@ImportResource</code>来加载XML配置文件。</p>
</li>
</ul>
</li>
</ul>
<h3 id="2-3-5-补充介绍"><a href="#2-3-5-补充介绍" class="headerlink" title="2.3.5 补充介绍"></a>2.3.5 补充介绍</h3><ul>
<li><p><code>@Scope</code></p>
<ul>
<li><p>用于类，单独使用<code>@Component</code>注解时会默认将组件标注为Singleton，即每次通过<code>getBean</code>方法获取到Bean总是同一个实例；</p>
</li>
<li><p>增加<code>@Scope</code>注解时，则可以将组件标注为不同的作用域的Bean，例如<code>@Scope(ConfigurableBeanFactory.SCOPE_PROTOTYPE)</code>将组件标注为Prototype（原型）。</p>
</li>
</ul>
</li>
<li><p><code>@PostConstruct</code></p>
<ul>
<li><p>用于Bean在注入必要依赖后的<code>init</code>方法，从而进行初始化；</p>
</li>
<li><p>Spring只根据<code>@PostConstruct</code>查找无参数方法，对方法名不作要求。</p>
</li>
</ul>
</li>
<li><p><code>@PreDestory</code></p>
<ul>
<li><p>用于Bean在容器关闭时的<code>shutdown</code>方法，从而进行相关的清理操作；</p>
</li>
<li><p>Spring只根据<code>@PreDestory</code>查找无参数方法，对方法名不作要求。</p>
</li>
</ul>
</li>
<li><p><code>@Primary</code></p>
<ul>
<li><p>在存在多个相同类型的Bean的情况下，用于指定优先注入的Bean，则注入时不需要指出该优先注入的Bean的别名；</p>
</li>
<li><p>相同类型的Bean只有一个可以指定为<code>@Primary</code>，其他必须用<code>@Qualiflier(&quot;beanNname&quot;)</code>指定别名。</p>
</li>
</ul>
</li>
<li><p><code>@PropertySource(&quot;app.properties&quot;)</code></p>
<ul>
<li><p>用于<code>AppConfig</code>配置类，告知容器自动读取名为<code>app.properties</code>的配置文件，接着可以使用<code>@Value(&quot;$&#123;key:defaultValue&#125;&quot;)</code>来注入配置文件中<code>key</code>的<code>value</code>，这比使用<code>@Value(&quot;classpath:/app.properties&quot;)</code>+输入流的方式来读取配置文件更加简单；</p>
</li>
<li><p>还有一种方式是先通过一个Bean（Spring容器中的默认类名称为<code>SmtpConfig</code>）持有所有的配置属性值，然后在其他Bean中使用<code>@value(&quot;#&#123;smtpConfig.property&#125;&quot;)</code>来注入属性值。</p>
</li>
</ul>
</li>
<li><p><code>@Profile</code></p>
<ul>
<li><p>用于配置不同环境下的Bean，程序运行时通过指定运行环境就可以使得容器只创建该环境下的Bean；</p>
</li>
<li><p>Spring提供了<code>native</code>（开发）、<code>test</code>（测试）和<code>production</code>（生产）这三种环境。</p>
</li>
</ul>
</li>
<li><p><code>@Conditional</code></p>
<ul>
<li>用于Bean声明；</li>
<li>提供了Bean的装载条件判断，从而确定是否创建该Bean。</li>
</ul>
</li>
</ul>
<h2 id="2-4-IoC-特性"><a href="#2-4-IoC-特性" class="headerlink" title="2.4 IoC 特性"></a>2.4 IoC 特性</h2><h3 id="2-4-1-工厂-Bean"><a href="#2-4-1-工厂-Bean" class="headerlink" title="2.4.1 工厂 Bean"></a>2.4.1 工厂 Bean</h3><p>Spring中Bean有两种，⼀种是普通 Bean，⼀种是工厂 Bean（<code>FactoryBean</code>），<code>FactoryBean</code>可以生成某个类型的 Bean 实例，可以借助于它自定义 Bean 的创建过程，一般用于创建比较复杂的需要通过特定创建方式的对象。</p>
<p>Spring 提供了工厂模式来创建 Bean，过程如下：</p>
<p>1）假如需要以工厂模式创建<code>Product</code>，首先需要定义一个工厂Bean（<code>ProductFactoryBean</code>），该工厂Bean需要实现<code>FactotyBean</code>接口；</p>
<p>2）Spring会优先实例化工厂Bean（<code>ProductFactoryBean</code>），然后通过工厂Bean的<code>getObject</code>方法创建真正的Bean（<code>Product</code>）；</p>
<p>3）因此，如果定义了一个工厂Bean，Spring创建的Bean实际上是这个工厂Bean的<code>getObject</code>方法所返回的Bean。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ProductFactoryBean</span> <span class="keyword">implements</span> <span class="title class_">FactoryBean</span>&lt;Product&gt; &#123;</span><br><span class="line">    </span><br><span class="line">    String product= <span class="string">&quot;P&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Product <span class="title function_">getObject</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="keyword">return</span> Product.of(product);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Class&lt;?&gt; getObjectType() &#123;</span><br><span class="line">        <span class="keyword">return</span> Product.class;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isSingleton</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="2-4-2-Bean-工厂"><a href="#2-4-2-Bean-工厂" class="headerlink" title="2.4.2 Bean 工厂"></a>2.4.2 Bean 工厂</h3><p><code>BeanFactory</code>接口（Bean工厂）是Spring框架中IoC容器的顶层接口，它只是用来定义一些基础功能和基础规范，是SpringIOC的基础容器。<code>ApplicationContext</code>是<code>BeanFactory</code>的一个子接口，具备<code>BeanFactory</code>提供的全部功能，是IoC容器的高级接口，比<code>BeanFactory</code>拥有更多的功能。</p>
<p>IoC容器初始化（获取<code>BeanFactory</code>）的关键之处在于<code>org.springframework.context.support.AbstractApplicationContext#refresh</code></p>
<p>1）在<code>AbstractApplicationContext</code>类的<code>refresh</code>方法中</p>
<ul>
<li><p>依次调用<code>obtainFreshBeanFactory</code>方法 –&gt; <code>refreshBeanFactory</code>方法和<code>getBeanFactory</code>方法；</p>
</li>
<li><p><code>AbstractRefreshableApplicationContext</code>类提供了<code>refreshBeanFactory</code>方法和<code>getBeanFactory</code>方法的具体实现来创建并返回Bean工厂；</p>
</li>
</ul>
<p>2）在<code>AbstractRefreshableApplicationContext</code>类的<code>refreshBeanFactory</code>方法中，完整代码如下</p>
<ul>
<li><p>以下代码的第8行，调用<code>createBeanFactory</code>方法来创建<code>DefaultListableBeanFactory</code>类型的<code>beanFactory</code>；</p>
</li>
<li><p>以下代码的第11行，调用<code>loadBeanDefinitions</code>方法来加载<code>beanFactory</code>中的<code>BeanDefinition</code>（JavaBean在IoC容器内部的数据结构类型）；</p>
</li>
<li><p><code>AbstractXmlApplicationContext</code>类提供了<code>loadBeanDefinitions</code>方法的具体实现；</p>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">refreshBeanFactory</span><span class="params">()</span> <span class="keyword">throws</span> BeansException &#123;</span><br><span class="line">    <span class="keyword">if</span> (hasBeanFactory()) &#123;</span><br><span class="line">        destroyBeans();</span><br><span class="line">        closeBeanFactory();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="type">DefaultListableBeanFactory</span> <span class="variable">beanFactory</span> <span class="operator">=</span> createBeanFactory();</span><br><span class="line">        beanFactory.setSerializationId(getId());</span><br><span class="line">        customizeBeanFactory(beanFactory);</span><br><span class="line">        loadBeanDefinitions(beanFactory);</span><br><span class="line">        <span class="built_in">this</span>.beanFactory = beanFactory;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">catch</span> (IOException ex) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">ApplicationContextException</span>(<span class="string">&quot;I/O error parsing bean definition source for &quot;</span> + getDisplayName(), ex);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>3）在<code>AbstractXmlApplicationContext</code>类的<code>loadBeanDefinitions</code>方法中，会依次调用多个类的<code>loadBeanDefinitions</code>方法，最终会调用到<code>XmlBeanDefinitionReader</code>类的<code>doLoadBeanDefinitions</code>方法；</p>
<p>4）在<code>XmlBeanDefinitionReader</code>类的<code>doLoadBeanDefinitions</code>方法中，截取了部分代码如下</p>
<ul>
<li><p>以下代码的第3行，调用<code>doLoadDocument</code>方法来读取XML信息，并保存到<code>Document</code>对象中；</p>
</li>
<li><p>以下代码的第4行，调用<code>registerBeanDefinitions</code>方法来解析<code>Document</code>对象，封装<code>BeanDefinition</code>对象并进行注册；</p>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">protected</span> <span class="type">int</span> <span class="title function_">doLoadBeanDefinitions</span><span class="params">(InputSource inputSource, Resource resource)</span> <span class="keyword">throws</span> BeanDefinitionStoreException &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="type">Document</span> <span class="variable">doc</span> <span class="operator">=</span> doLoadDocument(inputSource, resource);</span><br><span class="line">        <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> registerBeanDefinitions(doc, resource);</span><br><span class="line">        <span class="keyword">if</span> (logger.isDebugEnabled()) &#123;</span><br><span class="line">            logger.debug(<span class="string">&quot;Loaded &quot;</span> + count + <span class="string">&quot; bean definitions from &quot;</span> + resource);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> count;</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>5）在<code>XmlBeanDefinitionReader</code>类的<code>registerBeanDefinitions</code>方法中，完整代码如下</p>
<ul>
<li><p>以下代码的第4行的方法入参中，依次调用<code>createReaderContext</code>方法 –&gt; <code>getNamespaceHandlerResolver</code>方法 –&gt; <code>createDefaultNamespaceHandlerResolver</code>方法 –&gt; <code>DefaultNamespaceHandlerResolver</code>类的构造方法；</p>
</li>
<li><p>以下代码的第4行，调用<code>BeanDefinitionDocumentReader</code>接口的<code>registerBeanDefinitions</code>方法；</p>
</li>
<li><p><code>DefaultBeanDefinitionDocumentReader</code>类提供了<code>registerBeanDefinitions</code>方法的具体实现；</p>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">registerBeanDefinitions</span><span class="params">(Document doc, Resource resource)</span> <span class="keyword">throws</span> BeanDefinitionStoreException &#123;</span><br><span class="line">    <span class="type">BeanDefinitionDocumentReader</span> <span class="variable">documentReader</span> <span class="operator">=</span> createBeanDefinitionDocumentReader();</span><br><span class="line">    <span class="type">int</span> <span class="variable">countBefore</span> <span class="operator">=</span> getRegistry().getBeanDefinitionCount();</span><br><span class="line">    documentReader.registerBeanDefinitions(doc, createReaderContext(resource));</span><br><span class="line">    <span class="keyword">return</span> getRegistry().getBeanDefinitionCount() - countBefore;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>6）在<code>DefaultBeanDefinitionDocumentReader</code>类的<code>registerBeanDefinitions</code>方法中，会依次调用<code>doRegisterBeanDefinitions</code>方法 –&gt; <code>parseBeanDefinitions</code>方法 –&gt; <code>parseDefaultElement</code>方法 –&gt; <code>processBeanDefinition</code>方法；</p>
<p>7）在<code>DefaultBeanDefinitionDocumentReader</code>类的<code>processBeanDefinition</code>方法中，完整代码如下</p>
<ul>
<li><p>以下代码第2行，调用<code>parseBeanDefinitionElement</code>方法解析得到<code>BeanDefinitionHolder</code>对象；</p>
</li>
<li><p>以下代码第7行，依次调用<code>BeanDefinitionReaderUtils</code>类的<code>registerBeanDefinition</code>方法 –&gt;<code>BeanDefinitionRegistry</code>接口的<code>registerBeanDefinition</code>方法；</p>
</li>
<li><p><code>DefaultListableBeanFactory</code>类提供了<code>registerBeanDefinition</code>方法的具体实现；</p>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">processBeanDefinition</span><span class="params">(Element ele, BeanDefinitionParserDelegate delegate)</span> &#123;</span><br><span class="line">    <span class="type">BeanDefinitionHolder</span> <span class="variable">bdHolder</span> <span class="operator">=</span> delegate.parseBeanDefinitionElement(ele);</span><br><span class="line">    <span class="keyword">if</span> (bdHolder != <span class="literal">null</span>) &#123;</span><br><span class="line">        bdHolder = delegate.decorateBeanDefinitionIfRequired(ele, bdHolder);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// Register the final decorated instance.</span></span><br><span class="line">            BeanDefinitionReaderUtils.registerBeanDefinition(bdHolder, getReaderContext().getRegistry());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">catch</span> (BeanDefinitionStoreException ex) &#123;</span><br><span class="line">            getReaderContext().error(<span class="string">&quot;Failed to register bean definition with name &#x27;&quot;</span> +	bdHolder.getBeanName() + <span class="string">&quot;&#x27;&quot;</span>, ele, ex);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// Send registration event.</span></span><br><span class="line">        getReaderContext().fireComponentRegistered(<span class="keyword">new</span> <span class="title class_">BeanComponentDefinition</span>(bdHolder));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>8）在<code>DefaultListableBeanFactory</code>类中</p>
<ul>
<li><p>定义了如下所示的<code>beanDefinitionMap</code>和<code>beanDefinitionNames</code>域；</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/** Map of bean definition objects, keyed by bean name. */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Map&lt;String, BeanDefinition&gt; beanDefinitionMap = <span class="keyword">new</span> <span class="title class_">ConcurrentHashMap</span>&lt;&gt;(<span class="number">256</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">/** List of bean definition names, in registration order. */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">volatile</span> List&lt;String&gt; beanDefinitionNames = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;(<span class="number">256</span>);</span><br></pre></td></tr></table></figure></li>
<li><p>在<code>registerBeanDefinition</code>方法中，会把封装的 XML 中定义的 Bean信息封装得到的<code>BeanDefinition</code>类型的<code>beanDefinition</code>放入一个<code>beanDefinitionMap</code>，将<code>String</code>类型的<code>beanName</code>放入<code>beanDefinitionNames</code>中，从而完成注册。</p>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Still in startup registration phase</span></span><br><span class="line"><span class="built_in">this</span>.beanDefinitionMap.put(beanName, beanDefinition);</span><br><span class="line"><span class="built_in">this</span>.beanDefinitionNames.add(beanName);</span><br></pre></td></tr></table></figure>

<h3 id="2-4-3-Bean-的三级缓存"><a href="#2-4-3-Bean-的三级缓存" class="headerlink" title="2.4.3 Bean 的三级缓存"></a>2.4.3 Bean 的三级缓存</h3><p>Spring 的三级缓存就是三个<code>Map</code></p>
<ul>
<li><p>一级缓存中存放的完整创建好的单例 Bean 对象，在创建一个单例 Bean 时，会首先从一级缓存中尝试获取该 Bean 的实例，若能获取到则直接返回该实例，否则则继续创建该 Bean</p>
</li>
<li><p>二级缓存中存放的是尚未完全创建好的半成品单例 Bean 对象，存在循环依赖时就会创建这种半成品，当循环依赖的 Bean 创建完成后就将其存储到一级缓存中</p>
</li>
<li><p>三级缓存中存放的是单例 Bean 的创建工厂，当一个单例 Bean 被创建时，Spring 会首先将该 Bean 的创建工厂存储到三级缓存中，然后再执行 Bean 工厂的<code>getObject()</code>，生成该 Bean 实例对象并将其存储到一级缓存中</p>
</li>
</ul>
<p>Bean 之间的循环依赖一般都是设计有问题，应当尽可能避免，但如果两个 Bean 不可避免地需要循环引用，可以1）使用构造器注入并在某一个构造器中加入<code>@Lazy</code>注解使该类延迟初始化；2）使用 Spring 的三级缓存，此时 Spring 会提前暴露一个仅实例化而尚未完全初始化的半成品对象实例（对象初始化是可以延后的）。</p>
<ul>
<li><p>考虑到单例对象的创建和初始化只会发生一次，因此在容器运行期间的依赖关系不会发生变化，而原型对象的创建和初始化则可以发生多次，可以在容器运行期间动态变化（比如涉及不同的原型对象实例），因此这种方案这只能对单例对象奏效</p>
</li>
<li><p>考虑到对象实例化过程中就会调用构造器，无法通过构造器来注入一个尚未完全创建的对象，因此缓存方案要求依赖注入的方式不能都是构造器注入，在属性注入中，Spring 则可以顺利完成实例化过程从而先创建一个空对象或者半成品对象</p>
</li>
<li><p>对于普通对象来说，二级缓存就足够解决循环依赖问题了，但对于代理对象的循环依赖问题来说，如果没有三级缓存，则需要在二级缓存中存放半成品对象的代理对象，即在对象实例化之后初始化之前完成 AOP 代理，这就破坏了 AOP 代理的设计原则（原则是在原始 Bean 完全创建完成后再生成其代理 Bean，从而解耦原始 Bean 的创建和代理 Bean 的创建）</p>
</li>
<li><p>为了在遵守 AOP 代理原则的前提下解决代理对象的循环依赖问题，Spring 引入了保存对象工厂的三级缓存，通过对象工厂，如果循环依赖的 Bean 是代理 Bean，则工厂获取到的就是代理后的对象，如果对象没有被代理，那么工厂获取到的就是实例化的真实对象</p>
</li>
</ul>
<h3 id="2-4-4-Bean-的生命周期"><a href="#2-4-4-Bean-的生命周期" class="headerlink" title="2.4.4 Bean 的生命周期"></a>2.4.4 Bean 的生命周期</h3><p>在 IoC 容器的初始化过程中会对非懒加载的 Bean 定义完成资源定位，加载读取配置，并解析转化成 Spring 能够识别的<code>BeanDefinition</code>对象，最后将解析得到的<code>BeanDefinition</code>存到 HashMap 集合中（对于懒加载的 Bean 来说，其创建是在第一次调用<code>getBean</code>方法时完成的）。</p>
<img src="生命周期.jpg" alt="生命周期" style="zoom:100%;" />

<p>上图步骤 1-12 的关键调用点在<code>AbstractApplicationContext</code>类的<code>refresh</code>方法中</p>
<ul>
<li><p>调用<code>invokeBeanFactoryPostProcessors</code>方法，会实例化<code>BeanFactoryPostProcessor</code>实现类并执行其<code>postProcessBeanFactory</code>方法，对应上图步骤 1-2；</p>
</li>
<li><p>调用<code>registerBeanPostProcessors</code>方法，会实例化<code>BeanPostProcessor</code>实现类，对应上图步骤 3；</p>
</li>
<li><p>调用<code>finishBeanFactoryInitialization</code>方法，会通过反射执行 Bean 的构造方法（创建所有非懒加载的单例 Bean 实例）、注入属性、Bean Class 加载以及初始化，对应上图步骤 4-12，更多细节可查看 2.4.5 小节。</p>
</li>
</ul>
<h3 id="2-4-5-后置处理器"><a href="#2-4-5-后置处理器" class="headerlink" title="2.4.5 后置处理器"></a>2.4.5 后置处理器</h3><p>Spring提供了两种后置处理器<code>BeanFactoryPostProcessor</code>和<code>BeanPostProcessor</code>。从命名中可以看出区别：<code>BeanFactoryPostProcessor</code>是针对IoC容器（<code>BeanFactory</code>）初始化之后的后置处理器，<code>BeanPostProcessor</code>是针对Bean初始化之后的后置处理器。</p>
<p>1）<code>BeanFactoryPostProcessor</code>接口只提供了一个方法，该方法参数为<code>ConfigurableListableBeanFactory</code>；</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">BeanFactoryPostProcessor</span> &#123;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">postProcessBeanFactory</span><span class="params">(ConfigurableListableBeanFactory beanFactory)</span> <span class="keyword">throws</span> BeansException;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>ConfigurableListableBeanFactory</code>接口定义了一些方法，其中有个<code>getBeanDefinition</code>方法可以返回定义Bean的<code>BeanDefinition</code>对象，从而可以对定义的属性进行手动修改。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">ConfigurableListableBeanFactory</span> <span class="keyword">extends</span> <span class="title class_">ListableBeanFactory</span>, AutowireCapableBeanFactory, ConfigurableBeanFactory &#123;</span><br><span class="line">    BeanDefinition <span class="title function_">getBeanDefinition</span><span class="params">(String beanName)</span> <span class="keyword">throws</span> NoSuchBeanDefinitionException;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>2）定义一个类实现了<code>BeanPostProcessor</code>接口，默认是会对容器中所有的Bean进行处理，也可以通过方法参数来判断要处理的具体的某个Bean。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">BeanPostProcessor</span> &#123;</span><br><span class="line">    <span class="meta">@Nullable</span></span><br><span class="line">    <span class="keyword">default</span> Object <span class="title function_">postProcessBeforeInitialization</span><span class="params">(Object bean, String beanName)</span> <span class="keyword">throws</span> BeansException &#123;</span><br><span class="line">        <span class="keyword">return</span> bean;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Nullable</span></span><br><span class="line">    <span class="keyword">default</span> Object <span class="title function_">postProcessAfterInitialization</span><span class="params">(Object bean, String beanName)</span> <span class="keyword">throws</span> BeansException &#123;</span><br><span class="line">        <span class="keyword">return</span> bean;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="2-4-6-创建-Bean"><a href="#2-4-6-创建-Bean" class="headerlink" title="2.4.6 创建 Bean"></a>2.4.6 创建 Bean</h3><p>接2.4.3小节：</p>
<p>1）在<code>AbstractApplicationContext</code>类的<code>finishBeanFactoryInitialization</code>方法中，会调用<code>ConfigurableListableBeanFactory</code>接口的<code>preInstantiateSingletons</code>方法，<code>DefaultListableBeanFactory</code>类提供了<code>preInstantiateSingletons</code>方法的具体实现；</p>
<p>2）在<code>DefaultListableBeanFactory</code>类的<code>preInstantiateSingletons</code>方法中，截取了部分代码如下</p>
<ul>
<li><p>以下代码的第12行的<code>for</code>循环会触发所有非懒加载的单例Bean的初始化；</p>
</li>
<li><p>以下代码的第14行会判断是否是非懒加载的单例Bean，是的话则在IoC容器创建时创建Bean实例、依赖注入以及初始化；</p>
</li>
<li><p>以下代码的第32行会依次调用<code>AbstractBeanFactory</code>类的<code>getBean</code>方法 –&gt; <code>doGetBean</code>方法；</p>
</li>
<li><p>以下代码的第32行所触发的逻辑和懒加载时第一次调用<code>context.getBean(&quot;beanName&quot;)</code> 所触发的逻辑是一致的；</p>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">preInstantiateSingletons</span><span class="params">()</span> <span class="keyword">throws</span> BeansException &#123;</span><br><span class="line">    <span class="keyword">if</span> (logger.isTraceEnabled()) &#123;</span><br><span class="line">        logger.trace(<span class="string">&quot;Pre-instantiating singletons in &quot;</span> + <span class="built_in">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// Iterate over a copy to allow for init methods which in turn register new bean definitions.</span></span><br><span class="line">    <span class="comment">// While this may not be part of the regular factory bootstrap, it does otherwise work fine.</span></span><br><span class="line">    List&lt;String&gt; beanNames = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;(<span class="built_in">this</span>.beanDefinitionNames);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// Trigger initialization of all non-lazy singleton beans...</span></span><br><span class="line">    <span class="keyword">for</span> (String beanName : beanNames) &#123;</span><br><span class="line">        <span class="type">RootBeanDefinition</span> <span class="variable">bd</span> <span class="operator">=</span> getMergedLocalBeanDefinition(beanName);</span><br><span class="line">        <span class="keyword">if</span> (!bd.isAbstract() &amp;&amp; bd.isSingleton() &amp;&amp; !bd.isLazyInit()) &#123;</span><br><span class="line">            <span class="keyword">if</span> (isFactoryBean(beanName)) &#123;</span><br><span class="line">                <span class="type">Object</span> <span class="variable">bean</span> <span class="operator">=</span> getBean(FACTORY_BEAN_PREFIX + beanName);</span><br><span class="line">                <span class="keyword">if</span> (bean <span class="keyword">instanceof</span> FactoryBean) &#123;</span><br><span class="line">                    FactoryBean&lt;?&gt; factory = (FactoryBean&lt;?&gt;) bean;</span><br><span class="line">                    <span class="type">boolean</span> isEagerInit;</span><br><span class="line">                    <span class="keyword">if</span> (System.getSecurityManager() != <span class="literal">null</span> &amp;&amp; factory <span class="keyword">instanceof</span> SmartFactoryBean) &#123;</span><br><span class="line">                        isEagerInit = AccessController.doPrivileged((PrivilegedAction&lt;Boolean&gt;) ((SmartFactoryBean&lt;?&gt;) factory)::isEagerInit, getAccessControlContext());</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">else</span> &#123;</span><br><span class="line">                        isEagerInit = (factory <span class="keyword">instanceof</span> martFactoryBean &amp;&amp; ((SmartFactoryBean&lt;?&gt;) factory).isEagerInit());</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">if</span> (isEagerInit) &#123;</span><br><span class="line">                        getBean(beanName);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                getBean(beanName);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>3）在<code>AbstractBeanFactory</code>类的<code>doGetBean</code>方法中，截取了部分代码如下</p>
<ul>
<li><p>以下代码的第14行，通过<code>isPrototypeCurrentlyInCreation</code>方法来判断是否要获取一个正在被创建的原型Bean，是的话则直接抛出异常（原型Bean在创建之前会标记这个Bean正在被创建，等创建结束之后会删除标记），<strong>这代表Spring不支持原型 Bean的循环依赖，会直接抛出异常</strong>；</p>
</li>
<li><p>以下代码的第31行，会依次调用<code>AbstractAutowireCapableBeanFactory</code>类的<code>createBean</code>方法 –&gt; <code>doCreateBean</code>方法；</p>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">protected</span> &lt;T&gt; T <span class="title function_">doGetBean</span><span class="params">(String name, <span class="meta">@Nullable</span> Class&lt;T&gt; requiredType, <span class="meta">@Nullable</span> Object[] args, <span class="type">boolean</span> typeCheckOnly)</span>	<span class="keyword">throws</span> BeansException &#123;</span><br><span class="line">    <span class="type">String</span> <span class="variable">beanName</span> <span class="operator">=</span> transformedBeanName(name);</span><br><span class="line">    Object beanInstance;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// Eagerly check singleton cache for manually registered singletons.</span></span><br><span class="line">    <span class="type">Object</span> <span class="variable">sharedInstance</span> <span class="operator">=</span> getSingleton(beanName);</span><br><span class="line">    <span class="keyword">if</span> (sharedInstance != <span class="literal">null</span> &amp;&amp; args == <span class="literal">null</span>) &#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// Fail if we&#x27;re already creating this bean instance:</span></span><br><span class="line">        <span class="comment">// We&#x27;re assumably within a circular reference.</span></span><br><span class="line">        <span class="keyword">if</span> (isPrototypeCurrentlyInCreation(beanName)) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">BeanCurrentlyInCreationException</span>(beanName);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// Check if bean definition exists in this factory.</span></span><br><span class="line">        ...</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            ...</span><br><span class="line">            </span><br><span class="line">            <span class="comment">// Guarantee initialization of beans that the current bean depends on.</span></span><br><span class="line">            ...</span><br><span class="line">            </span><br><span class="line">            <span class="comment">// Create bean instance.</span></span><br><span class="line">            <span class="keyword">if</span> (mbd.isSingleton()) &#123;</span><br><span class="line">                sharedInstance = getSingleton(beanName, () -&gt; &#123;</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        <span class="keyword">return</span> createBean(beanName, mbd, args);</span><br><span class="line">                    &#125;</span><br><span class="line">                    ...</span><br><span class="line">                &#125;);</span><br><span class="line">                ...</span><br><span class="line">            &#125;</span><br><span class="line">            ...</span><br><span class="line">        &#125;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>4）在<code>AbstractAutowireCapableBeanFactory</code>类的<code>doCreateBean</code>方法中，截取了部分代码如下</p>
<ul>
<li><p>在以下代码的第9行，调用<code>createBeanInstance</code>方法，这里会通过反射调用构造器，创建了Bean对象（此时还未注入属性）；</p>
</li>
<li><p>在以下代码的第26行，调用<code>addSingletonFactory</code>方法，该方法的第二个入参是一个<code>ObjectFactory</code>类型，这里会<strong>将还未注入属性的Bean对象提前以<code>ObjectFactory</code>对象的形式暴露到IoC容器中，从而解决单例Bean的属性循环依赖问题（但无法解决构造器循环依赖问题，会直接抛出异常）</strong>；</p>
</li>
<li><p>在以下代码的第34行，调用<code>populateBean</code>方法，这里会对Bean注入属性；</p>
</li>
<li><p>在以下代码的第35行，调用<code>initializeBean</code>方法，这里会进行Bean Class加载以及Bean的初始化，更多细节可查看3.5.2小节。</p>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">protected</span> Object <span class="title function_">doCreateBean</span><span class="params">(String beanName, RootBeanDefinition mbd, <span class="meta">@Nullable</span> Object[] args)</span> <span class="keyword">throws</span> BeanCreationException &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// Instantiate the bean.</span></span><br><span class="line">    <span class="type">BeanWrapper</span> <span class="variable">instanceWrapper</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">if</span> (mbd.isSingleton()) &#123;</span><br><span class="line">        instanceWrapper = <span class="built_in">this</span>.factoryBeanInstanceCache.remove(beanName);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (instanceWrapper == <span class="literal">null</span>) &#123;</span><br><span class="line">        instanceWrapper = createBeanInstance(beanName, mbd, args);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">Object</span> <span class="variable">bean</span> <span class="operator">=</span> instanceWrapper.getWrappedInstance();</span><br><span class="line">    Class&lt;?&gt; beanType = instanceWrapper.getWrappedClass();</span><br><span class="line">    <span class="keyword">if</span> (beanType != NullBean.class) &#123;</span><br><span class="line">        mbd.resolvedTargetType = beanType;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    ...</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// Eagerly cache singletons to be able to resolve circular references</span></span><br><span class="line">    <span class="comment">// even when triggered by lifecycle interfaces like BeanFactoryAware.</span></span><br><span class="line">    <span class="type">boolean</span> <span class="variable">earlySingletonExposure</span> <span class="operator">=</span> (mbd.isSingleton() &amp;&amp; <span class="built_in">this</span>.allowCircularReferences &amp;&amp; isSingletonCurrentlyInCreation(beanName));</span><br><span class="line">    <span class="keyword">if</span> (earlySingletonExposure) &#123;</span><br><span class="line">        <span class="keyword">if</span> (logger.isTraceEnabled()) &#123;</span><br><span class="line">            logger.trace(<span class="string">&quot;Eagerly caching bean &#x27;&quot;</span> + beanName + <span class="string">&quot;&#x27; to allow for resolving potential circular references&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        addSingletonFactory(beanName, () -&gt; getEarlyBeanReference(beanName, mbd, bean));</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    ...</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// Initialize the bean instance.</span></span><br><span class="line">    <span class="type">Object</span> <span class="variable">exposedObject</span> <span class="operator">=</span> bean;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        populateBean(beanName, mbd, instanceWrapper);</span><br><span class="line">        exposedObject = initializeBean(beanName, exposedObject, mbd);</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="3、AOP"><a href="#3、AOP" class="headerlink" title="3、AOP"></a>3、AOP</h1><h2 id="3-1-问题与解决"><a href="#3-1-问题与解决" class="headerlink" title="3.1 问题与解决"></a>3.1 问题与解决</h2><p>假设业务的组件中有多个业务方法，每个业务方法除了要执行核心业务逻辑，还需要执行安全检查、事务管理等处理逻辑，这些处理逻辑会重复出现在每个四处分散的业务方法中。针对该问题可以使用代理模式，对每个执行业务方法的对象实现生成代理类，将这些处理逻辑放置在代理类当中，从而控制对原始对象的访问。</p>
<p>静态代理在编译期控制对对象的访问，这需要程序员手写很多代码，尤其是在需要代理的对象或类中方法比较多时，非常花费时间和精力，更简单的方法是将每一种处理看作一个切面，然后以某种自动化的方式将切面逻辑织入到核心逻辑中。动态代理则是在程序运行期间动态地控制对对象的访问，被广泛地用于许多 AOP 框架（例如 Spring AOP），为他们提供对方法的拦截过滤增强等。</p>
<p>依赖注入有助于应用对象之间的解耦，而 AOP (Aspect Oriented Programming) 把系统分解为不同的切面（比如安全检查、事务管理等处理），可以实现横切关注点与它们所影响的对象之间的解耦。AOP 是 OOP 的延续，OOP 是一种垂直纵向的继承体系，AOP 是一种横向抽取机制，将横切逻辑代码和业务逻辑代码分开，Java 中的 AOP 机制有：Java 代理、Spring 框架、AspectJ。</p>
<h2 id="3-2-术语介绍"><a href="#3-2-术语介绍" class="headerlink" title="3.2 术语介绍"></a>3.2 术语介绍</h2><ul>
<li><p><strong>连接点（Joinpoint）</strong></p>
<ul>
<li>连接点是应用执行过程中<strong>能够</strong>插入切面的所有点，是一种候选点；</li>
<li>切面代码利用这些点插入到应用的正常流程中，从而添加新的行为；</li>
<li>连接点模型有：字段连接点、构造器连接点、方法连接点；</li>
<li>Spring 只支持方法连接点，如果需要方法拦截之外的连接点拦截，可以转向更为强大的 Aspect。</li>
</ul>
</li>
<li><p><strong>通知（Advice）</strong> </p>
<ul>
<li><p>通知定义了切面是<strong>什么</strong>以及<strong>何时</strong>使用；</p>
</li>
<li><p>通知有以下五种类型；</p>
<table>
<thead>
<tr>
<th align="left">通知</th>
<th align="left">描述</th>
</tr>
</thead>
<tbody><tr>
<td align="left">Before</td>
<td align="left">在方法调用之前调用通知</td>
</tr>
<tr>
<td align="left">After-finally</td>
<td align="left">在方法完成之后调用通知，无论方法执行是否成功</td>
</tr>
<tr>
<td align="left">After-returning</td>
<td align="left">在方法成功执行之后调用通知</td>
</tr>
<tr>
<td align="left">After-throwing</td>
<td align="left">在方法抛出异常后调用通知</td>
</tr>
<tr>
<td align="left">Around</td>
<td align="left">通知包裹被通知的方法，在被通知方法的调用前和后执行自定义行为</td>
</tr>
</tbody></table>
</li>
<li><p>Spring所创建的通知都是由标准的Java类编写的。</p>
</li>
</ul>
</li>
<li><p><strong>切点（Pointcut）</strong></p>
<ul>
<li>切点定义了切面在<strong>何处</strong>使用，即哪些连接点会得到通知；</li>
<li>Spring 所定义的切点通常由 XML 文件或者注解来进行配置。</li>
</ul>
</li>
<li><p><strong>切面（Aspect）</strong></p>
<ul>
<li>切面是通知和切点的结合，切点和通知是切面的最基本元素；</li>
<li>通知和切点共同定义了关于切面的全部内容（什么、何时、何处）。</li>
</ul>
</li>
<li><p><strong>引入（Introduction）</strong></p>
<ul>
<li>引入允许在不修改现有类的情况下向现有类添加新方法或属性，令其具有新的行为和状态。</li>
</ul>
</li>
<li><p><strong>织入（Weaving）</strong></p>
<ul>
<li><p>织入是将切面应用到目标对象来创建新的代理对象的过程，切面在指定的连接点被织入到目标对象中；</p>
</li>
<li><p>在目标对象的生命周期里有以下三个时期可以进行织入；</p>
<table>
<thead>
<tr>
<th align="left">时期</th>
<th align="left">描述</th>
</tr>
</thead>
<tbody><tr>
<td align="left">编译期</td>
<td align="left">切面在目标类编译时被织入，比如 AspectJ</td>
</tr>
<tr>
<td align="left">类加载期</td>
<td align="left">切面在目标类加载到 JVM 时被织入</td>
</tr>
<tr>
<td align="left">运行期</td>
<td align="left">切面在应用运行的某个时刻被织入，比如 Spring AOP</td>
</tr>
</tbody></table>
</li>
<li><p>Spring 的 AOP 是基于 JVM 的动态代理实现的，在运行期将切面织入到 Spring 管理的 Bean 中， AspectJ AOP 是基于字节码操作实现的，在编译期织入切面；</p>
</li>
<li><p>Spring AOP 更加简单，AspectJ AOP 更加强大，如果切面比较少，那么两者性能差异不大，如果切面比较多，AspectJ AOP 比 Spring AOP 快很多。</p>
</li>
</ul>
</li>
</ul>
<h2 id="3-3-XML-配置"><a href="#3-3-XML-配置" class="headerlink" title="3.3 XML 配置"></a>3.3 XML 配置</h2><h3 id="3-3-1-使用步骤"><a href="#3-3-1-使用步骤" class="headerlink" title="3.3.1 使用步骤"></a>3.3.1 使用步骤</h3><p>1）通过Maven创建工程并引入<code>spring-aspects</code>依赖；</p>
<p>2）编写定义了切面逻辑的简单Java类；</p>
<p>3）在XML文件中将该类注册为Spring应用上下文中的一个Bean；</p>
<p>4）在XML文件中将该类配置为一个切面；</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">aop:config</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">aop:aspect</span> <span class="attr">id</span> = <span class="string">&quot;...&quot;</span> <span class="attr">ref</span> = <span class="string">&quot;...&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">aop:before</span> <span class="attr">pointcut</span> = <span class="string">&quot;...&quot;</span> <span class="attr">method</span> = <span class="string">&quot;...&quot;</span> <span class="attr">arg-names</span> = <span class="string">&quot;...&quot;</span> /&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">aop:after</span> <span class="attr">pointcut</span> = <span class="string">&quot;...&quot;</span> <span class="attr">method</span> = <span class="string">&quot;...&quot;</span> <span class="attr">arg-names</span> = <span class="string">&quot;...&quot;</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">aop:aspect</span>&gt;</span>                </span><br><span class="line"><span class="tag">&lt;/<span class="name">aop:config</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h3 id="3-3-2-配置元素"><a href="#3-3-2-配置元素" class="headerlink" title="3.3.2 配置元素"></a>3.3.2 配置元素</h3><ul>
<li><p>在<code>&lt;aop:config&gt;</code>元素内可以声明一个或多个通知器、切面或者切点；</p>
</li>
<li><p>在<code>&lt;aop:aspect&gt;</code>元素内可以声明一个简单的切面，<code>ref</code>属性引用了一个Bean，该Bean提供了在切面上通知所调用的方法；</p>
</li>
<li><p><code>&lt;aop:before&gt;</code>等元素分别定义不同的通知类型，<code>pointcut</code>属性定义了通知所应用的切点，<code>method</code>属性定义了切面上所调用的方法名，<code>arg-names</code>属性定义了所调用方法的入参；</p>
</li>
<li><p>如果有多个通知的<code>pointcut</code>属性值是一致的，那么可以通过以下配置方式来避免重复定义切点，其中，<code>&lt;aop-pointcut</code>元素中的<code>expression</code>属性定义了通知所应用的切点；</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">aop:config</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">aop:aspect</span> <span class="attr">ref</span> = <span class="string">&quot;...&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">aop:pointcut</span> <span class="attr">id</span> = <span class="string">&quot;xxx&quot;</span> <span class="attr">expression</span> = <span class="string">&quot;...&quot;</span> /&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">aop:before</span> <span class="attr">pointcut-ref</span> = <span class="string">&quot;xxx&quot;</span> <span class="attr">method</span> = <span class="string">&quot;...&quot;</span> <span class="attr">arg-names</span> = <span class="string">&quot;...&quot;</span> /&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">aop:after</span> <span class="attr">pointcut-ref</span> = <span class="string">&quot;xxx&quot;</span> <span class="attr">method</span> = <span class="string">&quot;...&quot;</span> <span class="attr">arg-names</span> = <span class="string">&quot;...&quot;</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">aop:aspect</span>&gt;</span>                </span><br><span class="line"><span class="tag">&lt;/<span class="name">aop:config</span>&gt;</span></span><br></pre></td></tr></table></figure></li>
<li><p><code>&lt;aop:before&gt;</code>等元素的<code>pointcut</code>属性以及<code>&lt;aop-pointcut</code>元素的<code>expression</code>属性的值是一个AspectJ切点表达式。</p>
</li>
</ul>
<h3 id="3-3-3-切点表达式"><a href="#3-3-3-切点表达式" class="headerlink" title="3.3.3 切点表达式"></a>3.3.3 切点表达式</h3><p>切点表达式指的是遵循特定语法结构的字符串，其作用是对符合语法格式的连接点进行通知。</p>
<p>在Spring AOP中，需要使用AspectJ的切点表达式来定义通知所引用的切点，比如表达式<code>execution(*A.B(..))</code>代表：</p>
<ul>
<li><p>使用<code>execution()</code>指示器来唯一选择<code>A</code>类（全限定类名）的<code>B</code>方法；</p>
</li>
<li><p>方法表达式以<code>*</code>开始，标识不关心方法的返回值类型；</p>
</li>
<li><p>方法参数列表为<code>(..)</code>，标识不关心方法的入参类型。</p>
</li>
</ul>
<p>需要注意的是：</p>
<ul>
<li><p>Spring仅支持AspectJ切点指示器的一个子集，<code>execution()</code>指示器就属于该子集；</p>
</li>
<li><p>当在Spring中尝试使用AspectJ子集之外的其他指示器时，会抛出异常；</p>
</li>
<li><p><code>bean()</code>指示器使用Bean的ID作为参数来限制切点只匹配特定的Bean，该指示器是由Spring 2.5新引入的。</p>
</li>
</ul>
<p>Spring支持的AspectJ切点指示器如下</p>
<ul>
<li><p><code>arg()</code>：限制连接点匹配参数为指定类型的执行方法</p>
</li>
<li><p><code>@args()</code>：限制连接点匹配参数由指定注解标注的执行方法</p>
</li>
<li><p><code>execution()</code>：用于匹配是连接点的执行方法</p>
</li>
<li><p><code>this()</code>：限制连接点匹配AOP代理的Bean引用为指定类型的类</p>
</li>
<li><p><code>target()</code>：限制连接点匹配目标对象为指定类型的类</p>
</li>
<li><p><code>@target()</code>：限制连接点匹配特定的执行对象，这些对象对应的类要具备指定类型的注解</p>
</li>
<li><p><code>within()</code>：限制连接点匹配指定的类型</p>
</li>
<li><p><code>@within()</code>：限制连接点匹配指定注解所标注的类型（当使用Spring AOP时，方法定义在由指定注解所标注的类里）</p>
</li>
<li><p><code>@annotation</code>：限制匹配带有指定注解连接点</p>
</li>
</ul>
<h3 id="3-3-4-引入新功能"><a href="#3-3-4-引入新功能" class="headerlink" title="3.3.4 引入新功能"></a>3.3.4 引入新功能</h3><p>切面除了能够为现有的方法增加额外的功能，还能为现有的Spring Bean增加新的方法。</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">aop:config</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">aop:aspect</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">aop:declare-parents</span> </span></span><br><span class="line"><span class="tag">           	<span class="attr">types-matching</span> = <span class="string">&quot;&quot;</span> <span class="attr">implements-interface</span> = <span class="string">&quot;&quot;</span> <span class="attr">default-impl</span> = <span class="string">&quot;&quot;</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">aop:aspect</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">aop:config</span>&gt;</span></span><br></pre></td></tr></table></figure>

<ul>
<li><p><code>&lt;aop:declare-parents&gt;</code>声明了此切面所通知的Bean在它的对象层次结构会中拥有新的父类型;</p>
</li>
<li><p>在这些Bean中，由<code>types-matching</code>属性指定的类型会实现由<code>implements-interface</code>属性指定的接口；</p>
</li>
<li><p>具体的实现由<code>default-impl</code>属性来直接标识或者由<code>delegate-ref</code>属性来间接委托。</p>
</li>
</ul>
<h2 id="3-4-注解配置"><a href="#3-4-注解配置" class="headerlink" title="3.4 注解配置"></a>3.4 注解配置</h2><p>在上一节的XML配置中，定义了切面逻辑的简单Java类中并没有任何地方让它成为一个切面，因此，不得不使用XML声明通知和切点。但是通过<code>@Aspect</code>注解，可以在不需要额外XML配置的情况下将简单Java类转换为一个切面。</p>
<h3 id="3-4-1-使用步骤"><a href="#3-4-1-使用步骤" class="headerlink" title="3.4.1 使用步骤"></a>3.4.1 使用步骤</h3><p>1）通过Maven创建工程并引入<code>spring-aspects</code>依赖；</p>
<p>2）使用<code>@Aspect</code>标注编写定义了切面逻辑的简单Java类（下文简称为切面Bean）；</p>
<p>3）使用<code>@Pointcut</code>定义一个可以在<code>@AspectJ</code>切面内可重用的切点；</p>
<ul>
<li><p><code>@Pointcut</code>注解的值是一个AspectJ切点表达式；</p>
</li>
<li><p><code>@Pointcut</code>注解所标注的是一个空的标识方法，供<code>@Pointcut</code>注解依附；</p>
</li>
<li><p>标识方法的方法签名相当于切点的名字，供通知拦截器引用；</p>
</li>
</ul>
<p>4）使用<code>@Before</code>等通知拦截器注解在切面Bean中编写拦截器代码（即切面逻辑）；</p>
<p>5）给<code>@Configuration</code>标注的配置类加上<code>@EnableAspectJAutoProxy</code>注解，使得IoC容器自动查找<code>@Aspect</code>所标注的Bean，并根据每个方法的通知拦截器将AOP织入到特定的Bean中。</p>
<h3 id="3-4-2-通知拦截器"><a href="#3-4-2-通知拦截器" class="headerlink" title="3.4.2 通知拦截器"></a>3.4.2 通知拦截器</h3><ul>
<li><p><code>@Before</code>：先执行拦截器代码，再执行目标代码，如果拦截器抛出异常，目标代码不执行；</p>
</li>
<li><p><code>@After</code>：先执行目标代码，再执行拦截器代码，无论目标代码是否抛出异常，拦截器代码都会执行；</p>
</li>
<li><p><code>@AfterReturning</code>：和<code>@After</code>的区别在于，只有目标代码正常返回时才会执行拦截器代码；</p>
</li>
<li><p><code>@AfterThrowing</code>：和<code>@After</code>的区别在于，只有目标代码抛出异常时才会执行拦截器代码；</p>
</li>
<li><p><code>@Around</code>：能在目标代码执行前后均执行拦截器代码，即便目标代码抛出异常，依旧继续执行拦截器代码，能够实现以上全部拦截器的功能。</p>
</li>
</ul>
<h3 id="3-4-3-精准指定切点"><a href="#3-4-3-精准指定切点" class="headerlink" title="3.4.3 精准指定切点"></a>3.4.3 精准指定切点</h3><p>除了使用 AspectJ 切点表达式，还可以考虑通过注解来标注需要拦截的方法，从而精准指定需要在何处织入切面。比如使用<code>@Transactional</code>注解去标注需要拦截的业务方法，即可精准指定需要在何处织入事务处理切面，实现声明式事务。</p>
<p>除了<code>@Transactional</code>注解，还可以自定义注解来标注需要拦截的方法，此时切面 Bean 中的切点表达式只需写为 AspectJ 指示器（自定义注解）这样的形式，即可在业务代码中通过自定义注解来精准指定需要在何处织入切面。</p>
<h3 id="3-4-4-引入新功能"><a href="#3-4-4-引入新功能" class="headerlink" title="3.4.4 引入新功能"></a>3.4.4 引入新功能</h3><p>在上文介绍了如何使用基于 XML 的 AOP 来为现有的 Spring Bean 增加新的方法，这一功能依旧可以使用基于注解的 AOP 来完成。</p>
<ul>
<li><p><code>@DeclareParents</code>等价于<code>aop:declare-parents&gt;</code>；</p>
</li>
<li><p><code>@DeclareParents</code>的<code>value</code>属性等同于<code>aop:declare-parents&gt;</code>的<code>types-matching</code>属性，标识应该被引入指定接口的Bean的类型；</p>
</li>
<li><p><code>@DeclareParents</code>的<code>defaultImpl</code>属性等同于<code>aop:declare-parents&gt;</code>的<code>default-impl</code>属性，标识所引入接口的实现；</p>
</li>
<li><p>被<code>@DeclareParents</code>所标注的<code>static</code>属性指定了将被引入的接口；</p>
</li>
<li><p><code>@DeclareParents</code>没有与<code>aop:declare-parents&gt;</code>的<code>delegate-ref</code>属性等价的属性。</p>
</li>
</ul>
<h2 id="3-5-AOP-特性"><a href="#3-5-AOP-特性" class="headerlink" title="3.5 AOP 特性"></a>3.5 AOP 特性</h2><h3 id="3-5-1-CGLIB"><a href="#3-5-1-CGLIB" class="headerlink" title="3.5.1 CGLIB"></a>3.5.1 CGLIB</h3><p>Spring 的 AOP 是基于 JVM 的动态代理实现的，在代理对象中织入切面逻辑。如果要代理的对象实现了某个接口，那么 Spring AOP 会使用基于反射的 <strong>JDK Proxy</strong> 去创建代理对象，而对于没有实现接口的对象，Spring AOP 会使用基于字节码处理框架的 <strong>CGLIB</strong> 生成一个被代理对象的子类来作为代理。需要注意的地方在于：</p>
<ul>
<li><p>Spring 通过 CGLIB 实现代理时要求原始类是可扩展的（非<code>final</code>）；</p>
</li>
<li><p>Spring 通过 <strong>CGLIB 创建的代理类不会初始化继承自原始类的任何成员变量</strong>，包括<code>final</code>类型的成员变量，也就是说，CGLIB 所创建的代理所继承的成员变量的值始终为<code>null</code>，因此加 AOP 很可能会导致 NPE；</p>
</li>
<li><p>以上 NPE 问题的解决方式是业务类通过<code>getXXX</code>方法而不是直接获取<code>XXX</code>变量的值，那么CGLIB 创建的代理类会覆写<code>getXXX</code>方法，从而返回原始业务类的<code>XXX</code>变量的值；</p>
</li>
<li><p>Spring 通过 <strong>CGLIB 创建的代理类无法覆写继承自原始类的<code>final</code>方法</strong>，即无法代理<code>final</code>方法。</p>
</li>
</ul>
<p>因此，为了正确使用 AOP：</p>
<ul>
<li><p>在访问被注入的 Bean 的成员变量时，总是调用<code>getXXX</code>方法而非直接访问字段；</p>
</li>
<li><p>编写可能会被代理的 Bean 时，避免编写<code>public final</code>方法。</p>
</li>
</ul>
<h3 id="3-5-2-创建代理-Bean"><a href="#3-5-2-创建代理-Bean" class="headerlink" title="3.5.2 创建代理 Bean"></a>3.5.2 创建代理 Bean</h3><p>接 2.4.5 小节：</p>
<p>1）在<code>AbstractAutowireCapableBeanFactory</code>类的<code>initializeBean</code>方法中，会依次调用<code>applyBeanPostProcessorsAfterInitialization</code>方法 –&gt; <code>BeanPostProcessor</code>接口的<code>postProcessAfterInitialization</code>方法，<code>AbstractAutoProxyCreator</code>类提供了<code>postProcessAfterInitialization</code>方法的具体实现；</p>
<p>2）在<code>AbstractAutoProxyCreator</code>类的<code>postProcessAfterInitialization</code>方法中，完整代码如下</p>
<ul>
<li><p>以下代码的第 5 行，检查当前 Bean 对象是否已经暴露过了，只有没有暴露过的对象，才生成其代理对象；</p>
</li>
<li><p>以下代码的第 6 行，会依次调用<code>wrapIfNecessary</code>方法 –&gt; <code>createProxy</code>方法，从而创建代理对象；</p>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> Object <span class="title function_">postProcessAfterInitialization</span><span class="params">(<span class="meta">@Nullable</span> Object bean, String beanName)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (bean != <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="type">Object</span> <span class="variable">cacheKey</span> <span class="operator">=</span> getCacheKey(bean.getClass(), beanName);</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">this</span>.earlyProxyReferences.remove(cacheKey) != bean) &#123;</span><br><span class="line">            <span class="keyword">return</span> wrapIfNecessary(bean, beanName, cacheKey);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> bean;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>3）在<code>AbstractAutoProxyCreator</code>类的<code>createProxy</code>方法中，截取了部分代码如下</p>
<ul>
<li><p>以下代码的第 7 行，调用<code>ProxyFactory</code>类的构造方法生成代理工厂，后续会将创建代理的工作交给<code>proxyFactory</code>；</p>
</li>
<li><p>以下代码的第 17 行，调用<code>ProxyFactory</code>类的<code>getProxy</code>方法来创建代理；</p>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">protected</span> Object <span class="title function_">createProxy</span><span class="params">(Class&lt;?&gt; beanClass, <span class="meta">@Nullable</span> String beanName, <span class="meta">@Nullable</span> Object[] specificInterceptors, TargetSource targetSource)</span> &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">this</span>.beanFactory <span class="keyword">instanceof</span> ConfigurableListableBeanFactory) &#123;</span><br><span class="line">        AutoProxyUtils.exposeTargetClass((ConfigurableListableBeanFactory) <span class="built_in">this</span>.beanFactory, beanName, beanClass);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="type">ProxyFactory</span> <span class="variable">proxyFactory</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ProxyFactory</span>();</span><br><span class="line">    proxyFactory.copyFrom(<span class="built_in">this</span>);</span><br><span class="line">    </span><br><span class="line">    ...</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// Use original ClassLoader if bean class not locally loaded in overriding class loader</span></span><br><span class="line">    <span class="type">ClassLoader</span> <span class="variable">classLoader</span> <span class="operator">=</span> getProxyClassLoader();</span><br><span class="line">    <span class="keyword">if</span> (classLoader <span class="keyword">instanceof</span> SmartClassLoader &amp;&amp; classLoader != beanClass.getClassLoader()) &#123;</span><br><span class="line">        classLoader = ((SmartClassLoader) classLoader).getOriginalClassLoader();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> proxyFactory.getProxy(classLoader);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>4）在<code>ProxyFactory</code>类的<code>getProxy</code>方法中，完整代码如下</p>
<ul>
<li><p>首先会依次调用<code>ProxyCreatorSupport</code>类的<code>createAopProxy</code>方法 –&gt; <code>getAopProxyFactory</code>方法 –&gt; <code>DefaultAopProxyFactory</code>类的<code>createAopProxy</code>方法，得到<code>AopProxy</code>类对象；</p>
</li>
<li><p>接着调用<code>AopProxy</code>类对象的<code>getProxy</code>方法得到代理类对象；</p>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> Object <span class="title function_">getProxy</span><span class="params">(<span class="meta">@Nullable</span> ClassLoader classLoader)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> createAopProxy().getProxy(classLoader);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>5）在 <code>DefaultAopProxyFactory</code>类的<code>createAopProxy</code>方法中，会判断创建代理对象时是使用 JDK 代理，还是使用 CGLIB，完整代码如下</p>
<ul>
<li><p>设置<code>proxyTargetClass=true</code>会强制使用 CGLIB；</p>
</li>
<li><p>没有设置参数并且对象类实现了接口则默认使用 JDK 代理；</p>
</li>
<li><p>没有设置参数并且对象类没有实现接口则也必须使用 CGLIB；</p>
</li>
<li><p>以<code>ObjenesisCglibAopProxy</code>类为例，它继承了父类<code>CglibAopProxy</code>的<code>getProxy</code>方法；</p>
</li>
<li><p>在<code>CglibAopProxy</code>类的<code>getProxy</code>方法中，最终会通过调用<code>createProxyClassAndInstance</code>方法来创建代理类，并生成一个代理类的实例。</p>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> AopProxy <span class="title function_">createAopProxy</span><span class="params">(AdvisedSupport config)</span> <span class="keyword">throws</span> AopConfigException &#123;</span><br><span class="line">    <span class="keyword">if</span> (!NativeDetector.inNativeImage() &amp;&amp; (config.isOptimize() || config.isProxyTargetClass() || hasNoUserSuppliedProxyInterfaces(config))) &#123;</span><br><span class="line">        Class&lt;?&gt; targetClass = config.getTargetClass();</span><br><span class="line">        <span class="keyword">if</span> (targetClass == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">AopConfigException</span>(<span class="string">&quot;TargetSource cannot determine target class: &quot;</span> + <span class="string">&quot;Either an interface or a target is required for proxy creation.&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (targetClass.isInterface() || Proxy.isProxyClass(targetClass) || ClassUtils.isLambdaClass(targetClass)) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">JdkDynamicAopProxy</span>(config);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">ObjenesisCglibAopProxy</span>(config);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">JdkDynamicAopProxy</span>(config);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h1 id="4、MVC"><a href="#4、MVC" class="headerlink" title="4、MVC"></a>4、MVC</h1><h2 id="4-1-问题与解决"><a href="#4-1-问题与解决" class="headerlink" title="4.1 问题与解决"></a>4.1 问题与解决</h2><p>由于 HTTP 协议的无状态性，基于 Web 的应用程序在状态管理、工作流等问题上面临着重大挑战，Spring MVC 就是为了解决这些问题而设计的。</p>
<p>Spring MVC 基于模型-视图-控制器（Model-View-Controller, MVC）模式实现，核心思想在于将业务逻辑、数据表示、数据显示都分离，有助于构建灵活、松耦合的 Web 应用程序。</p>
<p>整个 MVC 相当于三层架构中的 UI 表现层，通过 MVC 对 UI 层又进一步进行了分层，三者职责明确，且开发更简单</p>
<ul>
<li><p>Model 可以是一个 JavaBean，也可以是一个包含多个 JavaBean 的 Map，表示应用程序的核心业务逻辑和数据，用于处理数据的输入、输出、更新和存储等操作，只关注数据本身以及对数据的操作，而不关心数据的显示以及和用户的交互方式；</p>
</li>
<li><p>View 表示应用程序的用户界面，只负责把 Model 给“渲染”出来，显示出 Model 中的数据，可以与用户进行交互，只关心数据呈现以及与用户的交互，而不关心数据的处理或存储方式；</p>
</li>
<li><p>Controller 表示应用程序的处理逻辑，将用户的输入转化为对 Model 的操作，会调用业务处理方法并将得到的 Model 返回给 View，Controller 中尽量不放业务逻辑代码，实现了 View 和 Model 之间的解耦。</p>
</li>
</ul>
<h2 id="4-2-请求的生命周期"><a href="#4-2-请求的生命周期" class="headerlink" title="4.2 请求的生命周期"></a>4.2 请求的生命周期</h2><p>每当用户在 Web 浏览器中点击链接或者提交表单的时候，一个 Request 就开始工作了：</p>
<p>1）Request 首先会到达<code>DispatcherServlet</code>（前端控制器 Servlet，继承自<code>HttpServlet</code>）；</p>
<ul>
<li><p><code>DispatcherServlet</code>会查询一个或者多个<code>Handler mapping</code>（处理器映射）；</p>
</li>
<li><p><code>Handler mapping</code>根据 Request 所携带的 URL 信息来进行决策；</p>
</li>
<li><p><code>DispatcherServlet</code>根据查询结果来确定应该将 Request 委托给哪一个<code>Controller</code>（控制器）；</p>
</li>
</ul>
<p>2）Request 到达<code>Controller</code>后会卸下其负载（用户提交的信息）并等待<code>Controller</code>完成逻辑处理；</p>
<ul>
<li><p>设计良好的<code>Controller</code>本身几乎不处理工作，而是将业务逻辑委托给一个或多个服务对象；</p>
</li>
<li><p>在逻辑处理完成后，会产生一些信息，这些信息被称为 <strong>Model（模型）</strong>；</p>
</li>
<li><p>Model 需要被发送给一个 <strong>View（视图）</strong>，即以用户友好的方式进行格式化，一般是 HTML；</p>
</li>
<li><p><code>Controller</code>将 Model 数据打包，标示出用于渲染输出的 View 名称；</p>
</li>
<li><p><code>Controller</code>不会与特定的 View 相耦合；</p>
</li>
</ul>
<p>3）Request、Model 和 View 名称被<code>Controller</code>发送回<code>DispatcherServlet</code>；</p>
<ul>
<li><p>传递给<code>DispatcherServlet</code>的 View 名称仅仅是一个逻辑名，并不直接表示某个特定的 View；</p>
</li>
<li><p><code>DispatcherServlet</code>使用 ViewResolve（视图解析器）来为 View 的逻辑名称添加前后缀，然后查找一个特定的 View 实现模板；</p>
</li>
</ul>
<p>4）Request 的最后一站是 View 的实现模板，在这里 Request 交付 Model 数据，Request 的任务就完成了；</p>
<ul>
<li>View 模板通常是 JSP（JavaServer Page），但其他的 View 技术也可以使用；</li>
<li>View 模板通过 Model 数据会渲染输出一个 View，通过这个 View 将 Response 传递给客户端；</li>
</ul>
<p>至此，就完成了从 Request 离开浏览器到获取 Response 返回浏览器的过程。</p>
<h2 id="4-3-搭建步骤"><a href="#4-3-搭建步骤" class="headerlink" title="4.3 搭建步骤"></a>4.3 搭建步骤</h2><p>1）在web.xml文件中配置<code>DispatcherServlet</code>；</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">servlet</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">servlet-name</span>&gt;</span>spitter<span class="tag">&lt;/<span class="name">servlet-name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">servlet-class</span>&gt;</span></span><br><span class="line">        org.springframework.web.servlet.DispatcherServlet</span><br><span class="line">    <span class="tag">&lt;/<span class="name">servlet-class</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">load-on-startup</span>&gt;</span>1<span class="tag">&lt;/<span class="name">load-on-startup</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">servlet</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">servlet-mapping</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">servlet-name</span>&gt;</span>spitter<span class="tag">&lt;/<span class="name">servlet-name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">url-pattern</span>&gt;</span>/<span class="tag">&lt;/<span class="name">url-pattern</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">servlet-mapping</span>&gt;</span></span><br></pre></td></tr></table></figure>

<ul>
<li><p>由于<code>servlet-name</code>元素被配置为<code>spitter</code>，<code>DispatcherServlet</code>在加载时会从一个名为<code>spitter-servlet.xml</code>的文件来加载应用上下文；</p>
</li>
<li><p><code>servlet-mapping</code>元素的<code>url-pattern</code>属性将<code>DispatcherServlet</code>映射到<code>/</code>，声明了它会作为默认的servlet并且会处理所有的请求，包括对静态资源的请求；</p>
</li>
</ul>
<p>2）编写<code>spitter-servlet.xml</code>文件并配置注解驱动；</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">mvc:resources</span> <span class="attr">mapping</span> = <span class="string">&quot;/resources/**&quot;</span> <span class="attr">location</span> = <span class="string">&quot;/resources/&quot;</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">mvc:annotation-driven</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">context:component-scan</span> <span class="attr">base-package</span> = <span class="string">&quot;...&quot;</span> /&gt;</span></span><br></pre></td></tr></table></figure>

<ul>
<li><p><code>&lt;mvc:resources&gt;</code>元素建立了一个服务于静态资源的处理器，此时，所有的静态资源都必须放置在应用程序的/resources目录下；</p>
</li>
<li><p><code>&lt;mvc:annotation-driven/&gt;</code>标签与<code>DispatcherServlet</code>提供的处理器映射（<code>DefaultAnnotationHandlerMapping</code>）相结合就能实现基于注解的控制器类；</p>
</li>
<li><p>Spring也提供了其他类型的处理器映射，只需在Spring中配置该处理器映射Bean即可使用；</p>
</li>
<li><p><code>&lt;context:component-scan&gt;</code>元素将查找所有的控制器类并将其注册为Bean；</p>
</li>
</ul>
<p>3）编写首页控制器以及面向Spitter和Spittle的控制器，应当为应用程序所提供的每一种资源（而不是为每个用例）编写一个单独的控制器；</p>
<p>4）在<code>spitter-servlet.xml</code>文件中配置视图解析器</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span> = <span class="string">&quot;org.springframework.web.servlet.view.InternalResourceViewResolver&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span> = <span class="string">&quot;viewClass&quot;</span> </span></span><br><span class="line"><span class="tag">              <span class="attr">value</span> = <span class="string">&quot;org.springframework.web.servlet.view.JstlView&quot;</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span> = <span class="string">&quot;prefix&quot;</span> <span class="attr">value</span> = <span class="string">&quot;/WEB-INF/views/&quot;</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span> = <span class="string">&quot;suffix&quot;</span> <span class="attr">value</span> = <span class="string">&quot;.jsp&quot;</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure>

<ul>
<li><p>视图解析器<code>InternalResourceViewResolver</code>将View的逻辑名称与JSP（JavaServer Page）相匹配；</p>
</li>
<li><p><code>InternalResourceViewResolver</code>将View的逻辑名称添加前后缀得到View路径，并解析为View对象；</p>
</li>
<li><p>View对象将渲染的任务委托给视图模板，即将Request传递给JSP；</p>
</li>
<li><p>如果需要使用其他的视图解析器，同样需要在<code>spitter-servlet.xml</code>文件中将该视图解析器注册为一个<code>&lt;bean&gt;</code>；</p>
</li>
</ul>
<p>5）定义JSP视图并完成Spring应用上下文；</p>
<ul>
<li><p>Web层的配置都放在<code>spitter-servlet.xml</code>的文件中，这个文件会被<code>DispatcherServlet</code>加载，但还需要加载其他的配置文件；</p>
</li>
<li><p>通过使用<code>ContextLoaderListener</code>，能够加载其他的配置文件到一个Spring应用上下文中。</p>
</li>
</ul>
<h2 id="4-4-REST-功能"><a href="#4-4-REST-功能" class="headerlink" title="4.4 REST 功能"></a>4.4 REST 功能</h2><p>以信息为中心的表述性状态转移（Representational State Transfer, REST）已成为替换传统 SOAP Web 服务的流行方案，REST 就是将资源的状态以最合适的形式从服务器端转移到客户端（或者反之），RESTful 交互是同步的。</p>
<ul>
<li>表述性（Representational）：REST 资源可以用各种形式来进行表述，比如 XML、JSON 以及 HTML；</li>
<li>状态（State）：使用 REST 时，我们更关注资源的状态而不是对资源采取的行为，所有的资源都可以通过 URI 定位，而且这个定位与其他资源无关，也不会因为其他资源的变化而变化；</li>
<li>转移（Transfer）：REST 涉及转移资源数据，它以某一种表述形式从一个应用转移到另一个应用</li>
</ul>
<p>Spring 对 REST 的支持是构建在 Spring MVC 之上的，控制器可以处理所有的 HTTP 方法，包含四个主要的 REST 方法：GET、PUT、DELETE 以及 POST，分别对应对资源的检索、更新、删除和创建。通过适当设置<code>@RequestMapping</code>注解的<code>method</code>属性，就可以让<code>DispatcherServlet</code>把不同的HTTP方法的请求定向到特定的控制器方法上。</p>
<p>RESTful Web 服务与传统的 MVC 开发一个关键区别是返回给客户端的内容的创建方式：<strong>传统的 MVC 模式开发会直接返回给客户端一个视图，但是 RESTful Web 服务一般会将返回的数据以 JSON 的形式返回，实现前后端分离开发。</strong></p>
<p>可处理的 HTTP 方法具体介绍如下：</p>
<ul>
<li><p>GET</p>
<ul>
<li><p>可只直接使用<code>@GetMapping</code>注解；</p>
</li>
<li><p>是最常用的方法，可用于获取资源；</p>
</li>
<li><p>在浏览器中可以回退，请求会被浏览器主动缓存；</p>
</li>
<li><p>只能进行URL编码，只接收ASCII字符；</p>
</li>
<li><p>参数直接暴露在URL上，安全性较低，不能用于传递敏感信息。</p>
</li>
</ul>
</li>
<li><p>POST</p>
<ul>
<li><p>可只直接使用<code>@PostMapping</code>注解；</p>
</li>
<li><p>如果需要添加对象，可使用POST方法传递一个Model 对象；</p>
</li>
<li><p>访问同一地址时也需要再次提交请求，浏览器不会缓存请求；</p>
</li>
<li><p>除了URL，还支持多种编码方式；</p>
</li>
<li><p>参数可以放在request body 中，也可以通过URL传递。</p>
</li>
</ul>
</li>
<li><p>PUT</p>
<ul>
<li><p>可只直接使用<code>@PutMapping</code>注解；</p>
</li>
<li><p>如果对象需要更新，可使用PUT方法去发送请求。</p>
</li>
</ul>
</li>
<li><p>PATCH</p>
<ul>
<li><p>是一个新引入的方法，是对PUT方法的补充；</p>
</li>
<li><p>用来对己知资源进行局部更新，比如一个对象的部分数据而非整个对象数据。</p>
</li>
</ul>
</li>
<li><p>DELETE</p>
<ul>
<li><p>可只直接使用<code>@DeleteMapping</code>注解；</p>
</li>
<li><p>在执行前先查询是否有数据；</p>
</li>
<li><p>由于返回的是<code>void</code> 类型，要注意判断是否成功，可通过存储过程返回值来判断。</p>
</li>
</ul>
</li>
<li><p>OPTIONS</p>
<ul>
<li><p>用于获取当前URL所支持的方法；</p>
</li>
<li><p>返回的响应消患会在HTTP 头中包含“Allow”的信息，其值是所支持的方法， 如GET。</p>
</li>
</ul>
</li>
<li><p>HEAD</p>
<ul>
<li>代表发送HTTP 头消息，GET其实也带了HTTP 头消息。</li>
</ul>
</li>
<li><p>TRACE</p>
<ul>
<li>用于显示服务器收到的请求，从而进行测试或诊断。</li>
</ul>
</li>
</ul>
<h2 id="4-5-相关组件"><a href="#4-5-相关组件" class="headerlink" title="4.5 相关组件"></a>4.5 相关组件</h2><h3 id="4-5-1-控制器"><a href="#4-5-1-控制器" class="headerlink" title="4.5.1 控制器"></a>4.5.1 控制器</h3><ul>
<li><p><code>@Controller</code></p>
<ul>
<li>用于类，表明该类是MVC的控制器。</li>
</ul>
</li>
<li><p><code>@RequestBody</code></p>
<ul>
<li><p>用于请求方法参数；</p>
</li>
<li><p>可以将请求中的(JSON/XML）字符串绑走到相应的 Bean 上，也可以将其分别绑定到对应的字符串上。</p>
</li>
</ul>
</li>
<li><p><code>@ResponseBody</code></p>
<ul>
<li><p>用于方法；</p>
</li>
<li><p>将请求方法返回的对象转换为指定格式（JSON/XML）后，再写入<code>Response</code>对象的<code>body</code>数据区。</p>
</li>
</ul>
</li>
<li><p><code>@RestController</code></p>
<ul>
<li><p>是Spring 4.0之后才有的注解；</p>
</li>
<li><p>是<code>@Controller</code>和<code>@ResponseBody</code>的结合；</p>
</li>
<li><p>用于标注REST风格的控制器；</p>
</li>
<li><p>告诉Spring将结果字符串直接呈现给调用者。</p>
</li>
</ul>
</li>
<li><p><code>@RequestMapping</code></p>
<ul>
<li><p>提供了“路由”信息，告诉Spring任何带有/路径的HTTP请求都应该映射到home方法；</p>
</li>
<li><p>用于类时，定义了这个控制器所处理的根URL路径；</p>
</li>
<li><p>用于方法时，表明该方法是一个请求处理方法，要处理指定URL下的请求；</p>
</li>
<li><p>请求处理方法的签名可以将任何事物作为入参；</p>
</li>
<li><p><code>value</code>属性用于指定请求的地址；</p>
</li>
<li><p><code>method</code>属性用于指定请求的类型（GET、HEAD、POST、PUT、PATCH、DELETE、OPTIONS、TRACE）；</p>
</li>
<li><p><code>consumes</code>属性用于指定请求的内容类型；</p>
</li>
<li><p><code>produces</code>属性用于指定返回的内容类型；</p>
</li>
<li><p><code>params</code>属性用于指定请求中必须包含的参数值；</p>
</li>
<li><p><code>headers</code>属性用于指定请求中必须包含的header值。</p>
</li>
</ul>
</li>
<li><p><code>@RequestParam</code></p>
<ul>
<li>用于请求方法参数，当查询参数与方法参数名不匹配时，可以通过该注解将两者绑定。</li>
</ul>
</li>
<li><p><code>@PathVariable</code></p>
<ul>
<li>用于请求方法参数，将请求中的变量映射到请求处理方法的参数上。</li>
</ul>
</li>
</ul>
<h3 id="4-5-2-Servlet"><a href="#4-5-2-Servlet" class="headerlink" title="4.5.2 Servlet"></a>4.5.2 Servlet</h3><p>Servlet 是<code>javax.servlet</code>包中定义的一个接口，除了Controller以外，有时也需要使用Servlet来实现拦截和监昕功能。</p>
<ul>
<li><p><code>@WebServlet(urlPattern = &quot;&quot;)</code></p>
<ul>
<li><p>用于注册Servlet实现类；</p>
</li>
<li><p>使得<code>DispatcherServlet</code>核心控制器知道它的作用，以及处理请求<code>urlpattern</code>。</p>
</li>
</ul>
</li>
<li><p><code>＠ServletComponentScan</code></p>
<ul>
<li><p>用于启动类；</p>
</li>
<li><p>以扫描注册指定包内的所有Servlet、Filter以及监听器。</p>
</li>
</ul>
</li>
<li><p><code>HttpServlet</code></p>
<ul>
<li><p>Servlet抽象类；</p>
</li>
<li><p>自定义的Servlet需要继承<code>HttpServlet</code>，并重写<code>doGet</code>方法。</p>
</li>
</ul>
</li>
</ul>
<h3 id="4-5-3-过滤器"><a href="#4-5-3-过滤器" class="headerlink" title="4.5.3 过滤器"></a>4.5.3 过滤器</h3><p>对于多个页面都需要进行的例如参数校验等功能，可以通过过滤器来实现，从而避免重复代码。定义一个过滤器应当：</p>
<ul>
<li><p>实现<code>Filter</code>接口；</p>
</li>
<li><p>实现<code>init</code>、<code>doFilter</code>、<code>destory</code>方法；</p>
</li>
<li><p>使用<code>@WebFilter(urlPatterns = &quot;&quot;)</code>注解标注；</p>
</li>
<li><p>使用<code>＠ServletComponentScan</code>注解标注启动类。</p>
</li>
</ul>
<h3 id="4-5-4-监听器"><a href="#4-5-4-监听器" class="headerlink" title="4.5.4 监听器"></a>4.5.4 监听器</h3><p>监听器用于监听Web应用程序中某些对象或信息的创建、销毁、增加、修改、删除等动作，然后做出相应的响应处理。当对象的状态发生变化时，服务器自动调用监听器的方法。具体应用有统计在线用户人数、在结用户、系统加载时的信息初始化等。</p>
<p>Servlet 中的监听器分为以下类型：</p>
<ul>
<li><p>监听<code>ServletContext</code>、<code>Request</code>、<code>Session</code>作用域的创建和销毁；</p>
<ul>
<li><p><code>ServletContextListener</code>；</p>
</li>
<li><p><code>HttpSessionListener</code>；</p>
</li>
<li><p><code>ServletRequestListener</code>；</p>
</li>
</ul>
</li>
<li><p>监听<code>ServletContext</code>、<code>Request</code>、<code>Session</code>作用域中属性的变化（增加、修改、删除）；</p>
<ul>
<li><p><code>ServletContextAttributeListener</code>；</p>
</li>
<li><p><code>HttpSessionAttributeListener</code>；</p>
</li>
<li><p><code>ServletRequestAttributeListener</code>；</p>
</li>
</ul>
</li>
<li><p>监听<code>HttpSession</code>作用域中对象状态的改变（被绑定、解除绑走、钝化、活化）；</p>
<ul>
<li><p><code>HttpSessionBindingListener</code>；</p>
</li>
<li><p><code>HttpSessionActivationListener</code>；</p>
</li>
</ul>
</li>
</ul>
<p>定义一个监听器应当：</p>
<ul>
<li><p>实现上述任意类型的监听器接口；</p>
</li>
<li><p>实现监听器接口中对应的方法；</p>
</li>
<li><p>使用<code>@WebListener</code>注解标注；</p>
</li>
<li><p>使用<code>＠ServletComponentScan</code>注解标注启动类。</p>
</li>
</ul>
<h3 id="4-5-5-异常"><a href="#4-5-5-异常" class="headerlink" title="4.5.5 异常"></a>4.5.5 异常</h3><p>Spring 提供的异常处理方案是利用切面技术实现的，会将异常处理切面织入到目标控制器中。</p>
<ul>
<li><p>异常类一般需要包含以下信息：</p>
<ul>
<li>唯一标示异常的 code；</li>
<li>HTTP状态码；</li>
<li>错误路径；</li>
<li>发生错误的时间戳；</li>
<li>错误的具体信息。</li>
</ul>
</li>
<li><p><code>RuntimeException</code></p>
<ul>
<li><p>一般处理的异常都是<code>RuntimeException</code>；</p>
</li>
<li><p>可以通过继承<code>RuntimeException</code>或新建<code>ResponseStatusException</code>（通过构造器来注入属性值）来定义自己的异常类型。</p>
</li>
</ul>
</li>
<li><p><code>@ControllerAdvice</code>或<code>@RestControllerAdvice</code></p>
<ul>
<li><p>可以用于定义异常处理类，默认对所有的<code>Controller</code>都有效；</p>
</li>
<li><p><code>@ControllerAdvice(annotations = &#123;RestController.class&#125;)</code>可以指定特定的注解，使得异常处理类只处理特定注解所标记的类抛出的异常；</p>
</li>
<li><p><code>@ControllerAdvice(&quot;&quot;)</code>可以指定特定的包名，使得异常处理类只处理特定包内抛出的异常；</p>
</li>
<li><p><code>@ControllerAdvice(assignableTypes = &#123;ExceptionController.class&#125;)</code>可以指定特定的<code>Controller</code>，使得异常处理类只处理特定<code>Controller</code>抛出的异常。</p>
</li>
</ul>
</li>
<li><p><code>@ExceptionHandler</code></p>
<ul>
<li><p>可以用于定义异常处理方法，可以拦截控制器中发生的异常；</p>
</li>
<li><p><code>@ExceptionHandler(value = XXXException.class)</code>可以指定特定的异常类型，使得异常处理方法只处理特定的异常类型。</p>
</li>
</ul>
</li>
</ul>
<h3 id="4-5-6-HTTP-客户端"><a href="#4-5-6-HTTP-客户端" class="headerlink" title="4.5.6 HTTP 客户端"></a>4.5.6 HTTP 客户端</h3><p>Spring 6.0 中内置 HTTP 客户端，使用<code>@HttpExchange</code>标注的服务接口被视为 HTTP 端点，可以调用得到指定路径的 HTTP 接口返回。</p>
<h1 id="5、ORM"><a href="#5、ORM" class="headerlink" title="5、ORM"></a>5、ORM</h1><h2 id="5-1-问题与解决"><a href="#5-1-问题与解决" class="headerlink" title="5.1 问题与解决"></a>5.1 问题与解决</h2><p>业务实体在内存中表现为对象，在数据库中表现为关系型数据。内存中的对象不会被永久保存，只有关系型数据库（或 NoSQL 数据库，或文件）中的对象会被永久保存。ORM（Object Relation Mapping）指对象关系映射，对数据库中的表和内存中的对象建立了映射关系，是连接数据库的桥梁，用于将程序中的数据对象自动持久化到关系数据库中。</p>
<ul>
<li><p>ORM 在一个地方定义数据模型，更容易更新和维护，ORM 框架一般以中间件的形式存在，目前比较常用的 ORM 有 Hibernate、JPA、MyBatis 等，可以非常方便自动地完成数据消毒、预处理、事务等</p>
</li>
<li><p>基于 ORM 的业务代码比较简答，代码量少，语义性好，容易理解，开发者不必编写冗杂甚至性能不佳的 SQL，还会迫使应用程序使用 MVC 架构，ORM 就是天然的 Model，这都使得代码更加清晰</p>
</li>
<li><p>ORM 并不是轻量级工具，需要花费一定的学习成本和配置</p>
</li>
<li><p>对于复杂的查询，ORM 要么是无法表达，要不是性能不如原生的 SQL</p>
</li>
<li><p>ORM 抽象掉了数据库层，开发者无法了解底层的数据库操作，也无法定制一些特殊的 SQL</p>
</li>
</ul>
<p>数据源是对数据库连接、连接中的事务操作以及事务提交或回滚的抽象，负责和实体数据库的连接，是被第三方数据库实现的（一般不会使用 ORM 框架自带的数据库连接）。Java 中的数据源被定义<code>DataSource</code>，<code>DataSource</code>接口由驱动程序供应商实现，作为<code>DriverManager</code>的替代，<code>DataSource</code>是获取连接的首选方式，数据库连接有以下实现方式</p>
<ul>
<li><p>基本实现，标准连接对象</p>
</li>
<li><p>连接池实现，该连接对象将自动参与连接池，与中间层连接池管理器一起工作</p>
</li>
<li><p>分布式事务实现，该连接对象可以用于分布式事务，并且几乎总是参与连接池</p>
</li>
</ul>
<h2 id="5-2-Hibernate"><a href="#5-2-Hibernate" class="headerlink" title="5.2 Hibernate"></a>5.2 Hibernate</h2><p>Hibernate 是强大、方便、全自动的 ORM 框架，开发者只需要定义好数据库的表字段和 Java POJO 的映射关系和规则即可，Hibernate 会开放出接口自动处理数据库表的 CURD，并按照规定好的规则映射到 POJO 中，这个过程中操作者完全不需要感知 SQL 逻辑，此外，Hibernate 的缓存系统会在出现脏数据时及时报错。Hibernate 适用于性能要求不太严苛的系统。</p>
<h2 id="5-3-MyBatis"><a href="#5-3-MyBatis" class="headerlink" title="5.3 MyBatis"></a>5.3 MyBatis</h2><p><a target="_blank" rel="noopener" href="https://mybatis.org/mybatis-3/zh/index.html">MyBatis</a> 是一个小巧、简单、半自动化的 ORM 框架，可以使用简单的 XML 或注解来配置和映射原生信息，将接口和 Java 的 POJO 映射成数据库中的记录，免除了几乎所有的 JDBC 代码以及设置参数和获取结果集的工作（MyBatis3 提供的注解可以取代 XML），开发灵活性好，但开发者依旧需要自己编写 SQL 逻辑，这也意味可以定制动态 SQL，这是 Hibernate 所不具备的。MyBatis 适用于性能要求高、响应快、灵活的系统。</p>
<h3 id="5-3-1-动态参数"><a href="#5-3-1-动态参数" class="headerlink" title="5.3.1 动态参数"></a>5.3.1 动态参数</h3><p>在 MyBatis 的 mapper 文件中，可以使用<code>#&#123;&#125;</code>和<code>$&#123;&#125;</code>来作为动态参数的替换，<code>#&#123;&#125;</code>和<code>$&#123;&#125;</code>在预编译处理中是不一样的</p>
<ul>
<li><p>MyBatis 将<code>#&#123;&#125;</code>方式传入的参数当做字符串，在预处理节点会使用<code>?</code>替换，可以有效的避免 SQL 注入，能使用<code>#&#123;&#125;</code>的地方应尽量使用<code>#&#123;&#125;</code></p>
</li>
<li><p>MyBatis 不会对<code>$&#123;&#125;</code>方式传入的参数进行特殊处理，会直接将参数的值替换到 SQL 中，而不会进行参数值的安全转义或预处理，在一些情况下（比如动态传入排序列名，排序方式）无法使用<code>#&#123;&#125;</code>，只能使用<code>$&#123;&#125;</code></p>
</li>
<li><p>使用<code>$&#123;&#125;</code>时要注意会出现潜在的 SQL 注入问题，需要在应用程序中对输入参数进行严格的验证，确保输入符合预期格式</p>
</li>
</ul>
<p>此外，MyBatis 还提供了很多标签来支持动态 SQL 的生成，可以避免在编写 SQL 时出现重复的代码，提供代码的复用性和灵活性。</p>
<h3 id="5-3-2-缓存机制"><a href="#5-3-2-缓存机制" class="headerlink" title="5.3.2 缓存机制"></a>5.3.2 缓存机制</h3><p>SqlSession 是 MyBatis 对 SQL 执行的封装，真正的 SQL 处理逻辑要通过<code>Executor</code>来执行，MyBatis 在执行 SQL 查询时默认使用的<code>Executor</code>实现类是<code>CachingExecutor</code>类（这就是二级缓存）来检查缓存是否存在，如果没有命中缓存则会进入<code>BaseExecutor</code>（一级缓存）中继续执行，如果一级缓存没有命中的话，则通过数据源获取数据库连接，并调用 JDBC 执行真正的 SQL 逻辑，当获取到查询结果之后，就需要通过字段映射将每一行结果都分别封装为一个 Java 对象。</p>
<ul>
<li><p>一级缓存</p>
<ul>
<li><p>在同一个 session 中，MyBatis 会将执行过的 SQL 语句的结果缓存到内存中，下次再执行相同的 SQL 语句时，会先查看缓存中是否存在该结果，如果存在则直接返回缓存中的结果，不再执行 SQL 语句，这种一级缓存是默认开启的</p>
</li>
<li><p>一级缓存只是没有容量限定的<code>HashMap</code>，一级缓存最大范围是 SqlSession，有多个 SqlSession 或分布式环境下，范围为 SqlSession 的一级缓存会出现脏数据，建议设定缓存级别为 Statement</p>
</li>
</ul>
</li>
<li><p>二级缓存</p>
<ul>
<li><p>二级缓存是基于命名空间的缓存，可以在多个 SqlSession 之间共享缓存，但是可能会出现缓存数据更新不及时进而导致数据一致性问题</p>
</li>
<li><p>一般不使用 MyBatis 的二级缓存，而是直接使用第三方的缓存，实现更加精细灵活的缓存策略</p>
</li>
</ul>
</li>
</ul>
<h3 id="5-3-3-字段映射"><a href="#5-3-3-字段映射" class="headerlink" title="5.3.3 字段映射"></a>5.3.3 字段映射</h3><p>MyBatis 实现字段映射的代码主要在<code>ResultSetHandler</code>类中，该类是 MyBatis 查询结果集处理的核心类，负责将 JDBC ResultSet 对象转换成 Java 对象，并进行字段映射，步骤如下</p>
<ul>
<li><p>MyBatis 通过 JDBC API 向数据库发送 SQL 查询语句，并获得查询结果集</p>
</li>
<li><p>查询结果集中的每一行数据都被封装成一个 ResultSet 对象，MyBatis 遍历 ResultSet 对象中的数据</p>
</li>
<li><p>对于每一行数据，MyBatis 根据 Java 对象属性名和查询结果集中的列名进行匹配，将匹配成功的列数据映射到 Java 对象相应属性中</p>
</li>
<li><p>如果 Java 属性名和查询结果集中的列名不完全一致，MyBatis 可以通过 SQL 中通过 AS 来定义别名，或者使用 ResultMap 来定义 Java 对象属性和列的映射关系，对于一些复杂的映射关系，例如日期格式的转换、枚举类型的转换等，还可以通过自定义<code>TypeHandler</code>来实现</p>
</li>
<li><p>最终 MyBatis 将所有映射成功的 Java 对象封装成一个<code>List</code>返回</p>
</li>
</ul>
<h3 id="5-3-4-插件"><a href="#5-3-4-插件" class="headerlink" title="5.3.4 插件"></a>5.3.4 插件</h3><p>MyBatis 插件主要涉及三个关键接口</p>
<ul>
<li><p><code>Interceptor</code>，拦截器接口，定义了 MyBatis 插件的基本功能，包括插件的初始化、插件的拦截方法以及插件的销毁方法</p>
</li>
<li><p><code>Invocation</code>，调用接口，表示 MyBatis 在执行 SQL 语句时的状态，包括 SQL 语句、参数、返回值等信息</p>
</li>
<li><p><code>Plugin</code>，插件接口，MyBatis 在执行 SQL 语句时，会将所有注册的插件封装成<code>Plugin</code>对象，通过<code>Plugin</code>对象实现对 SQL 语句的拦截和修改</p>
</li>
</ul>
<p>插件的运行流程如下</p>
<ul>
<li><p>当 MyBatis 运行时，会将所有实现了<code>Interceptor</code>接口的插件进行初始化</p>
</li>
<li><p>将所有插件和原始的<code>Executor</code>对象封装成一个<code>InvocationChain</code>对象（责任链模式）</p>
</li>
<li><p>每次执行 SQL 语句时，MyBatis 都会通过<code>InvocationChain</code>对象依次调用所有插件的<code>intercept</code>方法，实现对 SQL 语句的拦截和修改，从而实现查询缓存、分页、分库分表等各种功能</p>
</li>
</ul>
<p>常见的 MyBatis 插件如用于分页的 PageHelper</p>
<h3 id="5-3-5-MyBatis-Plus"><a href="#5-3-5-MyBatis-Plus" class="headerlink" title="5.3.5 MyBatis-Plus"></a>5.3.5 MyBatis-Plus</h3><p>MyBatis-Plus 是增强版的 MyBatis</p>
<ul>
<li><p>提供了通用 Mapper 接口来快速进行增删改查，无需手写 SQL 语句</p>
</li>
<li><p>提供了一种简单易用高性能的物理分页插件，可以根据传入的分页参数自动计算出分页信息，无需手动编写分页 SQL 语句</p>
</li>
<li><p>可以根据数据库表自动生成实体类、Mapper 接口、Mapper XML 映射文件等代码，但某些情况下可能不够可靠，需要手动进行调整</p>
</li>
<li><p>可以使用 Lambda 表达式来构造查询条件和更新操作，代码更加简洁易读</p>
</li>
<li><p>提供了自定义的 SQL 注入功能，可以自由扩展 MyBatis 的 SQL 语句，实现更加灵活的 SQL 操作</p>
</li>
</ul>
<h3 id="5-3-6-分页机制"><a href="#5-3-6-分页机制" class="headerlink" title="5.3.6 分页机制"></a>5.3.6 分页机制</h3><p>MyBatis 提供基本物理的分页和基于逻辑的分页，物理分页指的是在最终执行的 SQL 中进行分页，可以通过 PageHelper 和 MyBatis-Plus 来实现；逻辑分页指的是在 SQL 中照常查全部结果不分页，在结果集中再进行分页，可以使用 RowBounds 来实现。</p>
<p>PageHelper 会将设置的分页参数存储到<code>ThreadLocal</code>中，在执行器执行 SQL 之前，从<code>ThreadLocal</code>中获取分页参数信息，然后修改 SQL 语句，限定查询的数据范围，实现物理分页的效果，并且在查询结束后再清除<code>ThreadLocal</code>中的分页参数。</p>
<p>RowBounds 是一个用于分页查询的 POJO 类，包含<code>offset</code>和<code>limit</code>这两个属性，使用 RowBounds 时无需在 SQL 语句中指定分页参数，在实际查询时会先将所有符合条件的记录返回，然后再在内存中进行分页，即抛弃掉不需要的数据再返回。</p>
<p>当数据量较小时，直接使用逻辑分页更简单，但当数据量比较大时，一定要使用物理分页，避免慢查询以及内存撑爆。</p>
<h2 id="5-4-JPA"><a href="#5-4-JPA" class="headerlink" title="5.4 JPA"></a>5.4 JPA</h2><p>Java 持久化 API（JPA，Java Persistence API）是一系列规范化接口，通过注解或 XML 描述 ORM，并将运行期的实体对象持久化到数据库中，让用户不通过任何配置即可完成数据库的操作。无论是哪种持久化存储方式，数据访问对象（Data Access Objects, DAO）都会提供对对象的增加、删除、修改、查询、排序以及分页等方法。</p>
<ul>
<li><p><code>@Entity</code></p>
<ul>
<li>用于声明数据库持久化实体类。</li>
</ul>
</li>
<li><p><code>@Table</code></p>
<ul>
<li><p>用于声明表名，一般与<code>@Entity</code>注解一起使用；</p>
</li>
<li><p>如果表名和实体类名相同，那么<code>＠Table</code>可以省略。</p>
</li>
</ul>
</li>
<li><p><code>@Id</code></p>
<ul>
<li>用于指定主键属性。</li>
</ul>
</li>
<li><p><code>@Transient</code></p>
<ul>
<li><p>表示该属性并非一个数据库表的字段的映射， ORM 框架将忽略该属性；</p>
</li>
<li><p>代表不持久的虚拟字段。</p>
</li>
</ul>
</li>
<li><p><code>@Column</code></p>
<ul>
<li>指定持久的字段属性，如果字段名与列名相同， 则可以省赂。</li>
</ul>
</li>
<li><p><code>@Basic</code></p>
<ul>
<li><p>指定实体属性的加载方式，实现关联数据的选择性加载；</p>
</li>
<li><p>有<code>LAZY</code>和<code>EAGER</code>两种，如<code>＠Basic(fetch=FetchType.LAZY)</code>；</p>
</li>
<li><p>懒加载是在属性被引用时才生成查询语句，抽取相关联数据；</p>
</li>
<li><p>实时加载则是执行完主查询后，不管是否被引用，都会马上执府后续的关联数据查询；</p>
</li>
<li><p>使用懒加载来调用关联数据，必须要保证主查询的Session （数据库连接会话）的生<br>命周期没有结束，否则是无法抽取到数据的。</p>
</li>
</ul>
</li>
<li><p><code>@Repository</code> ：用于标注和数据库操作有关的接口。</p>
</li>
<li><p><code>@Query</code>：用于指定接口方法的sql语句。</p>
</li>
<li><p><code>@Param</code>：用于指定方法参数名称。</p>
</li>
</ul>
<h2 id="5-5-JDBC"><a href="#5-5-JDBC" class="headerlink" title="5.5 JDBC"></a>5.5 JDBC</h2><p>JDBC（Java Data Base Connectivity）由一组用Java编写的类和接口组成</p>
<ul>
<li>是Java用于连接数据库的规范，为大部分关系型数据库提供访问接口，即用于执行数据库SQL语句的 Java API，是比较底层的高效的 API，在精通后适合用于性能调优</li>
<li>JDBC没有指定某种特定数据库，可以为多种数据库提供统一访问的接口，这也更符合程序设计的模式</li>
</ul>
<p>JDBC需要每次进行数据库连接，然后处理SQL语句、传值、关闭数据库。这些步骤繁琐易出错，为了减少这种可能的错误，减少开发人员的工作量，<code>JDBCTemplate</code>就被设计出来了。<code>JDBCTemplate</code>是对JDBC 的封装，更便于程序实现，替开发人员完成所有的JDBC 底层工作。此时，对于数据库的操作不再需要每次都进行连接、打开、关闭了。<code>JDBCtemplate</code>操作简单易学，但使用时依旧不够简洁。</p>
<h1 id="6、业务应用"><a href="#6、业务应用" class="headerlink" title="6、业务应用"></a>6、业务应用</h1><h2 id="6-1-事务"><a href="#6-1-事务" class="headerlink" title="6.1 事务"></a>6.1 事务</h2><p>Spring 的事务传播机制用于控制多个事务方法互相调用时的事务的行为，保证事务的原子性、一致性以及隔离性。</p>
<p><code>@Transactional</code>声明式事务</p>
<ul>
<li><p>往往在 service 层进行复杂业务场景中的多个事务方法互相调用时的事务传播控制，只有在使用基于接口的代理时才会生效，最小粒度是方法，使用<code>ThreadLocal</code>来存储事务上下文（是线程隔离的）；</p>
</li>
<li><p><code>rollbackFor</code>是用于指定触发事务回滚异常类型的事务属性，若不指定默认情况下只有<code>RuntimeExecption</code>和<code>Error</code>会触发回滚；</p>
</li>
<li><p><code>propagation</code>是用于指定事务传播级别的事务属性，Spring 规定了 7 种事务的传播级别：</p>
<ul>
<li><p>REQUIRED，如果不存在事务则开启一个事务，如果存在事务则加入之前的事务，总是只有一个事务在执行，是默认的传播机制，比如在写操作还未完成之前执行一些中间操作，这些中间操作应该使用这一级别，一旦中间操作报错则需回滚</p>
</li>
<li><p>REQUIRES_NEW，每次执行都新开一个事务</p>
</li>
<li><p>SUPPORTS，有事务则加入事务，没有事务则普通执行</p>
</li>
<li><p>NOT_SUPPORTED，有事务则暂停该事务，没有则普通执行，比如在写操作完成之后执行读操作，读操作应该使用这一级别，避免读操作报错导致前面的写操作回滚</p>
</li>
<li><p>MANDATORY，强制有事务，没有事务则报异常</p>
</li>
<li><p>NEVER，有事务则报异常</p>
</li>
<li><p>NESTED，如果之前有事务，则创建嵌套事务，嵌套事务回滚不影响父事务，但父事务回滚则影响嵌套事务</p>
</li>
</ul>
</li>
</ul>
<p>声明式事务使用简单，对代码没有侵入性，也容易被开发者忽略，进而以下一些情况都会导致声明式事务使用出问题</p>
<ul>
<li><p>在错误使用 AOP（类内部自调用、内部类调用、<code>static</code>方法、<code>final</code>方法、<code>private</code>方法）</p>
</li>
<li><p>在事务中加入一些分布式缓存、RPC、文件写入、消息发送等无法回滚的操作</p>
</li>
<li><p>错误地设置了<code>rollbackFor</code>、<code>propagation</code>属性</p>
</li>
<li><p>在事务方法内部 catch 了异常</p>
</li>
<li><p>使用了多线程（新线程中的操作不会被包含在原有事务中）等</p>
</li>
</ul>
<p>除了基于<code>@Transactional</code>的声明式事务，Spring 还提供基于<code>TransactionTemplate</code>等核心接口的编程式事务，开发者可以在代码中手动控制事务的开启、提交、回滚等操作，此时业务代码中就会清清楚楚地看到事务的具体控制细节，绝对不会被开发者忽略，也支持跨线程的事务管理。</p>
<h2 id="6-2-事件"><a href="#6-2-事件" class="headerlink" title="6.2 事件"></a>6.2 事件</h2><p>Spring Event 是 Spring 中的一种事件机制，建立在观察者模式的基础上，允许不同组件之间通过事件的方式进行通信，允许应用程序中的组件注册监听器来监听特定类型的事件，并在事件发生时执行相应的操作，可以很好地实现代码解耦，令职责划分更加清晰，尤其是一对多、多对多的复杂的事件驱动场景。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AaaService</span> &#123;</span><br><span class="line">  <span class="meta">@Autowired</span></span><br><span class="line">  <span class="keyword">private</span> ApplicationContext applicationContext;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">public</span> AaaResponse <span class="title function_">fun</span><span class="params">(AaaInfo aaaInfo)</span> &#123;</span><br><span class="line">    <span class="comment">// 业务逻辑</span></span><br><span class="line">    ...</span><br><span class="line">    <span class="comment">// 定义一个事件</span></span><br><span class="line">    <span class="type">ApplicationEvent</span> <span class="variable">aaaEvent</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AaaEvent</span>(aaaInfo);</span><br><span class="line">    <span class="comment">// 广播该事件</span></span><br><span class="line">    applicationContext.pulishEvent(aaaEvent);</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AaaEvent</span> <span class="keyword">extends</span> <span class="title class_">ApplicationEvent</span> &#123;</span><br><span class="line">  <span class="keyword">public</span> <span class="title function_">AaaEvent</span><span class="params">(AaaInfo aaaInfo)</span> &#123;</span><br><span class="line">    <span class="built_in">super</span>(aaaInfo);</span><br><span class="line">    ...</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Componet</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AaaEventListener</span> &#123;</span><br><span class="line">  <span class="meta">@EventListener(AaaEvent.class)</span></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onApplicationEvent</span><span class="params">(AaaEvent event)</span> &#123;</span><br><span class="line">    <span class="type">AaaInfo</span> <span class="variable">aaaInfo</span> <span class="operator">=</span> (AaaInfo) event.getSource();</span><br><span class="line">    <span class="comment">// 事件所驱动的业务逻辑</span></span><br><span class="line">    ...</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><p>如果需要在事务中发送和处理事件，则需要给<code>AaaService.fun()</code>加上<code>@Transactional</code>注解，并将<code>@EventListener</code>改成<code>TransactionalEventListener</code>，<code>TransactionalEventListener</code>的<code>phase</code>属性用于指定事件监听器的触发时机</p>
<ul>
<li>BEFORE_COMMIT，在事务提交前触发，如果监听器抛出异常将导致事务回滚，常用于在事务即将提交前执行某些额外的逻辑</li>
<li>AFTER_COMMIT，在事务成功提交后触发，这意味着它不会影响事务回滚，是默认的触发时机，常用于日志记录等不应影响事务回滚的操作</li>
<li>AFTER_ROLLBACK，在事务回滚后触发，常用于清理或记录与事务回滚相关的操作</li>
<li>AFTER_COMPLETION，在事务完成（不论是提交还是回滚）后触发，常用于执行一些与事务状态无关的清理工作</li>
</ul>
</li>
<li><p>默认情况下，Spring Event 的调用是同步的，可以通过<code>@Async</code>注解标注监听器来实现异步调用，<code>@Async</code>默认会使用<code>SimpleAsyncTaskExecutor</code>线程池，<code>SimpleAsyncTaskExecutor</code>并不是真正的线程池，不会重用线程，每次调用都会创建一个新的线程，也没有最大线程数设置，因此应该为<code>@Async</code>自定义一个线程池</p>
</li>
</ul>
<h2 id="6-3-应用启动"><a href="#6-3-应用启动" class="headerlink" title="6.3 应用启动"></a>6.3 应用启动</h2><p>Spring 提供了一些在应用启动阶段执行代码的几种方式，可以在应用的初始化阶段做一些类似缓存预热之类的应用初始化</p>
<ul>
<li><p>ApplicationReadyEvent 当且仅当在应用程序就绪之后才被触发，可以通过 ApplicationListener&lt;ApplicationReadyEvent&gt; 创建一些全局的启动逻辑</p>
</li>
<li><p>CommandLineRunner 接口的 run 方法会在应用启动之后被调用 ，调用时会传递（但不解析）用于启动应用程序的命令行参数，Spring 会将其作为应用启动的一部分，若运行失败则终止启动</p>
</li>
<li><p>ApplicationRunner 与 CommandLineRunner 的区别在于 ApplicationRunner 会解析命令行参数</p>
</li>
<li><p>@PostConstruct 标注的方法会在 Bean 的创建时期被调用，此时应用可能还没启动</p>
</li>
<li><p>InitializingBean 接口的 afterPropertiesSet 方法会在 Bean 的创建时期被调用，和 @PostConstruct 的区别在于 afterPropertiesSet 是在 Bean 的所有属性都被填充注入之后被调用，@PostConstruct 则没有这种属性填充限制，因此 afterPropertiesSet 不会遇到属性的 NPE 问题，更加安全（但如果使用构造器注入，则两种方式等效）</p>
</li>
</ul>
<p>构造函数 -&gt; Bean 的实例化完成 -&gt; @PostConstruct -&gt; 属性注入 -&gt; afterPropertiesSet -&gt; init-method -&gt; Bean 的初始化完成 -&gt; ApplicationRunner 与 CommandLineRunner -&gt; 应用就绪 -&gt; ApplicationReadyEvent</p>
<h1 id="7、参考资料"><a href="#7、参考资料" class="headerlink" title="7、参考资料"></a>7、参考资料</h1><ul>
<li>《Spring In Action，Third Edition》</li>
<li><a target="_blank" rel="noopener" href="https://docs.spring.io/spring-framework/docs/5.3.21/reference/html/">https://docs.spring.io/spring-framework/docs/5.3.21/reference/html/</a></li>
<li><a target="_blank" rel="noopener" href="https://www.liaoxuefeng.com/wiki/1252599548343744/1266263217140032">https://www.liaoxuefeng.com/wiki/1252599548343744/1266263217140032</a></li>
<li><a target="_blank" rel="noopener" href="https://snailclimb.gitee.io/javaguide/#/?id=springspringboot-%e5%bf%85%e7%9c%8b-1">https://snailclimb.gitee.io/javaguide/#/?id=springspringboot-%e5%bf%85%e7%9c%8b-1</a></li>
<li><a target="_blank" rel="noopener" href="https://www.cnblogs.com/zrtqsk/p/3735273.html">https://www.cnblogs.com/zrtqsk/p/3735273.html</a></li>
</ul>
</section>
    <!-- Tags START -->
    
    <!-- Tags END -->
    <!-- NAV START -->
    
  <div class="nav-container">
    <!-- reverse left and right to put prev and next in a more logic postition -->
    
      <a class="nav-left" href="/2022/05/08/java-concurrency/">
        <span class="nav-arrow">← </span>
        
          Java Concurrency
        
      </a>
    
    
      <a class="nav-right" href="/2022/05/11/design-patterns/">
        
          Design Patterns
        
        <span class="nav-arrow"> →</span>
      </a>
    
  </div>

    <!-- NAV END -->
    <!-- 打赏 START -->
    
    <!-- 打赏 END -->
    <!-- 二维码 START -->
    
    <!-- 二维码 END -->
    
      <!-- Utterances START -->
      <div id="utterances"></div>
      <script src="https://utteranc.es/client.js"
        repo=""
        issue-term="pathname"
        theme="github-light"
        crossorigin="anonymous"
        async></script>    
      <!-- Utterances END -->
    
  </article>
  <!-- Article END -->
  <!-- Catalog START -->
  
    <aside class="catalog-container">
  <div class="toc-main">
  
      
          <strong class="toc-title">OUTLINE</strong>
          <ol class="toc-nav"><li class="toc-nav-item toc-nav-level-1"><a class="toc-nav-link" href="#1%E3%80%81%E6%80%BB%E6%A6%82"><span class="toc-nav-text">1、总概</span></a></li><li class="toc-nav-item toc-nav-level-1"><a class="toc-nav-link" href="#2%E3%80%81IoC"><span class="toc-nav-text">2、IoC</span></a><ol class="toc-nav-child"><li class="toc-nav-item toc-nav-level-2"><a class="toc-nav-link" href="#2-1-%E9%97%AE%E9%A2%98%E4%B8%8E%E8%A7%A3%E5%86%B3"><span class="toc-nav-text">2.1 问题与解决</span></a></li><li class="toc-nav-item toc-nav-level-2"><a class="toc-nav-link" href="#2-2-XML-%E9%85%8D%E7%BD%AE"><span class="toc-nav-text">2.2 XML 配置</span></a><ol class="toc-nav-child"><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#2-2-1-%E4%BD%BF%E7%94%A8%E6%AD%A5%E9%AA%A4"><span class="toc-nav-text">2.2.1 使用步骤</span></a></li><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#2-2-2-%E9%9D%99%E6%80%81%E8%A3%85%E9%85%8D"><span class="toc-nav-text">2.2.2 静态装配</span></a></li><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#2-2-3-%E5%8A%A8%E6%80%81%E8%A3%85%E9%85%8D"><span class="toc-nav-text">2.2.3 动态装配</span></a></li><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#2-2-4-%E8%87%AA%E5%8A%A8%E8%A3%85%E9%85%8D"><span class="toc-nav-text">2.2.4 自动装配</span></a></li></ol></li><li class="toc-nav-item toc-nav-level-2"><a class="toc-nav-link" href="#2-3-%E6%B3%A8%E8%A7%A3%E9%85%8D%E7%BD%AE"><span class="toc-nav-text">2.3 注解配置</span></a><ol class="toc-nav-child"><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#2-3-1-%E4%BD%BF%E7%94%A8%E6%AD%A5%E9%AA%A4"><span class="toc-nav-text">2.3.1 使用步骤</span></a></li><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#2-3-2-%E8%87%AA%E5%8A%A8%E8%A3%85%E9%85%8D"><span class="toc-nav-text">2.3.2 自动装配</span></a></li><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#2-3-3-%E8%87%AA%E5%8A%A8%E6%A3%80%E6%B5%8B"><span class="toc-nav-text">2.3.3 自动检测</span></a></li><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#2-3-4-%E5%9F%BA%E4%BA%8E-Java-%E7%9A%84%E9%85%8D%E7%BD%AE"><span class="toc-nav-text">2.3.4 基于 Java 的配置</span></a></li><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#2-3-5-%E8%A1%A5%E5%85%85%E4%BB%8B%E7%BB%8D"><span class="toc-nav-text">2.3.5 补充介绍</span></a></li></ol></li><li class="toc-nav-item toc-nav-level-2"><a class="toc-nav-link" href="#2-4-IoC-%E7%89%B9%E6%80%A7"><span class="toc-nav-text">2.4 IoC 特性</span></a><ol class="toc-nav-child"><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#2-4-1-%E5%B7%A5%E5%8E%82-Bean"><span class="toc-nav-text">2.4.1 工厂 Bean</span></a></li><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#2-4-2-Bean-%E5%B7%A5%E5%8E%82"><span class="toc-nav-text">2.4.2 Bean 工厂</span></a></li><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#2-4-3-Bean-%E7%9A%84%E4%B8%89%E7%BA%A7%E7%BC%93%E5%AD%98"><span class="toc-nav-text">2.4.3 Bean 的三级缓存</span></a></li><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#2-4-4-Bean-%E7%9A%84%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F"><span class="toc-nav-text">2.4.4 Bean 的生命周期</span></a></li><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#2-4-5-%E5%90%8E%E7%BD%AE%E5%A4%84%E7%90%86%E5%99%A8"><span class="toc-nav-text">2.4.5 后置处理器</span></a></li><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#2-4-6-%E5%88%9B%E5%BB%BA-Bean"><span class="toc-nav-text">2.4.6 创建 Bean</span></a></li></ol></li></ol></li><li class="toc-nav-item toc-nav-level-1"><a class="toc-nav-link" href="#3%E3%80%81AOP"><span class="toc-nav-text">3、AOP</span></a><ol class="toc-nav-child"><li class="toc-nav-item toc-nav-level-2"><a class="toc-nav-link" href="#3-1-%E9%97%AE%E9%A2%98%E4%B8%8E%E8%A7%A3%E5%86%B3"><span class="toc-nav-text">3.1 问题与解决</span></a></li><li class="toc-nav-item toc-nav-level-2"><a class="toc-nav-link" href="#3-2-%E6%9C%AF%E8%AF%AD%E4%BB%8B%E7%BB%8D"><span class="toc-nav-text">3.2 术语介绍</span></a></li><li class="toc-nav-item toc-nav-level-2"><a class="toc-nav-link" href="#3-3-XML-%E9%85%8D%E7%BD%AE"><span class="toc-nav-text">3.3 XML 配置</span></a><ol class="toc-nav-child"><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#3-3-1-%E4%BD%BF%E7%94%A8%E6%AD%A5%E9%AA%A4"><span class="toc-nav-text">3.3.1 使用步骤</span></a></li><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#3-3-2-%E9%85%8D%E7%BD%AE%E5%85%83%E7%B4%A0"><span class="toc-nav-text">3.3.2 配置元素</span></a></li><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#3-3-3-%E5%88%87%E7%82%B9%E8%A1%A8%E8%BE%BE%E5%BC%8F"><span class="toc-nav-text">3.3.3 切点表达式</span></a></li><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#3-3-4-%E5%BC%95%E5%85%A5%E6%96%B0%E5%8A%9F%E8%83%BD"><span class="toc-nav-text">3.3.4 引入新功能</span></a></li></ol></li><li class="toc-nav-item toc-nav-level-2"><a class="toc-nav-link" href="#3-4-%E6%B3%A8%E8%A7%A3%E9%85%8D%E7%BD%AE"><span class="toc-nav-text">3.4 注解配置</span></a><ol class="toc-nav-child"><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#3-4-1-%E4%BD%BF%E7%94%A8%E6%AD%A5%E9%AA%A4"><span class="toc-nav-text">3.4.1 使用步骤</span></a></li><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#3-4-2-%E9%80%9A%E7%9F%A5%E6%8B%A6%E6%88%AA%E5%99%A8"><span class="toc-nav-text">3.4.2 通知拦截器</span></a></li><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#3-4-3-%E7%B2%BE%E5%87%86%E6%8C%87%E5%AE%9A%E5%88%87%E7%82%B9"><span class="toc-nav-text">3.4.3 精准指定切点</span></a></li><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#3-4-4-%E5%BC%95%E5%85%A5%E6%96%B0%E5%8A%9F%E8%83%BD"><span class="toc-nav-text">3.4.4 引入新功能</span></a></li></ol></li><li class="toc-nav-item toc-nav-level-2"><a class="toc-nav-link" href="#3-5-AOP-%E7%89%B9%E6%80%A7"><span class="toc-nav-text">3.5 AOP 特性</span></a><ol class="toc-nav-child"><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#3-5-1-CGLIB"><span class="toc-nav-text">3.5.1 CGLIB</span></a></li><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#3-5-2-%E5%88%9B%E5%BB%BA%E4%BB%A3%E7%90%86-Bean"><span class="toc-nav-text">3.5.2 创建代理 Bean</span></a></li></ol></li></ol></li><li class="toc-nav-item toc-nav-level-1"><a class="toc-nav-link" href="#4%E3%80%81MVC"><span class="toc-nav-text">4、MVC</span></a><ol class="toc-nav-child"><li class="toc-nav-item toc-nav-level-2"><a class="toc-nav-link" href="#4-1-%E9%97%AE%E9%A2%98%E4%B8%8E%E8%A7%A3%E5%86%B3"><span class="toc-nav-text">4.1 问题与解决</span></a></li><li class="toc-nav-item toc-nav-level-2"><a class="toc-nav-link" href="#4-2-%E8%AF%B7%E6%B1%82%E7%9A%84%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F"><span class="toc-nav-text">4.2 请求的生命周期</span></a></li><li class="toc-nav-item toc-nav-level-2"><a class="toc-nav-link" href="#4-3-%E6%90%AD%E5%BB%BA%E6%AD%A5%E9%AA%A4"><span class="toc-nav-text">4.3 搭建步骤</span></a></li><li class="toc-nav-item toc-nav-level-2"><a class="toc-nav-link" href="#4-4-REST-%E5%8A%9F%E8%83%BD"><span class="toc-nav-text">4.4 REST 功能</span></a></li><li class="toc-nav-item toc-nav-level-2"><a class="toc-nav-link" href="#4-5-%E7%9B%B8%E5%85%B3%E7%BB%84%E4%BB%B6"><span class="toc-nav-text">4.5 相关组件</span></a><ol class="toc-nav-child"><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#4-5-1-%E6%8E%A7%E5%88%B6%E5%99%A8"><span class="toc-nav-text">4.5.1 控制器</span></a></li><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#4-5-2-Servlet"><span class="toc-nav-text">4.5.2 Servlet</span></a></li><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#4-5-3-%E8%BF%87%E6%BB%A4%E5%99%A8"><span class="toc-nav-text">4.5.3 过滤器</span></a></li><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#4-5-4-%E7%9B%91%E5%90%AC%E5%99%A8"><span class="toc-nav-text">4.5.4 监听器</span></a></li><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#4-5-5-%E5%BC%82%E5%B8%B8"><span class="toc-nav-text">4.5.5 异常</span></a></li><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#4-5-6-HTTP-%E5%AE%A2%E6%88%B7%E7%AB%AF"><span class="toc-nav-text">4.5.6 HTTP 客户端</span></a></li></ol></li></ol></li><li class="toc-nav-item toc-nav-level-1"><a class="toc-nav-link" href="#5%E3%80%81ORM"><span class="toc-nav-text">5、ORM</span></a><ol class="toc-nav-child"><li class="toc-nav-item toc-nav-level-2"><a class="toc-nav-link" href="#5-1-%E9%97%AE%E9%A2%98%E4%B8%8E%E8%A7%A3%E5%86%B3"><span class="toc-nav-text">5.1 问题与解决</span></a></li><li class="toc-nav-item toc-nav-level-2"><a class="toc-nav-link" href="#5-2-Hibernate"><span class="toc-nav-text">5.2 Hibernate</span></a></li><li class="toc-nav-item toc-nav-level-2"><a class="toc-nav-link" href="#5-3-MyBatis"><span class="toc-nav-text">5.3 MyBatis</span></a><ol class="toc-nav-child"><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#5-3-1-%E5%8A%A8%E6%80%81%E5%8F%82%E6%95%B0"><span class="toc-nav-text">5.3.1 动态参数</span></a></li><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#5-3-2-%E7%BC%93%E5%AD%98%E6%9C%BA%E5%88%B6"><span class="toc-nav-text">5.3.2 缓存机制</span></a></li><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#5-3-3-%E5%AD%97%E6%AE%B5%E6%98%A0%E5%B0%84"><span class="toc-nav-text">5.3.3 字段映射</span></a></li><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#5-3-4-%E6%8F%92%E4%BB%B6"><span class="toc-nav-text">5.3.4 插件</span></a></li><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#5-3-5-MyBatis-Plus"><span class="toc-nav-text">5.3.5 MyBatis-Plus</span></a></li><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#5-3-6-%E5%88%86%E9%A1%B5%E6%9C%BA%E5%88%B6"><span class="toc-nav-text">5.3.6 分页机制</span></a></li></ol></li><li class="toc-nav-item toc-nav-level-2"><a class="toc-nav-link" href="#5-4-JPA"><span class="toc-nav-text">5.4 JPA</span></a></li><li class="toc-nav-item toc-nav-level-2"><a class="toc-nav-link" href="#5-5-JDBC"><span class="toc-nav-text">5.5 JDBC</span></a></li></ol></li><li class="toc-nav-item toc-nav-level-1"><a class="toc-nav-link" href="#6%E3%80%81%E4%B8%9A%E5%8A%A1%E5%BA%94%E7%94%A8"><span class="toc-nav-text">6、业务应用</span></a><ol class="toc-nav-child"><li class="toc-nav-item toc-nav-level-2"><a class="toc-nav-link" href="#6-1-%E4%BA%8B%E5%8A%A1"><span class="toc-nav-text">6.1 事务</span></a></li><li class="toc-nav-item toc-nav-level-2"><a class="toc-nav-link" href="#6-2-%E4%BA%8B%E4%BB%B6"><span class="toc-nav-text">6.2 事件</span></a></li><li class="toc-nav-item toc-nav-level-2"><a class="toc-nav-link" href="#6-3-%E5%BA%94%E7%94%A8%E5%90%AF%E5%8A%A8"><span class="toc-nav-text">6.3 应用启动</span></a></li></ol></li><li class="toc-nav-item toc-nav-level-1"><a class="toc-nav-link" href="#7%E3%80%81%E5%8F%82%E8%80%83%E8%B5%84%E6%96%99"><span class="toc-nav-text">7、参考资料</span></a></li></ol>
      
  
  </div>
</aside>
  
  <!-- Catalog END -->
</main>

<script>
  (function () {
    var url = 'http://example.com/2022/05/10/spring/';
    var banner = ''
    if (banner !== '' && banner !== 'undefined' && banner !== 'null') {
      $('#article-banner').css({
        'background-image': 'url(' + banner + ')'
      })
    } else {
      $('#article-banner').geopattern(url)
    }
    $('.header').removeClass('fixed-header')

    // error image
    $(".markdown-content img").on('error', function() {
      $(this).attr('src', '/css/images/error_icon.png')
      $(this).css({
        'cursor': 'default'
      })
    })

    // zoom image
    $(".markdown-content img").on('click', function() {
      var src = $(this).attr('src')
      if (src !== '/css/images/error_icon.png') {
        var imageW = $(this).width()
        var imageH = $(this).height()

        var zoom = ($(window).width() * 0.95 / imageW).toFixed(2)
        zoom = zoom < 1 ? 1 : zoom
        zoom = zoom > 2 ? 2 : zoom
        var transY = (($(window).height() - imageH) / 2).toFixed(2)

        $('body').append('<div class="image-view-wrap"><div class="image-view-inner"><img src="'+ src +'" /></div></div>')
        $('.image-view-wrap').addClass('wrap-active')
        $('.image-view-wrap img').css({
          'width': `${imageW}`,
          'transform': `translate3d(0, ${transY}px, 0) scale3d(${zoom}, ${zoom}, 1)`
        })
        $('html').css('overflow', 'hidden')

        $('.image-view-wrap').on('click', function() {
          $(this).remove()
          $('html').attr('style', '')
        })
      }
    })
  })();
</script>







    <div class="scroll-top">
  <span class="arrow-icon"></span>
</div>
    <footer class="app-footer">
  <p class="copyright">
    &copy; 2024 | Proudly powered by <a href="https://hexo.io" target="_blank">Hexo</a>
    <br>
    Theme by <a target="_blank" rel="noopener" href="https://github.com/yanm1ng">yanm1ng</a>
    
  </p>
</footer>

<script>
  function async(u, c) {
    var d = document, t = 'script',
      o = d.createElement(t),
      s = d.getElementsByTagName(t)[0];
    o.src = u;
    if (c) { o.addEventListener('load', function (e) { c(null, e); }, false); }
    s.parentNode.insertBefore(o, s);
  }
</script>
<script>
  async("//cdnjs.cloudflare.com/ajax/libs/fastclick/1.0.6/fastclick.min.js", function(){
    FastClick.attach(document.body);
  })
</script>

<script>
  var hasLine = 'true';
  async("//cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/highlight.min.js", function(){
    $('figure pre').each(function(i, block) {
      var figure = $(this).parents('figure');
      if (hasLine === 'false') {
        figure.find('.gutter').hide();
      }
      hljs.configure({useBR: true});
      var lang = figure.attr('class').split(' ')[1] || 'code';
      var codeHtml = $(this).html();
      var codeTag = document.createElement('code');
      codeTag.className = lang;
      codeTag.innerHTML = codeHtml;
      $(this).attr('class', '').empty().html(codeTag);
      figure.attr('data-lang', lang.toUpperCase());
      hljs.highlightBlock(block);
    });
  })
</script>
<!-- Baidu Tongji -->


<script src="/js/script.js"></script>


  </body>
</html>
<!DOCTYPE html>
<html>
  <head>
  <meta http-equiv="content-type" content="text/html; charset=utf-8">
  <!--<meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport">-->
  <meta name="description" content="要有一个从输入到输出的过程">
  <meta name="keyword" content="">
  
    <link rel="shortcut icon" href="/css/images/logo.png">
  
  <title>
    
      MySQL | CQ&#39;s Blog
    
  </title>
  <link href="//cdnjs.cloudflare.com/ajax/libs/font-awesome/4.7.0/css/font-awesome.min.css" rel="stylesheet">
  <link href="//cdnjs.cloudflare.com/ajax/libs/nprogress/0.2.0/nprogress.min.css" rel="stylesheet">
  <link href="//cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/tomorrow.min.css" rel="stylesheet">
  
<link rel="stylesheet" href="/css/style.css">

  
  <script src="//cdnjs.cloudflare.com/ajax/libs/jquery/3.2.1/jquery.min.js"></script>
  <script src="//cdnjs.cloudflare.com/ajax/libs/geopattern/1.2.3/js/geopattern.min.js"></script>
  <script src="//cdnjs.cloudflare.com/ajax/libs/nprogress/0.2.0/nprogress.min.js"></script>
  
  
  
  


  
  
    
<script src="/js/local-search.js"></script>


<meta name="generator" content="Hexo 5.4.2"></head>
<div class="wechat-share">
  <img src="/css/images/logo.png" />
</div>
  <body>
    <header class="header fixed-header">
  <div class="header-container">
    <a class="home-link" href="/">
      <div class="logo"></div>
      <span>CQ's Blog</span>
    </a>
    <ul class="right-list">
      
        <li class="list-item">
          
            <a href="/" class="item-link">Home</a>
          
        </li>
      
        <li class="list-item">
          
            <a href="/categories/" class="item-link">Categories</a>
          
        </li>
      
        <li class="list-item">
          
            <a href="/records" class="item-link">Records</a>
          
        </li>
      
        <li class="list-item">
          
            <a href="/scratches/" class="item-link">Scratches</a>
          
        </li>
      
        <li class="list-item">
          
            <a href="/archives/" class="item-link">Archives</a>
          
        </li>
      
      
        <li class="menu-item menu-item-search right-list">
    <a role="button" class="popup-trigger">
        <i class="fa fa-search fa-fw"></i>
    </a>
</li>
      
    </ul>
    <div class="menu">
      <span class="icon-bar"></span>
      <span class="icon-bar"></span>
      <span class="icon-bar"></span>
    </div>
    <div class="menu-mask">
      <ul class="menu-list">
        
          <li class="menu-item">
            
              <a href="/" class="menu-link">Home</a>
            
          </li>
        
          <li class="menu-item">
            
              <a href="/categories/" class="menu-link">Categories</a>
            
          </li>
        
          <li class="menu-item">
            
              <a href="/records" class="menu-link">Records</a>
            
          </li>
        
          <li class="menu-item">
            
              <a href="/scratches/" class="menu-link">Scratches</a>
            
          </li>
        
          <li class="menu-item">
            
              <a href="/archives/" class="menu-link">Archives</a>
            
          </li>
        
      </ul>
    </div>
    
      <div class="search-pop-overlay">
    <div class="popup search-popup">
        <div class="search-header">
            <span class="search-icon">
                <i class="fa fa-search"></i>
            </span>
            <div class="search-input-container">
                <input autocomplete="off" autocapitalize="off"
                    placeholder="Please enter your keyword(s) to search." spellcheck="false"
                    type="search" class="search-input">
            </div>
            <span class="popup-btn-close">
                <i class="fa fa-times-circle"></i>
            </span>
        </div>
        <div id="search-result">
            <div id="no-result">
                <i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i>
            </div>
        </div>
    </div>
</div>
    
  </div>
</header>

    <div id="article-banner">
  <h2>MySQL</h2>
  <!--<p class="post-date">2022-08-06</p>
  <div class="arrow-down">
    <a href="javascript:;"></a>
  </div>-->
</div>
<main class="app-body flex-box">
  <!-- Article START -->
  <article class="post-article">
    <section class="markdown-content"><h1 id="1、概述"><a href="#1、概述" class="headerlink" title="1、概述"></a>1、概述</h1><h2 id="1-1-基础概念"><a href="#1-1-基础概念" class="headerlink" title="1.1 基础概念"></a>1.1 基础概念</h2><h3 id="1-1-1-事务"><a href="#1-1-1-事务" class="headerlink" title="1.1.1 事务"></a>1.1.1 事务</h3><p>事务是一组是一个独立的工作单元，事务应当具备四个特性：</p>
<ul>
<li>原子性（atomicity）：一个事务必须被视为一个不可分割的最小工作单元，整个事务中的所有操作要么全部执行成功，要么全部执行失败。</li>
<li>一致性（consistency）：数据库总是从一个一致性的状态转换到另一个一致性的状态，在一致性状态下，所有事务对同一数据的读取结果都是相同的。</li>
<li>隔离性（isolation）：“通常来说”，一个事务所做的修改在最终提交之前，对其他事务是不可见的。</li>
<li>持久性（durability）：一旦事务提交，则其所做的修改就会永远保存到数据库中，持久性是有很多不同级别的。</li>
</ul>
<p>满足ACID特性的事务处理系统才是一个运行良好的系统，这种事务处理过程中额外的安全性也会需要数据库系统做更多额外的工作，需要更强的CPU处理能力，更大的内存和更多的磁盘空间。</p>
<h3 id="1-1-2-并发一致性问题"><a href="#1-1-2-并发一致性问题" class="headerlink" title="1.1.2 并发一致性问题"></a>1.1.2 并发一致性问题</h3><p>当事务的一致性没有满足时，就会出现一些并发一致性问题：</p>
<ul>
<li>脏读：一个事务读到其他事务还未提交的修改数据，假如其他事务撤销了该修改，那么当前事务读到的就是脏数据。</li>
<li>不可重复读：一个事务多次读取同一数据集合，假如此时有其他事务对这一数据集合进行了修改，那么当前事务多次读取到的结果是不同的。</li>
<li>幻读：一个事务多次读取同一数据集合，假如此时有其他事务对这一数据集合进行了插入或者删除，那么当前事务就会读取到幻行。</li>
</ul>
<h3 id="1-1-3-隔离级别"><a href="#1-1-3-隔离级别" class="headerlink" title="1.1.3 隔离级别"></a>1.1.3 隔离级别</h3><p>在SQL标准中定义了四种隔离级别：</p>
<ul>
<li>未提交读（READ UNCOMMITED）<ul>
<li>事务中的修改即使没有提交，对其他事务也都是可见的；</li>
<li>此时会出现脏读、不可重复读以及幻读。</li>
</ul>
</li>
<li>提交读（READ COMMITED）<ul>
<li>一个事务从开始到提交之前，所做的修改对其他事务都是不可见的；</li>
<li>这是大多数数据库系统的默认事务隔离级别；</li>
<li>此时可能会出现不可重复读和幻读。</li>
</ul>
</li>
<li>可重复读（REPEATABLE READ）<ul>
<li>在同一事务中多次读取同一数据的结果是一样的；</li>
<li>是MySQL的默认事务隔离级别；</li>
<li>可能会出现幻读。</li>
</ul>
</li>
<li>可串行化<ul>
<li>强制事务串行执行；</li>
<li>这一隔离级别需要加锁来实现；</li>
<li>不会出现并发一致性问题。</li>
</ul>
</li>
</ul>
<p>较低级别的隔离通常可以执行更高的并发，系统的开销也更低。</p>
<h2 id="1-2-MySQL架构"><a href="#1-2-MySQL架构" class="headerlink" title="1.2 MySQL架构"></a>1.2 MySQL架构</h2><p>MySQL是一个灵活的数据库系统，主要体现在：可适应不同的硬件，可支持多种数据类型，可支持多种应用类型，尤其是其存储引擎架构将数据的处理和存储相分离，极大地提高了使用时的灵活性。</p>
<p>MySQL的逻辑架构可分为三层：</p>
<ul>
<li>最上层是服务器层（与客户端对接）<ul>
<li>实现连接处理、授权认证等功能；</li>
<li>每个客户端连接都会在服务器进程中拥有一个线程，该连接的操作都会由这个线程执行，服务器对线程进行统一管理。</li>
</ul>
</li>
<li>第二层是查询执行引擎（实现所有的跨存储引擎的功能）<ul>
<li>比如查询解析、分析、优化、缓存等；</li>
<li>优化器并不关心具体使用的是什么存储引擎，但存储引擎对于优化是有影响的。</li>
</ul>
</li>
<li>第三层是存储引擎层<ul>
<li>MySQL支持多个存储引擎的架构，那么针对一些复杂问题（比如事务处理、锁管理等）就不需要单一的通用解决方案，每个存储引擎都可以提供自己的解决方案；</li>
<li>服务器通过API与存储引擎通信，这些API对服务器屏蔽了不同存储引擎之间的差异；</li>
<li>不同的存储引擎之间不会通信，只是相应上层服务器的请求。</li>
</ul>
</li>
</ul>
<h2 id="1-3-MySQL存储引擎"><a href="#1-3-MySQL存储引擎" class="headerlink" title="1.3 MySQL存储引擎"></a>1.3 MySQL存储引擎</h2><ul>
<li>InnoDB<ul>
<li>MySQL默认的事务性存储引擎是InnoDB，只有在需要它不支持的特性时，才考虑使用其他存储引擎；</li>
<li>InnoDB 可以将表的数据和索引存放在单独的文件中，存储格式是平台独立的；</li>
<li>InnoDB表是基于聚簇索引建立的，这与其他存储引擎有很大不同；</li>
<li>InnoDB但是MySQL中唯一支持外键的内置存储引擎；</li>
<li>InnoDB支持真正的热备份，MySQL其他的存储引擎不支持热备份，要获取一致性视图需要停止对所有表的写入。</li>
</ul>
</li>
<li>MyISAM<ul>
<li>在MySQL5.1之前，MyISAM是默认的存储引擎；</li>
<li>MyISAM提供全文索引、压缩等特性；</li>
<li>MyISAM不支持事务和行级锁，崩溃后无法安全恢复；</li>
<li>MyISAM适合的场景有：读场景、表比较小可以忍受修复操作的场景、表在创建并导入数据后不会再进行修改的场景（采用MyISAM压缩表）。</li>
</ul>
</li>
</ul>
<h2 id="1-4-MySQL特性"><a href="#1-4-MySQL特性" class="headerlink" title="1.4 MySQL特性"></a>1.4 MySQL特性</h2><ul>
<li><p>死锁</p>
<ul>
<li>死锁指两个或两个以上事务在同一资源上互相占用，并请求锁定对方占用的资源，从而导致恶性循环的现象；</li>
<li>死锁的产生可能是由于真正的数据冲突，也可能是由于存储引擎的实现方式；</li>
<li>死锁发生后只有部分或者完全回滚其他一种事务，才能打破死锁；</li>
<li>InnoDB目前处理死锁的方法是：将持有最少行级排它锁的事务进行回滚。</li>
</ul>
</li>
<li><p>日志</p>
<ul>
<li>事务日志可以帮助提高事务的效率；</li>
<li>存储引擎在修改表的数据时只需修改其内存拷贝，再将修改行为记录到持久在硬盘上的事务日志中，而不需要每次都将修改的数据持久到硬盘；</li>
<li>日志持久以后，内存中被修改的数据可以在后台慢慢地刷回到磁盘，这称之为预写式日志，修改数据需要写两次磁盘。</li>
</ul>
</li>
<li><p>自动提交</p>
<ul>
<li>事务由存储引擎实现，MySQL服务器层不管理事务；</li>
<li>不要在一个事务中混合使用事务型和非事务型的表，因为在回滚时，非事务型的表上的变更无法撤销，这会导致数据库处于不一致的状态；</li>
<li>InnoDB默认采用自动提交模式，可通过设置来禁用或者启用；</li>
<li>可以设置隔离级别，新的隔离级别会在下一个事务开始时生效 。</li>
</ul>
</li>
<li><p>锁定</p>
<ul>
<li>InnoDB采用两段锁定协议，事务执行时会自动根据隔离级别执行隐式锁定，所有的锁都在事务提交或者回滚时被一起释放；</li>
<li>MySQL服务器层也提供显式锁定语句，但除了禁用自动提交以外，任何时候都不要使用显式锁定，否则可能会产生无法预料的结果；</li>
<li>InnoDB采用间隙锁（next-key locking）来锁定索引中的间隙，防止幻影行的插入，从而防止幻读。</li>
</ul>
</li>
<li><p>MVCC</p>
<ul>
<li>基于提升并发性能的考虑，事务型存储引擎实现的都不是简单的行级锁，一般都同时实现了多版本并发控制（可以看作是行级锁的一个变种）；</li>
<li>MVCC是通过保存数据在某个时间点的快照来实现的，但没有一个统一的实现标准，InnoDB采用MVCC来支持高并发；</li>
<li>InnoDB的MVCC是在每行记录后面保存两个隐藏的列来实现的，分别是行的创建时间和行的过期时间，这个时间并非实际的时间值，而是版本号；</li>
<li>每个事务的开始时间的系统版本号会作为事务的版本号，用来和查询到的每行记录的版本号进行比较，只有创建时间小于等于当前版本号，且删除时间未定义或大于当前版本号的记录，才能作为查询结果；</li>
<li>由于未提交读总是读取最新数据行，而串行化会对所有读取的数据行加锁，所以MVCC只能在提交读和可重复读这两个隔离级别下工作。</li>
</ul>
</li>
</ul>
<h1 id="2、设计"><a href="#2、设计" class="headerlink" title="2、设计"></a>2、设计</h1><h2 id="2-1-数据类型"><a href="#2-1-数据类型" class="headerlink" title="2.1 数据类型"></a>2.1 数据类型</h2><p>不管储存哪种类型的数据，有以下几个原则：</p>
<ul>
<li>尽可能使用可以正确存储数据的最小数据类型</li>
<li>尽可能选择简单的操作代价低的数据类型，比如整型比字符型更简单</li>
<li>尽量避免NULL，NULL值会使得索引变得复杂</li>
<li>对于相关联的列，应选择与关联表中的对应列一样的数据类型</li>
<li>数据如何存储取决于存储引擎，对于相同的类型，并非所有的存储引擎都会按照相同的方式处理</li>
</ul>
<h3 id="2-1-1-整数类型"><a href="#2-1-1-整数类型" class="headerlink" title="2.1.1 整数类型"></a>2.1.1 整数类型</h3><p>可以存储的范围从-2^(N-1)到2^(N-1)-1，N是存储空间的位数，但无符号类型UNSIGNED表示不允许负值，这使得存储范围提高一倍。</p>
<table>
<thead>
<tr>
<th align="center"></th>
<th align="center"></th>
<th align="center"></th>
<th align="center"></th>
<th align="center"></th>
<th align="center"></th>
</tr>
</thead>
<tbody><tr>
<td align="center">类型</td>
<td align="center">TINYINT</td>
<td align="center">SMALLINT</td>
<td align="center">MEDIUMINT</td>
<td align="center">INT</td>
<td align="center">BIGINT</td>
</tr>
<tr>
<td align="center">位数</td>
<td align="center">8</td>
<td align="center">16</td>
<td align="center">24</td>
<td align="center">32</td>
<td align="center">64</td>
</tr>
</tbody></table>
<p>实数类型：可以用于存储带有小数部分的数字以及比BIGINT更大的整数，</p>
<table>
<thead>
<tr>
<th align="center"></th>
<th align="center"></th>
<th align="center"></th>
<th align="center"></th>
</tr>
</thead>
<tbody><tr>
<td align="center">类型</td>
<td align="center">FLOAT</td>
<td align="center">DOUBLE</td>
<td align="center">DECIMAL</td>
</tr>
<tr>
<td align="center">位数</td>
<td align="center">4</td>
<td align="center">8</td>
<td align="center">尽量只在需要对小数进行精确计算时使用</td>
</tr>
</tbody></table>
<h3 id="2-1-2-字符串类型"><a href="#2-1-2-字符串类型" class="headerlink" title="2.1.2 字符串类型"></a>2.1.2 字符串类型</h3><p>VARCHAR用于存储可变长字符串，当字符串列的最大长度比平均长度大很多，列的更新很少时，VARCHAR比定长类型更节省空间</p>
<p>CHAR类型是定长的，会根据定义的字符串长度分配足够的空间，适合存储很短的字符串，或者所有值都接近同一个长度，或者经常变更的数据</p>
<p>BLOB和TEXT都是为存储很大的数据而设计的字符串数据类型，分别采用二进制和字符方式存储。与其他类型不同，MySQL把每个BLOB和TEXT当做一个独立的对象处理</p>
<h3 id="2-1-3-日期和时间类型"><a href="#2-1-3-日期和时间类型" class="headerlink" title="2.1.3 日期和时间类型"></a>2.1.3 日期和时间类型</h3><p>DATETIME类型能保存大范围的值，使用8个字节的存储空间，与时区无关</p>
<p>TIMESTAMP类型只是用4个字节的存储空间，显示的值依赖于时区，默认为NOT NULL，应该尽量使用TIMESTAMP</p>
<h2 id="2-2-范式"><a href="#2-2-范式" class="headerlink" title="2.2 范式"></a>2.2 范式</h2><h3 id="2-2-1-定义"><a href="#2-2-1-定义" class="headerlink" title="2.2.1 定义"></a>2.2.1 定义</h3><p>范式（Normal Form）是用于设计关系型数据库的规范要求。</p>
<p>1NF要求数据库的每一列都是不可分割的基本数据项，而不能是集合、数组等非原子数据项（满足1NF的数据库才是关系数据库）。</p>
<p>2NF是在1NF的基础上，要求每一个非主属性完全函数依赖于主属性（消除部分依赖）。</p>
<p>3NF是在2NF的基础上，要求每一个非主属性都不依赖于其他非主属性（消除间接依赖）。</p>
<h3 id="2-2-3-范式和反范式"><a href="#2-2-3-范式和反范式" class="headerlink" title="2.2.3 范式和反范式"></a>2.2.3 范式和反范式</h3><p>范式化的表通常更小。</p>
<p>范式化的更新操作通常比反范式化要快。</p>
<p>范式化的表通常需要关联，代价昂贵，而反范式化的表则可以很好地避免关联。</p>
<p>通常混用范式和反范式。</p>
<p>最常见的反范式化数据的方法是复制或者缓存。</p>
<h3 id="2-2-4-缓存表和汇总表"><a href="#2-2-4-缓存表和汇总表" class="headerlink" title="2.2.4 缓存表和汇总表"></a>2.2.4 缓存表和汇总表</h3><p>有时提升性能最好的方法是在同一张表中保存衍生的冗余数据，甚至创建一张完全独立的缓存表或汇总表。</p>
<p>缓存表表示存储那些可以比较简单地从其他表获取数据的表，对优化搜索和检索查询语句很有效。</p>
<p>汇总表表示使用GROUP BY语句聚合数据的表。</p>
<p>在使用缓存表和汇总表时，必须决定是实时维护数据还是定期重建。</p>
<h2 id="2-3-索引"><a href="#2-3-索引" class="headerlink" title="2.3 索引"></a>2.3 索引</h2><p>索引是存储引擎用于快速找到记录的一种数据结构，可以理解为看书时的内容页码。在MySQL中，索引是在存储引擎层而不是服务器层实现的，不同存储引擎的索引的底层实现和工作方式不一样。</p>
<h3 id="2-3-1-B-Tree索引"><a href="#2-3-1-B-Tree索引" class="headerlink" title="2.3.1 B-Tree索引"></a>2.3.1 B-Tree索引</h3><p>如果没有特别指明类型，那默认指B-Tree索引。</p>
<p>B-Tree索引意味着所有的值都是按顺序存储的，每一个叶子节点到根节点的距离相同。如果是B+Tree索引，则每一个叶子节点都包含指向下一个叶子节点的指针，从而方便叶子节点的范围遍历。</p>
<p>使用B-Tree索引时</p>
<ul>
<li>不再需要进行全表扫描，能够加快访问数据的速度</li>
<li>必须按照索引的最左列开始查找，不能跳过索引中的列，适合全键值、键值范围或键值最左前缀查找范围数据</li>
<li>如果查询中有某个列的范围查询则其右边所有列都无法使用索引优化查找</li>
<li>B-Tree索引列是顺序组织存储的，如果B-Tree索引可以按某种方式查找到值，那么也可以按照这种方式用于排序，适合ORDER BY、GROUP BY顺序查找</li>
</ul>
<h3 id="2-3-2-哈希索引"><a href="#2-3-2-哈希索引" class="headerlink" title="2.3.2 哈希索引"></a>2.3.2 哈希索引</h3><p>哈希索引基于哈希表实现，对于每一行数据，存储引擎都会对所有的索引列计算一个哈希码，哈希索引将所有的哈希码存储在索引中，同时在哈希表中保存指向每个数据行的指针。</p>
<p>使用哈希索引时</p>
<ul>
<li><p>哈希索引自身只需存储哈希值和行指针，索引的结构非常紧凑，因此哈希索引查找的速度非常快，除非有很多哈希冲突</p>
</li>
<li><p>哈希索引数据不是按照索引值顺序存储的，因此无法用于排序</p>
</li>
<li><p>哈希索引始终使用索引列的全部内容来计算哈希值，因此不支持部分索引列匹配查找，只有精确匹配索引所有列的查询才有效</p>
</li>
<li><p>哈希索引不支持任何范围查询，只支持等值比较查询，包括<code>=</code>、<code>IN()</code></p>
</li>
</ul>
<p>InnoDB引擎当注意到某些索引值被使用得非常频繁时，它会在内存中基于B-Tree索引之上再创建一个哈希索引，这样就让B-Tree索引也具有哈希索引的一些优点，这个功能叫做自适应哈希索引。</p>
<h3 id="2-3-3-全文索引"><a href="#2-3-3-全文索引" class="headerlink" title="2.3.3 全文索引"></a>2.3.3 全文索引</h3><p>通过数值比较、范围过滤等就可以完成绝大多数需要的查询了，但是如果希望通过关键字的匹配来进行基于相似度的查询过滤，而不是精确的数值比较，就可以使用全文索引。互联网搜索引擎就是一种全文索引。 </p>
<p>使用全文索引时</p>
<ul>
<li>全文索引查找的是文本中的关键词，而不是直接比较索引中的值</li>
<li>在相同的列上同时创建全文索引和基于值的B-Tree索引不会有冲突</li>
<li>全文索引适用于MATCH AGAINST操作，而不是普通的WHERE条件操作，且MATCH函数中指定的列必须和全文索引中指定的列完全相同，WHERE条件比较必须在完成全文搜索返回记录后才能进行</li>
<li>使用全文索引的查询自动按照相似度进行排序，此时MySQL无法再使用索引排序，如果需要相关性以外的排序操作，那么只能在查询中使用ORDER BY做文件排序</li>
<li>全文索引不会记录查询关键字来自哪一行，因此无法使用全文索引来查询某个关键字是否在某一列中存在，也无法用作索引覆盖扫描</li>
</ul>
<h3 id="2-3-4-聚簇索引"><a href="#2-3-4-聚簇索引" class="headerlink" title="2.3.4 聚簇索引"></a>2.3.4 聚簇索引</h3><p>聚簇索引并不是一种单独的索引类型，而是一种数据存储方式。聚簇索引的存储并不是物理上的连续，而是逻辑上的连续。因为无法同时把数据行存放在两个不同的地方，所以一个表只能有一个聚簇索引。</p>
<p>InnoDB的聚簇索引在同一个结构中保存了B-Tree索引和数据行，叶子节点包含所有的数据行。在InnoDB中，聚簇索引“就是”表。</p>
<p>InnoDB一般选择主键的索引来作为聚簇索引，如果没有定义主键则选择一个唯一的非空索引代替，如果没有这样的索引则隐式定义一个主键（比如自增列）来作为聚簇索引，从而聚集数据。</p>
<p>聚簇索引以外的索引都是非聚簇索引，也叫二级索引或辅助索引。InnoDB的辅助索引的叶子节点存储数据行的主键值，而不是指向数据行物理位置的指针。当通过辅助索引来查找数据时，InnoDB会通过辅助索引叶子节点获得对应的主键值，然后再通过主键索引来找到一个完整的数据行。</p>
<p>使用聚簇索引时</p>
<ul>
<li>聚簇索引将相关数据保存在一起，因此可以减少磁盘I/O</li>
<li>聚簇索引的索引和数据保存在同一个B-Tree中，因此数据访问会更快</li>
<li>聚簇索引列的更新代价很高，因为会强制将每个被更新的行移动到新的位置，甚至在插入新行时可能导致页分裂，占用更多的磁盘空间</li>
<li>辅助索引访问需要两次索引查找，而不是一次</li>
<li>尽量避免使用数据随机（不连续且值的分布范围非常大）的列来做聚簇索引，自增列就比较好</li>
</ul>
<h3 id="2-3-5-覆盖索引"><a href="#2-3-5-覆盖索引" class="headerlink" title="2.3.5 覆盖索引"></a>2.3.5 覆盖索引</h3><p>覆盖索引指索引包含所有需要查询的字段的值，此时只访问索引即可，而无须再回表查询。</p>
<p>由于覆盖索引必须要存储索引列的值，而哈希索引和全文索引都不存储索引列的值，所以MySQL只能用B-Tree索引来做覆盖索引。</p>
<p> 使用覆盖索引时</p>
<ul>
<li>索引条目通常远小于数据行大小，更容易全部放入内存中，因此可以极大地减少数据访问量</li>
<li>索引是按照列值顺序存储的，因此可以将随机I/O变为顺序I/O，且范围查询会比随机从磁盘读取每一行数据的I/O次数更少</li>
<li>按照覆盖索引顺序扫描得到的有序结果会比对先得到结果再进行排序操作的效率更高</li>
</ul>
<h3 id="2-3-6-高性能索引"><a href="#2-3-6-高性能索引" class="headerlink" title="2.3.6 高性能索引"></a>2.3.6 高性能索引</h3><p>索引大大减少了服务器需要扫描的数据量，可以帮助服务器避免排序和临时表，可以将随机I/O变为顺序I/O，可以减少需要锁定的行。但正确创建和使用索引才能真正发挥出索引的优势，应当遵循以下原则</p>
<ul>
<li>对于非常小的表，大部分情况下简单的全表扫描更高效；对于中大型的表，索引就非常有效；对于特大型的表，建立和使用索引的代价非常大，需要通过分区技术来区分出查询需要的一组数据，而不是一条记录一条记录的匹配</li>
<li>索引列不能是表达式的一部分，也不能是函数的参数，应尽量简化WHERE条件，始终将索引列单独放在比较符号的一侧</li>
<li>对于BLOB、TEXT或者很长的VARCHAR类型的列，索引这些列的完整长度会让索引变得大且慢，此时应使用前缀索引并仔细考虑前缀长度，需要注意MySQL无法使用前缀索引做ORDER BY、GROUP BY以及覆盖扫描</li>
<li>在多个列上建立独立的单列索引大部分情况下并不能提高MySQL的查询性能，需要考虑建立合适的多列索引，但也并不一定始终将选择性最高的列放到索引最前列</li>
<li>不要创建重复索引（指在相同的列上按照相同的顺序创建的相同类型的索引），尽量避免创建冗余索引</li>
<li>尽可能设计既满足排序，又用于查找行的索引</li>
<li>确保关联查询时的ON或者USING子句中的列上有索引，只需要在关联顺序中的第二个表的相应列上创建索引</li>
<li>确保GROUP BY和ORDER BY中的表达式只涉及到一个表中的列，且列上有索引，这样MySQL才有可能使用索引来优化这个过程</li>
</ul>
<h1 id="3、优化"><a href="#3、优化" class="headerlink" title="3、优化"></a>3、优化</h1><p>优化主要就是在快速、精确和简单这三者之间尽量满足其二。</p>
<h2 id="3-1-查询"><a href="#3-1-查询" class="headerlink" title="3.1 查询"></a>3.1 查询</h2><h3 id="3-1-1-执行流程"><a href="#3-1-1-执行流程" class="headerlink" title="3.1.1 执行流程"></a>3.1.1 执行流程</h3><p>优化查询的目标在于降低查询的响应时间，查询性能低下最基本的原因是访问的数据太多，消耗大多时间，所以需要确认存储引擎是否在检索以及服务器是否在分析大量超过需要的数据。</p>
<p>要写一个好的查询，那么就要理解查询是如何被执行的，理解时间都被消耗在哪些地方，从而对查询进行优化，查询的执行流程如下</p>
<ul>
<li>客户端发送一条查询到服务器</li>
<li>服务器检查缓存，若命中缓存则立即返回缓存中的结果</li>
<li>若没有命中缓存，则进行SQL解析、预处理、并由优化器生成执行计划</li>
<li>根据执行计划调用存储引擎的API来执行查询（索引的作用就在于可以减少存储引擎需要访问的数据行）</li>
<li>存储引擎将检索到的数据返回给服务器，服务器进行调用后的数据处理，并将结果给客户端（如果查询可以被缓存，这时也会将结果存放到查询缓存中）</li>
</ul>
<h3 id="3-1-2-重构方式"><a href="#3-1-2-重构方式" class="headerlink" title="3.1.2 重构方式"></a>3.1.2 重构方式</h3><p>对MySQL连接来说，连接和断开连接都非常轻量级，在返回一个小的查询结果方面很高效，因此<strong>可以考虑将大查询切分为多个小查询</strong>。</p>
<p>对MySQL的查询缓存来说，如果关联中的某个表发生了变化，那么就无法使用查询缓存，因此<strong>可以将关联查询分解，对每个表进行单表查询并在应用程序中进行关联</strong>，与此同时，执行单个查询还可以减少锁竞争。</p>
<p>MySQL客户端和服务器之间的通信协议是半双工的，这意味着一旦客户端发送了请求，那么接下来就只能等待并完整地接收整个响应结果，而不能让服务器中途停止发送数据，因此<strong>必要时一定要在查询中加上LIMIT限制</strong>，从而让查询能够早点结束，早点释放相应的资源。</p>
<p>MySQL总是通过创建并填充临时表的方式来执行UNION，MySQL默认会给临时表加上DISTINCT选项，这会导致对整个临时表的数据做唯一性检查，代价非常高，因此<strong>除非确实需要服务器消除重复的行，则一定要使用UNION ALL关键字</strong>，此外，如果希望UNION的各个子句能够根据LIMIT只取部分结果集，或者希望先排序再合并结果集的话，就需要在UNION的各个子句中分别使用LIMIT和ORDER BY，然后再加上全局的LIMIT和ORDER BY。</p>
<p>COUNT() 函数可以统计某个列值的数量，也可以统计行数，如果在括号中指定了列或者列的表达式，则统计的就是这个表达式的非空结果数，如果括号中是<code>*</code>时，会忽略所有的列而直接统计所有的行数，此时效率更高，因此<strong>在需要统计列值的数量又确定该列均不为空时，最好使用COUNT(*)。</strong></p>
<h3 id="3-1-3-特定类型重构"><a href="#3-1-3-特定类型重构" class="headerlink" title="3.1.3 特定类型重构"></a>3.1.3 特定类型重构</h3><p>MySQL优化器在大多数情况下能够很好的工作，但依旧存在一定的局限性，会对某些类型的查询生成低效的执行计划，因此需要对这类查询进行改写重构，比如</p>
<ul>
<li><p>WHERE条件中使用IN() 或者EXISTS() 包含的子查询需要重构为关联查询</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> film</span><br><span class="line"><span class="keyword">WHERE</span> film_id <span class="keyword">IN</span> (<span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> film_actor <span class="keyword">WHERE</span> actor_id <span class="operator">=</span> <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> film</span><br><span class="line"><span class="keyword">WHERE</span> <span class="keyword">NOT</span> <span class="keyword">EXISTS</span> (<span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> film_actor <span class="keyword">WHERE</span> film_actor.film_id <span class="operator">=</span> film_id);</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 改为</span></span><br><span class="line"><span class="keyword">SELECT</span> film.<span class="operator">*</span> <span class="keyword">FROM</span> film</span><br><span class="line"><span class="keyword">INNER</span> <span class="keyword">JOIN</span> film_actor <span class="keyword">USING</span>(film_id)</span><br><span class="line"><span class="keyword">WHERE</span> actor_id <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">SELECT</span> film.<span class="operator">*</span> <span class="keyword">FROM</span> film</span><br><span class="line"><span class="keyword">LEFT</span> <span class="keyword">JOIN</span> film_actor <span class="keyword">USING</span>(film_id)</span><br><span class="line"><span class="keyword">WHERE</span> film_actor.film_id <span class="keyword">IS</span> <span class="keyword">NULL</span>;</span><br></pre></td></tr></table></figure></li>
<li><p>使用DISTINCT和GROUP BY的关联查询会产生临时表，需要重构为子查询</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="keyword">DISTINCT</span> film.<span class="operator">*</span> <span class="keyword">FROM</span> film</span><br><span class="line"><span class="keyword">INNER</span> <span class="keyword">JOIN</span> film_actor <span class="keyword">USING</span>(film_id);</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 改为</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> film</span><br><span class="line"><span class="keyword">WHERE</span> <span class="keyword">EXISTS</span> (<span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> film_actor <span class="keyword">WHERE</span> film_actor.film_id <span class="operator">=</span> film_id);</span><br></pre></td></tr></table></figure></li>
<li><p>关联查询做分组时，采用查找表的标识列来做分组的效率会比其他列更高，尤其是使用第二个表的标识列效率更高</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> actor.<span class="operator">*</span> <span class="keyword">FROM</span> film_actor</span><br><span class="line"><span class="keyword">INNER</span> <span class="keyword">JOIN</span> actor <span class="keyword">USING</span> (actor_id)</span><br><span class="line"><span class="keyword">GROUP</span> <span class="keyword">BY</span> actor.first_name, actor.last_name;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 改为</span></span><br><span class="line"><span class="keyword">SELECT</span> actor.<span class="operator">*</span> <span class="keyword">FROM</span> film_actor</span><br><span class="line"><span class="keyword">INNER</span> <span class="keyword">JOIN</span> actor <span class="keyword">USING</span> (actor_id)</span><br><span class="line"><span class="keyword">GROUP</span> <span class="keyword">BY</span> actor.actor_id;</span><br></pre></td></tr></table></figure></li>
<li><p>关联查询的SELECT中尽量不要使用非分组列，因为查询得到的非分组列的结果通常是不定的，如果使用非分组列则应确保该非分组列一定是直接依赖分组列，并且在每个分组中的值是唯一的，或者业务上根本不在乎这个值具体是什么</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> actor.<span class="operator">*</span> <span class="keyword">FROM</span> film_actor</span><br><span class="line"><span class="keyword">INNER</span> <span class="keyword">JOIN</span> actor <span class="keyword">USING</span> (actor_id)</span><br><span class="line"><span class="keyword">GROUP</span> <span class="keyword">BY</span> actor.actor_id;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 改为</span></span><br><span class="line"><span class="keyword">SELECT</span> actor.actor_id <span class="keyword">FROM</span> film_actor</span><br><span class="line"><span class="keyword">INNER</span> <span class="keyword">JOIN</span> actor <span class="keyword">USING</span> (actor_id)</span><br><span class="line"><span class="keyword">GROUP</span> <span class="keyword">BY</span> actor.actor_id;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 或者</span></span><br><span class="line"><span class="keyword">SELECT</span> actor.first_name, actor.last_name <span class="keyword">FROM</span> film_actor</span><br><span class="line"><span class="keyword">INNER</span> <span class="keyword">JOIN</span> actor <span class="keyword">USING</span> (actor_id)</span><br><span class="line"><span class="keyword">GROUP</span> <span class="keyword">BY</span> actor.actor_id;</span><br></pre></td></tr></table></figure></li>
<li><p>分组查询时，如果没有通过ORDER BY子句显示的指定排序列，结果集会自动按照分组列进行排序，如果不关心结果集的顺序，而这种默认又导致了需要文件排序，则应显示指定不需要排序，如果希望按照分组列进行排序，也应显示指定排序方向</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> actor.actor_id <span class="keyword">FROM</span> film_actor</span><br><span class="line"><span class="keyword">INNER</span> <span class="keyword">JOIN</span> actor <span class="keyword">USING</span> (actor_id)</span><br><span class="line"><span class="keyword">GROUP</span> <span class="keyword">BY</span> actor.actor_id;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 改为</span></span><br><span class="line"><span class="keyword">SELECT</span> actor.actor_id <span class="keyword">FROM</span> film_actor</span><br><span class="line"><span class="keyword">INNER</span> <span class="keyword">JOIN</span> actor <span class="keyword">USING</span> (actor_id)</span><br><span class="line"><span class="keyword">GROUP</span> <span class="keyword">BY</span> actor.actor_id</span><br><span class="line"><span class="keyword">ORDER</span> <span class="keyword">BY</span> <span class="keyword">NULL</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 或者</span></span><br><span class="line"><span class="keyword">SELECT</span> actor.actor_id <span class="keyword">FROM</span> film_actor</span><br><span class="line"><span class="keyword">INNER</span> <span class="keyword">JOIN</span> actor <span class="keyword">USING</span> (actor_id)</span><br><span class="line"><span class="keyword">GROUP</span> <span class="keyword">BY</span> actor.actor_id <span class="keyword">DESC</span>;</span><br></pre></td></tr></table></figure></li>
<li><p>当使用LIMIT且偏移量又非常大的时候，可以考虑使用覆盖索引来扫描大量偏移找到真正所需的行，然后根据需要做一次关联操作从而返回所需的列</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> film_id, description <span class="keyword">FROM</span> film</span><br><span class="line"><span class="keyword">ORDER</span> <span class="keyword">BY</span> title LIMIT <span class="number">1000</span>, <span class="number">5</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 改为</span></span><br><span class="line"><span class="keyword">SELECT</span> film_id, description <span class="keyword">FROM</span> film</span><br><span class="line"><span class="keyword">INNER</span> <span class="keyword">JOIN</span> (<span class="keyword">SELECT</span> film_id <span class="keyword">FROM</span> film <span class="keyword">ORDER</span> <span class="keyword">BY</span> title LIMIT <span class="number">1000</span>, <span class="number">5</span>) <span class="keyword">USING</span> (film_id);</span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="3-2-分区"><a href="#3-2-分区" class="headerlink" title="3.2 分区"></a>3.2 分区</h2><h3 id="3-2-1-分区表"><a href="#3-2-1-分区表" class="headerlink" title="3.2.1 分区表"></a>3.2.1 分区表</h3><p>对用户来说，分区表是一个独立的逻辑表，但是底层由多个物理子表组成。分区的主要目的是将数据按照一个较粗的粒度分在不同的表中，将相关的数据存放在一起。适用于大数据量的过滤场景。</p>
<p>MySQL通过对底层物理子表封装来实现分区表，所有的字表都是被隐藏的，只能通过分区表去访问字表。</p>
<p>MySQL存储引擎管理分区的各个底层表和管理普通表一样，从存储引擎的角度来看，分区底层表和普通表没有不同，无须区分。与此同时，索引也是按照分区的子表定义的，分区表的索引只是在各个底层表上各自加上一个完全相同的索引。</p>
<p>MySQL支持多种分区表。使用较多的是根据范围进行分区，每个分区存储落在某个范围的记录。除此之外，MySQL还支持键值、哈希和列表分区以及子分区。</p>
<p>分区表达式可以是列，也可以是包含列的表达式，但表达式返回的值必须是一个确定的整数，而且不能是一个常数。</p>
<h3 id="3-2-2-优势与限制"><a href="#3-2-2-优势与限制" class="headerlink" title="3.2.2 优势与限制"></a>3.2.2 优势与限制</h3><p>分区表的优点如下</p>
<ul>
<li>查询、批量删除、优化、检查、备份和修复时都很方便</li>
<li>将需要放入内存的数据范围缩小至小范围的热点数据</li>
<li>可令不同的分区分布在不同的物理设备上，高效利用多个硬件设备</li>
<li>减少InnoDB的单个索引的互斥访问、锁竞争等</li>
</ul>
<p>分区表的限制如下</p>
<ul>
<li>一个表最多只能有1024个分区</li>
<li>如果分区字段中有主键或者唯一索引的列，那么所有主键列和唯一索引列都必须包含进来</li>
<li>分区表中无法使用外键约束</li>
<li>所有的分区底层表都必须使用相同的存储引擎（有些存储引擎不支持分区）</li>
<li>索引作用范围在各个分区内，没有全局索引</li>
</ul>
<h3 id="3-2-3-使用分区"><a href="#3-2-3-使用分区" class="headerlink" title="3.2.3 使用分区"></a>3.2.3 使用分区</h3><p>数据库在根据索引的扫描结果回表查询所有符合条件的记录时，会产生大量的随机I/O，响应时间会大的不可接收的程度，此外，索引维护的代价也非常高。因此，在数据量超大的时候，B-Tree索引就无法起作用了（除非是覆盖索引），</p>
<p>此时，需要通过分区技术以代价非常小的方式区分出查询需要的较小范围的数据。因为分区不需要精确定位每条数据的位置，无需额外的数据结构记录每个分区有哪些数据，所以代价非常低，只需要一个简答的表达式就可以表达每个分区存放是什么数据。</p>
<p>使用分区表时需要注意的事项如下</p>
<ul>
<li><p>分区表达式的值不能为NULL</p>
<p>当表达式的值为NULL或者非法时，该记录会被存放到第一个分区，那么后续对数据进行操作时，不仅仅会全量扫描WHERE条件筛选出的分区，还会扫描存放NULL值和非法值的第一个分区，如果第一个分区非常大，数据操作的代价也就非常大</p>
</li>
<li><p>分区列与索引列匹配</p>
<p>如果定义的索引列和分区列不匹配，会导致查询无法进行分区过滤，应当避免建立与分区列不匹配的索引</p>
</li>
<li><p>范围分区的分区数尽量限制在100以下</p>
<p>在进行范围分区时，随着分区数的增长，搜索分区的成本越来越高，可以通过限制分区的数量来缓解（其他分区类型，比如键分区和哈希分区，则没有这样的问题）</p>
</li>
<li><p>使用批量操作而非单行单个操作</p>
<p>当查询访问分区表时，在分区过滤之前是需要打开并锁住所有底层表的，这对单行单个操作来说会带来明显的额外开销，因此可以用批量操作的方式来降低单个操作的此类开销</p>
</li>
<li><p>访问分区表时要在WHERE条件中带入分区列</p>
<p>即便在创建分区时可以使用表达式，但在在查询时只能根据列来过滤分区，不能根据表达式的值去过滤分区</p>
</li>
</ul>
<h2 id="3-3-缓存"><a href="#3-3-缓存" class="headerlink" title="3.3 缓存"></a>3.3 缓存</h2><h3 id="3-3-1-缓存与命中"><a href="#3-3-1-缓存与命中" class="headerlink" title="3.3.1 缓存与命中"></a>3.3.1 缓存与命中</h3><p>MySQL将缓存存放在一个引用表中，通过一个哈希值引用，从而缓存完整的SELECT查询结果。当判断缓存是否命中时，MySQL会直接使用SQL语句和客户端发送过来的其他原始信息进行比较，任何字符上的不同（包括空格、注释）都会导致缓存不命中。当查询命中该缓存，MySQL会立即返回结果（即使要查询的表被锁住时），跳过了解析、优化和执行阶段。</p>
<p>此外，当查询语句中具有不确定的数据或者任何用户自定义函数、用户变量、临时表以及包含列级权限的表时，则不会缓存结果；如果查询中涉及到任何一个表发生了变化，那么和这个表相关的所有的缓存数据以及关联表的缓存数据都将失效。</p>
<p>在一个InnoDB事务在提交之前，与该事务所修改的表相关的查询时无法被缓存的，因此长时间运行的事务会大大降低缓存的命中率。</p>
<h3 id="3-3-2-缓存与内存"><a href="#3-3-2-缓存与内存" class="headerlink" title="3.3.2 缓存与内存"></a>3.3.2 缓存与内存</h3><p>查询缓存是完全存储在内存中的，缓存数据包含维护相关的数据（大约40KB）和查询结果，用于查询结果的内存则被分为一个个变长的数据块。</p>
<p>当有查询结果需要缓存时，MySQL会申请一个数据块用于存储结果，由于需要在查询开始返回时结果时就分配空间，而此时是无法预知查询结果到底多大的，无法为每一个查询结果精确分配大小恰好匹配的缓存空间，因此可能会在缓存数据块之间留下很多内存碎片。</p>
<p>此外，如果缓存使用了很大的内存并存放了大量的查询结果，而在进行缓存失效操作时是需要通过一个全局锁来保护的，此时，所有需要做该操作的查询（无论是否命中缓存、还是缓存失效检测）都要等待这个锁，这就很可能导致整个系统都僵死一段时间，因此缓存过大时会带来过大的系统消耗。</p>
<p>查询缓存并不一定能起到正向作用，但对于复杂的SELECT语句且涉及到的UPDATE、DELETE和INSERT操作相比SELECT来说非常少的情况，可以使用查询缓存。</p>
<h3 id="3-3-3-缓存和InnoDB"><a href="#3-3-3-缓存和InnoDB" class="headerlink" title="3.3.3 缓存和InnoDB"></a>3.3.3 缓存和InnoDB</h3><p>因为InnoDB有自己的MVCC机制，所以相比其他存储引擎，InnoDB和查询缓存的交互要更加复杂。InnoDB会控制在一个事务中是否可以使用查询缓存，每一个InnoDB表的内存数据字典都保存了一个事务的ID号，而事务是否可以访问查询缓存取决于当前事务ID以及对应的数据表上是否有锁。</p>
<p>原则上，在InnoDB的MVCC架构下，当某些修改不影响其他事务读取一致的数据时，是可以使用查询缓存的，但是这样实现起来会非常复杂，InnoDB做了一个简化，让所有有加锁操作的事务都不使用任何查询缓存。</p>
<h3 id="3-3-4-使用缓存"><a href="#3-3-4-使用缓存" class="headerlink" title="3.3.4 使用缓存"></a>3.3.4 使用缓存</h3><p>库表结构的设计、查询语句、应用程序设计都可能会影响到查询缓存的效率，一些使用注意事项如下</p>
<ul>
<li>用多个小表代替一个大表对查询缓存有好处，这会使得失效策略能够在一个更合适的粒度上进行</li>
<li>批量写入相比单条写入效率更好，这会使得缓存失效操作只需进行一次，但不要同时做延迟写和批量写，这会导致服务器僵死较长时间</li>
<li>控制缓存空间，空间太大时进行过期操作会导致服务器僵死较长时间</li>
<li>对于写密集型的应用来说，直接禁用查询缓存可能会提高系统的性能</li>
<li>对于读密集型的应用来说，由于互斥信号量的竞争，有时也可以通过禁用缓存来提高性能</li>
<li>在高并发压力环境中查询缓存往往会导致系统性能的下降，此时不建议使用查询缓存</li>
</ul>
<h2 id="3-4-其他"><a href="#3-4-其他" class="headerlink" title="3.4 其他"></a>3.4 其他</h2><h3 id="3-4-1-视图"><a href="#3-4-1-视图" class="headerlink" title="3.4.1 视图"></a>3.4.1 视图</h3><p>视图本身是一个虚拟表，不存放任何数据，不能建立索引，而在使用SQL语言访问视图时，视图返回的数据是从MySQL从其他表中生成的。因此，视图就像是一个窗口，用户通过各种视图来从不同的角度查看自己感兴趣的数据。</p>
<p>在基于视图执行查询时，MySQL可以使用合并算法和临时表算法来实现视图。如果可能，会尽可能使用合并算法，但如果视图中包含GROUP BY、DISTINCT、任何聚合函数，UNION、子查询等只要无法在原表记录和视图记录中简历一一映射场景时，都会使用临时表算法来实现视图。当视图使用临时表时，无法将WHERE条件下推到各个具体的表，也不能使用任何索引。</p>
<p>使用临时表算法实现的视图在某些时候性能会很糟糕，而即使是基于合并算法实现的视图也会有额外的开销，而且视图的性能难以预测，所以视图在性能优化上还不是那么成熟。</p>
<h3 id="3-4-2-外键"><a href="#3-4-2-外键" class="headerlink" title="3.4.2 外键"></a>3.4.2 外键</h3><p>InnoDB是MySQL中唯一支持外键的内置存储引擎，外键用于确保两个相关表中始终有一致的数据列，但这也导致查询需要额外访问一些别的表，意味着需要额外的锁，甚至会导致一些死锁，且难以排查。</p>
<p>对于相关数据的同时更新使用外键更合适，但是如果外键只是用作数值约束，那么使用触发器或者显示的通过枚举来限制取值的性能会更好些。</p>
<p>如果设计的是一个高性能的系统，那么在更在意系统性能的情况下不会使用外键，而是通过应用程序来维护。</p>
<h3 id="3-4-3-触发器"><a href="#3-4-3-触发器" class="headerlink" title="3.4.3 触发器"></a>3.4.3 触发器</h3><p>触发器可以在执行增删改操作的前后执行一些特定的操作，可以读取或者改变触发SQL语句所影响的数据，因此，可以使用触发器实现一些强制限制，否则，就需要在应用程序中实现这些逻辑。</p>
<p>触发器可以用于自动更新反范式化数据以及记录变更日志等，可以保证数据总是一致的，可以减少客户端和服务器之间的通信，可以简化应用逻辑，还可以提高性能。</p>
<p>但对于每一个表的每一个事件，最多只能定义一个触发器，且MySQL只支持基于行的触发，即触发器始终是针对一条记录的，如果变更的数据集非常大的话，效率会很低。</p>
<p>在InnoDB表上的触发器是在同一个事务中完成的，原操作和触发器操作会同时失败或者成功，因此，在排查问题时原操作和触发器都需要进行排查。</p>
<h3 id="3-4-4-存储过程"><a href="#3-4-4-存储过程" class="headerlink" title="3.4.4 存储过程"></a>3.4.4 存储过程</h3><p>存储过程的执行效率低于应用程序，但优于某些操作，比如存储过程调用可以替代很多小查询时（节省了查询解析和网络开销）。</p>
<p>存储过程难以调试，MySQL也没有控制存储程序的资源消耗的方案，所以存储过程中的一个小错误可能直接把服务器拖死。</p>
<p>存储过程会给数据服务器增加额外的压力，而数据库服务器的扩展性相比应用程序要差很多。</p>
<p>最好不要复制对存储过程的调用，直接复制由存储过程程序改变的数据则会更好。</p>
<h1 id="4、复制"><a href="#4、复制" class="headerlink" title="4、复制"></a>4、复制</h1><p>复制解决的基本问题是让一台服务器的数据和其他服务器保持同步，实现一种“水平扩展”的架构，这种功能不仅有利于构建高性能的应用，同时也是死高可用性、可扩展性、灾难恢复、备份以及数据仓库等工作的基础。</p>
<p>通过复制所实现的“水平扩展”可以将读操作指向备库来获得更好的读扩展，但由于不能像分发读操作那样将写操作等同地分发到更多服务器上，随着查询数量的增加，需要的服务器数量的增加并非线性扩展，即当为单台主库增加备库时，将很快达到投入远高于回报的地步。因此，对于写操作，并不适合通过复制来扩展写操作，写操作通常是复制的瓶颈（对数据进行分区是唯一可以扩展写操作的方法）。</p>
<h2 id="4-1-复制方式"><a href="#4-1-复制方式" class="headerlink" title="4.1 复制方式"></a>4.1 复制方式</h2><h3 id="4-1-1-执行流程"><a href="#4-1-1-执行流程" class="headerlink" title="4.1.1 执行流程"></a>4.1.1 执行流程</h3><p>MySQL支持两种复制方式，基于行的复制和基于语句的复制，这两种方式都有以下三个步骤</p>
<ul>
<li>在主库每次提交事务完成数据更新前，把数据更改记录到二进制日志（这些记录被称为二进制日志事件），记录后主库会告知存储引擎可以提交事务了（MySQL会按事务提交的顺序而非每条语句的执行顺序来记录二进制日志）</li>
<li>备库启动一个I/O线程，该线程跟主库建立一个普通的客户端连接，然后在主库上启动一个二进制转储线程，该线程会自动读取主库上二进制日志中的事件，备库I/O线程会将接收到的事件记录到自己的中继日志中，完成从二进制日志到中继日志的复制</li>
<li>备库启动一个SQL线程来读取中继日志中的事件，将其重放到备库数据之上，实现异步的数据复制</li>
</ul>
<p>以上这种复制架构实现了获取事件和重放事件的解耦，允许这两个过程异步进行，但是<strong>由于备库只有一个SQL线程来重放中继日志中的事件，因此主库上并发运行的查询在备库只能串行化执行</strong>。此外，<strong>需要给每个服务器分配一个全局唯一的服务器ID</strong>，当复制SQL线程读中继日志时，会丢弃事件中记录的服务器ID和该服务器本身ID相同的事件，从而打破复制过程中的无限循环。</p>
<h3 id="4-1-2-两种方式对比"><a href="#4-1-2-两种方式对比" class="headerlink" title="4.1.2 两种方式对比"></a>4.1.2 两种方式对比</h3><p>基于语句的复制也称为逻辑复制，此时，主库会记录那些造成数据更改的查询，当备库读取并重放这些事件时，实际上只是把主库上执行过的SQL再执行一遍。</p>
<ul>
<li>逻辑复制实现起来非常简单，并且能让二进制日志里的事件更加紧凑</li>
<li>即便主备的模式不同（比如表的定义不同但数据类型相兼容，列的顺序不同等），逻辑复制依旧能够工作</li>
<li>逻辑复制基本上就是执行SQL，那么所有在服务器上发生的变更都以一种容易理解的方式运行，出现问题时可以很好地定位</li>
<li>考虑到同一条SQL在不同时刻下执行可能并不相同，因此在传输的二进制日志中，除了查询语句，还包括了一些元数据信息（比如当前的时间戳），即便如此，依旧存在无法一些被正确复制的SQL（比如使用了触发器或者存储过程）</li>
<li>由于更新必须是串行的，这意味着需要更多的锁，可能代价会很高</li>
<li>不是所有的存储引擎都支持这种复制模式</li>
<li>单线程的逻辑复制常常导致备库容量小于主库</li>
</ul>
<p>基于行的复制会将实际数据记录在二进制日志中。</p>
<ul>
<li>基于行的复制的最大的好处是可以正确的复制每一行数据，无需重放更新主库数据的查询，能更加高效的复制数据</li>
<li>因为基于行的复制并不要求这种强串行化是可重复的，因此可以减少锁的使用，也占用更少的CPU</li>
<li>基于行的复制模式下，如果在备库更新一个不存在的记录时会报错并停止复制，因此能够帮助找到并解决数据不一致的情况</li>
<li>但如果被更新的数据量非常大，比如全表更新，此时每一行的数据都会被记录到二进制日志中，这使得二进制日志事件非常庞大，复制开销会很大</li>
<li>基于行的复制并不知道主库中到底执行了哪些SQL，因此出现问题时很难找到问题所在</li>
</ul>
<p>MySQL默认情况下使用的是基于语句的复制方式，如果发现语句无法被正确地复制，就切换到基于行的复制模式。</p>
<h2 id="4-2-复制拓扑"><a href="#4-2-复制拓扑" class="headerlink" title="4.2 复制拓扑"></a>4.2 复制拓扑</h2><h3 id="4-2-1-主库和备库"><a href="#4-2-1-主库和备库" class="headerlink" title="4.2.1 主库和备库"></a>4.2.1 主库和备库</h3><p>可以在任意多个主库和备库之间建立复制，但要注意每个备库只能有一个主库，一个主库可以有多个备库，一个备库可以有多个兄弟备库，每个备库必须有唯一的服务器ID并保持ID不变，备库可以把其主库上的数据变化传播到其他备库。</p>
<ul>
<li>在有少量写和大量读时，可以使用一主多备的结构（备库之间没有交互），将读分摊到多个备库上，直到主备之间的带宽成为瓶颈为止，这种结构简单、灵活，避免了很多其他拓扑结构的复杂性</li>
<li>当两个处于不同地理位置的办公室，并且都需要一份可写的数据拷贝时，可以使用主-主复制的结构，两台服务器中的每一个都被配置成对方的主库和备库，这种结构最大的问题是解决冲突，需要仔细的配置划分数据和权限</li>
<li>主主复制结构的一个变体是令其中一台服务器是只读的被动服务器，这能很好的避免冲突，且由于配置是对称的，反复切换制动和被动服务器也非常方便，是构建容错性和高可用性的非常强大的方式</li>
<li>环形复制结构可以由三个或更多的主库，每个服务器都是它之前的服务器的备库，是它之后的服务器的主库，主主复制结构就是环形复制结构的一个特例，但两个服务器以上的环形结构不具备对称配置和简单的故障转移，并且完全依赖于环上的每一个可用节点，这大大增大了整个系统失效的几率，应该尽量避免这种脆弱的环形结构</li>
</ul>
<h3 id="4-2-2-分发主库"><a href="#4-2-2-分发主库" class="headerlink" title="4.2.2 分发主库"></a>4.2.2 分发主库</h3><p>复制操作在主库的开销主要是启用二进制日志带来的开销，备库对主库增加的网络I/O开销，唤醒复制线程发送时间的开销等。</p>
<p>每个备库会在主库上创建一个二进制转储线程来读取二进制日志文件中的数据并将其发送给备库，每个备库都重复这样的工作而不会共享资源。那么当备库足够多并且有很大的事件时，主库上的负载会显著上升，甚至可能由于备库同时请求同样的事件而耗尽内存并崩溃或者是大量的磁盘检索。</p>
<p>如果需要多个备库，可以从主库移除负载并使用分发主库。分发主库事实上也是一个备库，它的唯一目的就是提取主库的二进制日志。此时，多个备库连接到分发主库而非原来的主库。这种主库、分发主库以及备库组成的复制拓扑结构使原来的主库摆脱大量备库带来的负担。</p>
<p>此外，分发主库还可以用于对二进制日志事件执行过滤和重写规则，这比在每个备库上重复进行日志记录、重写和过滤要高效很多。但由于分发主库的存在，各个备库与原始主库的二进制日志坐标已经不相同的，所以无法使用一个备库来代替主库。</p>
<h3 id="4-2-3-定制化方案"><a href="#4-2-3-定制化方案" class="headerlink" title="4.2.3 定制化方案"></a>4.2.3 定制化方案</h3><p>MySQL可以根据需要定制解决方案，典型的定制方案包括组合过滤、分发和向不同的存储引擎复制，这其中最大的限制是合理地监控、管理以及所拥有的资源的约束（比如网络带宽、CPU能力等）。</p>
<ul>
<li>选择性复制：在主库上将数据划分到不同的数据库里，将数据库复制到不同的备库上</li>
<li>分离功能：在线事务处理（OLTP）查询比较短并且是事务型的，在线数据分析（OLAP）查询通常很大，也很慢，并且不要求绝对最新的数据，这两种查询给服务器带来的负担不同，需要不同的配置，可使用不同的备库上来执行</li>
<li>数据归档：在备库上保留主库上删除过的数据，实现数据归档</li>
<li>日志服务器：通过创建没有数据的日志服务器，用于可靠的地存储主库的二进制日志，更加容易重放和过滤二进制日志事件，对崩溃后重启复制也很有帮助</li>
</ul>
<h1 id="5、备份"><a href="#5、备份" class="headerlink" title="5、备份"></a>5、备份</h1><p>对于备份来说，复制是一项很有意义的技术补充，但复制既不是备份也不能够取代备份。</p>
<p>在上一章介绍了数据库之间的增量数据更新的复制方式，然而在一种更加典型的案例（同时也是大多数情况）下，有一个已经运行了一段时间的主库，然后用一台新安装的备库与之同步，此时需要考虑存量数据的复制，可以通过以下方式中任意一种来实现复制</p>
<ul>
<li>冷备份：关闭主库，然后将数据复制到备库，重启主库后，使用一个新的二进制日志文件</li>
<li>热备份：如果仅使用了MyISAM表，可以在主库运行时通过热备份来复制数据</li>
<li>使用快照或备份：如果知道对应的二进制日志坐标，就可以使用主库的快照或者备份来初始化备库（如果使用备份，需要确保存在从备份的时间点开始到现在的主库二进制日志）</li>
</ul>
<h1 id="6、补充"><a href="#6、补充" class="headerlink" title="6、补充"></a>6、补充</h1><p><strong>（这些补充内容以后有空单开一篇详细学下）</strong></p>
<h2 id="基准测试"><a href="#基准测试" class="headerlink" title="基准测试"></a>基准测试</h2><p>基准测试是针对系统设计的一种压力测试，可以观察系统在不同压力下的行为。在新系统正式上线到生产环境之前都应该进行基准测试，而且，基准测试应该运行足够长的时间，应该确认测试结果可重复。</p>
<p>可以考虑的测试指标有</p>
<ul>
<li>吞吐量：指单位时间内的事务处理数，常用的测试单位是每秒事务数（TPS）或每分钟事务数（TPM）</li>
<li>响应时间或延迟：指测试任务所需的整体时间</li>
<li>并发性：指任意时间内有多少同时发生的并发请求，并发性测试通常不是为了测试应用能达到的并发度，而是为了测试应用在不同并发下的性能</li>
<li>可扩展性：指系统资源增加时系统性能的提升情况（理想情况下是呈线性提升），可扩展性指标便于发现系统应用的瓶颈</li>
</ul>
<p>归根结底，应当尽可能收集一些需求，测试那些对用户来说最重要的指标。</p>
<h2 id="性能剖析"><a href="#性能剖析" class="headerlink" title="性能剖析"></a>性能剖析</h2><p>性能剖析（profiling）用于测量服务器的时间花费在哪里并生成剖析报告，项目中应尽量包含性能剖析的代码。</p>
<p>注：</p>
<ul>
<li>“查询”泛指所有发送给服务器的命令</li>
<li>性能用查询的响应时间来度量</li>
<li>性能优化是指在一定的工作负载下尽可能地降低响应时间</li>
</ul>
<h1 id="7、参考资料"><a href="#7、参考资料" class="headerlink" title="7、参考资料"></a>7、参考资料</h1><ul>
<li>《High Performance MySQL, Third Edition》</li>
</ul>
</section>
    <!-- Tags START -->
    
    <!-- Tags END -->
    <!-- NAV START -->
    
  <div class="nav-container">
    <!-- reverse left and right to put prev and next in a more logic postition -->
    
      <a class="nav-left" href="/2022/07/02/accident/">
        <span class="nav-arrow">← </span>
        
          Accident -
        
      </a>
    
    
      <a class="nav-right" href="/2022/09/01/week-1/">
        
          2022.8.29 - 2022.9.2
        
        <span class="nav-arrow"> →</span>
      </a>
    
  </div>

    <!-- NAV END -->
    <!-- 打赏 START -->
    
    <!-- 打赏 END -->
    <!-- 二维码 START -->
    
    <!-- 二维码 END -->
    
      <!-- Utterances START -->
      <div id="utterances"></div>
      <script src="https://utteranc.es/client.js"
        repo=""
        issue-term="pathname"
        theme="github-light"
        crossorigin="anonymous"
        async></script>    
      <!-- Utterances END -->
    
  </article>
  <!-- Article END -->
  <!-- Content START -->
  
    <aside class="content-container">
  <div class="toc-main">
  
      
          <strong class="toc-title">CONTENT</strong>
          <ol class="toc-nav"><li class="toc-nav-item toc-nav-level-1"><a class="toc-nav-link" href="#1%E3%80%81%E6%A6%82%E8%BF%B0"><span class="toc-nav-text">1、概述</span></a><ol class="toc-nav-child"><li class="toc-nav-item toc-nav-level-2"><a class="toc-nav-link" href="#1-1-%E5%9F%BA%E7%A1%80%E6%A6%82%E5%BF%B5"><span class="toc-nav-text">1.1 基础概念</span></a><ol class="toc-nav-child"><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#1-1-1-%E4%BA%8B%E5%8A%A1"><span class="toc-nav-text">1.1.1 事务</span></a></li><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#1-1-2-%E5%B9%B6%E5%8F%91%E4%B8%80%E8%87%B4%E6%80%A7%E9%97%AE%E9%A2%98"><span class="toc-nav-text">1.1.2 并发一致性问题</span></a></li><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#1-1-3-%E9%9A%94%E7%A6%BB%E7%BA%A7%E5%88%AB"><span class="toc-nav-text">1.1.3 隔离级别</span></a></li></ol></li><li class="toc-nav-item toc-nav-level-2"><a class="toc-nav-link" href="#1-2-MySQL%E6%9E%B6%E6%9E%84"><span class="toc-nav-text">1.2 MySQL架构</span></a></li><li class="toc-nav-item toc-nav-level-2"><a class="toc-nav-link" href="#1-3-MySQL%E5%AD%98%E5%82%A8%E5%BC%95%E6%93%8E"><span class="toc-nav-text">1.3 MySQL存储引擎</span></a></li><li class="toc-nav-item toc-nav-level-2"><a class="toc-nav-link" href="#1-4-MySQL%E7%89%B9%E6%80%A7"><span class="toc-nav-text">1.4 MySQL特性</span></a></li></ol></li><li class="toc-nav-item toc-nav-level-1"><a class="toc-nav-link" href="#2%E3%80%81%E8%AE%BE%E8%AE%A1"><span class="toc-nav-text">2、设计</span></a><ol class="toc-nav-child"><li class="toc-nav-item toc-nav-level-2"><a class="toc-nav-link" href="#2-1-%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B"><span class="toc-nav-text">2.1 数据类型</span></a><ol class="toc-nav-child"><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#2-1-1-%E6%95%B4%E6%95%B0%E7%B1%BB%E5%9E%8B"><span class="toc-nav-text">2.1.1 整数类型</span></a></li><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#2-1-2-%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%B1%BB%E5%9E%8B"><span class="toc-nav-text">2.1.2 字符串类型</span></a></li><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#2-1-3-%E6%97%A5%E6%9C%9F%E5%92%8C%E6%97%B6%E9%97%B4%E7%B1%BB%E5%9E%8B"><span class="toc-nav-text">2.1.3 日期和时间类型</span></a></li></ol></li><li class="toc-nav-item toc-nav-level-2"><a class="toc-nav-link" href="#2-2-%E8%8C%83%E5%BC%8F"><span class="toc-nav-text">2.2 范式</span></a><ol class="toc-nav-child"><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#2-2-1-%E5%AE%9A%E4%B9%89"><span class="toc-nav-text">2.2.1 定义</span></a></li><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#2-2-3-%E8%8C%83%E5%BC%8F%E5%92%8C%E5%8F%8D%E8%8C%83%E5%BC%8F"><span class="toc-nav-text">2.2.3 范式和反范式</span></a></li><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#2-2-4-%E7%BC%93%E5%AD%98%E8%A1%A8%E5%92%8C%E6%B1%87%E6%80%BB%E8%A1%A8"><span class="toc-nav-text">2.2.4 缓存表和汇总表</span></a></li></ol></li><li class="toc-nav-item toc-nav-level-2"><a class="toc-nav-link" href="#2-3-%E7%B4%A2%E5%BC%95"><span class="toc-nav-text">2.3 索引</span></a><ol class="toc-nav-child"><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#2-3-1-B-Tree%E7%B4%A2%E5%BC%95"><span class="toc-nav-text">2.3.1 B-Tree索引</span></a></li><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#2-3-2-%E5%93%88%E5%B8%8C%E7%B4%A2%E5%BC%95"><span class="toc-nav-text">2.3.2 哈希索引</span></a></li><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#2-3-3-%E5%85%A8%E6%96%87%E7%B4%A2%E5%BC%95"><span class="toc-nav-text">2.3.3 全文索引</span></a></li><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#2-3-4-%E8%81%9A%E7%B0%87%E7%B4%A2%E5%BC%95"><span class="toc-nav-text">2.3.4 聚簇索引</span></a></li><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#2-3-5-%E8%A6%86%E7%9B%96%E7%B4%A2%E5%BC%95"><span class="toc-nav-text">2.3.5 覆盖索引</span></a></li><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#2-3-6-%E9%AB%98%E6%80%A7%E8%83%BD%E7%B4%A2%E5%BC%95"><span class="toc-nav-text">2.3.6 高性能索引</span></a></li></ol></li></ol></li><li class="toc-nav-item toc-nav-level-1"><a class="toc-nav-link" href="#3%E3%80%81%E4%BC%98%E5%8C%96"><span class="toc-nav-text">3、优化</span></a><ol class="toc-nav-child"><li class="toc-nav-item toc-nav-level-2"><a class="toc-nav-link" href="#3-1-%E6%9F%A5%E8%AF%A2"><span class="toc-nav-text">3.1 查询</span></a><ol class="toc-nav-child"><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#3-1-1-%E6%89%A7%E8%A1%8C%E6%B5%81%E7%A8%8B"><span class="toc-nav-text">3.1.1 执行流程</span></a></li><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#3-1-2-%E9%87%8D%E6%9E%84%E6%96%B9%E5%BC%8F"><span class="toc-nav-text">3.1.2 重构方式</span></a></li><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#3-1-3-%E7%89%B9%E5%AE%9A%E7%B1%BB%E5%9E%8B%E9%87%8D%E6%9E%84"><span class="toc-nav-text">3.1.3 特定类型重构</span></a></li></ol></li><li class="toc-nav-item toc-nav-level-2"><a class="toc-nav-link" href="#3-2-%E5%88%86%E5%8C%BA"><span class="toc-nav-text">3.2 分区</span></a><ol class="toc-nav-child"><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#3-2-1-%E5%88%86%E5%8C%BA%E8%A1%A8"><span class="toc-nav-text">3.2.1 分区表</span></a></li><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#3-2-2-%E4%BC%98%E5%8A%BF%E4%B8%8E%E9%99%90%E5%88%B6"><span class="toc-nav-text">3.2.2 优势与限制</span></a></li><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#3-2-3-%E4%BD%BF%E7%94%A8%E5%88%86%E5%8C%BA"><span class="toc-nav-text">3.2.3 使用分区</span></a></li></ol></li><li class="toc-nav-item toc-nav-level-2"><a class="toc-nav-link" href="#3-3-%E7%BC%93%E5%AD%98"><span class="toc-nav-text">3.3 缓存</span></a><ol class="toc-nav-child"><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#3-3-1-%E7%BC%93%E5%AD%98%E4%B8%8E%E5%91%BD%E4%B8%AD"><span class="toc-nav-text">3.3.1 缓存与命中</span></a></li><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#3-3-2-%E7%BC%93%E5%AD%98%E4%B8%8E%E5%86%85%E5%AD%98"><span class="toc-nav-text">3.3.2 缓存与内存</span></a></li><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#3-3-3-%E7%BC%93%E5%AD%98%E5%92%8CInnoDB"><span class="toc-nav-text">3.3.3 缓存和InnoDB</span></a></li><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#3-3-4-%E4%BD%BF%E7%94%A8%E7%BC%93%E5%AD%98"><span class="toc-nav-text">3.3.4 使用缓存</span></a></li></ol></li><li class="toc-nav-item toc-nav-level-2"><a class="toc-nav-link" href="#3-4-%E5%85%B6%E4%BB%96"><span class="toc-nav-text">3.4 其他</span></a><ol class="toc-nav-child"><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#3-4-1-%E8%A7%86%E5%9B%BE"><span class="toc-nav-text">3.4.1 视图</span></a></li><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#3-4-2-%E5%A4%96%E9%94%AE"><span class="toc-nav-text">3.4.2 外键</span></a></li><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#3-4-3-%E8%A7%A6%E5%8F%91%E5%99%A8"><span class="toc-nav-text">3.4.3 触发器</span></a></li><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#3-4-4-%E5%AD%98%E5%82%A8%E8%BF%87%E7%A8%8B"><span class="toc-nav-text">3.4.4 存储过程</span></a></li></ol></li></ol></li><li class="toc-nav-item toc-nav-level-1"><a class="toc-nav-link" href="#4%E3%80%81%E5%A4%8D%E5%88%B6"><span class="toc-nav-text">4、复制</span></a><ol class="toc-nav-child"><li class="toc-nav-item toc-nav-level-2"><a class="toc-nav-link" href="#4-1-%E5%A4%8D%E5%88%B6%E6%96%B9%E5%BC%8F"><span class="toc-nav-text">4.1 复制方式</span></a><ol class="toc-nav-child"><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#4-1-1-%E6%89%A7%E8%A1%8C%E6%B5%81%E7%A8%8B"><span class="toc-nav-text">4.1.1 执行流程</span></a></li><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#4-1-2-%E4%B8%A4%E7%A7%8D%E6%96%B9%E5%BC%8F%E5%AF%B9%E6%AF%94"><span class="toc-nav-text">4.1.2 两种方式对比</span></a></li></ol></li><li class="toc-nav-item toc-nav-level-2"><a class="toc-nav-link" href="#4-2-%E5%A4%8D%E5%88%B6%E6%8B%93%E6%89%91"><span class="toc-nav-text">4.2 复制拓扑</span></a><ol class="toc-nav-child"><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#4-2-1-%E4%B8%BB%E5%BA%93%E5%92%8C%E5%A4%87%E5%BA%93"><span class="toc-nav-text">4.2.1 主库和备库</span></a></li><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#4-2-2-%E5%88%86%E5%8F%91%E4%B8%BB%E5%BA%93"><span class="toc-nav-text">4.2.2 分发主库</span></a></li><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#4-2-3-%E5%AE%9A%E5%88%B6%E5%8C%96%E6%96%B9%E6%A1%88"><span class="toc-nav-text">4.2.3 定制化方案</span></a></li></ol></li></ol></li><li class="toc-nav-item toc-nav-level-1"><a class="toc-nav-link" href="#5%E3%80%81%E5%A4%87%E4%BB%BD"><span class="toc-nav-text">5、备份</span></a></li><li class="toc-nav-item toc-nav-level-1"><a class="toc-nav-link" href="#6%E3%80%81%E8%A1%A5%E5%85%85"><span class="toc-nav-text">6、补充</span></a><ol class="toc-nav-child"><li class="toc-nav-item toc-nav-level-2"><a class="toc-nav-link" href="#%E5%9F%BA%E5%87%86%E6%B5%8B%E8%AF%95"><span class="toc-nav-text">基准测试</span></a></li><li class="toc-nav-item toc-nav-level-2"><a class="toc-nav-link" href="#%E6%80%A7%E8%83%BD%E5%89%96%E6%9E%90"><span class="toc-nav-text">性能剖析</span></a></li></ol></li><li class="toc-nav-item toc-nav-level-1"><a class="toc-nav-link" href="#7%E3%80%81%E5%8F%82%E8%80%83%E8%B5%84%E6%96%99"><span class="toc-nav-text">7、参考资料</span></a></li></ol>
      
  
  </div>
</aside>
  
  <!-- Content END -->
</main>

<script>
  (function () {
    var url = 'http://example.com/2022/08/06/mysql/';
    var banner = ''
    if (banner !== '' && banner !== 'undefined' && banner !== 'null') {
      $('#article-banner').css({
        'background-image': 'url(' + banner + ')'
      })
    } else {
      $('#article-banner').geopattern(url)
    }
    $('.header').removeClass('fixed-header')

    // error image
    $(".markdown-content img").on('error', function() {
      $(this).attr('src', '/css/images/error_icon.png')
      $(this).css({
        'cursor': 'default'
      })
    })

    // zoom image
    $(".markdown-content img").on('click', function() {
      var src = $(this).attr('src')
      if (src !== '/css/images/error_icon.png') {
        var imageW = $(this).width()
        var imageH = $(this).height()

        var zoom = ($(window).width() * 0.95 / imageW).toFixed(2)
        zoom = zoom < 1 ? 1 : zoom
        zoom = zoom > 2 ? 2 : zoom
        var transY = (($(window).height() - imageH) / 2).toFixed(2)

        $('body').append('<div class="image-view-wrap"><div class="image-view-inner"><img src="'+ src +'" /></div></div>')
        $('.image-view-wrap').addClass('wrap-active')
        $('.image-view-wrap img').css({
          'width': `${imageW}`,
          'transform': `translate3d(0, ${transY}px, 0) scale3d(${zoom}, ${zoom}, 1)`
        })
        $('html').css('overflow', 'hidden')

        $('.image-view-wrap').on('click', function() {
          $(this).remove()
          $('html').attr('style', '')
        })
      }
    })
  })();
</script>







    <div class="scroll-top">
  <span class="arrow-icon"></span>
</div>
    <!--
<footer class="app-footer">
  <p class="copyright">
    &copy; 2024 | Proudly powered by <a href="https://hexo.io" target="_blank">Hexo</a>
    <br>
    Theme by <a target="_blank" rel="noopener" href="https://github.com/yanm1ng">yanm1ng</a>
    
  </p>
</footer>
-->

<script>
  function async(u, c) {
    var d = document, t = 'script',
      o = d.createElement(t),
      s = d.getElementsByTagName(t)[0];
    o.src = u;
    if (c) { o.addEventListener('load', function (e) { c(null, e); }, false); }
    s.parentNode.insertBefore(o, s);
  }
</script>
<script>
  async("//cdnjs.cloudflare.com/ajax/libs/fastclick/1.0.6/fastclick.min.js", function(){
    FastClick.attach(document.body);
  })
</script>

<script>
  var hasLine = 'true';
  async("//cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/highlight.min.js", function(){
    $('figure pre').each(function(i, block) {
      var figure = $(this).parents('figure');
      if (hasLine === 'false') {
        figure.find('.gutter').hide();
      }
      hljs.configure({useBR: true});
      var lang = figure.attr('class').split(' ')[1] || 'code';
      var codeHtml = $(this).html();
      var codeTag = document.createElement('code');
      codeTag.className = lang;
      codeTag.innerHTML = codeHtml;
      $(this).attr('class', '').empty().html(codeTag);
      figure.attr('data-lang', lang.toUpperCase());
      hljs.highlightBlock(block);
    });
  })
</script>
<!-- Baidu Tongji -->


<script src="/js/script.js"></script>


  </body>
</html>
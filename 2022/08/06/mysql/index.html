<!DOCTYPE html>
<html>
  <head>
  <meta http-equiv="content-type" content="text/html; charset=utf-8">
  <meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport">
  <meta name="description" content="要有一个从输入到输出的过程">
  <meta name="keyword" content="hexo-theme, vuejs">
  
    <link rel="shortcut icon" href="/css/images/logo.png">
  
  <title>
    
      MySQL | CQ&#39;s Blog
    
  </title>
  <link href="//cdnjs.cloudflare.com/ajax/libs/font-awesome/4.7.0/css/font-awesome.min.css" rel="stylesheet">
  <link href="//cdnjs.cloudflare.com/ajax/libs/nprogress/0.2.0/nprogress.min.css" rel="stylesheet">
  <link href="//cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/tomorrow.min.css" rel="stylesheet">
  
<link rel="stylesheet" href="/css/style.css">

  
  <script src="//cdnjs.cloudflare.com/ajax/libs/jquery/3.2.1/jquery.min.js"></script>
  <script src="//cdnjs.cloudflare.com/ajax/libs/geopattern/1.2.3/js/geopattern.min.js"></script>
  <script src="//cdnjs.cloudflare.com/ajax/libs/nprogress/0.2.0/nprogress.min.js"></script>
  
  
  
  
    <!-- MathJax support START -->
    <script type="text/x-mathjax-config">
      MathJax.Hub.Config({
        tex2jax: {
          inlineMath: [ ['$','$'], ["\\(","\\)"]  ],
          processEscapes: true,
          skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
        }
      });
    </script>

    <script type="text/x-mathjax-config">
      MathJax.Hub.Queue(function() {
        var all = MathJax.Hub.getAllJax(), i;
        for (i=0; i < all.length; i += 1) {
          all[i].SourceElement().parentNode.className += ' has-jax';
        }
      });
    </script>
    <script type="text/javascript" src="//cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
    <!-- MathJax support END -->
  


  
  
    
<script src="/js/local-search.js"></script>


<meta name="generator" content="Hexo 5.4.2"></head>
<div class="wechat-share">
  <img src="/css/images/logo.png" />
</div>
  <body>
    <header class="header fixed-header">
  <div class="header-container">
    <a class="home-link" href="/">
      <div class="logo"></div>
      <span>CQ's Blog</span>
    </a>
    <ul class="right-list">
      
        <li class="list-item">
          
            <a href="/" class="item-link">Home</a>
          
        </li>
      
        <li class="list-item">
          
            <a href="/" class="item-link">Categories</a>
          
        </li>
      
        <li class="list-item">
          
            <a href="/records" class="item-link">Records</a>
          
        </li>
      
        <li class="list-item">
          
            <a href="/scratches/" class="item-link">Scratches</a>
          
        </li>
      
        <li class="list-item">
          
            <a href="/archives/" class="item-link">Archives</a>
          
        </li>
      
      
        <li class="menu-item menu-item-search right-list">
    <a role="button" class="popup-trigger">
        <i class="fa fa-search fa-fw"></i>
    </a>
</li>
      
    </ul>
    <div class="menu">
      <span class="icon-bar"></span>
      <span class="icon-bar"></span>
      <span class="icon-bar"></span>
    </div>
    <div class="menu-mask">
      <ul class="menu-list">
        
          <li class="menu-item">
            
              <a href="/" class="menu-link">Home</a>
            
          </li>
        
          <li class="menu-item">
            
              <a href="/" class="menu-link">Categories</a>
            
          </li>
        
          <li class="menu-item">
            
              <a href="/records" class="menu-link">Records</a>
            
          </li>
        
          <li class="menu-item">
            
              <a href="/scratches/" class="menu-link">Scratches</a>
            
          </li>
        
          <li class="menu-item">
            
              <a href="/archives/" class="menu-link">Archives</a>
            
          </li>
        
      </ul>
    </div>
    
      <div class="search-pop-overlay">
    <div class="popup search-popup">
        <div class="search-header">
            <span class="search-icon">
                <i class="fa fa-search"></i>
            </span>
            <div class="search-input-container">
                <input autocomplete="off" autocapitalize="off"
                    placeholder="Please enter your keyword(s) to search." spellcheck="false"
                    type="search" class="search-input">
            </div>
            <span class="popup-btn-close">
                <i class="fa fa-times-circle"></i>
            </span>
        </div>
        <div id="search-result">
            <div id="no-result">
                <i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i>
            </div>
        </div>
    </div>
</div>
    
  </div>
</header>

    <div id="article-banner">
  <h2>MySQL</h2>
  <!--<p class="post-date">2022-08-06</p>
  <div class="arrow-down">
    <a href="javascript:;"></a>
  </div>-->
</div>
<main class="app-body flex-box">
  <!-- Article START -->
  <article class="post-article">
    <section class="markdown-content"><h1 id="1、概述"><a href="#1、概述" class="headerlink" title="1、概述"></a>1、概述</h1><h2 id="1-1-基础概念"><a href="#1-1-基础概念" class="headerlink" title="1.1 基础概念"></a>1.1 基础概念</h2><h3 id="1-1-1-关系型数据库"><a href="#1-1-1-关系型数据库" class="headerlink" title="1.1.1 关系型数据库"></a>1.1.1 关系型数据库</h3><p>关系型数据库是指采用了关系模型来组织数据的数据库，可以简单理解为二维表格模型，常见的 MySQL、Oracle 都是关系型数据库</p>
<ul>
<li>以行和列的形式组织数据，以便用户管理</li>
<li>采用结构化查询语言（SQL）来对数据库进行查询，支持各种范围查询、公式计算等</li>
<li>数据通常存储在硬盘中（这导致了一定的性能问题），MySQL 可以基于内存存储</li>
<li>十分强调规范化设计原则（三范式）、数据一致性、事务以及读写性能</li>
</ul>
<p>NoSQL 表示非关系型数据库，比如 Redis、MongoDB 等</p>
<ul>
<li>主要指那些非关系型的、分布式的，一般不保证事务的数据存储系统，一般无法回滚（MongoDB 在集群模式下可以回滚）</li>
<li>无需提前设计表结构，数据可以根据需要自由地存储和组织，高效灵活，非常适合那些复杂、高变化、高并发量的场景</li>
<li>基于键值来存储数据，通过 key 来查询数据，不一定支持范围查询、公式计算等，对于 value 的类型有不同的支持，没有固定的要求和限制</li>
<li>数据通常存储在内存中（MongoDB 基于磁盘存储）</li>
</ul>
<h3 id="1-1-2-事务"><a href="#1-1-2-事务" class="headerlink" title="1.1.2 事务"></a>1.1.2 事务</h3><p>事务是一组数据库操作序列，是一个独立的工作单元，事务应当具备四个特性：</p>
<ul>
<li>原子性（atomicity）：一个事务必须被视为一个不可分割的最小工作单元，整个事务中的所有操作要么全部执行成功，要么全部执行失败。</li>
<li>一致性（consistency）：确保数据库总是从一个一致性的状态转换到另一个一致性的状态，在一致性状态下，所有事务对同一数据的读取结果都是相同的。</li>
<li>隔离性（isolation）：一个事务所做的修改在最终提交之前，对其他事务是不可见的，即一个事务的执行不会对其他事务执行产生影响。</li>
<li>持久性（durability）：一旦事务提交，则其所做的修改就会永远保存到数据库中，持久性是有很多不同级别的。</li>
</ul>
<p>满足 ACID 特性的事务处理系统才是一个运行良好的系统，这种事务处理过程中额外的安全性也会需要数据库系统做更多额外的工作，需要更强的 CPU 处理能力，更大的内存和更多的磁盘空间。</p>
<h3 id="1-1-3-并发一致性问题"><a href="#1-1-3-并发一致性问题" class="headerlink" title="1.1.3 并发一致性问题"></a>1.1.3 并发一致性问题</h3><p>当事务的一致性没有满足时，就会出现一些并发一致性问题：</p>
<ul>
<li>脏读：一个事务读到其他事务还未提交的修改数据，假如其他事务撤销了该修改，那么当前事务读到的就是脏数据/无效数据。</li>
<li>不可重复读：一个事务多次读取同一数据集合，假如此时有其他事务对这一数据集合进行了修改，那么当前事务多次读取到的结果是不同的。</li>
<li>幻读：一个事务多次读取同一数据集合，假如此时有其他事务对这一数据集合进行了插入或者删除，那么当前事务就会读取到幻行（行数不一致），是不可重复读的一种特殊场景。</li>
</ul>
<h3 id="1-1-4-隔离级别"><a href="#1-1-4-隔离级别" class="headerlink" title="1.1.4 隔离级别"></a>1.1.4 隔离级别</h3><p>在 SQL 标准中定义了四种隔离级别：</p>
<ul>
<li>未提交读（READ UNCOMMITED）<ul>
<li>事务中的修改即使没有提交，对其他事务也都是可见的；</li>
<li>此时会出现脏读、不可重复读以及幻读。</li>
</ul>
</li>
<li>提交读（READ COMMITED）<ul>
<li>一个事务从开始到提交之前，所做的修改对其他事务都是不可见的；</li>
<li>是 Oracle 等大多数数据库系统的默认事务隔离级别；</li>
<li>此时可能会出现不可重复读和幻读。</li>
</ul>
</li>
<li>可重复读（REPEATABLE READ）<ul>
<li>在同一事务中多次读取同一数据的结果是一样的；</li>
<li>是 MySQL 的默认事务隔离级别；</li>
<li>可能会出现幻读。</li>
</ul>
</li>
<li>可串行化（SERIALIZABLE）<ul>
<li>强制事务串行执行；</li>
<li>这一隔离级别需要加锁来实现；</li>
<li>不会出现并发一致性问题。</li>
</ul>
</li>
</ul>
<p>较低级别的隔离通常可以执行更高的并发，系统的开销也更低，但需要开发人员自行解决该隔离级别无法保证解决的问题。</p>
<p>注：</p>
<ul>
<li>Oracle 只支持 READ COMMITED、SERIALIZABLE、READ-ONLY 这三种隔离级别，显然 SERIALIZABLE 和 READ-ONLY 不适合作为默认级别，那就只剩下 READ COMMITED 这一个默认选择了</li>
<li>MySQL 的定位是一个稳定的关系型数据库，那么为了解决单点故障就引入了主从复制机制，为了保证主从服务器之间的数据一致性就需要通过 BinLog 进行数据同步，早期的 BinLog 只有 statement 这种记录格式（即记录 SQL 语句原文），如果此时使用 READ COMMITED 这一隔离级别，那么一旦后执行的 SQL 先被提交，也就先被记录到 BinLog 中，BinLog 中记录的 SQL 的执行顺序的错误会导致从表的数据与主表不一致，而在 REPEATABLE READ 这一隔离级别下，间隙锁会保证一定是先执行的 SQL 先被提交，从而避免后续的一系列问题，因此 MySQL 使用 REPEATABLE READ 作为默认的隔离级别</li>
<li>后来 MySQL 的 BinLog 出现了 statement 以外的其他记录格式（row 和 mixed），其中 row 格式可以在 READ COMMITED 下正常工作，此时就可以将 MySQL 的隔离级别改为 READ COMMITED，从而执行更高的并发</li>
</ul>
<h2 id="1-2-MySQL"><a href="#1-2-MySQL" class="headerlink" title="1.2 MySQL"></a>1.2 MySQL</h2><h3 id="1-2-1-架构"><a href="#1-2-1-架构" class="headerlink" title="1.2.1 架构"></a>1.2.1 架构</h3><p>MySQL 是一个灵活的数据库系统，主要体现在：可适应不同的硬件，可支持多种数据类型，可支持多种应用类型，尤其是其存储引擎架构将数据的处理和存储相分离，极大地提高了使用时的灵活性。</p>
<p>MySQL 的逻辑架构可分为三层：</p>
<ul>
<li>最上层是服务器层（与客户端对接）<ul>
<li>实现连接处理、授权认证等功能；</li>
<li>每个客户端连接都会在服务器进程中拥有一个线程，该连接的操作都会由这个线程执行，服务器对线程进行统一管理。</li>
</ul>
</li>
<li>第二层是查询执行引擎（实现所有的跨存储引擎的功能）<ul>
<li>比如查询解析、分析、优化、缓存等；</li>
<li>优化器并不关心具体使用的是什么存储引擎，但存储引擎对于优化是有影响的。</li>
</ul>
</li>
<li>第三层是存储引擎层<ul>
<li>MySQL 支持多个存储引擎的架构，那么针对一些复杂问题（比如事务处理、锁管理等）就不需要单一的通用解决方案，每个存储引擎都可以提供自己的解决方案；</li>
<li>服务器通过API与存储引擎通信，这些 API 对服务器屏蔽了不同存储引擎之间的差异；</li>
<li>不同的存储引擎之间不会通信，只是响应上层服务器的请求。</li>
</ul>
</li>
</ul>
<h3 id="1-2-2-存储引擎"><a href="#1-2-2-存储引擎" class="headerlink" title="1.2.2 存储引擎"></a>1.2.2 存储引擎</h3><p>数据库存储引擎是用于存储、处理和保护数据的核心服务，可控制访问权限并快速处理事务，MySQL 的存储引擎是基于表的，即可以指定某张表使用何种存储引擎</p>
<ul>
<li>InnoDB<ul>
<li>MySQL 默认的事务性存储引擎是 InnoDB，只有在需要它不支持的特性时，才考虑使用其他存储引擎；</li>
<li>InnoDB 可以将表的数据和索引存放在单独的文件中，存储格式是平台独立的；</li>
<li>InnoDB 在 5.6 之后支持全文索引（5.6 之前不支持）；</li>
<li>InnoDB 表是基于聚簇索引建立的，索引和数据存储在一起，这与其他存储引擎有很大不同；</li>
<li>InnoDB 支持事务、行级锁、表锁，还是 MySQL 中唯一支持外键的内置存储引擎；</li>
<li>InnoDB 不保存表的行数，必须建立针对自增长字段的单个字段的索引；</li>
<li>InnoDB 在清空整个表时是一行一行的删除，效率非常慢；</li>
<li>InnoDB 支持真正的热备份，MySQL 其他的存储引擎不支持热备份，要获取一致性视图需要停止对所有表的写入；</li>
<li>InnoDB 适合频繁修改的场景、涉及到安全性较高的场景。</li>
</ul>
</li>
<li>MyISAM<ul>
<li>在 MySQL5.5 之前，MyISAM 是默认的存储引擎；</li>
<li>MyISAM 提供高效的全文索引、压缩等特性；</li>
<li>MyISAM 支持表锁，不支持事务、外键、行级锁，崩溃后无法安全恢复；</li>
<li>MyISAM 采用非聚簇索引，采用索引和数据分离的存储方式；</li>
<li>MyISAM 保存表的行数，自增长字段可以和其他字段一起建立联合索引，不要求针对自增长字段的单个字段的索引；</li>
<li>MyISAM 在清空整个表时会重建表；</li>
<li>MyISAM 适合的场景有：频繁查询的读场景、插入为主的场景、表比较小可以忍受修复操作的场景、表在创建并导入数据后不会再进行修改的场景（采用 MyISAM 压缩表）。</li>
</ul>
</li>
</ul>
<h3 id="1-2-3-特性"><a href="#1-2-3-特性" class="headerlink" title="1.2.3 特性"></a>1.2.3 特性</h3><ul>
<li><p>存储</p>
<ul>
<li>MySQL 的数据是存储在磁盘上面的（Memory 引擎除外），但是为了提升读写性能，InnoDB 就引入 Buffer Pool 这一中间层，Buffer Pool 是在内存上的一块连续空间，主要用途是缓存数据页（页预读以及写脏页）</li>
<li>MySQL 的内存表技术允许将数据和索引存储在内存中，从而提高检索速度和修改数据的效率，可以实现快速响应的查询，节约硬盘存储空间，创建内存表与创建普通表一样，但需要将存储引擎设置为：ENGINE = MEMORY；</li>
<li>数据库的行格式决定了一行数据是如何进行物理存储的，进而影响查询和 DML 操作的性能，在 InnoDB 中，常见的行格式有 4 种；<ul>
<li>COMPACT，除了保存字段值外，还会利用空值列表保存 null 值，还会记录变长字段长度列表和记录头信息，适合处理大量包含可变长度列的数据</li>
<li>REDUNDANT，会把该条记录中所有列（包括隐藏列）的长度信息都存储到字段长度偏移列表中，这种格式用的比较少</li>
<li>DYNAMIC，是 COMPACT 的改进版，保持了 COMPACT 的优点，同时在存储大的可变长度列时更加灵活，能够动态地选择存储额页内或页外，适用于大部分的应用场景，并在存储空间和性能上做了一定的平衡，结构与 COMPACT 大致相同</li>
<li>COMPRESSED，是在 DYNAMIC 的基础上添加了页外压缩功能，可以在存储页外数据时对数据进行压缩，从而减少磁盘占用空间，在查询时会自动解压缩并返回结果，增加了 CPU 的使用，可能会降低一些查询性能</li>
<li>BARRACUDA，相对于前面的格式，支持更多高级特性，如动态行格式、行级压缩、空间管理等</li>
</ul>
</li>
</ul>
</li>
<li><p>死锁</p>
<ul>
<li>死锁指两个或两个以上并发事务在同一资源上互相占用，并请求锁定对方占用的资源，从而导致恶性循环的现象；</li>
<li>死锁的产生可能是由于真正的数据冲突，也可能是由于存储引擎的实现方式；</li>
<li>可以通过减少锁的数量、减少锁的时长、固定访问顺序以及减少操作的数据量等方式来预防死锁发生；</li>
<li>死锁发生后只有部分或者完全回滚其中一种事务，才能打破死锁；</li>
<li>InnoDB 目前处理死锁的方法是：将持有最少行级排它锁的事务进行回滚；</li>
<li>补充：即使只操作同一条记录，也会发生死锁，这是因为数据库锁的是索引，并不是记录，事务中更新一条记录时可能会使用到多个索引值，那就意味着那么存在多个线程按照不同的顺序去获取这一条记录对应的多个锁时，依旧存在发生死锁的可能</li>
</ul>
</li>
<li><p>日志</p>
<ul>
<li>事务日志可以帮助提高事务的效率，存储引擎在修改表的数据时只需修改其内存拷贝，再将修改行为记录到持久在硬盘上的事务日志中，而不需要每次都将修改的数据持久到硬盘，日志持久以后，内存中被修改的数据可以在后台慢慢地刷回到磁盘，这称之为预写式日志，修改数据需要写两次磁盘；</li>
<li>BinLog、RedoLog、UndoLog 都是 MySQL 的日志类型文件</li>
<li>BinLog 主要用来对数据库进行数据备份、崩溃恢复和数据复制（适用于所有的存储引擎），记录的是数据库中所有 DDL 和 DML 语句，是包含了一切的最全面最原始的东西，BinLog 支持 statement、row 和 mixed 这<a target="_blank" rel="noopener" href="https://www.yuque.com/hollis666/niq4hm/pl5wcg4cmn8dgufn">三种记录格式</a>；</li>
<li>RedoLog 和 UndoLog 主要用于事务管理（只能用于 InnoDB 存储引擎），记录的是事务中的数据修改操作和回滚操作；</li>
<li>RedoLog 用于崩溃恢复，保持事务的持久性，记录了事务的所有数据更改（不仅是数据更改的最终结果，还有实现这些更改的具体操作）；</li>
<li>UndoLog 用于回滚，保持事务的原子性和一致性，记录的是事务执行前的内容。</li>
</ul>
</li>
<li><p>自动提交</p>
<ul>
<li>事务由存储引擎实现，MySQL 服务器层不管理事务；</li>
<li>不要在一个事务中混合使用事务型和非事务型的表，因为在回滚时，非事务型的表上的变更无法撤销，这会导致数据库处于不一致的状态；</li>
<li>InnoDB 默认采用自动提交模式，可通过设置来禁用或者启用；</li>
<li>InnoDB 的所有操作都是在事务中执行的，即便是没有修改的查询也会自动开启一个隐式事务，这种隐式事务不会持有任何锁，并且处于自动提交模式；</li>
<li>可以设置隔离级别，新的隔离级别会在下一个事务开始时生效</li>
</ul>
</li>
<li><p>Online DDL</p>
<ul>
<li>在出现 Online DDL 之前，InnoDB 索引构建期间会对表加排它锁，Online DDL 则允许尽最大可能在不阻塞其他会话的情况下（需要等待所有进行中的事务都提交）创建或删除索引</li>
<li>一般在非高峰期进行此类操作，避免影响用户正常使用，Online DDL 一旦操作失败，其回滚的成本较高，因此在进行 DDL 之前要进行充分的测试和规划，确保有备份和回滚计划</li>
</ul>
</li>
</ul>
<h3 id="1-2-4-锁"><a href="#1-2-4-锁" class="headerlink" title="1.2.4 锁"></a>1.2.4 锁</h3><p>InnoDB 采用两段锁定协议，事务执行时会自动根据隔离级别执行隐式锁定，所有的锁都在事务提交或者回滚时被一起释放</p>
<p>MySQL 服务器层也提供显式锁定语句，但除了禁用自动提交以外，任何时候都不要使用显式锁定，否则可能会产生无法预料的结果</p>
<p>MySQL 提供的锁可以按照不同的方式进行划分</p>
<ul>
<li>按照操作划分为 DML 锁、DDL 锁</li>
<li>按照加锁方式划分为自动锁、显式锁</li>
<li>按照粒度划分为<ul>
<li>行级锁是 MySQL 中粒度最小的锁，只针对当前操作的行进行加锁，锁冲突概率最低，并发度高，但加锁的开销是最大的，加锁是最慢的，会出现死锁</li>
<li>表级锁是 MySQL 中粒度最大的锁，对当前操作的整张表加锁，实现简单，资源消耗较少，加锁快，锁冲突概率最高，并发度低，不会出现死锁</li>
<li>页级锁是行级锁和表级锁之间的折中，一次锁定相邻的一组记录，各方面性能都介于行级锁和表级锁之间，会出现死锁</li>
<li>InnoDB 是通过给索引上的索引项加锁来实现行级锁的（Oracle 则是在数据块中对相应数据行加锁），这意味着<ul>
<li>只有通过索引条件检索数据时才会使用行级锁，否则将使用表级锁</li>
<li>只要使用索引（无论是什么类型的索引）就会使用行级锁</li>
<li>只要使用相同的索引键（即便访问不同行）就会出现锁冲突</li>
<li>即便在 SQL 条件中使用了索引字段，但真正是否使用索引是由 MySQL 优化器通过判断不同执行计划来内部决定的</li>
</ul>
</li>
</ul>
</li>
<li>按照级别划分为共享锁、排它锁<ul>
<li>共享锁，是读取操作创建的锁（又称读锁），其他事务可以并发读取数据，但任何事务都不能对数据进行修改，即不能获取数据的排它锁，直到共享锁释放</li>
<li>排它锁，是写入操作创建的锁（又称写锁），其他任何事务都不能并发读取或者修改数据，获取排它锁的线程既可以读又可以写</li>
</ul>
</li>
<li>按照使用方式划分为乐观锁、悲观锁<ul>
<li>乐观锁，主要通过 CAS + 版本号机制实现，假设数据一般情况下不会造成冲突，并不会使用数据库提供的锁机制，开销低，效率高，适用于读操作频繁，写操作较少的场景，一旦粒度控制的不好，业务失败的概率就会比较高</li>
<li>悲观锁，需要先关闭事务自动提交属性，然后通过<code>SELECT ... FOR UPDATE</code>来进行加锁，会在修改数据之前先加排它锁，若加锁失败则等待或者抛出异常（响应方式由用户根据实际需要决定），加排他锁成功后就可以对记录进行修改，事务完成后自动释放排它锁，开销大，效率低，会产生死锁，适用于写操作频繁，并发程度高的场景</li>
<li>虽然乐观锁相比于悲观锁只是没有提前加锁，并通过 CAS 做并发校验，但是在真正更新数据的那一刻依旧是需要加一个短暂的锁的，悲观锁的提前加锁则使得锁定的时长要长的多</li>
</ul>
</li>
<li>按照锁的对象划分为<ul>
<li>记录锁（Record Lock），锁的是索引记录（即使没有定义索引，InnoDB 也会自动创建一个隐藏的聚集索引，并使用这个索引来锁定记录），锁粒度较小</li>
<li>间隙锁（Gap Lock），锁的是索引记录之间的间隙（间隙指的是索引数据结构中可以插入新值的位置），或第一个索引记录之前的间隙，或最后一个索引记录之后的间隙</li>
<li>记录锁和间隙锁的组合（Next-Key Lock），同时锁索引记录和间隙，是左开右闭的，锁粒度加大，死锁的可能性更大</li>
<li>使用 Gap Lock 和 Next-Key Lock 的前提是可重复读这一隔离级别，在这一级别下，加锁的基本单位是 Next-Key Lock，然后再视情况退化为 Record Lock 或 Gap Lock</li>
</ul>
</li>
<li>意向锁<ul>
<li>当一个事务请求获取行级锁或表级锁时，MySQL 会自动获取相应的表的意向锁，那么其他事务尝试获取锁时，就可以先基于这个意向锁来判断是否有事务已经加过锁，并根据锁的级别是共享锁还是排它锁来判断自己是否可以获取锁，这样就可以在不阻塞其他事务的情况下为当前事务锁定资源</li>
<li>意向锁并不是直接锁定资源，而是为了通知其他事务，以防各个事务在资源上设置不兼容的锁</li>
<li>意向锁并不是由用户请求的，而是有 MySQL 管理的，是一个表级锁，会在触发意向锁的事务提交或者回滚后释放</li>
<li>意向锁按照级别划分为<ul>
<li>意向共享锁，表示事务打算在资源上设置共享锁，并且不希望其他事务设置排它锁</li>
<li>意向排它锁，表示事务打算在资源上设置排它锁，并且不希望其他事务设置共享锁或排它锁</li>
</ul>
</li>
</ul>
</li>
<li>字典锁（MetaData Lock）<ul>
<li>MDL 锁是一种用于管理元数据并发访问的锁机制，而不是数据本身的锁</li>
<li>数据库会在执行 DDL 操作时加上 MDL，保护数据库中的元数据对象（表、列、索引、视图等），确保在 DDL 操作期间不会出现数据一致性问题和竞争条件</li>
<li>MDL 也可以分为共享 MDL 和排他 MDL，当事务开始时，通常会以共享 MDL 的方式访问元数据对象，如果事务需要对元数据对象进行修改操作，就需要将共享 MDL 升级为排他 MDL，这种升级通常是系统自动执行的</li>
</ul>
</li>
</ul>
<h3 id="1-2-5-MVCC"><a href="#1-2-5-MVCC" class="headerlink" title="1.2.5 MVCC"></a>1.2.5 MVCC</h3><ul>
<li><p>基于提升并发性能的考虑，事务型存储引擎实现的都不是简单的行级锁，一般都同时实现了多版本并发控制（MVCC），可以看作是行级锁的一个变种；</p>
</li>
<li><p>MVCC 实现的基础是快照读，快照读是通过在 UndoLog 中保存数据在某个时间点的快照来实现的，不加锁的查询语句就会进行快照读，（加锁的查询语句以及增删改语句都会进行当前读，当前读就是读取最新数据，是悲观锁实现的基础）；</p>
</li>
<li><p>InnoDB 的 MVCC 是在每行记录后面保存两个隐藏的列来实现的，分别是行的创建时间和行的过期时间，这个时间并非实际的时间值，而是版本号；</p>
</li>
<li><p>每个事务的开始时间的系统版本号会作为事务的版本号（自增长、唯一的），事务版本号被用来标记该事务所做的修改，事务版本号会和事务查询到的每行记录的版本号进行比较，只有创建时间小于等于当前事务版本号，且删除时间未定义或大于当前事务版本号的记录，才能作为查询结果，避免了脏读问题；</p>
</li>
<li><p>由于未提交读总是要读取最新数据行（无论是否提交），而串行化会对所有读取的数据行加锁，所以 MVCC 只能在提交读和可重复读这两个隔离级别下工作；</p>
</li>
<li><p>在提交读隔离级别下，每次读取都会重新生成一个快照，总是读取最新的已提交数据行，这一隔离级别下只会使用 Record Lock；</p>
</li>
<li><p>在可重复读隔离级别下，MVCC 只会在第一次读取的时候生成快照，后续的所有读都是基于这同一个快照，只有本事务对数据进行更改才会更新快照，避免了不可重复读问题。</p>
</li>
<li><p>在可重复读隔离级别下的幻读问题</p>
<ul>
<li>本事务不对数据记录进行更改时，所有的读取都基于第一次读取时生成的快照，避免了幻读问题</li>
<li>本事务对数据记录更改时，通过 Gap Lock 和 Next-Key Lock 将记录之间的间隙锁住，可以防止其他事务插入新行，避免了幻读问题</li>
<li>当本事务第一次读取之后，存在其他事务插入新行并提交，接着本事务再对数据进行更改时（加锁已经迟了），那么本事务更新快照之后就会读到其他事务插入的行，发生幻读问题，这种情况必须在本事务一开始就立即加锁，才能避免幻读问题，但这也是导致死锁的一个重要根源，需要慎重使用，没有死锁的话感觉已经变成串行执行事务了……</li>
<li>综上，在可重复读隔离级别下，MVCC + 数据修改时加的间隙锁可以避免大部分的幻读问题，MVCC + 事务一开启就立即加锁可以避免幻读问题，但容易死锁，InnoDB 只有使用可串行化这一隔离级别才可以彻底解决幻读问题</li>
</ul>
</li>
</ul>
<h1 id="2、设计"><a href="#2、设计" class="headerlink" title="2、设计"></a>2、设计</h1><h2 id="2-1-数据类型"><a href="#2-1-数据类型" class="headerlink" title="2.1 数据类型"></a>2.1 数据类型</h2><p>不管储存哪种类型的数据，有以下几个原则：</p>
<ul>
<li>尽可能使用可以正确存储数据的最小数据类型</li>
<li>尽可能选择简单的操作代价低的数据类型，比如整型比字符型更简单</li>
<li>尽量避免 NULL，NULL 值会使得索引变得复杂</li>
<li>对于相关联的列，应选择与关联表中的对应列一样的数据类型</li>
<li>数据如何存储取决于存储引擎，对于相同的类型，并非所有的存储引擎都会按照相同的方式处理</li>
</ul>
<h3 id="2-1-1-整数类型"><a href="#2-1-1-整数类型" class="headerlink" title="2.1.1 整数类型"></a>2.1.1 整数类型</h3><p>可以存储的范围从-2^(N-1)到2^(N-1)-1，N是存储空间的位数，但无符号类型UNSIGNED表示不允许负值，这使得存储范围提高一倍。</p>
<table>
<thead>
<tr>
<th align="center"></th>
<th align="center"></th>
<th align="center"></th>
<th align="center"></th>
<th align="center"></th>
<th align="center"></th>
</tr>
</thead>
<tbody><tr>
<td align="center">类型</td>
<td align="center">TINYINT</td>
<td align="center">SMALLINT</td>
<td align="center">MEDIUMINT</td>
<td align="center">INT</td>
<td align="center">BIGINT</td>
</tr>
<tr>
<td align="center">位数</td>
<td align="center">8</td>
<td align="center">16</td>
<td align="center">24</td>
<td align="center">32</td>
<td align="center">64</td>
</tr>
</tbody></table>
<p>实数类型：可以用于存储带有小数部分的数字以及比BIGINT更大的整数，</p>
<table>
<thead>
<tr>
<th align="center"></th>
<th align="center"></th>
<th align="center"></th>
<th align="center"></th>
</tr>
</thead>
<tbody><tr>
<td align="center">类型</td>
<td align="center">FLOAT</td>
<td align="center">DOUBLE</td>
<td align="center">DECIMAL</td>
</tr>
<tr>
<td align="center">位数</td>
<td align="center">4</td>
<td align="center">8</td>
<td align="center">尽量只在需要对小数进行精确计算时使用</td>
</tr>
</tbody></table>
<h3 id="2-1-2-字符串类型"><a href="#2-1-2-字符串类型" class="headerlink" title="2.1.2 字符串类型"></a>2.1.2 字符串类型</h3><p>CHAR 类型是定长的（0 ~ 255），会根据定义的字符串长度分配足够的空间，会在存储时自动在结尾添加空格来将字符串填满至指定长度（这也就导致了原字符串内容末尾的空格信息丢失），适合存储很短的字符串，或者所有值都接近同一个长度，或者经常变更的数据（这是因为长度固定，不会产生碎片以及页分裂）</p>
<p>VARCHAR 用于存储可变长字符串（0 ~ 65535），兼容性更好，只会存储实际的字符串内容，不会填充空格，但会额外用到 1 ~ 2 个字节存储长度信息，当字符串列的最大长度比平均长度大很多，列的更新很少时，VARCHAR 比定长类型更节省空间，而列更新时很可能会导致页分裂</p>
<p>BLOB 和 TEXT 都是为存储很大的数据而设计的字符串数据类型，分别采用二进制和字符方式存储。与其他类型不同，MySQL 把每个 BLOB 和 TEXT 当做一个独立的对象处理</p>
<p>可变长度列（VARCHAR、VARBINARY、BLOB、TEXT）的前 768 字节的数据存储在 B 树节点的索引记录中，超出部分则存储在溢出页中</p>
<p>固定长度列若是大于或等于 768 字节，则会被编码为可变长度列，可以存储在页外</p>
<p>MySQL 对 Unicode 的支持<a target="_blank" rel="noopener" href="https://www.yuque.com/hollis666/niq4hm/hwe1ut">参考</a></p>
<h3 id="2-1-3-日期和时间类型"><a href="#2-1-3-日期和时间类型" class="headerlink" title="2.1.3 日期和时间类型"></a>2.1.3 日期和时间类型</h3><p>DATETIME类型能保存大范围的值，使用8个字节的存储空间，与时区无关</p>
<p>TIMESTAMP类型只是用4个字节的存储空间，显示的值依赖于时区，默认为NOT NULL，应该尽量使用TIMESTAMP</p>
<h2 id="2-2-范式"><a href="#2-2-范式" class="headerlink" title="2.2 范式"></a>2.2 范式</h2><h3 id="2-2-1-定义"><a href="#2-2-1-定义" class="headerlink" title="2.2.1 定义"></a>2.2.1 定义</h3><p>范式（Normal Form）是用于设计关系型数据库的规范要求，这些规范可以让数据库的设计更加简洁清晰，也会更好地保证一致性。</p>
<ul>
<li>1NF 要求数据库的每一列都是不可分割的基本数据项，而不能是集合、数组等非原子数据项（满足 1NF 的数据库才是关系数据库）</li>
<li>2NF 是在 1NF 的基础上，要求每一个非主属性完全函数依赖于主属性（消除部分依赖）</li>
<li>3NF 是在 2NF 的基础上，要求每一个非主属性都不依赖于其他非主属性（消除间接依赖）</li>
</ul>
<p>完全遵守数据库三范式确实可以避免一些写时异常，提升一些写入性能，但同时也会丢失一些读取性能，这是因为表中没有任何冗余字段，那么查询时就会经常有多表关联查询，为了解决这一问题，就产生了反范式。</p>
<h3 id="2-2-2-范式和反范式"><a href="#2-2-2-范式和反范式" class="headerlink" title="2.2.2 范式和反范式"></a>2.2.2 范式和反范式</h3><p>范式化的表通常更小，范式化的更新操作通常比反范式化要快，范式化的表通常需要关联，代价昂贵，而反范式化的表则可以很好地避免关联。</p>
<p>反范式是一种针对遵从设计范式的数据库的性能优化策略，一定是发生在满足范式设计的基础上，相当于先遵守规则，但进行局部调整，并不等于非范式化，通常混用范式和反范式。</p>
<p>最常见的反范式化数据的方法是复制、缓存、增加冗余字段，其实就是用空间换时间，方便进行数据查询，而不再需要经常做多表联合查询，此时带来的问题是如何保证这些冗余之间的一致性。</p>
<p>在一些数据量大、并发高、查询频率远高于写入频率的场景下，适当做一些反范式，可以提升性能，降低响应时延，提升并发效率。</p>
<h3 id="2-2-3-缓存表和汇总表"><a href="#2-2-3-缓存表和汇总表" class="headerlink" title="2.2.3 缓存表和汇总表"></a>2.2.3 缓存表和汇总表</h3><p>有时提升性能最好的方法是在同一张表中保存衍生的冗余数据，甚至创建一张完全独立的缓存表或汇总表。</p>
<p>缓存表表示存储那些可以比较简单地从其他表获取数据的表，对优化搜索和检索查询语句很有效。</p>
<p>汇总表表示使用 GROUP BY 语句聚合数据的表。</p>
<p>在使用缓存表和汇总表时，必须决定是实时维护数据还是定期重建。</p>
<h2 id="2-3-索引"><a href="#2-3-索引" class="headerlink" title="2.3 索引"></a>2.3 索引</h2><p>索引是存储引擎用于快速找到记录的一种数据结构，可以理解为看书时的内容页码。在MySQL中，索引是在存储引擎层而不是服务器层实现的，不同存储引擎的索引的底层实现和工作方式不一样。</p>
<h3 id="2-3-1-B-Tree-索引"><a href="#2-3-1-B-Tree-索引" class="headerlink" title="2.3.1 B+Tree 索引"></a>2.3.1 B+Tree 索引</h3><p>B Tree 和 B+Tree 都是自平衡搜索数据结构，非叶子节点的根节点至少有 2 个子节点，非根非叶子节点至少有 m/2（向上取整）个子节点，至多有 m 个子节点（m 是 B 树的阶数），更多的子节点决定了更低的树高，进而减少了磁盘访问次数，具有 k 个子节点的非叶子节点包含 k - 1 个升序排列的键，每一个叶子节点到根节点的距离相同，在插入和删除节点时会通过节点的分裂和合并来保持树的平衡</p>
<ul>
<li>B Tree 的节点（叶子节点和非叶子节点）既存储索引值，也存储相关数据记录，B+Tree 的非叶子节点仅存储索引值，所有的数据记录都按顺序存储在叶子节点中</li>
<li>B Tree 的叶子节点之间没有直接连接，B+Tree 的每一个叶子节点都包含指向上一个叶子节点和下一个叶子节点的指针（双向链表），方便进行范围查询</li>
<li>B Tree 的范围查询需要在整棵树上进行遍历，命中的可能是非叶子节点也可能是叶子节点，B+Tree 的范围查找直接遍历叶子节点即可，无需回溯到非叶子节点</li>
<li>B Tree 的查询需要遍历整棵树，磁盘 I/O 次数较多，适用于随机读写（可能可以在非叶子节点中提前找到所需的数据记录）、内存受限的环境（整棵树占用更小的内存空间）</li>
<li>B+Tree 基于叶子节点的高效的范围查询则使得 I/O 次数相对较少，且非叶子节点只存储索引值则可以用来存储更多的索引数据，适用于大规模数据集的范围查询（不需要遍历整棵树）</li>
</ul>
<p>B+Tree 索引是目前关系型数据库系统中最常见、最有效的索引，如果没有特别指明类型，那默认指 B+Tree 索引，使用 B+Tree 索引时</p>
<ul>
<li>不再需要进行全表扫描，能够加快访问数据的速度</li>
<li>必须按照索引的最左列开始查找，不能跳过索引中的列，适合全键值、键值范围或键值最左前缀的范围查找</li>
<li>如果查询中有某个列的范围查询则其右边所有列都无法使用索引优化查找</li>
<li>B+Tree 索引列是顺序组织存储的，如果 B+Tree 索引可以按某种方式查找到值，那么也可以按照这种方式用于排序，适合 ORDER BY、GROUP BY 顺序查找</li>
<li>叶子节点的大小是固定的，一般都会设置为一页的大小，因此可以很好地利用磁盘预读特性来一次性读取多个节点到内存中，减少 I/O 操作次数</li>
<li>在插入和删除数据时需要调整索引结构，可能会涉及到页分裂和页合并，索引的维护成本高</li>
</ul>
<h3 id="2-3-2-唯一索引"><a href="#2-3-2-唯一索引" class="headerlink" title="2.3.2 唯一索引"></a>2.3.2 唯一索引</h3><p>MySQL 基于 B+Tree 索引实现唯一索引，B+Tree 的每个节点上都会添加一个指向唯一性索引值的指针，当在索引列上插入新值/更新索引列时，会触发唯一性检查器，使用 B+Tree 检查索引列中是否存在要插入的值/更新后的新值，如果已经存在就会抛出唯一性约束冲突的异常。</p>
<ul>
<li>唯一索引查询通常会比非唯一索引查询更快，这是因此唯一索引能够快速定位到唯一值，而非唯一索引则需要扫描整个索引并匹配符合条件的记录</li>
<li>唯一性检查器在一定程度上降低了插入性能，而唯一性索引列的值的更新则需要先删除旧记录，再插入新纪录，也会一定程度上降低更新性能</li>
</ul>
<p>主键索引是一种特殊的唯一索引</p>
<ul>
<li>主键索引不能为 NULL，但唯一索引是可以为 NULL 的</li>
<li>主键索引在一张表中只能有一个，但唯一索引在一张表中可以创建多个</li>
<li>在 InnoDB 中，主键索引就是聚簇索引，因此基于主键索引的查询一定不需要回表，而唯一索引通常是非聚簇索引，通常需要回表，但也可能成为聚簇索引，比如没有创建主键索引时，MySQL 会默认选择一个唯一的非空索引作为聚簇索引</li>
<li>主键可以被其他表引用为外键，而唯一索引是不可以的</li>
</ul>
<h3 id="2-3-3-索引跳跃"><a href="#2-3-3-索引跳跃" class="headerlink" title="2.3.3 索引跳跃"></a>2.3.3 索引跳跃</h3><p>B+Tree 索引先按联合索引左边的 key 进行排序，再按依次按照右边的 key 进行排序，左前缀匹配中的”左“是指联合索引的顺序左，和 SQL 中的查询条件的顺序没有关系，如果不涉及联合索引，根据单个字段的索引进行查询时（比如模糊匹配）也需要遵守最左前缀。</p>
<p>但对于索引跳跃扫描来说，可以支持不符合索引最左前缀原则条件下的 SQL，依旧能够使用联合索引来减少不必要的扫描，这种索引跳跃扫描其实是隐式地构造了联合索引中的左侧索引列的扫描条件，这种查询优化比较适用于索引左侧列取值范围比较小，区分度不高的情况，一旦索引左侧列的区分度特别高，索引跳跃扫描反而会更慢。</p>
<p>索引跳跃扫描有一些限制条件如下</p>
<ul>
<li>表至少有一个联合索引，联合索引最前和最后的列可以是空的，但中间的列必须是非空的</li>
<li>查询必须只能依赖一张表，不能多表联合</li>
<li>查询中不能使用 GROUP BY 或 DISTINCT 语句</li>
<li>查询的字段必须是索引中的列</li>
</ul>
<h3 id="2-3-4-哈希索引"><a href="#2-3-4-哈希索引" class="headerlink" title="2.3.4 哈希索引"></a>2.3.4 哈希索引</h3><p>哈希索引基于哈希表实现，对于每一行数据，存储引擎都会对所有的索引列计算一个哈希码，哈希索引将所有的哈希码存储在索引中，同时在哈希表中保存指向每个数据行的指针，使用哈希索引时</p>
<ul>
<li>哈希索引自身只需存储哈希值和行指针，索引的结构非常紧凑，因此哈希索引查找的速度非常快，除非有很多哈希冲突</li>
<li>哈希索引数据不是按照索引值顺序存储的，因此无法用于排序</li>
<li>哈希索引始终使用索引列的全部内容来计算哈希值，因此不支持部分索引列匹配查找，只有精确匹配索引所有列的查询才有效</li>
<li>哈希索引不支持任何范围查询，只支持等值比较查询，包括<code>=</code>、<code>IN()</code></li>
<li>在插入和删除数据时只需要计算新行的哈希码或者删除哈希码，索引的维护成本低</li>
</ul>
<p>InnoDB 引擎在注意到某些索引值被使用得非常频繁时，它会在内存中基于 B+Tree 索引之上再创建一个哈希索引，这样就让 B+Tree 索引也具有哈希索引的一些优点，这个功能叫做自适应哈希索引。</p>
<h3 id="2-3-5-全文索引"><a href="#2-3-5-全文索引" class="headerlink" title="2.3.5 全文索引"></a>2.3.5 全文索引</h3><p>通过数值比较、范围过滤等就可以完成绝大多数需要的查询了，但是如果希望通过关键字的匹配来进行基于相似度的查询过滤，而不是精确的数值比较，就可以使用全文索引（在 MySQL 5.6 提供的）。互联网搜索引擎就是一种全文索引。 </p>
<p>使用全文索引时</p>
<ul>
<li>全文索引查找的是文本中的关键词，而不是直接比较索引中的值</li>
<li>在相同的列上同时创建全文索引和基于值的 B+Tree 索引不会有冲突</li>
<li>全文索引适用于 MATCH AGAINST 操作，而不是普通的WHERE条件操作，且MATCH函数中指定的列必须和全文索引中指定的列完全相同，WHERE条件比较必须在完成全文搜索返回记录后才能进行</li>
<li>使用全文索引的查询自动按照相似度进行排序，此时MySQL无法再使用索引排序，如果需要相关性以外的排序操作，那么只能在查询中使用ORDER BY做文件排序</li>
<li>全文索引不会记录查询关键字来自哪一行，因此无法使用全文索引来查询某个关键字是否在某一列中存在，也无法用作索引覆盖扫描</li>
</ul>
<h3 id="2-3-6-聚簇索引"><a href="#2-3-6-聚簇索引" class="headerlink" title="2.3.6 聚簇索引"></a>2.3.6 聚簇索引</h3><p>聚簇索引并不是一种单独的索引类型，而是一种数据存储方式。聚簇索引就是将数据与索引连续地存储在一起，这种连续并不是物理上的连续，而是逻辑上的连续，这种索引方式保证数据行的物理存储顺序和索引的逻辑顺序相同，因此查找聚簇索引的速度非常快。因为无法同时把数据行存放在两个不同的地方，所以一个表只能有一个聚簇索引。</p>
<p>聚簇索引以外的索引都是非聚簇索引，也叫二级索引或辅助索引，辅助索引就是将数据和索引分开存储，不影响表中数据行的物理存储顺序，而是单独创建一张索引表，用于存储索引列和对应数据行的指针。</p>
<p>InnoDB 一般选择主键索引来构建聚簇索引，在 B+ Tree 这一数据结构中保存了索引值和数据行，将数据行按照主键顺序存储在叶子节点中。在InnoDB 中，聚簇索引“就是”表。</p>
<p>InnoDB 选择非主键字段构建辅助索引，辅助索引的叶子节点存储的不再是数据行，而是数据行的索引字段值和指向数据页数据行的逻辑指针（主键值）。当通过辅助索引来查找数据时，InnoDB 会通过辅助索引叶子节点获得对应的主键值，然后再通过主键索引来找到一个完整的数据行，这个过程就叫做回表。</p>
<p>使用聚簇索引时</p>
<ul>
<li>聚簇索引将相关数据保存在一起，因此可以减少磁盘 I/O</li>
<li>聚簇索引的索引和数据保存在同一个 B+ Tree 中，因此数据访问会更快</li>
<li>聚簇索引列的更新代价很高，因为会强制将每个被更新的行移动到新的位置，甚至在插入新行时可能导致页分裂，占用更多的磁盘空间</li>
<li>辅助索引访问需要两次索引查找（多了一次回表），而不是一次</li>
<li>尽量避免使用数据随机（不连续且值的分布范围非常大）的列来做聚簇索引，自增列就比较好</li>
</ul>
<h3 id="2-3-7-覆盖索引"><a href="#2-3-7-覆盖索引" class="headerlink" title="2.3.7 覆盖索引"></a>2.3.7 覆盖索引</h3><p>覆盖索引指索引包含所有需要查询的字段的值，此时只访问索引即可，而无须再回表查询。</p>
<p>由于覆盖索引必须要存储索引列的值，而哈希索引和全文索引都不存储索引列的值，所以 MySQL 只能用 B+Tree 索引来做覆盖索引。</p>
<p> 使用覆盖索引时</p>
<ul>
<li>索引条目通常远小于数据行大小，更容易全部放入内存中，因此可以极大地减少数据访问量</li>
<li>索引是按照列值顺序存储的，因此可以将随机 I/O 变为顺序 I/O，且范围查询会比随机从磁盘读取每一行数据的 I/O 次数更少</li>
<li>按照覆盖索引顺序扫描得到的有序结果会比对先得到结果再进行排序操作的效率更高</li>
<li>如果不符合最左前缀匹配的话，即便是索引覆盖也无法用到索引</li>
</ul>
<p>MyISAM 中的索引都是非聚簇索引，索引和数据时分开存储互相独立的，在 MyISAM 的索引树中，叶子节点上存储地并不是数据，而是数据所在的地址，在根据索引查询的过程中，必须先查到数据所在的地址，然后再查询真正的数据，至少有两次查询过程，而在 InnoDB 中，基于聚簇索引或者覆盖索引的查询则不需要回表。</p>
<h3 id="2-3-8-索引下推"><a href="#2-3-8-索引下推" class="headerlink" title="2.3.8 索引下推"></a>2.3.8 索引下推</h3><p>索引下推是指先通过 WHERE 条件中的索引字段返回符合条件的索引，然后根据剩余的 WHERE 条件来判断索引是否符合条件。</p>
<p>如果不应用索引下推，那么就会先通过 WHERE 条件中的索引字段返回符合条件的数据行，然后根据剩余的 WHERE 条件来判断数据是否符合条件。</p>
<p>索引下推技术减少了回表次数。</p>
<h2 id="2-4-高性能索引"><a href="#2-4-高性能索引" class="headerlink" title="2.4 高性能索引"></a>2.4 高性能索引</h2><h3 id="2-4-1-建立索引"><a href="#2-4-1-建立索引" class="headerlink" title="2.4.1 建立索引"></a>2.4.1 建立索引</h3><p>索引大大减少了服务器需要扫描的数据量，可以帮助服务器避免排序和临时表，可以将随机 I/O 变为顺序 I/O，可以减少需要锁定的行。但正确创建和使用索引才能真正发挥出索引的优势，应当遵循以下原则</p>
<ul>
<li>对于非常小的表，大部分情况下简单的全表扫描更高效；对于中大型的表中频繁查询的列，索引就非常有效；对于特大型的表，建立和使用索引的代价非常大，需要通过分区技术来区分出查询需要的一组数据，而不是一条记录一条记录的匹配</li>
<li>不同类型的索引适用于不同类型的查询，应根据实际情况选择适合的索引类型，B+ Tree 索引、哈希索引、全文索引、前缀索引等</li>
<li>索引列不能是表达式的一部分，也不能是函数的参数，应尽量简化 WHERE 条件，始终将索引列单独放在比较符号的一侧</li>
<li>对于 BLOB、TEXT 或者很长的 VARCHAR 类型的列，索引这些列的完整长度会让索引变得大且慢，此时应使用前缀索引并仔细考虑前缀长度，需要注意 MySQL 无法使用前缀索引做 ORDER BY、GROUP BY 以及覆盖扫描</li>
<li>在多个列上建立独立的单列索引大部分情况下并不能提高 MySQL 的查询性能，尤其是多个列一起被频繁查询时，需要考虑建立合适的多列联合索引并通过索引覆盖来避免回表查询，且优先将选择性高的列放到联合索引最前列</li>
<li>对于区分度不高的列建立索引也不一定没用，性能差并不是区分度不高导致的，而是要具体分析索引扫描的行数成本，如果存在某个值对应的行数很少，那么对该列建立索引依旧有可能大大降低需要扫描的行数，提升性能</li>
<li>索引并不是越多越好，不要创建重复索引（指在相同的列上按照相同的顺序创建的相同类型的索引），尽量避免创建冗余索引，过多的索引会占用大量的磁盘空间，影响写入和删除性能</li>
<li>尽可能设计既满足排序，又用于查找行的索引</li>
<li>确保关联查询时的 ON 或者 USING 子句中的列上有索引，只需要在关联顺序中的第二个表的相应列上创建索引</li>
<li>确保 GROUP BY 和 ORDER BY 中的表达式只涉及到一个表中的列，且列上有索引，这样 MySQL 才有可能使用索引来优化这个过程</li>
<li>对于创建出的索引，要经常使用执行计划分析来查看索引是否有在正确使用</li>
</ul>
<h3 id="2-4-2-索引失效"><a href="#2-4-2-索引失效" class="headerlink" title="2.4.2 索引失效"></a>2.4.2 索引失效</h3><p>索引失效可能是因为</p>
<ul>
<li>索引列参与计算</li>
<li>对索引列进行函数操作</li>
<li>使用 OR 且 OR 的两边存在大于或小于的比较（如果 OR 两边都是等于号判断则依旧可以走索引）</li>
<li>LIKE 操作且匹配值的前面有匹配符（如果只是值后面有匹配符是可以走索引的），可以通过反转列值来将前面的匹配符移到后面</li>
<li>隐式类型转换</li>
<li>!= 比较</li>
<li>IS NOT NULL</li>
<li>IN</li>
</ul>
<h3 id="2-4-3-索引选择"><a href="#2-4-3-索引选择" class="headerlink" title="2.4.3 索引选择"></a>2.4.3 索引选择</h3><p>到底使用哪个索引是优化器根据成本预估来决定的，优化器会倾向于选择一个成本最低的方式进行查询，成本与以下因素有关</p>
<ul>
<li>基数性，就是通常说的区分度，基数性越高，区分度越好，成本越低，优化器越倾向于使用该索引</li>
<li>选择性，指过滤数据的能力，决定着扫描行数，扫描行数越少，成本越低</li>
<li>索引覆盖，优化器倾向于使用覆盖索引来减少回表</li>
<li>ORDER BY，为了减少 file sort，优化器倾向于直接使用天然有序的索引</li>
<li>索引类型，优化器会根据查询类型来选择最合适的索引类型</li>
<li>访问类型，范围查询、点查找、扫描等不同的访问类型也会影响索引的选择，比如某些索引更适合范围查询</li>
<li>索引的大小和深度，较小、较浅的索引占用更少的磁盘空间，通常更快</li>
<li>内存使用，对于大型表，优化器还会考虑执行计划的内存使用情况，尽量避免造成过多的内存占用</li>
<li>系统资源限制，优化器还会考虑内存、磁盘 I/O 等系统资源限制</li>
</ul>
<p>如果优化器选错了索引，可能是因为不准确的统计信息、复杂的查询逻辑以及系统配置等，因此可以通过定期更新统计信息、使用强制索引（FORCE INDEX，谨慎使用）、优化查询（详细见 3.1 小节）、调整索引、调整 MySQL 系统配置等方式来解决。</p>
<h3 id="2-4-4-低性能"><a href="#2-4-4-低性能" class="headerlink" title="2.4.4 低性能"></a>2.4.4 低性能</h3><p>使用索引查询仍然很慢可能是因为</p>
<ul>
<li>优化器选错索引</li>
<li>数据分布不均匀导致某些索引节点的数据量很大，而某些节点的数据量很少</li>
<li>SQL 语句本身存在问题，优化方式详见下节</li>
<li>数据库表以及索引设计不合理</li>
<li>系统硬件或网络环境问题</li>
</ul>
<h1 id="3、优化"><a href="#3、优化" class="headerlink" title="3、优化"></a>3、优化</h1><p>优化主要就是在快速、精确和简单这三者之间尽量满足其二。</p>
<h2 id="3-1-查询"><a href="#3-1-查询" class="headerlink" title="3.1 查询"></a>3.1 查询</h2><h3 id="3-1-1-执行流程"><a href="#3-1-1-执行流程" class="headerlink" title="3.1.1 执行流程"></a>3.1.1 执行流程</h3><p>优化查询的目标在于降低查询的响应时间，查询性能低下最基本的原因是访问的数据太多，消耗大多时间，所以需要确认存储引擎是否在检索以及服务器是否在分析大量超过需要的数据。</p>
<p>要写一个好的查询，那么就要理解查询是如何被执行的，理解时间都被消耗在哪些地方，从而对查询进行优化，查询的执行流程如下</p>
<ul>
<li>客户端使用 C/S 通信协议与 MySQL 建立连接，发送一条查询到服务器</li>
<li>服务器检查查询缓存，若命中缓存则立即返回缓存中的结果</li>
<li>若没有命中缓存，则进行 SQL 解析（语法分析和语义分析）、预处理、并由优化器生成执行计划</li>
<li>根据执行计划调用存储引擎的 API 来执行查询（索引的作用就在于可以减少存储引擎需要访问的数据行）</li>
<li>存储引擎将检索到的数据返回给服务器，服务器进行调用后的数据处理，并将结果给客户端（如果查询可以被缓存，这时也会将结果存放到查询缓存中）</li>
</ul>
<p>查询缓存允许 MySQL 将查询结果缓存起来，以便在以后相同的查询被再次执行时可以直接返回缓存中的结果不必再次重新解析和执行该查询语句，查询缓存在 session 之间共享，因此由一个客户端生成的结果集可以用来响应另一个客户端发出的相同查询，可以提高查询性能。</p>
<p>查询缓存要求查询必须以字节级别完全匹配，大小写敏感，包含非确定函数或使用临时表的查询结果不会被缓存，查询缓存不能很好地应对不均匀的查询分布，会占据大量内存开销，还可能因为数据库中的数据更改而导致一致性问题，此外，对底层表的任何修改都会导致这些表的所有缓存失效。</p>
<p>在 MySQL 5.6 之前查询缓存默认是开启的，从 MySQL 5.6 开始查询缓存默认是禁用的，在 MySQL 8 中取消了查询缓存，以提高整体性能和可维护性。</p>
<p>一个查询的执行顺序依次是FROM、JOIN、WHERE、GROUP BY、HAVING、SELECT、DISTINCT、ORDER BY、LIMIT</p>
<h3 id="3-1-2-关联查询"><a href="#3-1-2-关联查询" class="headerlink" title="3.1.2 关联查询"></a>3.1.2 关联查询</h3><p>在 MySQL 中可以使用 JOIN 在两个或多个表中进行关联查询</p>
<ul>
<li>INNER JOIN（内连接或等值连接），获取两张表中字段匹配的记录，取交集</li>
<li>LEFT JOIN（左连接），获取左表所有记录和右表中匹配的记录，取交集和左表</li>
<li>RIGHT JOIN（右连接），获取右表所有记录和左表中匹配的记录，取交集和右表</li>
</ul>
<p>MySQL 是使用嵌套循环的方式来实现关联查询的，第一张表做外循环/驱动表，第二张表做内循环/被驱动表，外循环/驱动表的每一条记录跟内循环/被驱动表中的记录作比较，符合条件的输出，具体到算法实现上有三种，假设驱动表的行数是 N，被驱动表的行数是 M</p>
<ul>
<li>simple nested loop，全量扫描两张表进行两两对比，复杂度是 O(N*M)</li>
<li>index nested loop，当被驱动表用到的字段有索引时，可以用到索引进行查询，因为索引是 B+Tree，复杂度近似是 O(N*logM)</li>
<li>block nested loop，会提前把驱动表的一部分结果放到 JOIN BUFFER 中，然后被驱动表的每一行都和整个缓存中的数据对比，复杂度还是 O(N*M)，但是由于缓存是基于内存的，所以效率更高</li>
</ul>
<p>以上算法效率都不高，假设每张表的行数都是 N，M 张表的关联查询的复杂度是 O(N^M)，所以不建议使用多表 JOIN，可以改成在代码中基于内存进行关联查询，或者增加数据库中的数据冗余，从而避免关联查询 SQL。</p>
<p>对于 LEFT JOIN 来说，一般选择左表作为驱动表，对于 RIGHT JOIN 来说，一般选择右表作为驱动表，但具体使用哪张表作为驱动表是由优化器以更高的访问性能和筛选性能为原则来决定的，优化器倾向于选择较小的/能够使用过滤条件进行筛选的表作为驱动表，以减少后续的匹配操作。</p>
<p>HASH JOIN 可以用于优化嵌套循环的关联查询，底层用到了 HASH 表，基本思想是将驱动表数据加载到内存/磁盘，由此建立 HASH 表，接着只需要遍历一遍被驱动表，然后再去通过哈希查找在哈希表中寻找匹配的行，就可以完成 JOIN 操作了。</p>
<h3 id="3-1-3-重构方式"><a href="#3-1-3-重构方式" class="headerlink" title="3.1.3 重构方式"></a>3.1.3 重构方式</h3><p>对 MySQL 连接来说，连接和断开连接都非常轻量级，在返回一个小的查询结果方面很高效，因此<strong>可以考虑将大查询切分为多个小查询</strong>。</p>
<p>对 MySQL 的查询缓存来说，如果关联中的某个表发生了变化，那么就无法使用查询缓存，因此<strong>可以将关联查询分解，对每个表进行单表查询并在应用程序中进行关联</strong>，与此同时，执行单个查询还可以减少锁竞争。</p>
<p>MySQL 客户端和服务器之间的通信协议是半双工的，这意味着一旦客户端发送了请求，那么接下来就只能等待并完整地接收整个响应结果，而不能让服务器中途停止发送数据，因此<strong>必要时一定要在查询中加上 LIMIT 限制</strong>，从而让查询能够早点结束，早点释放相应的资源。</p>
<p>MySQL 总是通过创建并填充临时表的方式来执行 UNION，MySQL 默认会给临时表加上 DISTINCT 选项，这会导致对整个临时表的数据做唯一性检查，代价非常高，因此<strong>除非确实需要服务器消除重复的行，则一定要使用 UNION ALL 关键字</strong>，此外，如果希望 UNION 的各个子句能够根据 LIMIT 只取部分结果集，或者希望先排序再合并结果集的话，就需要在 UNION 的各个子句中分别使用 LIMIT 和 ORDER BY，然后再加上全局的 LIMIT 和 ORDER BY。</p>
<p>COUNT() 函数可以统计某个列值的数量，也可以统计行数，如果在括号中指定了列或者列的表达式，则统计的就是这个表达式的非空结果数，如果括号中是<code>*</code>时，会忽略所有的列而直接统计所有的行数，此时效率更高，因此<strong>在需要统计列值的数量又确定该列均不为空时，最好使用COUNT(*)。</strong></p>
<h3 id="3-1-4-特定类型重构"><a href="#3-1-4-特定类型重构" class="headerlink" title="3.1.4 特定类型重构"></a>3.1.4 特定类型重构</h3><p>MySQL 优化器在大多数情况下能够很好的工作，但依旧存在一定的局限性，会对某些类型的查询生成低效的执行计划，因此需要对这类查询进行改写重构，比如</p>
<ul>
<li><p>WHERE 条件中使用 IN() 或者 EXISTS() 包含的子查询需要重构为关联查询</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> film</span><br><span class="line"><span class="keyword">WHERE</span> film_id <span class="keyword">IN</span> (<span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> film_actor <span class="keyword">WHERE</span> actor_id <span class="operator">=</span> <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> film</span><br><span class="line"><span class="keyword">WHERE</span> <span class="keyword">NOT</span> <span class="keyword">EXISTS</span> (<span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> film_actor <span class="keyword">WHERE</span> film_actor.film_id <span class="operator">=</span> film_id);</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 改为</span></span><br><span class="line"><span class="keyword">SELECT</span> film.<span class="operator">*</span> <span class="keyword">FROM</span> film</span><br><span class="line"><span class="keyword">INNER</span> <span class="keyword">JOIN</span> film_actor <span class="keyword">USING</span>(film_id)</span><br><span class="line"><span class="keyword">WHERE</span> actor_id <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">SELECT</span> film.<span class="operator">*</span> <span class="keyword">FROM</span> film</span><br><span class="line"><span class="keyword">LEFT</span> <span class="keyword">JOIN</span> film_actor <span class="keyword">USING</span>(film_id)</span><br><span class="line"><span class="keyword">WHERE</span> film_actor.film_id <span class="keyword">IS</span> <span class="keyword">NULL</span>;</span><br></pre></td></tr></table></figure></li>
<li><p>使用 DISTINCT 和 GROUP BY 的关联查询会产生临时表，需要重构为子查询</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="keyword">DISTINCT</span> film.<span class="operator">*</span> <span class="keyword">FROM</span> film</span><br><span class="line"><span class="keyword">INNER</span> <span class="keyword">JOIN</span> film_actor <span class="keyword">USING</span>(film_id);</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 改为</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> film</span><br><span class="line"><span class="keyword">WHERE</span> <span class="keyword">EXISTS</span> (<span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> film_actor <span class="keyword">WHERE</span> film_actor.film_id <span class="operator">=</span> film_id);</span><br></pre></td></tr></table></figure></li>
<li><p>关联查询做分组时，采用查找表的标识列来做分组的效率会比其他列更高，尤其是使用第二个表的标识列效率更高</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> actor.<span class="operator">*</span> <span class="keyword">FROM</span> film_actor</span><br><span class="line"><span class="keyword">INNER</span> <span class="keyword">JOIN</span> actor <span class="keyword">USING</span> (actor_id)</span><br><span class="line"><span class="keyword">GROUP</span> <span class="keyword">BY</span> actor.first_name, actor.last_name;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 改为</span></span><br><span class="line"><span class="keyword">SELECT</span> actor.<span class="operator">*</span> <span class="keyword">FROM</span> film_actor</span><br><span class="line"><span class="keyword">INNER</span> <span class="keyword">JOIN</span> actor <span class="keyword">USING</span> (actor_id)</span><br><span class="line"><span class="keyword">GROUP</span> <span class="keyword">BY</span> actor.actor_id;</span><br></pre></td></tr></table></figure></li>
<li><p>关联查询的 SELECT 中尽量不要使用非分组列，因为查询得到的非分组列的结果通常是不定的，如果使用非分组列则应确保该非分组列一定是直接依赖分组列，并且在每个分组中的值是唯一的，或者业务上根本不在乎这个值具体是什么</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> actor.<span class="operator">*</span> <span class="keyword">FROM</span> film_actor</span><br><span class="line"><span class="keyword">INNER</span> <span class="keyword">JOIN</span> actor <span class="keyword">USING</span> (actor_id)</span><br><span class="line"><span class="keyword">GROUP</span> <span class="keyword">BY</span> actor.actor_id;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 改为</span></span><br><span class="line"><span class="keyword">SELECT</span> actor.actor_id <span class="keyword">FROM</span> film_actor</span><br><span class="line"><span class="keyword">INNER</span> <span class="keyword">JOIN</span> actor <span class="keyword">USING</span> (actor_id)</span><br><span class="line"><span class="keyword">GROUP</span> <span class="keyword">BY</span> actor.actor_id;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 或者</span></span><br><span class="line"><span class="keyword">SELECT</span> actor.first_name, actor.last_name <span class="keyword">FROM</span> film_actor</span><br><span class="line"><span class="keyword">INNER</span> <span class="keyword">JOIN</span> actor <span class="keyword">USING</span> (actor_id)</span><br><span class="line"><span class="keyword">GROUP</span> <span class="keyword">BY</span> actor.actor_id;</span><br></pre></td></tr></table></figure></li>
<li><p>分组查询时，如果没有通过 ORDER BY 子句显示的指定排序列，结果集会自动按照分组列进行排序，如果不关心结果集的顺序，而这种默认又导致了需要文件排序，则应显示指定不需要排序，如果希望按照分组列进行排序，也应显示指定排序方向</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> actor.actor_id <span class="keyword">FROM</span> film_actor</span><br><span class="line"><span class="keyword">INNER</span> <span class="keyword">JOIN</span> actor <span class="keyword">USING</span> (actor_id)</span><br><span class="line"><span class="keyword">GROUP</span> <span class="keyword">BY</span> actor.actor_id;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 改为</span></span><br><span class="line"><span class="keyword">SELECT</span> actor.actor_id <span class="keyword">FROM</span> film_actor</span><br><span class="line"><span class="keyword">INNER</span> <span class="keyword">JOIN</span> actor <span class="keyword">USING</span> (actor_id)</span><br><span class="line"><span class="keyword">GROUP</span> <span class="keyword">BY</span> actor.actor_id</span><br><span class="line"><span class="keyword">ORDER</span> <span class="keyword">BY</span> <span class="keyword">NULL</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 或者</span></span><br><span class="line"><span class="keyword">SELECT</span> actor.actor_id <span class="keyword">FROM</span> film_actor</span><br><span class="line"><span class="keyword">INNER</span> <span class="keyword">JOIN</span> actor <span class="keyword">USING</span> (actor_id)</span><br><span class="line"><span class="keyword">GROUP</span> <span class="keyword">BY</span> actor.actor_id <span class="keyword">DESC</span>;</span><br></pre></td></tr></table></figure></li>
<li><p>当使用 LIMIT 且偏移量又非常大的时候，可以考虑使用覆盖索引来扫描大量偏移找到真正所需的行，然后根据需要做一次关联操作从而返回所需的列</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> film_id, description <span class="keyword">FROM</span> film</span><br><span class="line"><span class="keyword">ORDER</span> <span class="keyword">BY</span> title LIMIT <span class="number">1000</span>, <span class="number">5</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 改为</span></span><br><span class="line"><span class="keyword">SELECT</span> film_id, description <span class="keyword">FROM</span> film</span><br><span class="line"><span class="keyword">INNER</span> <span class="keyword">JOIN</span> (<span class="keyword">SELECT</span> film_id <span class="keyword">FROM</span> film <span class="keyword">ORDER</span> <span class="keyword">BY</span> title LIMIT <span class="number">1000</span>, <span class="number">5</span>) <span class="keyword">USING</span> (film_id);</span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="3-2-更新"><a href="#3-2-更新" class="headerlink" title="3.2 更新"></a>3.2 更新</h2><h3 id="3-2-1-执行流程"><a href="#3-2-1-执行流程" class="headerlink" title="3.2.1 执行流程"></a>3.2.1 执行流程</h3><p>一次完整的 Update 操作过程基本如下</p>
<ul>
<li>InnoDB 首先在 Buffer Pool 中查找要更新的记录是否在内存中，如果不在，则从磁盘读取该页到 Buffer Pool 中</li>
<li>InnoDB 在 UndoLog 中记录修改前的数据（用来保证事务原子性和一致性，事务回滚时将修改操作回滚到修改前的状态），UndoLog 的写入是先写入到内存中，再由一个后台线程定时刷新到磁盘中（异步执行）</li>
<li>InnoDB 在 Buffer Pool 中更新该页，将该页的状态设置为脏页（表示该页已经被修改但尚未写入磁盘），更新的同时也将修改操作写入到 RedoLog buffer 中</li>
<li>InnoDB 在提交事务时会将 RedoLog 写入磁盘（以保证事务持久性），将事务信息（事务开始的时间、数据库名、表名、事务 ID、SQL 语句）记录到 BinLog 中（主从复制，用于将主库上的事务同步到从库上），这一过程通过两阶段提交来保证一致性</li>
<li>InnoDB 在提交事务之后，通过一个后台线程在 MySQL 服务器空闲或者负载较低时（或者 MySQL 关闭或重启时）将 Buffer Pool 中的脏页写入磁盘（异步执行），因此可能会延迟写入</li>
</ul>
<h3 id="3-2-2-两阶段提交"><a href="#3-2-2-两阶段提交" class="headerlink" title="3.2.2 两阶段提交"></a>3.2.2 两阶段提交</h3><p>如果先写入 RedoLog 成功，但还没来得及写入 BinLog 时系统崩溃，在 MySQL 重启后可以根据 RedoLog 重写，但是主从同步时，从库无法从 BinLog 中得知这条 SQL，进而会导致主从数据不一致。</p>
<p>如果先写入 BinLog 成功，但还没来得及写入 RedoLog 时系统崩溃，MySQL 重启后不会进行重写，主库中的操作丢失，但是主从同步时，从库会从 BinLog 中得知这条 SQL，依旧会导致主从数据不一致。</p>
<p>两阶段提交是在更新过程中保持 BinLog 和 RedoLog 一致性的一种手段，RedoLog 和 BinLog 中都会记录一个全局唯一标识的事务 ID，如果 RedoLog 和 BinLog 中所记录的事务 ID 是一致的，MySQL 就认为 RedoLog 和 BinLog 逻辑上是一致的。</p>
<ul>
<li>Prepare 阶段，这个阶段 SQL 已经成功执行并生成 RedoLog，假如此时系统崩溃，直接回滚事务即可，RedoLog 和 BinLog 都没有相应的记录</li>
<li>BinLog 持久化，通过<code>write</code>将 BinLog 写入文件缓冲区，通过<code>fsync</code>将 BinLog 从文件缓冲区永久写入磁盘，假如此时系统崩溃，重启后检查 BinLog 中的事务是否存在且完整，如果完整则提交事务，不存在或不完整则回滚事务</li>
<li>Commit，在执行引擎内部执行事务操作，更新 RedoLog，假如此时系统崩溃，重启后的处理同上一步一致</li>
</ul>
<p>组提交通过将多个事务的提交操作合并成一个批处理操作来减少磁盘 I/O 和锁定开销，从而加速事务的处理，此时需要累计多个事务都到达 Prepare 阶段后再将一组日志一次性持久化到磁盘。</p>
<h3 id="3-2-3-插入或更新"><a href="#3-2-3-插入或更新" class="headerlink" title="3.2.3 插入或更新"></a>3.2.3 插入或更新</h3><p>INSERT INTO … ON DUPLICATE KEY UPDATE 语句可以实现插入或更新的功能，这要求表必须有主键或唯一索引，插入的数据必须包含主键或唯一索引，主键或唯一索引列的值不能为 Null</p>
<p>此外，REPLACE INTO 会在存在唯一索引冲突时先删除旧记录，INSERT IGNORE INTO 会在唯一索引冲突时忽略该条插入操作且不报错</p>
<h3 id="3-2-4-热点数据更新"><a href="#3-2-4-热点数据更新" class="headerlink" title="3.2.4 热点数据更新"></a>3.2.4 热点数据更新</h3><p>热点数据的高效更新对于高并发秒杀场景至关重要</p>
<ul>
<li>库存拆分<ul>
<li>将一个大的库存拆分成多个小库存，拆分后更新操作就可以分散道不同的库表中进行，降低锁粒度提升并发</li>
<li>实现较简单，但存在碎片问题、库存调控并不方便</li>
</ul>
</li>
<li>请求合并<ul>
<li>将多个库存扣减请求合并成一个，进行批量更新</li>
<li>实现较简单，更适用于异步场景，或者经过分析后认为可以将更新合并的场景</li>
</ul>
</li>
<li>将 UPDATE 转换成 INSERT<ul>
<li>直接插入一次占用记录，然后异步统计剩余库存</li>
<li>没有 UPDATE 操作，无锁冲突，但不好统计剩余库存</li>
</ul>
</li>
<li>热点检测<ul>
<li>针对频繁更新或秒杀类业务场景，大幅度优化对于热点行数据的 UPDATE 操作，当开启热点更新自动探测时，系统会自动探测是否有单行的热点更新，让大量的并发 UPDATE 排队执行，以减少大量行锁造成的并发性能下降</li>
<li>开发不需要做额外的事情，但改造 MySQL 有成本，有很多云上数据库都支持这种热点检测</li>
</ul>
</li>
</ul>
<h2 id="3-3-分区"><a href="#3-3-分区" class="headerlink" title="3.3 分区"></a>3.3 分区</h2><h3 id="3-3-1-分区表"><a href="#3-3-1-分区表" class="headerlink" title="3.3.1 分区表"></a>3.3.1 分区表</h3><p>对用户来说，分区表是一个独立的逻辑表，但是底层由多个物理子表组成。分区的主要目的是将数据按照一个较粗的粒度分在不同的表中，将相关的数据存放在一起。适用于大数据量的过滤场景。</p>
<p>MySQL通过对底层物理子表封装来实现分区表，所有的字表都是被隐藏的，只能通过分区表去访问字表。</p>
<p>MySQL存储引擎管理分区的各个底层表和管理普通表一样，从存储引擎的角度来看，分区底层表和普通表没有不同，无须区分。与此同时，索引也是按照分区的子表定义的，分区表的索引只是在各个底层表上各自加上一个完全相同的索引。</p>
<p>MySQL支持多种分区表。使用较多的是根据范围进行分区，每个分区存储落在某个范围的记录。除此之外，MySQL还支持键值、哈希和列表分区以及子分区。</p>
<p>分区表达式可以是列，也可以是包含列的表达式，但表达式返回的值必须是一个确定的整数，而且不能是一个常数。</p>
<h3 id="3-3-2-优势与限制"><a href="#3-3-2-优势与限制" class="headerlink" title="3.3.2 优势与限制"></a>3.3.2 优势与限制</h3><p>分区表的优点如下</p>
<ul>
<li>查询、批量删除、优化、检查、备份和修复时都很方便</li>
<li>将需要放入内存的数据范围缩小至小范围的热点数据</li>
<li>可令不同的分区分布在不同的物理设备上，高效利用多个硬件设备</li>
<li>减少InnoDB的单个索引的互斥访问、锁竞争等</li>
</ul>
<p>分区表的限制如下</p>
<ul>
<li>一个表最多只能有1024个分区</li>
<li>如果分区字段中有主键或者唯一索引的列，那么所有主键列和唯一索引列都必须包含进来</li>
<li>分区表中无法使用外键约束</li>
<li>所有的分区底层表都必须使用相同的存储引擎（有些存储引擎不支持分区）</li>
<li>索引作用范围在各个分区内，没有全局索引</li>
</ul>
<h3 id="3-3-3-使用分区"><a href="#3-3-3-使用分区" class="headerlink" title="3.3.3 使用分区"></a>3.3.3 使用分区</h3><p>数据库在根据索引的扫描结果回表查询所有符合条件的记录时，会产生大量的随机I/O，响应时间会大的不可接收的程度，此外，索引维护的代价也非常高。因此，在数据量超大的时候，B+Tree索引就无法起作用了（除非是覆盖索引），</p>
<p>此时，需要通过分区技术以代价非常小的方式区分出查询需要的较小范围的数据。因为分区不需要精确定位每条数据的位置，无需额外的数据结构记录每个分区有哪些数据，所以代价非常低，只需要一个简答的表达式就可以表达每个分区存放是什么数据。</p>
<p>使用分区表时需要注意的事项如下</p>
<ul>
<li><p>分区表达式的值不能为NULL</p>
<p>当表达式的值为NULL或者非法时，该记录会被存放到第一个分区，那么后续对数据进行操作时，不仅仅会全量扫描WHERE条件筛选出的分区，还会扫描存放NULL值和非法值的第一个分区，如果第一个分区非常大，数据操作的代价也就非常大</p>
</li>
<li><p>分区列与索引列匹配</p>
<p>如果定义的索引列和分区列不匹配，会导致查询无法进行分区过滤，应当避免建立与分区列不匹配的索引</p>
</li>
<li><p>范围分区的分区数尽量限制在100以下</p>
<p>在进行范围分区时，随着分区数的增长，搜索分区的成本越来越高，可以通过限制分区的数量来缓解（其他分区类型，比如键分区和哈希分区，则没有这样的问题）</p>
</li>
<li><p>使用批量操作而非单行单个操作</p>
<p>当查询访问分区表时，在分区过滤之前是需要打开并锁住所有底层表的，这对单行单个操作来说会带来明显的额外开销，因此可以用批量操作的方式来降低单个操作的此类开销</p>
</li>
<li><p>访问分区表时要在WHERE条件中带入分区列</p>
<p>即便在创建分区时可以使用表达式，但在在查询时只能根据列来过滤分区，不能根据表达式的值去过滤分区</p>
</li>
</ul>
<h2 id="3-4-缓存"><a href="#3-4-缓存" class="headerlink" title="3.4 缓存"></a>3.4 缓存</h2><h3 id="3-4-1-缓存与命中"><a href="#3-4-1-缓存与命中" class="headerlink" title="3.4.1 缓存与命中"></a>3.4.1 缓存与命中</h3><p>MySQL将缓存存放在一个引用表中，通过一个哈希值引用，从而缓存完整的SELECT查询结果。当判断缓存是否命中时，MySQL会直接使用SQL语句和客户端发送过来的其他原始信息进行比较，任何字符上的不同（包括空格、注释）都会导致缓存不命中。当查询命中该缓存，MySQL会立即返回结果（即使要查询的表被锁住时），跳过了解析、优化和执行阶段。</p>
<p>此外，当查询语句中具有不确定的数据或者任何用户自定义函数、用户变量、临时表以及包含列级权限的表时，则不会缓存结果；如果查询中涉及到任何一个表发生了变化，那么和这个表相关的所有的缓存数据以及关联表的缓存数据都将失效。</p>
<p>在一个InnoDB事务在提交之前，与该事务所修改的表相关的查询时无法被缓存的，因此长时间运行的事务会大大降低缓存的命中率。</p>
<h3 id="3-4-2-缓存与内存"><a href="#3-4-2-缓存与内存" class="headerlink" title="3.4.2 缓存与内存"></a>3.4.2 缓存与内存</h3><p>查询缓存是完全存储在内存中的，缓存数据包含维护相关的数据（大约40KB）和查询结果，用于查询结果的内存则被分为一个个变长的数据块。</p>
<p>当有查询结果需要缓存时，MySQL会申请一个数据块用于存储结果，由于需要在查询开始返回时结果时就分配空间，而此时是无法预知查询结果到底多大的，无法为每一个查询结果精确分配大小恰好匹配的缓存空间，因此可能会在缓存数据块之间留下很多内存碎片。</p>
<p>此外，如果缓存使用了很大的内存并存放了大量的查询结果，而在进行缓存失效操作时是需要通过一个全局锁来保护的，此时，所有需要做该操作的查询（无论是否命中缓存、还是缓存失效检测）都要等待这个锁，这就很可能导致整个系统都僵死一段时间，因此缓存过大时会带来过大的系统消耗。</p>
<p>查询缓存并不一定能起到正向作用，但对于复杂的SELECT语句且涉及到的UPDATE、DELETE和INSERT操作相比SELECT来说非常少的情况，可以使用查询缓存。</p>
<h3 id="3-4-3-缓存和-InnoDB"><a href="#3-4-3-缓存和-InnoDB" class="headerlink" title="3.4.3 缓存和 InnoDB"></a>3.4.3 缓存和 InnoDB</h3><p>因为InnoDB有自己的MVCC机制，所以相比其他存储引擎，InnoDB和查询缓存的交互要更加复杂。InnoDB会控制在一个事务中是否可以使用查询缓存，每一个InnoDB表的内存数据字典都保存了一个事务的ID号，而事务是否可以访问查询缓存取决于当前事务ID以及对应的数据表上是否有锁。</p>
<p>原则上，在InnoDB的MVCC架构下，当某些修改不影响其他事务读取一致的数据时，是可以使用查询缓存的，但是这样实现起来会非常复杂，InnoDB做了一个简化，让所有有加锁操作的事务都不使用任何查询缓存。</p>
<h3 id="3-4-4-使用缓存"><a href="#3-4-4-使用缓存" class="headerlink" title="3.4.4 使用缓存"></a>3.4.4 使用缓存</h3><p>库表结构的设计、查询语句、应用程序设计都可能会影响到查询缓存的效率，一些使用注意事项如下</p>
<ul>
<li>用多个小表代替一个大表对查询缓存有好处，这会使得失效策略能够在一个更合适的粒度上进行</li>
<li>批量写入相比单条写入效率更好，这会使得缓存失效操作只需进行一次，但不要同时做延迟写和批量写，这会导致服务器僵死较长时间</li>
<li>控制缓存空间，空间太大时进行过期操作会导致服务器僵死较长时间</li>
<li>对于写密集型的应用来说，直接禁用查询缓存可能会提高系统的性能</li>
<li>对于读密集型的应用来说，由于互斥信号量的竞争，有时也可以通过禁用缓存来提高性能</li>
<li>在高并发压力环境中查询缓存往往会导致系统性能的下降，此时不建议使用查询缓存</li>
</ul>
<h2 id="3-5-其他"><a href="#3-5-其他" class="headerlink" title="3.5 其他"></a>3.5 其他</h2><h3 id="3-5-1-视图"><a href="#3-5-1-视图" class="headerlink" title="3.5.1 视图"></a>3.5.1 视图</h3><p>视图本身是一个虚拟表，不存放任何数据，不能建立索引，而在使用SQL语言访问视图时，视图返回的数据是从MySQL从其他表中生成的。因此，视图就像是一个窗口，用户通过各种视图来从不同的角度查看自己感兴趣的数据。</p>
<p>在基于视图执行查询时，MySQL可以使用合并算法和临时表算法来实现视图。如果可能，会尽可能使用合并算法，但如果视图中包含GROUP BY、DISTINCT、任何聚合函数，UNION、子查询等只要无法在原表记录和视图记录中简历一一映射场景时，都会使用临时表算法来实现视图。当视图使用临时表时，无法将WHERE条件下推到各个具体的表，也不能使用任何索引。</p>
<p>使用临时表算法实现的视图在某些时候性能会很糟糕，而即使是基于合并算法实现的视图也会有额外的开销，而且视图的性能难以预测，所以视图在性能优化上还不是那么成熟。</p>
<h3 id="3-5-2-主键"><a href="#3-5-2-主键" class="headerlink" title="3.5.2 主键"></a>3.5.2 主键</h3><p>主键可以是任意一种数据类型，一般是以一个自增字段作为主键，这可以避免主键重复，减少新行插入时的重排序，减少数据页的分裂以及分裂导致的内存碎片和 I/O 操作，查询速度更快，但由于 ID 是顺序自增可预测的，这就给系统带来了一定的安全风险，ID 也可能会用尽（用尽后下一次插入会报主键冲突），另外在分库分表场景下无法依赖一张表的自增来做主键 ID（会有冲突）。</p>
<p>如果没有定义主键 InnoDB 则选择一个唯一的非空索引代替，如果没有这样的索引则隐式定义一个隐藏的主键（比如 row_id，用户无法看到或修改这个列，但可以使用该列来进行排序或连接操作）来作为聚簇索引，从而聚集数据。隐式主键 row_id 用完后下一次插入会覆盖历史数据（无感知）。</p>
<p>UUID 虽然几乎不可能用完，但是会增加存储需求，会导致较频繁的页分裂，写入开销大，也不适合范围查询，取值无实际含义，不方便页面展示，查询效率低。</p>
<p>一旦自增主键真的用完，可以考虑使用分布式 ID。</p>
<h3 id="3-5-3-外键"><a href="#3-5-3-外键" class="headerlink" title="3.5.3 外键"></a>3.5.3 外键</h3><p>InnoDB 是 MySQL 中唯一支持外键的内置存储引擎，外键用于确保两个相关表中始终有一致的数据列，有助于维护数据的一致性和完整性，但这也导致查询需要额外访问一些别的表，意味着需要额外的锁，甚至会导致一些死锁，且难以排查。</p>
<p>对于相关数据的同时更新使用外键更合适，但是如果外键只是用作数值约束，那么使用触发器或者显示的通过枚举来限制取值的性能会更好些。</p>
<p>级联更新时强阻塞，存在数据库更新风暴的风险，外键与级联更新适用于单机低并发，不适合分布式、高并发集群，如果设计的是一个高性能的系统，那么在更在意系统性能的情况下不会使用外键，而是通过应用程序来维护。</p>
<p>外键通过难以跨越不同数据库来建立关系，无法适应分库分表场景。</p>
<h3 id="3-5-4-触发器"><a href="#3-5-4-触发器" class="headerlink" title="3.5.4 触发器"></a>3.5.4 触发器</h3><p>触发器可以在执行增删改操作的前后执行一些特定的操作，可以读取或者改变触发SQL语句所影响的数据，因此，可以使用触发器实现一些强制限制，否则，就需要在应用程序中实现这些逻辑。</p>
<p>触发器可以用于自动更新反范式化数据以及记录变更日志等，可以保证数据总是一致的，可以减少客户端和服务器之间的通信，可以简化应用逻辑，还可以提高性能。</p>
<p>但对于每一个表的每一个事件，最多只能定义一个触发器，且MySQL只支持基于行的触发，即触发器始终是针对一条记录的，如果变更的数据集非常大的话，效率会很低。</p>
<p>在InnoDB表上的触发器是在同一个事务中完成的，原操作和触发器操作会同时失败或者成功，因此，在排查问题时原操作和触发器都需要进行排查。</p>
<h3 id="3-5-5-存储过程"><a href="#3-5-5-存储过程" class="headerlink" title="3.5.5 存储过程"></a>3.5.5 存储过程</h3><p>存储过程是一种在数据库中存储地预编译的代码块，可以执行一系列的数据库操作，存储过程被设计用来完成特定的功能或业务逻辑，通常是一组 SQL 语句的集合。</p>
<p>存储过程的执行效率低于应用程序，但优于某些操作，比如存储过程调用可以替代很多小查询时（节省了查询解析和网络开销）。</p>
<p>存储过程难以维护和调试，MySQL也没有控制存储程序的资源消耗的方案，所以存储过程中的一个小错误可能直接把服务器拖死。</p>
<p>存储过程会给数据服务器增加额外的压力，而数据库服务器的扩展性相比应用程序要差很多，存储过程通常不是跨数据库平台兼容的。</p>
<p>过度依赖存储过程可能会导致数据库权限和访问控制变得复杂，也很难将它们纳入常规的源代码管理、代码审查和版本控制流程。</p>
<p>最好不要复制对存储过程的调用，直接复制由存储过程程序改变的数据则会更好。</p>
<p>一般推荐的做法是直接在应用程序中实现业务逻辑，这可以通过任何服务器端编程语言完成，可以提高代码的可移植性和可维护性，应用程序代码也更加容易管理和部署。</p>
<h3 id="3-5-6-排序"><a href="#3-5-6-排序" class="headerlink" title="3.5.6 排序"></a>3.5.6 排序</h3><p>排序的方式主要取决于优化器的选择，如果优化器认为使用索引更快则采用索引排序，否则就会采用文件排序（filesort）。</p>
<p>索引天然就是有序的，因此采用索引排序的效率是最高的，在查询字段和排序组成联合索引并且查询条件符合最左前缀匹配，查询可以用到索引覆盖时采用索引排序的概率很大，此外通过 LIMIT 等方式来将查询行数限制在一个较小的大小时大概率也会采用索引排序。</p>
<p>在采用 filesort 时，MySQL 会给每个线程分配一块内存用于排序，称为 sort_buffer，如果需要排序的内容小于 sort_buffer，排序就会在 sort_buffer 内存中进行，否则就需要使用磁盘临时文件，临时文件采用归并排序，首先会把需要排序的数据拆分到多个临时文件里同步进行排序操作，然后把多个排好序的文件合并成一个结果集返回给客户端。</p>
<p>如果需要排序的字段长度并不长，那么就会使用全字段排序（将查询的所有字段都放到 sort_buffer 或临时文件中）直接返回结果集，如果字段长度很长，则采用 row_id 排序，并在根据排序字段完成对主键的排序后二次回表再返回结果集。</p>
<p>ORDER BY 的列中，如果多行具有相同的值，服务器会自由地以任何顺序返回这些行，因此在排序的基础上进行分页时一定要通过具备唯一性的字段来令排序方式固定。</p>
<h3 id="3-5-7-计数"><a href="#3-5-7-计数" class="headerlink" title="3.5.7 计数"></a>3.5.7 计数</h3><p>COUNT(1) 和 COUNT(*) 表示是直接查询符合条件的行数（包含值为 Null 的行），两者性能接近，COUNT(col) 表示是查询符合条件的列的不为 Null 的行数，由于 COUNT(col) 需要判断是否为 Null，因此性能比前两个要慢一些。</p>
<p>由于 MyISAM 的锁是表级锁，不会有并发的行数修改，所以 MyISAM 把表的总行数单独记录下来，在没有 WHERE 条件的行数查询时就可以直接返回记录下来的表的行数；而 InnoDB 支持行级锁，表的行数可能会被并发修改，那么缓存记录下来的总行数就是不准确的了，那么在统计行数时，InnoDB 会优先选择最小的非聚簇索引（比聚簇索引小得多）来扫表。</p>
<h3 id="3-5-8-分页"><a href="#3-5-8-分页" class="headerlink" title="3.5.8 分页"></a>3.5.8 分页</h3><p>LIMIT 0 可以快速返回一个空的结果集，这是用来检测一个查询是否有效的一种很有用的方式。</p>
<p>MySQL 通常更愿意执行全表扫描，但如果通过 LIMIT 限制只查询很少的行数的话，某些情况下就可能会使用索引。</p>
<p>LIMIT 很适合用来提前终止扫描，即避免不必要的扫描，如果明确知道需要的行数的话，那么建议使用 LIMIT。</p>
<p>对于同样大小的页，查询偏移量更大的页显然性能更差，这种深度分页会先读取包括偏移量和所需页的记录，再丢弃偏移量数据，返回所需页。</p>
<p>可以通过主键查询来优化深度分页，首先通过子查询来获取所需页的主键（仅需要丢弃偏移主键数据），然后再使用这些主键在主查询中获取完整的数据行，基于主键的查询则非常高效。</p>
<h3 id="3-5-9-数据页"><a href="#3-5-9-数据页" class="headerlink" title="3.5.9 数据页"></a>3.5.9 数据页</h3><p>InnoDB 数据页是 InnoDB 存储引擎中用于存储数据的基本单位，是磁盘上的一个连续区域，大小通常为 16 KB，InnoDB 的每次读写都是以一个数据页大小为单位的，B+Tree 的每个节点都对应着一个数据页，B+Tree 通过节点之间的指针连接了不同层级的数据页，从而构建了一个高效有序的索引结构。</p>
<p>页分裂是指将该页中的一部分索引记录移动到一个新的页面中，从而为新记录腾出空间，保持 B+Tree 的平衡和性能，分裂这个动作可能会引起连锁反应，从叶子节点沿着树结构一路分裂到根节点。页合并是指将两个相邻的索引页面合并成一个更大的页面，减少 B+Tree 的层级，从而提升查询性能。</p>
<p>页分裂和页合并时涉及大量数据移动和重组的操作，频繁进行这种操作会导致 B+Tree 索引结构频繁调整，增加数据库的 I/O 负担和 CPU 消耗，影响数据库的插入和删除等操作的整体性能，也导致磁盘上数据库占用更多的磁盘空间以及较多的空间碎片。</p>
<p>插入大量数据时尽量使用批量插入的方式，而不是逐条插入，从而减少页分裂的次数。为了避免频繁删除导致页面过于稀疏而触发页合并，一般建议使用逻辑删除而不是物理删除。</p>
<h3 id="3-5-10-长事务"><a href="#3-5-10-长事务" class="headerlink" title="3.5.10 长事务"></a>3.5.10 长事务</h3><p>长事务是指事务中要执行的 SQL 很多，事务的事件比较长，这会导致长时间占用数据库连接，难以回滚，更多更大概率的锁竞争，大量日志等问题，因此应当确保事务中只包含必须的处理，将不需要再事务中进行的操作（如读操作、内存计算、I/O 操作、远程调用等）放到事务外处理。</p>
<h3 id="3-5-11-删除"><a href="#3-5-11-删除" class="headerlink" title="3.5.11 删除"></a>3.5.11 删除</h3><p>DELETE 用于删除表中的一行或多行记录，可以配合 WHERE 一起使用，操作过程中会记录 BinLog，比较慢，可以回滚，不会重置自增的计数器，是 DML。</p>
<p>TRUNCATE 用于快速删除表中的所有记录，并重置自增的计数器，不可以配合 WHERE 一起使用，速度很快，是 DDL。</p>
<p>DROP 用于删除整个表结果及其数据，不可以配合 WHERE 一起使用，操作不可回滚，速度很快，是 DDL，如果需要恢复可以尝试数据库备份但不保证可以百分百恢复。</p>
<h2 id="3-6-执行计划"><a href="#3-6-执行计划" class="headerlink" title="3.6 执行计划"></a>3.6 执行计划</h2><p>查看执行计划时需要重点关注的字段如下</p>
<ul>
<li>type<ul>
<li>表示查询时所使用的索引类型</li>
<li>system，系统表，数据量很少，往往在内存中，不需要磁盘 I/O</li>
<li>const，使用唯一索引，唯一的常数值进行索引匹配</li>
<li>eq_ref，使用唯一索引，只会扫描索引树中的一个匹配行</li>
<li>ref，使用非唯一索引，只会扫描索引树中的一部分来查找匹配的行</li>
<li>range，范围扫描，只会扫描索引树中的一个范围来查找匹配的行</li>
<li>index，全索引扫描，会遍历索引树来查找匹配的行</li>
<li>ALL，全表扫描，没有使用索引</li>
</ul>
</li>
<li>key<ul>
<li>表示查询优化器选择使用的索引</li>
</ul>
</li>
<li>Extra<ul>
<li>Using where，表示查询的列未被索引覆盖，需要检索到数据行后再进行条件过滤</li>
<li>Using index，表示查询的列被索引覆盖，只需要扫描索引，无需回表检索行</li>
<li>Using index condition，表示在索引上执行了部分条件过滤，即索引下推</li>
<li>Using where; Using index，表示查询的列被索引覆盖，且条件过滤列式索引列之一，但不符合最左前缀</li>
<li>Using join buffer，表示使用了连接缓存</li>
<li>Using temporary，表示创建了临时表来存储查询结果，一般在排序或分组时发生</li>
</ul>
</li>
</ul>
<p>执行计划中排在第一行的表是驱动表，排在第二行的表是被驱动表</p>
<p><a target="_blank" rel="noopener" href="https://www.yuque.com/hollis666/niq4hm/fho0bamf4qpcril5">https://www.yuque.com/hollis666/niq4hm/fho0bamf4qpcril5</a></p>
<p><a target="_blank" rel="noopener" href="https://www.yuque.com/hollis666/niq4hm/gux80i">https://www.yuque.com/hollis666/niq4hm/gux80i</a></p>
<p><a target="_blank" rel="noopener" href="https://www.yuque.com/hollis666/niq4hm/upcggbxiyk11gudc">https://www.yuque.com/hollis666/niq4hm/upcggbxiyk11gudc</a></p>
<p><a target="_blank" rel="noopener" href="https://www.yuque.com/hollis666/niq4hm/dxmpt2">https://www.yuque.com/hollis666/niq4hm/dxmpt2</a></p>
<p>累了，学不动，等以后有空再研究</p>
<h1 id="4、复制"><a href="#4、复制" class="headerlink" title="4、复制"></a>4、复制</h1><p>复制解决的基本问题是让一台服务器的数据和其他服务器保持同步，实现一种“水平扩展”的架构，这种功能不仅有利于构建高性能的应用，同时也是死高可用性、可扩展性、灾难恢复、备份以及数据仓库等工作的基础。</p>
<p>通过复制所实现的“水平扩展”可以将读操作指向备库来获得更好的读扩展，但由于不能像分发读操作那样将写操作等同地分发到更多服务器上，随着查询数量的增加，需要的服务器数量的增加并非线性扩展，即当为单台主库增加备库时，将很快达到投入远高于回报的地步。因此，对于写操作，并不适合通过复制来扩展写操作，写操作通常是复制的瓶颈（对数据进行分区是唯一可以扩展写操作的方法）。</p>
<h2 id="4-1-复制方式"><a href="#4-1-复制方式" class="headerlink" title="4.1 复制方式"></a>4.1 复制方式</h2><h3 id="4-1-1-执行流程"><a href="#4-1-1-执行流程" class="headerlink" title="4.1.1 执行流程"></a>4.1.1 执行流程</h3><p>MySQL支持两种复制方式，基于行的复制和基于语句的复制，这两种方式都有以下三个步骤</p>
<ul>
<li>在主库每次提交事务完成数据更新前，把数据更改记录到 BinLog（这些记录被称为 BinLog 事件），记录后主库会告知存储引擎可以提交事务了（MySQL 会按事务提交的顺序而非每条语句的执行顺序来记录 BinLog）</li>
<li>备库启动一个 I/O 线程，该线程跟主库建立一个普通的客户端连接，然后在主库上启动一个二进制转储线程，该线程会自动读取主库上 BinLog 中的事件，备库 I/O 线程会将接收到的事件记录到自己的 RelayLog 中，完成从 BinLog 到 RelayLog 的复制</li>
<li>备库启动一个 SQL 线程来读取 RelayLog 中的事件，将其重放到备库数据之上，实现异步的数据复制</li>
</ul>
<p>以上这种复制架构实现了获取事件和重放事件的解耦，允许这两个过程异步进行，但是<strong>由于备库只有一个 SQL 线程来重放 RelayLog 中的事件，因此主库上并发运行的查询在备库只能串行化执行</strong>。此外，<strong>需要给每个服务器分配一个全局唯一的服务器 ID</strong>，当复制 SQL 线程读中继日志时，会丢弃事件中记录的服务器 ID 和该服务器本身 ID 相同的事件，从而打破复制过程中的无限循环。</p>
<p>主从延迟是指在主从复制过程中，从服务器上的数据与主服务器上的数据之间存在的时间差或延迟，一般来说可能是网络延迟、从节点 CPU、内存、线程数量等性能问题导致的。</p>
<h3 id="4-1-2-复制方式"><a href="#4-1-2-复制方式" class="headerlink" title="4.1.2 复制方式"></a>4.1.2 复制方式</h3><p>基于语句的复制也称为逻辑复制，此时，主库会记录那些造成数据更改的查询，当备库读取并重放这些事件时，实际上只是把主库上执行过的SQL再执行一遍。</p>
<ul>
<li>逻辑复制实现起来非常简单，并且能让二进制日志里的事件更加紧凑</li>
<li>即便主备的模式不同（比如表的定义不同但数据类型相兼容，列的顺序不同等），逻辑复制依旧能够工作</li>
<li>逻辑复制基本上就是执行 SQL，那么所有在服务器上发生的变更都以一种容易理解的方式运行，出现问题时可以很好地定位</li>
<li>考虑到同一条 SQL 在不同时刻下执行可能并不相同，因此在传输的二进制日志中，除了查询语句，还包括了一些元数据信息（比如当前的时间戳），即便如此，依旧存在无法一些被正确复制的 SQL（比如使用了触发器或者存储过程）</li>
<li>由于更新必须是串行的，这意味着需要更多的锁，可能代价会很高</li>
<li>不是所有的存储引擎都支持这种复制模式</li>
<li>单线程的逻辑复制常常导致备库容量小于主库</li>
</ul>
<p>基于行的复制会将实际数据记录在二进制日志中。</p>
<ul>
<li>基于行的复制的最大的好处是可以正确的复制每一行数据，无需重放更新主库数据的查询，能更加高效的复制数据</li>
<li>因为基于行的复制并不要求这种强串行化是可重复的，因此可以减少锁的使用，也占用更少的 CPU</li>
<li>基于行的复制模式下，如果在备库更新一个不存在的记录时会报错并停止复制，因此能够帮助找到并解决数据不一致的情况</li>
<li>但如果被更新的数据量非常大，比如全表更新，此时每一行的数据都会被记录到二进制日志中，这使得二进制日志事件非常庞大，复制开销会很大</li>
<li>基于行的复制并不知道主库中到底执行了哪些 SQL，因此出现问题时很难找到问题所在</li>
</ul>
<p>MySQL 默认情况下使用的是基于语句的复制方式，如果发现语句无法被正确地复制，就切换到基于行的复制模式。</p>
<h3 id="4-1-3-异步和同步"><a href="#4-1-3-异步和同步" class="headerlink" title="4.1.3 异步和同步"></a>4.1.3 异步和同步</h3><p>MySQL 目前支持全同步复制、异步复制和半同步复制。</p>
<p>异步复制是 MySQL 默认的复制方式，主库在执行完事务操作以后，会立刻返回给客户端，无需关心从库是否完成该事务的执行，当主库执行完事务但还没来得及将数据同步给从库时，从库就会丢失这次事务的变更内容。</p>
<p>全同步复制是指主库执行完一个事务后等待所有从库完成数据复制之后才会给客户端反馈，这种方式可以保障安全性，但当从库比较多时性能很差。</p>
<p>半同步复制是介入全同步复制和异步复制之间的一种方案，主库在执行完一个事务之后，也不会立刻给客户端反馈，而是等其中一个从库完成数据同步之后再反馈给客户端，但也不必等待所有从库都完成事务。</p>
<h2 id="4-2-复制拓扑"><a href="#4-2-复制拓扑" class="headerlink" title="4.2 复制拓扑"></a>4.2 复制拓扑</h2><h3 id="4-2-1-主库和备库"><a href="#4-2-1-主库和备库" class="headerlink" title="4.2.1 主库和备库"></a>4.2.1 主库和备库</h3><p>可以在任意多个主库和备库之间建立复制，但要注意每个备库只能有一个主库，一个主库可以有多个备库，一个备库可以有多个兄弟备库，每个备库必须有唯一的服务器 ID 并保持 ID 不变，备库可以把其主库上的数据变化传播到其他备库。</p>
<ul>
<li>在有少量写和大量读时，可以使用一主多备的结构（备库之间没有交互），将读分摊到多个备库上，直到主备之间的带宽成为瓶颈为止，这种结构简单、灵活，避免了很多其他拓扑结构的复杂性</li>
<li>当两个处于不同地理位置的办公室，并且都需要一份可写的数据拷贝时，可以使用主-主复制的结构，两台服务器中的每一个都被配置成对方的主库和备库，这种结构最大的问题是解决冲突，需要仔细的配置划分数据和权限</li>
<li>主主复制结构的一个变体是令其中一台服务器是只读的被动服务器，这能很好的避免冲突，且由于配置是对称的，反复切换制动和被动服务器也非常方便，是构建容错性和高可用性的非常强大的方式</li>
<li>环形复制结构可以由三个或更多的主库，每个服务器都是它之前的服务器的备库，是它之后的服务器的主库，主主复制结构就是环形复制结构的一个特例，但两个服务器以上的环形结构不具备对称配置和简单的故障转移，并且完全依赖于环上的每一个可用节点，这大大增大了整个系统失效的几率，应该尽量避免这种脆弱的环形结构</li>
</ul>
<h3 id="4-2-2-分发主库"><a href="#4-2-2-分发主库" class="headerlink" title="4.2.2 分发主库"></a>4.2.2 分发主库</h3><p>复制操作在主库的开销主要是启用 BinLog 带来的开销，备库对主库增加的网络 I/O 开销，唤醒复制线程发送时间的开销等。</p>
<p>每个备库会在主库上创建一个二进制转储线程来读取 BinLog 文件中的数据并将其发送给备库，每个备库都重复这样的工作而不会共享资源。那么当备库足够多并且有很大的事件时，主库上的负载会显著上升，甚至可能由于备库同时请求同样的事件而耗尽内存并崩溃或者是大量的磁盘检索。</p>
<p>如果需要多个备库，可以从主库移除负载并使用分发主库。分发主库事实上也是一个备库，它的唯一目的就是提取主库的 BinLog。此时，多个备库连接到分发主库而非原来的主库。这种主库、分发主库以及备库组成的复制拓扑结构使原来的主库摆脱大量备库带来的负担。</p>
<p>此外，分发主库还可以用于对 BinLog 事件执行过滤和重写规则，这比在每个备库上重复进行日志记录、重写和过滤要高效很多。但由于分发主库的存在，各个备库与原始主库的 BinLog 坐标已经不相同的，所以无法使用一个备库来代替主库。</p>
<h3 id="4-2-3-定制化方案"><a href="#4-2-3-定制化方案" class="headerlink" title="4.2.3 定制化方案"></a>4.2.3 定制化方案</h3><p>MySQL可以根据需要定制解决方案，典型的定制方案包括组合过滤、分发和向不同的存储引擎复制，这其中最大的限制是合理地监控、管理以及所拥有的资源的约束（比如网络带宽、CPU能力等）。</p>
<ul>
<li>选择性复制：在主库上将数据划分到不同的数据库里，将数据库复制到不同的备库上</li>
<li>分离功能：在线事务处理（OLTP）查询比较短并且是事务型的，在线数据分析（OLAP）查询通常很大，也很慢，并且不要求绝对最新的数据，这两种查询给服务器带来的负担不同，需要不同的配置，可使用不同的备库上来执行</li>
<li>数据归档：在备库上保留主库上删除过的数据，实现数据归档</li>
<li>日志服务器：通过创建没有数据的日志服务器，用于可靠的地存储主库的二进制日志，更加容易重放和过滤二进制日志事件，对崩溃后重启复制也很有帮助</li>
</ul>
<h1 id="5、备份"><a href="#5、备份" class="headerlink" title="5、备份"></a>5、备份</h1><p>对于备份来说，复制是一项很有意义的技术补充，但复制既不是备份也不能够取代备份。</p>
<p>在上一章介绍了数据库之间的增量数据更新的复制方式，然而在一种更加典型的案例（同时也是大多数情况）下，有一个已经运行了一段时间的主库，然后用一台新安装的备库与之同步，此时需要考虑存量数据的复制，可以通过以下方式中任意一种来实现复制</p>
<ul>
<li>冷备份：关闭主库，然后将数据复制到备库，重启主库后，使用一个新的二进制日志文件</li>
<li>热备份：如果仅使用了MyISAM表，可以在主库运行时通过热备份来复制数据</li>
<li>使用快照或备份：如果知道对应的二进制日志坐标，就可以使用主库的快照或者备份来初始化备库（如果使用备份，需要确保存在从备份的时间点开始到现在的主库二进制日志）</li>
</ul>
<h1 id="6、补充"><a href="#6、补充" class="headerlink" title="6、补充"></a>6、补充</h1><p><strong>（这些补充内容以后有空单开一篇详细学下）</strong></p>
<h2 id="基准测试"><a href="#基准测试" class="headerlink" title="基准测试"></a>基准测试</h2><p>基准测试是针对系统设计的一种压力测试，可以观察系统在不同压力下的行为。在新系统正式上线到生产环境之前都应该进行基准测试，而且，基准测试应该运行足够长的时间，应该确认测试结果可重复。</p>
<p>可以考虑的测试指标有</p>
<ul>
<li>吞吐量：指单位时间内的事务处理数，常用的测试单位是每秒事务数（TPS）或每分钟事务数（TPM）</li>
<li>响应时间或延迟：指测试任务所需的整体时间</li>
<li>并发性：指任意时间内有多少同时发生的并发请求，并发性测试通常不是为了测试应用能达到的并发度，而是为了测试应用在不同并发下的性能</li>
<li>可扩展性：指系统资源增加时系统性能的提升情况（理想情况下是呈线性提升），可扩展性指标便于发现系统应用的瓶颈</li>
</ul>
<p>归根结底，应当尽可能收集一些需求，测试那些对用户来说最重要的指标。</p>
<h2 id="性能剖析"><a href="#性能剖析" class="headerlink" title="性能剖析"></a>性能剖析</h2><p>性能剖析（profiling）用于测量服务器的时间花费在哪里并生成剖析报告，项目中应尽量包含性能剖析的代码。</p>
<p>注：</p>
<ul>
<li>“查询”泛指所有发送给服务器的命令</li>
<li>性能用查询的响应时间来度量</li>
<li>性能优化是指在一定的工作负载下尽可能地降低响应时间</li>
</ul>
<h2 id="加密解密"><a href="#加密解密" class="headerlink" title="加密解密"></a>加密解密</h2><p>服务端加解密指的是数据在入库之前就加密好，需要时从数据库读出来之后再解密，可以保证数据绝对安全</p>
<p>MD5 严格来说不是加密算法，只是一种哈希算法，MD5 不支持解密，只能用于哪种存储后只做匹配而不作查询展示的场景，如用户密码</p>
<p>MySQL 提供了一些内置的<a target="_blank" rel="noopener" href="https://www.yuque.com/hollis666/niq4hm/xg32pfnstsrh9pdp">加密函数</a>，可以直接用来对数据进行加密，</p>
<p>加密虽然可以保证数据安全，但也会增加性能开销，引入更高的复杂性，使得查询和检索更加困难，密钥的正确管理也会成为关键问题</p>
<p>如果需要对加密数据进行模糊查询，可以明文进行分词，然后分别加密存储到数据库中，那么就可以对分词文本进行模糊匹配，但可以进行模糊匹配的文本就限定在分词文本的范围中，还是不够灵活，另一种改进的方式是将所有需要用于模糊查询的信息都拼接成一个字符串放到同一个字段中，这样就只需要通过这个字段做模糊查询即可。</p>
<h1 id="7、参考资料"><a href="#7、参考资料" class="headerlink" title="7、参考资料"></a>7、参考资料</h1><ul>
<li>《High Performance MySQL, Third Edition》</li>
<li><a target="_blank" rel="noopener" href="https://dev.mysql.com/blog-archive/whats-new-in-mysql-8-0-generally-available/">https://dev.mysql.com/blog-archive/whats-new-in-mysql-8-0-generally-available/</a></li>
<li><a target="_blank" rel="noopener" href="https://www.yuque.com/hollis666/niq4hm/qimt8ayyqk8y5qc7">https://www.yuque.com/hollis666/niq4hm/qimt8ayyqk8y5qc7</a></li>
<li><a target="_blank" rel="noopener" href="https://www.yuque.com/hollis666/niq4hm/mgpczmz7la99dkft">https://www.yuque.com/hollis666/niq4hm/mgpczmz7la99dkft</a></li>
<li><a target="_blank" rel="noopener" href="https://www.yuque.com/hollis666/niq4hm/zhfa5g">https://www.yuque.com/hollis666/niq4hm/zhfa5g</a></li>
</ul>
</section>
    <!-- Tags START -->
    
    <!-- Tags END -->
    <!-- NAV START -->
    
  <div class="nav-container">
    <!-- reverse left and right to put prev and next in a more logic postition -->
    
      <a class="nav-left" href="/2022/07/02/accident/">
        <span class="nav-arrow">← </span>
        
          Accident -
        
      </a>
    
    
      <a class="nav-right" href="/2022/09/01/week-1/">
        
          2022.8.29 - 2022.9.2
        
        <span class="nav-arrow"> →</span>
      </a>
    
  </div>

    <!-- NAV END -->
    <!-- 打赏 START -->
    
    <!-- 打赏 END -->
    <!-- 二维码 START -->
    
    <!-- 二维码 END -->
    
      <!-- Utterances START -->
      <div id="utterances"></div>
      <script src="https://utteranc.es/client.js"
        repo=""
        issue-term="pathname"
        theme="github-light"
        crossorigin="anonymous"
        async></script>    
      <!-- Utterances END -->
    
  </article>
  <!-- Article END -->
  <!-- Catalog START -->
  
    <aside class="catalog-container">
  <div class="toc-main">
  
      
          <strong class="toc-title">OUTLINE</strong>
          <ol class="toc-nav"><li class="toc-nav-item toc-nav-level-1"><a class="toc-nav-link" href="#1%E3%80%81%E6%A6%82%E8%BF%B0"><span class="toc-nav-text">1、概述</span></a><ol class="toc-nav-child"><li class="toc-nav-item toc-nav-level-2"><a class="toc-nav-link" href="#1-1-%E5%9F%BA%E7%A1%80%E6%A6%82%E5%BF%B5"><span class="toc-nav-text">1.1 基础概念</span></a><ol class="toc-nav-child"><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#1-1-1-%E5%85%B3%E7%B3%BB%E5%9E%8B%E6%95%B0%E6%8D%AE%E5%BA%93"><span class="toc-nav-text">1.1.1 关系型数据库</span></a></li><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#1-1-2-%E4%BA%8B%E5%8A%A1"><span class="toc-nav-text">1.1.2 事务</span></a></li><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#1-1-3-%E5%B9%B6%E5%8F%91%E4%B8%80%E8%87%B4%E6%80%A7%E9%97%AE%E9%A2%98"><span class="toc-nav-text">1.1.3 并发一致性问题</span></a></li><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#1-1-4-%E9%9A%94%E7%A6%BB%E7%BA%A7%E5%88%AB"><span class="toc-nav-text">1.1.4 隔离级别</span></a></li></ol></li><li class="toc-nav-item toc-nav-level-2"><a class="toc-nav-link" href="#1-2-MySQL"><span class="toc-nav-text">1.2 MySQL</span></a><ol class="toc-nav-child"><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#1-2-1-%E6%9E%B6%E6%9E%84"><span class="toc-nav-text">1.2.1 架构</span></a></li><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#1-2-2-%E5%AD%98%E5%82%A8%E5%BC%95%E6%93%8E"><span class="toc-nav-text">1.2.2 存储引擎</span></a></li><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#1-2-3-%E7%89%B9%E6%80%A7"><span class="toc-nav-text">1.2.3 特性</span></a></li><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#1-2-4-%E9%94%81"><span class="toc-nav-text">1.2.4 锁</span></a></li><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#1-2-5-MVCC"><span class="toc-nav-text">1.2.5 MVCC</span></a></li></ol></li></ol></li><li class="toc-nav-item toc-nav-level-1"><a class="toc-nav-link" href="#2%E3%80%81%E8%AE%BE%E8%AE%A1"><span class="toc-nav-text">2、设计</span></a><ol class="toc-nav-child"><li class="toc-nav-item toc-nav-level-2"><a class="toc-nav-link" href="#2-1-%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B"><span class="toc-nav-text">2.1 数据类型</span></a><ol class="toc-nav-child"><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#2-1-1-%E6%95%B4%E6%95%B0%E7%B1%BB%E5%9E%8B"><span class="toc-nav-text">2.1.1 整数类型</span></a></li><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#2-1-2-%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%B1%BB%E5%9E%8B"><span class="toc-nav-text">2.1.2 字符串类型</span></a></li><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#2-1-3-%E6%97%A5%E6%9C%9F%E5%92%8C%E6%97%B6%E9%97%B4%E7%B1%BB%E5%9E%8B"><span class="toc-nav-text">2.1.3 日期和时间类型</span></a></li></ol></li><li class="toc-nav-item toc-nav-level-2"><a class="toc-nav-link" href="#2-2-%E8%8C%83%E5%BC%8F"><span class="toc-nav-text">2.2 范式</span></a><ol class="toc-nav-child"><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#2-2-1-%E5%AE%9A%E4%B9%89"><span class="toc-nav-text">2.2.1 定义</span></a></li><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#2-2-2-%E8%8C%83%E5%BC%8F%E5%92%8C%E5%8F%8D%E8%8C%83%E5%BC%8F"><span class="toc-nav-text">2.2.2 范式和反范式</span></a></li><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#2-2-3-%E7%BC%93%E5%AD%98%E8%A1%A8%E5%92%8C%E6%B1%87%E6%80%BB%E8%A1%A8"><span class="toc-nav-text">2.2.3 缓存表和汇总表</span></a></li></ol></li><li class="toc-nav-item toc-nav-level-2"><a class="toc-nav-link" href="#2-3-%E7%B4%A2%E5%BC%95"><span class="toc-nav-text">2.3 索引</span></a><ol class="toc-nav-child"><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#2-3-1-B-Tree-%E7%B4%A2%E5%BC%95"><span class="toc-nav-text">2.3.1 B+Tree 索引</span></a></li><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#2-3-2-%E5%94%AF%E4%B8%80%E7%B4%A2%E5%BC%95"><span class="toc-nav-text">2.3.2 唯一索引</span></a></li><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#2-3-3-%E7%B4%A2%E5%BC%95%E8%B7%B3%E8%B7%83"><span class="toc-nav-text">2.3.3 索引跳跃</span></a></li><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#2-3-4-%E5%93%88%E5%B8%8C%E7%B4%A2%E5%BC%95"><span class="toc-nav-text">2.3.4 哈希索引</span></a></li><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#2-3-5-%E5%85%A8%E6%96%87%E7%B4%A2%E5%BC%95"><span class="toc-nav-text">2.3.5 全文索引</span></a></li><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#2-3-6-%E8%81%9A%E7%B0%87%E7%B4%A2%E5%BC%95"><span class="toc-nav-text">2.3.6 聚簇索引</span></a></li><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#2-3-7-%E8%A6%86%E7%9B%96%E7%B4%A2%E5%BC%95"><span class="toc-nav-text">2.3.7 覆盖索引</span></a></li><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#2-3-8-%E7%B4%A2%E5%BC%95%E4%B8%8B%E6%8E%A8"><span class="toc-nav-text">2.3.8 索引下推</span></a></li></ol></li><li class="toc-nav-item toc-nav-level-2"><a class="toc-nav-link" href="#2-4-%E9%AB%98%E6%80%A7%E8%83%BD%E7%B4%A2%E5%BC%95"><span class="toc-nav-text">2.4 高性能索引</span></a><ol class="toc-nav-child"><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#2-4-1-%E5%BB%BA%E7%AB%8B%E7%B4%A2%E5%BC%95"><span class="toc-nav-text">2.4.1 建立索引</span></a></li><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#2-4-2-%E7%B4%A2%E5%BC%95%E5%A4%B1%E6%95%88"><span class="toc-nav-text">2.4.2 索引失效</span></a></li><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#2-4-3-%E7%B4%A2%E5%BC%95%E9%80%89%E6%8B%A9"><span class="toc-nav-text">2.4.3 索引选择</span></a></li><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#2-4-4-%E4%BD%8E%E6%80%A7%E8%83%BD"><span class="toc-nav-text">2.4.4 低性能</span></a></li></ol></li></ol></li><li class="toc-nav-item toc-nav-level-1"><a class="toc-nav-link" href="#3%E3%80%81%E4%BC%98%E5%8C%96"><span class="toc-nav-text">3、优化</span></a><ol class="toc-nav-child"><li class="toc-nav-item toc-nav-level-2"><a class="toc-nav-link" href="#3-1-%E6%9F%A5%E8%AF%A2"><span class="toc-nav-text">3.1 查询</span></a><ol class="toc-nav-child"><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#3-1-1-%E6%89%A7%E8%A1%8C%E6%B5%81%E7%A8%8B"><span class="toc-nav-text">3.1.1 执行流程</span></a></li><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#3-1-2-%E5%85%B3%E8%81%94%E6%9F%A5%E8%AF%A2"><span class="toc-nav-text">3.1.2 关联查询</span></a></li><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#3-1-3-%E9%87%8D%E6%9E%84%E6%96%B9%E5%BC%8F"><span class="toc-nav-text">3.1.3 重构方式</span></a></li><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#3-1-4-%E7%89%B9%E5%AE%9A%E7%B1%BB%E5%9E%8B%E9%87%8D%E6%9E%84"><span class="toc-nav-text">3.1.4 特定类型重构</span></a></li></ol></li><li class="toc-nav-item toc-nav-level-2"><a class="toc-nav-link" href="#3-2-%E6%9B%B4%E6%96%B0"><span class="toc-nav-text">3.2 更新</span></a><ol class="toc-nav-child"><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#3-2-1-%E6%89%A7%E8%A1%8C%E6%B5%81%E7%A8%8B"><span class="toc-nav-text">3.2.1 执行流程</span></a></li><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#3-2-2-%E4%B8%A4%E9%98%B6%E6%AE%B5%E6%8F%90%E4%BA%A4"><span class="toc-nav-text">3.2.2 两阶段提交</span></a></li><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#3-2-3-%E6%8F%92%E5%85%A5%E6%88%96%E6%9B%B4%E6%96%B0"><span class="toc-nav-text">3.2.3 插入或更新</span></a></li><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#3-2-4-%E7%83%AD%E7%82%B9%E6%95%B0%E6%8D%AE%E6%9B%B4%E6%96%B0"><span class="toc-nav-text">3.2.4 热点数据更新</span></a></li></ol></li><li class="toc-nav-item toc-nav-level-2"><a class="toc-nav-link" href="#3-3-%E5%88%86%E5%8C%BA"><span class="toc-nav-text">3.3 分区</span></a><ol class="toc-nav-child"><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#3-3-1-%E5%88%86%E5%8C%BA%E8%A1%A8"><span class="toc-nav-text">3.3.1 分区表</span></a></li><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#3-3-2-%E4%BC%98%E5%8A%BF%E4%B8%8E%E9%99%90%E5%88%B6"><span class="toc-nav-text">3.3.2 优势与限制</span></a></li><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#3-3-3-%E4%BD%BF%E7%94%A8%E5%88%86%E5%8C%BA"><span class="toc-nav-text">3.3.3 使用分区</span></a></li></ol></li><li class="toc-nav-item toc-nav-level-2"><a class="toc-nav-link" href="#3-4-%E7%BC%93%E5%AD%98"><span class="toc-nav-text">3.4 缓存</span></a><ol class="toc-nav-child"><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#3-4-1-%E7%BC%93%E5%AD%98%E4%B8%8E%E5%91%BD%E4%B8%AD"><span class="toc-nav-text">3.4.1 缓存与命中</span></a></li><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#3-4-2-%E7%BC%93%E5%AD%98%E4%B8%8E%E5%86%85%E5%AD%98"><span class="toc-nav-text">3.4.2 缓存与内存</span></a></li><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#3-4-3-%E7%BC%93%E5%AD%98%E5%92%8C-InnoDB"><span class="toc-nav-text">3.4.3 缓存和 InnoDB</span></a></li><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#3-4-4-%E4%BD%BF%E7%94%A8%E7%BC%93%E5%AD%98"><span class="toc-nav-text">3.4.4 使用缓存</span></a></li></ol></li><li class="toc-nav-item toc-nav-level-2"><a class="toc-nav-link" href="#3-5-%E5%85%B6%E4%BB%96"><span class="toc-nav-text">3.5 其他</span></a><ol class="toc-nav-child"><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#3-5-1-%E8%A7%86%E5%9B%BE"><span class="toc-nav-text">3.5.1 视图</span></a></li><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#3-5-2-%E4%B8%BB%E9%94%AE"><span class="toc-nav-text">3.5.2 主键</span></a></li><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#3-5-3-%E5%A4%96%E9%94%AE"><span class="toc-nav-text">3.5.3 外键</span></a></li><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#3-5-4-%E8%A7%A6%E5%8F%91%E5%99%A8"><span class="toc-nav-text">3.5.4 触发器</span></a></li><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#3-5-5-%E5%AD%98%E5%82%A8%E8%BF%87%E7%A8%8B"><span class="toc-nav-text">3.5.5 存储过程</span></a></li><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#3-5-6-%E6%8E%92%E5%BA%8F"><span class="toc-nav-text">3.5.6 排序</span></a></li><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#3-5-7-%E8%AE%A1%E6%95%B0"><span class="toc-nav-text">3.5.7 计数</span></a></li><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#3-5-8-%E5%88%86%E9%A1%B5"><span class="toc-nav-text">3.5.8 分页</span></a></li><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#3-5-9-%E6%95%B0%E6%8D%AE%E9%A1%B5"><span class="toc-nav-text">3.5.9 数据页</span></a></li><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#3-5-10-%E9%95%BF%E4%BA%8B%E5%8A%A1"><span class="toc-nav-text">3.5.10 长事务</span></a></li><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#3-5-11-%E5%88%A0%E9%99%A4"><span class="toc-nav-text">3.5.11 删除</span></a></li></ol></li><li class="toc-nav-item toc-nav-level-2"><a class="toc-nav-link" href="#3-6-%E6%89%A7%E8%A1%8C%E8%AE%A1%E5%88%92"><span class="toc-nav-text">3.6 执行计划</span></a></li></ol></li><li class="toc-nav-item toc-nav-level-1"><a class="toc-nav-link" href="#4%E3%80%81%E5%A4%8D%E5%88%B6"><span class="toc-nav-text">4、复制</span></a><ol class="toc-nav-child"><li class="toc-nav-item toc-nav-level-2"><a class="toc-nav-link" href="#4-1-%E5%A4%8D%E5%88%B6%E6%96%B9%E5%BC%8F"><span class="toc-nav-text">4.1 复制方式</span></a><ol class="toc-nav-child"><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#4-1-1-%E6%89%A7%E8%A1%8C%E6%B5%81%E7%A8%8B"><span class="toc-nav-text">4.1.1 执行流程</span></a></li><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#4-1-2-%E5%A4%8D%E5%88%B6%E6%96%B9%E5%BC%8F"><span class="toc-nav-text">4.1.2 复制方式</span></a></li><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#4-1-3-%E5%BC%82%E6%AD%A5%E5%92%8C%E5%90%8C%E6%AD%A5"><span class="toc-nav-text">4.1.3 异步和同步</span></a></li></ol></li><li class="toc-nav-item toc-nav-level-2"><a class="toc-nav-link" href="#4-2-%E5%A4%8D%E5%88%B6%E6%8B%93%E6%89%91"><span class="toc-nav-text">4.2 复制拓扑</span></a><ol class="toc-nav-child"><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#4-2-1-%E4%B8%BB%E5%BA%93%E5%92%8C%E5%A4%87%E5%BA%93"><span class="toc-nav-text">4.2.1 主库和备库</span></a></li><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#4-2-2-%E5%88%86%E5%8F%91%E4%B8%BB%E5%BA%93"><span class="toc-nav-text">4.2.2 分发主库</span></a></li><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#4-2-3-%E5%AE%9A%E5%88%B6%E5%8C%96%E6%96%B9%E6%A1%88"><span class="toc-nav-text">4.2.3 定制化方案</span></a></li></ol></li></ol></li><li class="toc-nav-item toc-nav-level-1"><a class="toc-nav-link" href="#5%E3%80%81%E5%A4%87%E4%BB%BD"><span class="toc-nav-text">5、备份</span></a></li><li class="toc-nav-item toc-nav-level-1"><a class="toc-nav-link" href="#6%E3%80%81%E8%A1%A5%E5%85%85"><span class="toc-nav-text">6、补充</span></a><ol class="toc-nav-child"><li class="toc-nav-item toc-nav-level-2"><a class="toc-nav-link" href="#%E5%9F%BA%E5%87%86%E6%B5%8B%E8%AF%95"><span class="toc-nav-text">基准测试</span></a></li><li class="toc-nav-item toc-nav-level-2"><a class="toc-nav-link" href="#%E6%80%A7%E8%83%BD%E5%89%96%E6%9E%90"><span class="toc-nav-text">性能剖析</span></a></li><li class="toc-nav-item toc-nav-level-2"><a class="toc-nav-link" href="#%E5%8A%A0%E5%AF%86%E8%A7%A3%E5%AF%86"><span class="toc-nav-text">加密解密</span></a></li></ol></li><li class="toc-nav-item toc-nav-level-1"><a class="toc-nav-link" href="#7%E3%80%81%E5%8F%82%E8%80%83%E8%B5%84%E6%96%99"><span class="toc-nav-text">7、参考资料</span></a></li></ol>
      
  
  </div>
</aside>
  
  <!-- Catalog END -->
</main>

<script>
  (function () {
    var url = 'http://example.com/2022/08/06/mysql/';
    var banner = ''
    if (banner !== '' && banner !== 'undefined' && banner !== 'null') {
      $('#article-banner').css({
        'background-image': 'url(' + banner + ')'
      })
    } else {
      $('#article-banner').geopattern(url)
    }
    $('.header').removeClass('fixed-header')

    // error image
    $(".markdown-content img").on('error', function() {
      $(this).attr('src', '/css/images/error_icon.png')
      $(this).css({
        'cursor': 'default'
      })
    })

    // zoom image
    $(".markdown-content img").on('click', function() {
      var src = $(this).attr('src')
      if (src !== '/css/images/error_icon.png') {
        var imageW = $(this).width()
        var imageH = $(this).height()

        var zoom = ($(window).width() * 0.95 / imageW).toFixed(2)
        zoom = zoom < 1 ? 1 : zoom
        zoom = zoom > 2 ? 2 : zoom
        var transY = (($(window).height() - imageH) / 2).toFixed(2)

        $('body').append('<div class="image-view-wrap"><div class="image-view-inner"><img src="'+ src +'" /></div></div>')
        $('.image-view-wrap').addClass('wrap-active')
        $('.image-view-wrap img').css({
          'width': `${imageW}`,
          'transform': `translate3d(0, ${transY}px, 0) scale3d(${zoom}, ${zoom}, 1)`
        })
        $('html').css('overflow', 'hidden')

        $('.image-view-wrap').on('click', function() {
          $(this).remove()
          $('html').attr('style', '')
        })
      }
    })
  })();
</script>







    <div class="scroll-top">
  <span class="arrow-icon"></span>
</div>
    <footer class="app-footer">
  <p class="copyright">
    &copy; 2024 | Proudly powered by <a href="https://hexo.io" target="_blank">Hexo</a>
    <br>
    Theme by <a target="_blank" rel="noopener" href="https://github.com/yanm1ng">yanm1ng</a>
    
  </p>
</footer>

<script>
  function async(u, c) {
    var d = document, t = 'script',
      o = d.createElement(t),
      s = d.getElementsByTagName(t)[0];
    o.src = u;
    if (c) { o.addEventListener('load', function (e) { c(null, e); }, false); }
    s.parentNode.insertBefore(o, s);
  }
</script>
<script>
  async("//cdnjs.cloudflare.com/ajax/libs/fastclick/1.0.6/fastclick.min.js", function(){
    FastClick.attach(document.body);
  })
</script>

<script>
  var hasLine = 'true';
  async("//cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/highlight.min.js", function(){
    $('figure pre').each(function(i, block) {
      var figure = $(this).parents('figure');
      if (hasLine === 'false') {
        figure.find('.gutter').hide();
      }
      hljs.configure({useBR: true});
      var lang = figure.attr('class').split(' ')[1] || 'code';
      var codeHtml = $(this).html();
      var codeTag = document.createElement('code');
      codeTag.className = lang;
      codeTag.innerHTML = codeHtml;
      $(this).attr('class', '').empty().html(codeTag);
      figure.attr('data-lang', lang.toUpperCase());
      hljs.highlightBlock(block);
    });
  })
</script>
<!-- Baidu Tongji -->


<script src="/js/script.js"></script>


  </body>
</html>
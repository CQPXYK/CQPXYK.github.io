<!DOCTYPE html>
<html>
  <head>
  <meta http-equiv="content-type" content="text/html; charset=utf-8">
  <meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport">
  <meta name="description" content="要有一个从输入到输出的过程">
  <meta name="keyword" content="hexo-theme, vuejs">
  
    <link rel="shortcut icon" href="/css/images/logo.png">
  
  <title>
    
      Docker | CQ&#39;s Blog
    
  </title>
  <link href="//cdnjs.cloudflare.com/ajax/libs/font-awesome/4.7.0/css/font-awesome.min.css" rel="stylesheet">
  <link href="//cdnjs.cloudflare.com/ajax/libs/nprogress/0.2.0/nprogress.min.css" rel="stylesheet">
  <link href="//cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/tomorrow.min.css" rel="stylesheet">
  
<link rel="stylesheet" href="/css/style.css">

  
  <script src="//cdnjs.cloudflare.com/ajax/libs/jquery/3.2.1/jquery.min.js"></script>
  <script src="//cdnjs.cloudflare.com/ajax/libs/geopattern/1.2.3/js/geopattern.min.js"></script>
  <script src="//cdnjs.cloudflare.com/ajax/libs/nprogress/0.2.0/nprogress.min.js"></script>
  
  
  
  
    <!-- MathJax support START -->
    <script type="text/x-mathjax-config">
      MathJax.Hub.Config({
        tex2jax: {
          inlineMath: [ ['$','$'], ["\\(","\\)"]  ],
          processEscapes: true,
          skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
        }
      });
    </script>

    <script type="text/x-mathjax-config">
      MathJax.Hub.Queue(function() {
        var all = MathJax.Hub.getAllJax(), i;
        for (i=0; i < all.length; i += 1) {
          all[i].SourceElement().parentNode.className += ' has-jax';
        }
      });
    </script>
    <script type="text/javascript" src="//cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
    <!-- MathJax support END -->
  


  
  
    
<script src="/js/local-search.js"></script>


<meta name="generator" content="Hexo 5.4.2"></head>
<div class="wechat-share">
  <img src="/css/images/logo.png" />
</div>
  <body>
    <header class="header fixed-header">
  <div class="header-container">
    <a class="home-link" href="/">
      <div class="logo"></div>
      <span>CQ's Blog</span>
    </a>
    <ul class="right-list">
      
        <li class="list-item">
          
            <a href="/" class="item-link">Home</a>
          
        </li>
      
        <li class="list-item">
          
            <a href="/" class="item-link">Categories</a>
          
        </li>
      
        <li class="list-item">
          
            <a href="/records" class="item-link">Records</a>
          
        </li>
      
        <li class="list-item">
          
            <a href="/scratches/" class="item-link">Scratches</a>
          
        </li>
      
        <li class="list-item">
          
            <a href="/archives/" class="item-link">Archives</a>
          
        </li>
      
      
        <li class="menu-item menu-item-search right-list">
    <a role="button" class="popup-trigger">
        <i class="fa fa-search fa-fw"></i>
    </a>
</li>
      
    </ul>
    <div class="menu">
      <span class="icon-bar"></span>
      <span class="icon-bar"></span>
      <span class="icon-bar"></span>
    </div>
    <div class="menu-mask">
      <ul class="menu-list">
        
          <li class="menu-item">
            
              <a href="/" class="menu-link">Home</a>
            
          </li>
        
          <li class="menu-item">
            
              <a href="/" class="menu-link">Categories</a>
            
          </li>
        
          <li class="menu-item">
            
              <a href="/records" class="menu-link">Records</a>
            
          </li>
        
          <li class="menu-item">
            
              <a href="/scratches/" class="menu-link">Scratches</a>
            
          </li>
        
          <li class="menu-item">
            
              <a href="/archives/" class="menu-link">Archives</a>
            
          </li>
        
      </ul>
    </div>
    
      <div class="search-pop-overlay">
    <div class="popup search-popup">
        <div class="search-header">
            <span class="search-icon">
                <i class="fa fa-search"></i>
            </span>
            <div class="search-input-container">
                <input autocomplete="off" autocapitalize="off"
                    placeholder="Please enter your keyword(s) to search." spellcheck="false"
                    type="search" class="search-input">
            </div>
            <span class="popup-btn-close">
                <i class="fa fa-times-circle"></i>
            </span>
        </div>
        <div id="search-result">
            <div id="no-result">
                <i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i>
            </div>
        </div>
    </div>
</div>
    
  </div>
</header>

    <div id="article-banner">
  <h2>Docker</h2>
  <!--<p class="post-date">2022-09-06</p>
  <div class="arrow-down">
    <a href="javascript:;"></a>
  </div>-->
</div>
<main class="app-body flex-box">
  <!-- Article START -->
  <article class="post-article">
    <section class="markdown-content"><h1 id="英文版"><a href="#英文版" class="headerlink" title="英文版"></a><a href="../../../../2023/09/01/week-53/">英文版</a></h1><h1 id="问题与解决"><a href="#问题与解决" class="headerlink" title="问题与解决"></a>问题与解决</h1><p><strong>容器</strong>：应用可以被部署并运行在 VM 上，但是考虑到 VM 需要使用过多的硬件资源来运行一整套操作系统（是对硬件的封装隔离），而容器则仅包含一些应用运行所必要的软件和配置来运行一个进程（是对进程的封装隔离），实现了比 VM 更宽松的隔离特性，更加充分的硬件资源利用以及更快速轻量的应用运行环境，应用在容器中的运行性能接近于在物理平台上的性能。</p>
<p><strong>云服务</strong>：单体应用是最传统的架构模式，整个系统有一个统一的数据中心，各个功能模块显式进行相互依赖，随着应用变得越来越庞大，流量负载越来越高，单体应用在可扩展性和容错性上都存在致命缺陷，则倾向于使用一组互相独立且富余的服务器系统（云服务），而非单体服务来运行应用。</p>
<p><strong>Docker</strong>：考虑到在每一个服务机器上都进行应用环境配置是很繁琐的工作，版本更新以及更换平台时还需要重新配置。因此，考虑在发布一个项目时，将项目应用带上环境安装一起打包，即发布的 jar 包中是包含环境的，这就是现在的 Docker 镜像（image）。</p>
<h1 id="Docker"><a href="#Docker" class="headerlink" title="Docker"></a>Docker</h1><p>Docker 是一个可以在云平台上构建，运行以及管理容器的软件框架，采用了 <code>C/S</code> 架构，包括客户端和服务端。</p>
<p>Docker 守护进程（<code>Daemon</code>）作为服务端接受来自客户端的请求，并处理这些请求（创建、运行、分发容器）一般在宿主主机后台运行，Docker 客户端则为用户提供一系列可执行命令，用户用这些命令实现跟 Docker 守护进程交互。客户端和服务端既可以运行在一个机器上，也可通过 <code>socket</code> 或者 <code>RESTful API</code> 来进行通信。</p>
<p>基于 Docker：</p>
<ul>
<li>不再需要费力配置应用环境、交付、部署、迁移、运维、升级和扩容都变得更加快速便捷；</li>
<li>简化了容器的创建和维护，并实现了进一步的封装和共享，比如容器间独立的文件系统，网络隔离，共享的操作系统，网络互联等；</li>
<li>镜像非常小巧，只包含必要的核心环境，生成的容器运行轻便，占据较少的硬件资源，性能接近原生，秒级启动。</li>
</ul>
<h1 id="镜像与容器"><a href="#镜像与容器" class="headerlink" title="镜像与容器"></a>镜像与容器</h1><p>镜像就是一个轻量级、可执行的独立软件包，用来打包软件的完整运行环境和基于运行环境开发的软件，它包含某个软件所需的所有内容（代码、库、环境变量和配置文件），但不包含任何动态数据，其内容在构建之后不会被改变。一般使用<code>&lt;仓库名&gt;:&lt;标签&gt;</code>的格式来指定具体是哪个软件哪个版本的镜像。</p>
<p>Docker 镜像实际上由一层一层的文件系统组成，这种层级的文件系统称为联合文件系统（Union File System）。所有的 Docker 镜像都起始于一个基础镜像层（rootfs），当进行修改或者增加新的内容时，就会在当前镜像层之上，创建新的镜像层，而非修改现有镜像。每一个镜像层与它之下的镜像层都可以组成一个镜像，镜像与镜像之间会复用一些镜像层，这也意味着应当尽可能令镜像保持轻量，避免镜像中包含任何不必要的数据。</p>
<p>Docker 镜像和容器（container）之间的关系就像是类和对象，Docker 镜像是容器的静态定义，容器是镜像的动态运行实例。Docker 镜像都是只读的，当通过镜像新建容器并启动时，一个新的可写层被加载到镜像的顶部，这一层就是容器存储层（可用于存储容器运行时产生的临时数据），容器之下都叫镜像层。当开发者对容器存储层的操作结束后，可以将容器层与容器之下的镜像层一起打包发布自己定义的新镜像（但尽量不用使用这种方式来定制镜像）。</p>
<p>容器是一种对进程进行隔离的软件运行环境，包含了应用代码以及代码正常运行所需的所有内容，完全隔离并抽象了底层基础设置和操作系统，还提供了对运行进程进行资源控制的功能。一个应用进程对应一个容器（不建议在一个容器中运行多个应用），各个应用程序在各自的容器内互不干扰的独立运行，容器能够对运行中进程所使用的资源进行干预。</p>
<p>容器化/容器虚拟化是一种对软件进行构建、打包以及部署的方法，运行在容器虚拟化中的应用程序直接运行于宿主机的内核，其运行效率与真实运行在物理平台上的应用程序不相上下，远超虚拟机等其他虚拟化技术实现。</p>
<h1 id="Dockerfile"><a href="#Dockerfile" class="headerlink" title="Dockerfile"></a>Dockerfile</h1><p><code>Dockerfile</code>是用于自动化构建 Docker 镜像的指令脚本，脚本中的每一个指令都对应一层镜像，不管是开发还是运维都能通过<code>Dockerfile</code>来清晰的理解应用运行条件及环境，实现透明化的构建流程。开发者通过 Dockerfile 来打包 Docker 镜像，可以实现低版本环境的持续集成（CI），基于 Docker 镜像，容器实例的创建成为轻松廉价的行为，可以根据实际需要来进行容器创建和关闭之间的无缝衔接，运维者通过 Docker 镜像部署容器内运行的服务，可以实现高版本环境的持续部署（CD）。</p>
<p>编写<code>Dockerfile</code>脚本指令时：</p>
<ul>
<li><p>一般使用空目录或者项目根目录作为上下文目录，仅仅将构建镜像所以的文件放置于上下文目录中，不要引入无关文件</p>
</li>
<li><p>每个保留关键字（指令）都必须是大写字母</p>
</li>
<li><p>指令执行顺序从上到下，每个指令都会创建一个新的镜像层</p>
</li>
<li><p>镜像层数应尽可能少，通过<code>&amp;&amp;</code>将可以合并的多条指令合并为一条指令（过长的指令通过<code>\</code>换行）</p>
</li>
<li><p>确保每一层只添加真正需要的添加的东西，任何无关的东西都应该清理掉</p>
</li>
</ul>
<p>通过<code>docker build xxx .</code>构建镜像时：</p>
<ul>
<li><p>在Docker 服务器端（也就是 Docker 引擎）中构建，并非是在本地 Docker 客户端构建</p>
</li>
<li><p>当前目录<code>.</code>被指定为上下文目录，目录下的所有内容会被打包发送至 Docker 引擎</p>
</li>
<li><p>Docker 引擎就根据上下文目录中的内容来构建 Docker 镜像</p>
</li>
</ul>
<h1 id="容器数据卷"><a href="#容器数据卷" class="headerlink" title="容器数据卷"></a>容器数据卷</h1><p>如果容器存储层中的数据是临时数据，会随着容器的死亡而消失，容器中的临时数据的持久化依赖于挂载，挂载实现了本地与容器，容器与容器之间的数据同步与共享。在 Docker 中，通过挂载来进行数据共享或持久化的文件或目录，都称为容器数据卷（volume），数据卷的生存周期独立于容器，也没有针对数据卷的自动清理机制。</p>
<p>在挂载时，可以给该挂载指定名字（容器内路径一定要指定），指定名字的挂载称为具名挂载，没有指定名字的挂载称为匿名挂载。没有被任何容器所使用的数据卷可以删除。具名挂载可以通过名字来删除数据卷，而匿名挂载的数据卷可以看成它们与对应的容器产生了绑定，因此可以在容器删除时将它们一并删除。</p>
<p>可以专门用一个容器来做其他容器之间的数据共享与备份，这个容器称为数据卷容器。数据卷容器没有具体指定的应用，也不需要运行，使用它的目的就是为了定义一个或多个数据卷那并持有它们的引用。</p>
<h1 id="Docker-网络"><a href="#Docker-网络" class="headerlink" title="Docker 网络"></a>Docker 网络</h1><p>对于大部分的程序来说，它们的运行都不会是孤立的，而是要与其他程序进行交互的，网络通讯是目前最常用的一种程序间的数据交换方式。</p>
<p>当启动 Docker 服务时，它会创建一个默认的 bridge 网络，容器在不专门指定网络的情况都会连接到这个网络上。</p>
<p>Docker 可以对每个容器的网络进行配置，可以在容器间建立虚拟网络来包裹多个容器并与其他网络环境隔离，让应用从宿主机操作系统的网络环境中独立出来，形成容器自由的网络设备。</p>
<h1 id="Docker-Compose"><a href="#Docker-Compose" class="headerlink" title="Docker Compose"></a>Docker Compose</h1><p>一个相对完整的应用系统往往由数十个甚至上百个应用程序或微服务组成，需要多个应用（多个容器）协作完成工作。</p>
<p>如果说<code>Dockerfile</code>是将容器内运行环境的搭建固化下来，那么 Docker Compose 就可以理解为一个管理容器的工具，是将多个相关联容器的合作运行的方式和配置固化下来。</p>
<p>Docker Compose 的配置文件是一个基于 YAML 格式的文件，version 这一配置代表当前<code>docker-compose.yml</code>文件内容所采用的版本（建议使用最新的版本），services 这一配置是整个<code>docker-compose.yml</code>的核心部分，其中每个 service 里的配置代表的是一个应用集群（多个相同镜像的容器）的配置。</p>
<p>Docker Compose 能够对这个集群做到黑盒效果，让其他的应用和容器无法感知它们的具体结构。</p>
<h1 id="Docker-Swarm"><a href="#Docker-Swarm" class="headerlink" title="Docker Swarm"></a>Docker Swarm</h1><p>当使用 Docker Compose 来定义集群时，可以通过 Docker Swarm 来部署和编排集群。对于 Docker Swarm 来说，每个 Docker daemon 实例都可以成为集群中的一个节点。</p>
<p>在任意一个 Docker 实例上都可以通过<code>docker swarm init</code>来初始化集群，初始化后，这个 Docker 实例就自动成为了集群的管理节点，而其他的 Docker 实例可以通过运行<code>docker swarm join</code>来加入集群，逐渐建立出用于服务开发的 Docker 集群。</p>
<p>在 <code>Swarm</code> 集群中也可以使用 <code>compose</code> 文件 （<code>docker-compose.yml</code>） 来配置、启动多个服务。</p>
<p>Docker Swarm 是 Docker 的原生容器集群编排工具，此外，<a href="../../../10/03/kubernetes/">Kubernetes</a> 同样可以解决这一系列的容器编排问题，在 K8S 被设计为与 Docker 配合良好之后，Docker 提供了自己的集成 K8S 发行版来代替 Docker Swarm 作为 Docker Enterprise 的默认容器编排工具。</p>
<p>一个<code>Dockerfile</code>用于定义一个 Docker 镜像，一个Docker 镜像用于部署基于同一个镜像的多个容器，一个<code>docker-compose.yml</code>用于定义基于不同镜像的一系列互相合作的容器所构成的集群，即一个项目或者说业务单元，Docker Swarm/K8S 用于部署编排各种容器集群。</p>
<h1 id="入门命令"><a href="#入门命令" class="headerlink" title="入门命令"></a>入门命令</h1><ul>
<li><p><code>docker version</code></p>
<ul>
<li>显示所安装docker的版本信息</li>
</ul>
</li>
<li><p><code>docker info</code></p>
<ul>
<li>显示docker的系统信息，包括镜像和容器的数量</li>
</ul>
</li>
<li><p><code>docker system df</code></p>
<ul>
<li>查看镜像、容器、数据卷所占用的空间</li>
</ul>
</li>
<li><p><code>docker images</code></p>
<ul>
<li><p>查看本地主机上的所有镜像</p>
</li>
<li><p><code>-q</code>只显示镜像的Id</p>
</li>
</ul>
</li>
<li><p><code>docker search xxx</code></p>
<ul>
<li>搜索docker镜像</li>
</ul>
</li>
<li><p><code>docker pull xxx</code></p>
<ul>
<li>下载docker镜像</li>
</ul>
</li>
<li><p><code>docker rmi xxx</code></p>
<ul>
<li>删除docker镜像</li>
</ul>
</li>
<li><p><code>docker image prune</code></p>
<ul>
<li>删除因同名而被取消名称的旧镜像</li>
</ul>
</li>
<li><p><code>docker run</code></p>
<ul>
<li><p>本机寻找镜像，没有的话去Docker Hub上下载镜像到本地，Docker Hub上找不到的话返回错误，找到后使用本地镜像新建容器并运行</p>
</li>
<li><p><code>-it</code>交互式操作终端</p>
</li>
<li><p><code>--rm</code>容器退出后将其删除</p>
</li>
<li><p><code>-d</code>后台运行</p>
</li>
<li><p><code>-p</code>端口映射</p>
</li>
<li><p><code>-v</code>数据卷挂载（必须使用绝对路径，不能使用相对路径）</p>
</li>
<li><p><code>-e</code>环境配置</p>
</li>
<li><p><code>--name</code>容器名字</p>
</li>
<li><p><code>--volumes-from xxx</code>挂载备份<code>xxx</code>容器中的数据</p>
</li>
<li><p><code>--expose xxx</code>端口暴露</p>
</li>
<li><p><code>--net xxx</code>指定容器走得网络</p>
</li>
<li><p><code>--link xxx</code>指定容器要连接的容器（只能连接同一网络中的其他容器）</p>
</li>
</ul>
</li>
<li><p><code>exit</code></p>
<ul>
<li>停止运行当前容器并退出</li>
</ul>
</li>
<li><p><code>Ctrl + P + Q</code></p>
<ul>
<li>退出当前容器但不停止运行</li>
</ul>
</li>
<li><p><code>docker ps</code></p>
<ul>
<li><p>查看正在运行的容器</p>
</li>
<li><p><code>docker ps -a</code>查看所有状态的容器</p>
</li>
</ul>
</li>
<li><p><code>docker rm xxx</code></p>
<ul>
<li><p>删除容器，但不能删除正在运行的容器</p>
</li>
<li><p><code>docker rm -f</code>删除所有容器，包括正在运行的容器</p>
</li>
</ul>
</li>
<li><p><code>docker container prune</code></p>
<ul>
<li>删除所有处于终止状态的容器</li>
</ul>
</li>
<li><p><code>docker start/restart/stop/kill xxx</code></p>
<ul>
<li>启动/重启/停止/强制停止容器</li>
</ul>
</li>
<li><p><code>docker logs xxx</code></p>
<ul>
<li>查看容器日志</li>
</ul>
</li>
<li><p><code>docker top xxx</code></p>
<ul>
<li>查看容器进程信息</li>
</ul>
</li>
<li><p><code>docker inspect xxx</code></p>
<ul>
<li>查看容器的元数据</li>
</ul>
</li>
<li><p><code>docker exec -it xxx</code></p>
<ul>
<li><p>进入当前正在运行的容器，并开启一个新的终端</p>
</li>
<li><p><code>docker attach xxx</code>进入容器，不会启动新的终端</p>
</li>
</ul>
</li>
<li><p><code>docker cp 容器id: 容器内路径 目的地</code></p>
<ul>
<li>从容器内拷贝文件到主机上</li>
</ul>
</li>
<li><p><code>docker volume rm xxx</code></p>
<ul>
<li><p>删除指定名称的数据卷</p>
</li>
<li><p><code>-v xxx</code>删除容器关联的数据卷</p>
</li>
<li><p><code>docker volume prune</code>删除没有被容器引用的数据卷</p>
</li>
</ul>
</li>
<li><p><code>docker network create</code></p>
<ul>
<li><p>创建自定义的docker网络，连接不同的容器</p>
</li>
<li><p>与网络相关的命令都以<code>docker network</code>开头</p>
</li>
</ul>
</li>
<li><p><code>docker commit</code></p>
<ul>
<li>提交修改后的容器，获得一个新的自定义镜像</li>
</ul>
</li>
<li><p><code>docker build xxx .</code></p>
<ul>
<li>根据编写的dockerfile文件构建一个镜像</li>
<li><code>.</code>表示当前目录，这个路径用于指定上下文路径</li>
</ul>
</li>
<li><p><code>docker push</code></p>
<ul>
<li>发布自己构建的镜像</li>
</ul>
</li>
<li><p><code>docker history xxx</code></p>
<ul>
<li>查看镜像是如何生成的（会给出dockerfile中的所有指令）</li>
</ul>
</li>
<li><p>Dockerfile脚本中的常用指令如下</p>
<ul>
<li><p><code>FROM</code>指定基础镜像</p>
</li>
<li><p><code>MAINTAINER</code>指定镜像的作者</p>
</li>
<li><p><code>RUN</code>指定镜像构建时需要运行的命令</p>
</li>
<li><p><code>COPY</code>指定需要复制到镜像中的文件</p>
</li>
<li><p><code>ADD</code>指定需要向镜像中添加的文件（适合用于需要自动解压缩的场合，不需要自动解压则使用<code>COPY</code>更佳）</p>
</li>
<li><p><code>WORKDIR</code>指定镜像的工作目录</p>
</li>
<li><p><code>USER</code>指定执行<code>RUN</code>、<code>CMD</code>等这类命令的身份</p>
</li>
<li><p><code>VOLUME</code>指定镜像挂载的宿主机目录</p>
</li>
<li><p><code>EXPOSE</code>指定对外暴露的端口</p>
</li>
<li><p><code>CMD</code>指定容器启动时主程序需要执行的启动命令，替换式</p>
</li>
<li><p><code>ENTRYPOINT</code>指定容器启动时需要执行的初始化相关的命令，追加式</p>
</li>
<li><p><code>ENV</code>指定构建镜像时需要设置的环境变量</p>
</li>
<li><p><code>ARG</code>与<code>ENV</code>同理，但<code>ARG</code>所设置的变量在将来容器运行时是不会存在的，并且可以在构建命令<code>docker builder</code>中用<code>--build-arg &lt;参数名&gt;=&lt;值&gt;</code>来覆盖变量值</p>
</li>
</ul>
</li>
</ul>
<h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><ul>
<li><a target="_blank" rel="noopener" href="https://juejin.cn/book/6844733746462064654">开发者必备的Docker 实践指南- 有明- 掘金小册</a></li>
<li><a target="_blank" rel="noopener" href="https://yeasy.gitbook.io/docker_practice/">Docker — 从入门到实践</a></li>
<li><a target="_blank" rel="noopener" href="https://www.bilibili.com/video/BV1og4y1q7M4?spm_id_from=333.337.search-card.all.click&amp;vd_source=0b01a9c17ef5ab558386031fc8124c56">https://www.bilibili.com/video/BV1og4y1q7M4?spm_id_from=333.337.search-card.all.click&amp;vd_source=0b01a9c17ef5ab558386031fc8124c56</a></li>
<li><a target="_blank" rel="noopener" href="https://linux.cn/article-11307-1.html">使用开源工具构建 DevOps 流水线的初学者指南</a></li>
<li><a target="_blank" rel="noopener" href="https://opensource.com/resources/what-docker">https://opensource.com/resources/what-docker</a></li>
<li><a target="_blank" rel="noopener" href="https://docs.docker.com/engine/reference/builder/">https://docs.docker.com/engine/reference/builder/</a></li>
</ul>
</section>
    <!-- Tags START -->
    
    <!-- Tags END -->
    <!-- NAV START -->
    
  <div class="nav-container">
    <!-- reverse left and right to put prev and next in a more logic postition -->
    
      <a class="nav-left" href="/2022/09/01/week-1/">
        <span class="nav-arrow">← </span>
        
          2022.8.29 - 2022.9.2
        
      </a>
    
    
      <a class="nav-right" href="/2022/09/06/week-2/">
        
          2022.9.5 - 2022.9.9
        
        <span class="nav-arrow"> →</span>
      </a>
    
  </div>

    <!-- NAV END -->
    <!-- 打赏 START -->
    
    <!-- 打赏 END -->
    <!-- 二维码 START -->
    
    <!-- 二维码 END -->
    
      <!-- Utterances START -->
      <div id="utterances"></div>
      <script src="https://utteranc.es/client.js"
        repo=""
        issue-term="pathname"
        theme="github-light"
        crossorigin="anonymous"
        async></script>    
      <!-- Utterances END -->
    
  </article>
  <!-- Article END -->
  <!-- Catalog START -->
  
    <aside class="catalog-container">
  <div class="toc-main">
  
      
          <strong class="toc-title">OUTLINE</strong>
          <ol class="toc-nav"><li class="toc-nav-item toc-nav-level-1"><a class="toc-nav-link" href="#%E8%8B%B1%E6%96%87%E7%89%88"><span class="toc-nav-text">英文版</span></a></li><li class="toc-nav-item toc-nav-level-1"><a class="toc-nav-link" href="#%E9%97%AE%E9%A2%98%E4%B8%8E%E8%A7%A3%E5%86%B3"><span class="toc-nav-text">问题与解决</span></a></li><li class="toc-nav-item toc-nav-level-1"><a class="toc-nav-link" href="#Docker"><span class="toc-nav-text">Docker</span></a></li><li class="toc-nav-item toc-nav-level-1"><a class="toc-nav-link" href="#%E9%95%9C%E5%83%8F%E4%B8%8E%E5%AE%B9%E5%99%A8"><span class="toc-nav-text">镜像与容器</span></a></li><li class="toc-nav-item toc-nav-level-1"><a class="toc-nav-link" href="#Dockerfile"><span class="toc-nav-text">Dockerfile</span></a></li><li class="toc-nav-item toc-nav-level-1"><a class="toc-nav-link" href="#%E5%AE%B9%E5%99%A8%E6%95%B0%E6%8D%AE%E5%8D%B7"><span class="toc-nav-text">容器数据卷</span></a></li><li class="toc-nav-item toc-nav-level-1"><a class="toc-nav-link" href="#Docker-%E7%BD%91%E7%BB%9C"><span class="toc-nav-text">Docker 网络</span></a></li><li class="toc-nav-item toc-nav-level-1"><a class="toc-nav-link" href="#Docker-Compose"><span class="toc-nav-text">Docker Compose</span></a></li><li class="toc-nav-item toc-nav-level-1"><a class="toc-nav-link" href="#Docker-Swarm"><span class="toc-nav-text">Docker Swarm</span></a></li><li class="toc-nav-item toc-nav-level-1"><a class="toc-nav-link" href="#%E5%85%A5%E9%97%A8%E5%91%BD%E4%BB%A4"><span class="toc-nav-text">入门命令</span></a></li><li class="toc-nav-item toc-nav-level-1"><a class="toc-nav-link" href="#%E5%8F%82%E8%80%83%E8%B5%84%E6%96%99"><span class="toc-nav-text">参考资料</span></a></li></ol>
      
  
  </div>
</aside>
  
  <!-- Catalog END -->
</main>

<script>
  (function () {
    var url = 'http://example.com/2022/09/06/docker/';
    var banner = ''
    if (banner !== '' && banner !== 'undefined' && banner !== 'null') {
      $('#article-banner').css({
        'background-image': 'url(' + banner + ')'
      })
    } else {
      $('#article-banner').geopattern(url)
    }
    $('.header').removeClass('fixed-header')

    // error image
    $(".markdown-content img").on('error', function() {
      $(this).attr('src', '/css/images/error_icon.png')
      $(this).css({
        'cursor': 'default'
      })
    })

    // zoom image
    $(".markdown-content img").on('click', function() {
      var src = $(this).attr('src')
      if (src !== '/css/images/error_icon.png') {
        var imageW = $(this).width()
        var imageH = $(this).height()

        var zoom = ($(window).width() * 0.95 / imageW).toFixed(2)
        zoom = zoom < 1 ? 1 : zoom
        zoom = zoom > 2 ? 2 : zoom
        var transY = (($(window).height() - imageH) / 2).toFixed(2)

        $('body').append('<div class="image-view-wrap"><div class="image-view-inner"><img src="'+ src +'" /></div></div>')
        $('.image-view-wrap').addClass('wrap-active')
        $('.image-view-wrap img').css({
          'width': `${imageW}`,
          'transform': `translate3d(0, ${transY}px, 0) scale3d(${zoom}, ${zoom}, 1)`
        })
        $('html').css('overflow', 'hidden')

        $('.image-view-wrap').on('click', function() {
          $(this).remove()
          $('html').attr('style', '')
        })
      }
    })
  })();
</script>







    <div class="scroll-top">
  <span class="arrow-icon"></span>
</div>
    <footer class="app-footer">
  <p class="copyright">
    &copy; 2025 | Proudly powered by <a href="https://hexo.io" target="_blank">Hexo</a>
    <br>
    Theme by <a target="_blank" rel="noopener" href="https://github.com/yanm1ng">yanm1ng</a>
    
  </p>
</footer>

<script>
  function async(u, c) {
    var d = document, t = 'script',
      o = d.createElement(t),
      s = d.getElementsByTagName(t)[0];
    o.src = u;
    if (c) { o.addEventListener('load', function (e) { c(null, e); }, false); }
    s.parentNode.insertBefore(o, s);
  }
</script>
<script>
  async("//cdnjs.cloudflare.com/ajax/libs/fastclick/1.0.6/fastclick.min.js", function(){
    FastClick.attach(document.body);
  })
</script>

<script>
  var hasLine = 'true';
  async("//cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/highlight.min.js", function(){
    $('figure pre').each(function(i, block) {
      var figure = $(this).parents('figure');
      if (hasLine === 'false') {
        figure.find('.gutter').hide();
      }
      hljs.configure({useBR: true});
      var lang = figure.attr('class').split(' ')[1] || 'code';
      var codeHtml = $(this).html();
      var codeTag = document.createElement('code');
      codeTag.className = lang;
      codeTag.innerHTML = codeHtml;
      $(this).attr('class', '').empty().html(codeTag);
      figure.attr('data-lang', lang.toUpperCase());
      hljs.highlightBlock(block);
    });
  })
</script>
<!-- Baidu Tongji -->


<script src="/js/script.js"></script>


  </body>
</html>
<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>搭建个人博客</title>
    <url>/2022/05/06/blog/</url>
    <content><![CDATA[<h1 id="1、工具"><a href="#1、工具" class="headerlink" title="1、工具"></a>1、工具</h1><ul>
<li><p><a href="../../07/git/">Git</a>：一种分布式版本控制系统（DVCS）；</p>
</li>
<li><p>GitHub：一个只支持Git进行版本控制的代码托管平台；</p>
</li>
<li><p>GitHub Pages：提供免费静态网站托管服务，它能够对GitHub中的静态文件资源进行处理并展示成一个网站，同时还会给这个网站提供一个特定的域名，但用户也可以将域名改成自己想要的；</p>
</li>
<li><p>Node.js：一个开源和跨平台的JavaScript运行时环境；</p>
</li>
<li><p>Hexo：一个将用户编辑的md格式的文件生成HTML静态资源文件的博客框架。</p>
</li>
</ul>
<h1 id="2、前期准备"><a href="#2、前期准备" class="headerlink" title="2、前期准备"></a>2、前期准备</h1><h2 id="2-1-Git、GitHub及配置"><a href="#2-1-Git、GitHub及配置" class="headerlink" title="2.1 Git、GitHub及配置"></a>2.1 Git、GitHub及配置</h2><p>1）在<a href="https://git-scm.com/downloads">Git</a>下载安装包并安装；</p>
<p>2）鼠标右键可以看到：<code>Git Bash Here</code>，单击打开；</p>
<p>3）输入<code>git --version</code>，可以看到安装好的版本信息；</p>
<p>4）在<a href="https://github.com/">GitHub</a>注册账号；</p>
<p>5）设置Git用户信息；</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git config --global user.name <span class="string">&quot;GitHubName&quot;</span></span><br><span class="line">git config --global user.email <span class="string">&quot;GitHubEmail&quot;</span></span><br></pre></td></tr></table></figure>

<p>6）生成SSH key</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">ssh-keygen -t rsa -C <span class="string">&quot;GitHubEmail&quot;</span></span><br><span class="line"><span class="comment"># -t rsa 指定要创建的秘钥类型为 RSA</span></span><br><span class="line"><span class="comment"># -C &quot;GitHubEmail&quot; 指定追加到公钥文件末尾以便于识别的注释（通常以电子邮件地址用作注释，但也可以使用任何最适合你基础结构的事物）</span></span><br></pre></td></tr></table></figure>

<p>7）连续一路回车直到生成一个矩形图案，此时，可以看到用户目录下生成了<code>.ssh</code>文件夹，该文件夹的<code>id_rsa</code>和<code>id_rsa.pub</code>两个文件分别对应SSH key的私钥和公钥；</p>
<img src="文件目录截图1.png" alt="文件目录截图1" style="zoom:70%;" />

<img src="文件目录截图2.png" alt="文件目录截图2" style="zoom:70%;" />

<p>8）打开 GitHub 主页 –&gt; <code>Settings</code> –&gt; <code>SSH and GPG keys</code> –&gt; <code>New SSH key</code>，将<code>id_rsa.pub</code>中的内容复制粘贴到key中，title 可以随便取，点击<code>Add SSH key</code>；</p>
<img src="项目设置截图1.png" alt="项目设置截图1" style="zoom:70%;" />

<p>9）验证是否成功；</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">ssh -T git@github.com</span><br></pre></td></tr></table></figure>

<p>10）SSH key配置完毕后，就可以将本地的源码和资源上传到GitHub，而无需每次都输账号和密码。</p>
<h2 id="2-2-GitHub-Page和域名"><a href="#2-2-GitHub-Page和域名" class="headerlink" title="2.2 GitHub Page和域名"></a>2.2 GitHub Page和域名</h2><p>1）打开GitHub主页 –&gt; <code>+</code>按钮 –&gt; <code>New respository</code>，在<code>Repository name</code>输入框中填入<code>GitHubName.github.io</code>，勾选<code>Initialize this repository with a README</code>选项；</p>
<p>2）在浏览器中输入<a href="https://githubname.github.io/">https://GitHubName.github.io/</a> 即可看到如下页面，代表成功开启了GitHub Pages服务；</p>
<img src="浏览器截图1.png" alt="浏览器截图1" style="zoom:70%;" />

<p>3）在<a href="https://wanwang.aliyun.com/">万网-阿里云</a>注册账号或直接登录，选择还未被注册的域名，进入结算页面，创建持有者信息模本，验证并等待审核，付钱；</p>
<img src="域名注册截图1.png" alt="域名注册截图1" style="zoom:70%;" />

<p>4）由于GitHub推荐在DNS中使用A记录和CNAME相结合的方式，在注册好的个人域名后点击解析添加如下两条解析记录，其中，IPv4地址可以通过<code>ping</code>得到；</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">ping GitHubName.github.io</span><br></pre></td></tr></table></figure>

<img src="域名注册截图2.png" alt="域名注册截图2" style="zoom:70%;" />

<p>5）打开GitHubName.github.io仓库 –&gt; <code>Add file</code> –&gt; <code>Create new file</code>，文件名为<code>CNAME</code>，内容为注册好的个人域名，然后提交；</p>
<img src="项目设置截图2.png" alt="项目设置截图2" style="zoom:70%;" />

<p>6）打开GitHubName.github.io仓库 –&gt; <code>Settings</code> –&gt; <code>Pages</code>，勾选<code>Enforce HTTPS</code>选项即可强制走Https；</p>
<img src="项目设置截图3.png" alt="项目设置截图3" style="zoom:70%;" />

<p>7）在浏览器中输入个人域名即可看到如下页面，代表成功绑定了域名。</p>
<img src="浏览器截图2.png" alt="浏览器截图2" style="zoom:70%;" />

<h2 id="2-3-Node-js和Hexo"><a href="#2-3-Node-js和Hexo" class="headerlink" title="2.3 Node.js和Hexo"></a>2.3 Node.js和Hexo</h2><p>1）在<a href="https://nodejs.org/en/download/">Node.js</a>下载安装包并安装；</p>
<p>2）查看安装好的版本信息；</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">node -v</span><br><span class="line">npm -v</span><br></pre></td></tr></table></figure>

<p>3）在<code>nodejs</code>文件夹中新建两个空文件夹 <code>node_cache</code>、<code>node_global</code>；</p>
<img src="文件目录截图3.png" alt="文件目录截图3" style="zoom:70%;" />

<p>4）配置（如果不配置的话，后续安装模块时会安装到C盘，不方便管理，甚至有可能安装好hexo后却无法使用）；</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">npm config <span class="built_in">set</span> prefix <span class="string">&quot;D:\nodejs\node_global&quot;</span></span><br><span class="line">npm config <span class="built_in">set</span> cache <span class="string">&quot;D:\nodejs\node_cache&quot;</span></span><br></pre></td></tr></table></figure>

<p>5）打开控制面板 –&gt; 系统 –&gt; 高级系统设置 –&gt; 环境变量，在系统变量中新建一个变量名为<code>ODE_PATH</code>，值为<code>D:\nodejs\node_global\node_modules</code>的变量；</p>
<img src="系统设置截图1.png" alt="系统设置截图1" style="zoom:70%;" />

<p>6）编辑用户变量里的<code>Path</code>，将npm的路径改为：<code>D:\nodejs\node_global</code>；</p>
<img src="系统设置截图2.png" alt="系统设置截图2" style="zoom:70%;" />

<p>7）安装webpack并查看版本信息；</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">npm install webpack –g</span><br><span class="line">npm webpack –v</span><br></pre></td></tr></table></figure>

<p>至此，npm在安装全局模块时的路径和环境变量均设置完成；</p>
<p>8）安装hexo并查看版本信息。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">npm install -g hexo-cli</span><br><span class="line">hexo –v</span><br></pre></td></tr></table></figure>

<h1 id="3、博客搭建"><a href="#3、博客搭建" class="headerlink" title="3、博客搭建"></a>3、博客搭建</h1><h2 id="3-1-搭建和预览"><a href="#3-1-搭建和预览" class="headerlink" title="3.1 搭建和预览"></a>3.1 搭建和预览</h2><p>1）在想要放置的地方建立一个文件夹<code>GitHubName.github.io</code>作为博客根目录；</p>
<p>2）在博客根目录下初始化hexo，可以看到博客根目录中有了以下内容；</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">hexo init</span><br><span class="line">npm install</span><br></pre></td></tr></table></figure>

<img src="文件目录截图4.png" alt="文件目录截图4" style="zoom:70%;" />

<p>3）在<code>source</code>文件夹下新建一个<code>CNAME</code>文件，然后在此文件中写入注册好的个人域名；</p>
<img src="文件目录截图5.png" alt="文件目录截图5" style="zoom:70%;" />

<p>4）在博客根目录下静态部署，生成博客，此时会将<code>source\_posts</code>文件夹下的<code>hello-world.md</code>文件解析到一个<code>public</code>文件夹下，并生成<code>db.json</code>文件；</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">hexo g</span><br></pre></td></tr></table></figure>

<img src="文件目录截图6.png" alt="文件目录截图6" style="zoom:70%;" />

<p>5）在博客根目录下本地运行</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">hexo s</span><br></pre></td></tr></table></figure>

<p>至此，在<a href="http://localhost:4000/">http://localhost:4000/</a> 即可本地预览博客，预览结束之后按<code>Ctrl+C</code>来停止运行服务器，每当修改完网站里的东西就可以通过这种方式来预览，而不是直接发布到网上。</p>
<h2 id="3-2-配置和部署"><a href="#3-2-配置和部署" class="headerlink" title="3.2 配置和部署"></a>3.2 配置和部署</h2><p>1）在博客根目录下的<code>_config.yml</code>文件中作以下配置，<code>_config.yml</code>是整个博客的配置文件，每项配置参数在中<a href="https://hexo.io/zh-cn/docs/configuration">hexo官网</a>有详细的介绍；</p>
<img src="配置文件截图1.png" alt="配置文件截图1" style="zoom:70%;" />

<p>2）在博客根目录下安装一个帮助我们上传文件的Git部署插件；</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">npm install hexo-deployer-git --save</span><br></pre></td></tr></table></figure>

<p>3）将博客部署到GitHub服务器，这一步如果没有反应的话，就在<code>_config.yml</code>文件中所配置<code>repo</code>的冒号后再增加一个空格；</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">hexo d</span><br></pre></td></tr></table></figure>

<p>4）在浏览器中输入个人域名即可看到如下页面，代表成功部署了博客。</p>
<img src="浏览器截图3.png" alt="浏览器截图3" style="zoom:70%;" />

<h2 id="3-3-个性化主题"><a href="#3-3-个性化主题" class="headerlink" title="3.3 个性化主题"></a>3.3 个性化主题</h2><p>1）在<a href="https://hexo.io/themes/">hexo themes</a>中挑一个想要的hexo主题，在博客根目录下执行以下操作，即可将xxx主题保存到<code>themes\xxx</code>文件夹下；</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git <span class="built_in">clone</span> xxxURL themes\xxx</span><br></pre></td></tr></table></figure>

<p>2）在博客根目录下的<code>_config.yml</code>文件中作以下配置；</p>
<img src="配置文件截图2.png" alt="配置文件截图2" style="zoom:70%;" />

<p>3）关于个人图标、打赏、评论等功能需要在xxx主题的<code>_config.yml</code>等文件中进行配置，不同主题的配置方法可能略有不同，可自行根据所设置主题的<code>README.md</code>文件所介绍的内容进行配置；</p>
<p>4）在博客根目录下重复以下步骤即可在<a href="http://localhost:4000/">http://localhost:4000/</a> 中预览新主题下的博客；</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">hexo clean</span><br><span class="line">hexo g</span><br><span class="line">hexo s</span><br></pre></td></tr></table></figure>

<p>5）将博客部署到GitHub服务器并等待一段时间后，在浏览器中输入个人域名即可看到所设置主题下的博客。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">hexo d</span><br></pre></td></tr></table></figure>

<h2 id="3-4-菜单和写作"><a href="#3-4-菜单和写作" class="headerlink" title="3.4 菜单和写作"></a>3.4 菜单和写作</h2><p>1）在<code>themes\xxx</code>目录下的<code>_config.yml</code>文件中作以下配置，即可设置想要的博客菜单，下图设置了首页、分类以及归档菜单；</p>
<img src="配置文件截图3.png" alt="配置文件截图3" style="zoom:70%;" />

<p>2）在博客根目录下执行以下操作即可在<code>source</code>目录下生成一个<code>categories</code>文件夹，编辑（<a href="https://markdown.com.cn/">markdown</a>）该文件夹中的<code>index.md</code>文件，那么在网页上点击<code>categories</code>菜单后就能显示出所编辑的内容；</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">hexo new page categories</span><br></pre></td></tr></table></figure>

<img src="文件目录截图7.png" alt="文件目录截图7" style="zoom:70%;" />

<p>3）为了在静态部署生成博客时能够将<code>source\_posts</code>中的图片资源也解析到<code>public</code>文件夹中，需要在博客根目录下的<code>_config.yml</code>文件中作以下配置；</p>
<img src="配置文件截图4.png" alt="配置文件截图4" style="zoom:90%;" />

<p>4）此时执行以下操作即可在<code>source\_post</code>目录新建一个<code>xxx.md</code>文件和一个<code>xxx</code>文件夹，那么在编辑<code>xxx.md</code>文件时所使用的图片资源就放置在<code>xxx</code>文件夹中；</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">hexo new xxx</span><br></pre></td></tr></table></figure>

<p>5）有时候需要在不同页面跳转，只需在其他md文件中插入需要的跳转的md文件被解析后的地址，即可完成跳转；</p>
<p>6）重复之前的预览、调整和部署操作，在浏览器中输入个人域名即可看到编辑后的博客内容；</p>
<p>7）在博客根目录下安装以下插件可分别令博客支持搜索功能和文章加密功能。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">npm install hexo-generator-searchdb</span><br><span class="line">npm install --save hexo-blog-encrypt</span><br></pre></td></tr></table></figure>

<h2 id="3-5-多设备同步"><a href="#3-5-多设备同步" class="headerlink" title="3.5 多设备同步"></a>3.5 多设备同步</h2><p>hexo 每次更新并部署的都是由 source 文件夹中的源文件所生成的静态 html 文件，远程 repo 中并不包含源文件，因此多设备同步的原理就是将源文件也上传到远程 repo 中，<strong>多个设备之间同步的是源文件（不是静态文件），静态 html 文件依旧可以在各自设备本地由源文件生成更新并部署</strong>。网上关于多设备同步全都是在现有的博客 repo 中新建一个分支来存放源文件，由于我并不想公开源文件所以就用另一个 private repo 来作为源文件的同步中心。</p>
<p>1）用于生成静态 html 所需的文件见下图中选中的内容，其中，scaffolds 是博文模板，source 是博文源文件，themes 是博客主题，_config.yml 是全局配置文件，package.json 记录了 hexo 需要的包的信息（npm 根据这个信息来安装 hexo 环境）；</p>
<img src="设备同步截图1.png" alt="设备同步截图1" style="zoom:60%;" />

<p>2）由于 themes 并不会频繁更改，而且其中的内容也是由其他的 theme repo clone 得到的，含有不能嵌套上传的 .git，所以我将除了 themes 以外的内容（另外还加上了 .npmignore）选作需要通过 private repo 来同步的内容；</p>
<p>3）在每个设备准备好工作前后用于同步的<code>Sync-Before-Update.sh</code>和<code>Sync-After-Update.sh</code>脚本并通过<code>sudo chmod a+x xxx.sh</code>命令赋权，脚本内容如下（<a href="../../../../2023/10/14/shell-script/">参考</a>）；</p>
<img src="设备同步截图2.png" alt="设备同步截图2" style="zoom:70%;" />

<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">!/bin/bash</span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">Sync-Before-Update.sh</span></span><br><span class="line">script_path=&quot;$(dirname &quot;$BASH_SOURCE&quot;)&quot;</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">stop <span class="built_in">local</span> deploy</span></span><br><span class="line">if [[ &quot;$OSTYPE&quot; = darwin* ]]; then</span><br><span class="line">	kill -9 `lsof -ti:4000`</span><br><span class="line">fi</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">update lastest backup</span></span><br><span class="line">cd &quot;$script_path/backup/documents&quot;</span><br><span class="line">git pull</span><br><span class="line">cp -R source ../../GitHubName.github.io/</span><br><span class="line">cp -R scaffolds ../../GitHubName.github.io/</span><br><span class="line">cp _config.yml ../../GitHubName.github.io/</span><br><span class="line">cp package.json ../../GitHubName.github.io/</span><br><span class="line">cp package-lock.json ../../GitHubName.github.io/</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">run <span class="built_in">local</span> deploy</span></span><br><span class="line">cd &quot;$script_path/GitHubName.github.io&quot;</span><br><span class="line">if [[ &quot;$OSTYPE&quot; = darwin* ]]; then</span><br><span class="line">	hexo s</span><br><span class="line">fi</span><br></pre></td></tr></table></figure>

<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">!/bin/bash</span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">Sync-After-Update.sh</span></span><br><span class="line">script_path=&quot;$(dirname &quot;$BASH_SOURCE&quot;)&quot;</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">backup update</span></span><br><span class="line">cd &quot;$script_path/backup/documents&quot;</span><br><span class="line">cp -R ../../GitHubName.github.io/source .</span><br><span class="line">cp -R ../../GitHubName.github.io/scaffolds .</span><br><span class="line">cp ../../GitHubName.github.io/_config.yml .</span><br><span class="line">cp ../../GitHubName.github.io/package.json .</span><br><span class="line">cp ../../GitHubName.github.io/package-lock.json .</span><br><span class="line">git add .</span><br><span class="line">git commit -m &#x27;update&#x27;</span><br><span class="line">git push</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">remote deploy</span></span><br><span class="line">cd &quot;$script_path/GitHubName.github.io&quot;</span><br><span class="line">hexo clean</span><br><span class="line">hexo g</span><br><span class="line">hexo d</span><br></pre></td></tr></table></figure>

<p>4）运行<code>Sync-After-Update.sh</code>，原设备 GitHubName.github.io 目录中选定的内容就同步到原设备本地的 private repo 以及远程的 private repo 中，每次完成在当前设备的工作之后，都需要运行一次<code>Sync-After-Update.sh</code>来完成源文件的同步和静态文件的重新部署；</p>
<img src="设备同步截图3.png" alt="设备同步截图3" style="zoom:70%;" />

<p>5）在新设备安装 Git，设置 Git 用户信息，生成新的 ssh key 并将其添加到 GitHub 主页；</p>
<img src="设备同步截图4.png" alt="设备同步截图4" style="zoom:40%;" />

<p>6）在新设备安装 Node.js（不要用 brew 安装，路径会有问题），配置 npm 环境变量，在设备本地建立和原设备一致的 GitHubName.github.io 目录并进入该目录；</p>
<p>7）在新设备 GitHubName.github.io 目录下依次运行如下三个命令来分别安装 hexo、安装 package.json 中所记录的 hexo 所需要的包、安装 hexo 部署工具；</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">npm install hexo</span><br><span class="line">npm install</span><br><span class="line">npm install hexo-deployer-git</span><br></pre></td></tr></table></figure>

<p>8）运行<code>Sync-Before-Update.sh</code>，原设备 GitHubName.github.io 目录中选定的内容就同步到新设备 GitHubName.github.io 目录以及设备本地的 private repo 中，每次在当前设备进行工作之前，都需要运行一次<code>Sync-Before-Update.sh</code>来得到最新的源文件。</p>
<img src="设备同步截图5.png" alt="设备同步截图5" style="zoom:45%;" />

<h1 id="4、问题记录"><a href="#4、问题记录" class="headerlink" title="4、问题记录"></a>4、问题记录</h1><p>1）<strong>插入图片的路径问题：</strong>静态部署前<code>xxx.md</code>文件中所插入的图片位于<code>xxx</code>文件夹中，静态部署后图片会被解析到与html文件相同的文件夹下，因此，在编辑完成后静态部署前需要将插入图片的路径更改为正确的形式，这一点可自行观察解析后的<code>public</code>文件夹结构</p>
<p>2）<strong>代码显示问题：</strong>无序列表文本中采用反引号包裹的代码在网页上没有显示出代码形式，而是普通文本形式，此时，需要在无序列表的某一条中的最后依次输入回车和后退（不要输入连续两次回车），此时反引号包裹的代码即可在网页上正常显示了（导致这个问题的原因暂时还不知道）</p>
<p>3）<strong>浏览器上的更新问题：</strong>有时候需要将浏览数据清除，再重新打开网页才能正确显示出更新后的博客内容</p>
<p>4）<strong>GitHub Page 不显示问题</strong>：仓库设为私有后，博客将无法正常显示，即便再改为公有后还是无法显示，此时需要在 GitHub Page 中将域名移除重新添加即可</p>
<p>5）<strong>命令执行权限问题</strong>：有的命令需要管理员身份才能执行，比如<code>hexo d</code></p>
<p>6）<strong>部署时报错</strong>：先删除 <code>.deploy_git</code> 文件夹，然后输入 <code>git config --global core.autocrlf false</code>，最后重新部署即可</p>
<img src="报错截图1.png" alt="文件目录截图7" style="zoom:70%;" />

<h1 id="5、参考资料"><a href="#5、参考资料" class="headerlink" title="5、参考资料"></a>5、参考资料</h1><ul>
<li><a href="https://sketchk.xyz/2017/03/24/A-Guide-Of-Making-Your-Personal-Blog-Part-1/">《A-Guide-Of-Making-Your-Personal-Blog》</a></li>
<li><a href="https://docs.github.com/cn/pages/configuring-a-custom-domain-for-your-github-pages-site/about-custom-domains-and-github-pages">《about-custom-domains-and-github-pages》</a></li>
<li><a href="https://juejin.cn/post/6844904131266609165">https://juejin.cn/post/6844904131266609165</a></li>
<li><a href="https://zhuanlan.zhihu.com/p/102592286">https://zhuanlan.zhihu.com/p/102592286</a></li>
<li><a href="http://lowrank.science/archives/">http://lowrank.science/archives/</a></li>
<li><a href="https://github.com/D0n9X1n/hexo-blog-encrypt/blob/master/ReadMe.zh.md">https://github.com/D0n9X1n/hexo-blog-encrypt/blob/master/ReadMe.zh.md</a></li>
<li><a href="https://www.itfanr.cc/2021/04/16/hexo-blog-article-encryption/">https://www.itfanr.cc/2021/04/16/hexo-blog-article-encryption/</a></li>
<li><a href="https://blog.csdn.net/K1052176873/article/details/122879462">https://blog.csdn.net/K1052176873/article/details/122879462</a></li>
</ul>
]]></content>
  </entry>
  <entry>
    <title>Cloud Computing</title>
    <url>/2024/03/09/cloud-computing/</url>
    <content><![CDATA[<h1 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h1><p>在远端提供的基础设施服务就称之为云</p>
<ul>
<li><p>云的资源在用户看来是可以随时获取、按需使用、无限扩展的，通过租用云服务器，调用云端计算资源，企业和个人都不再需要自行准备硬件工具，工作会更加方便</p>
</li>
<li><p>云计算应用中一般提供硬件虚拟化、平台虚拟化、应用程序虚拟化等虚拟化技术（虚拟化技术是一种资源管理技术，是将计算机的各种实体资源，如服务器、网络、内存等，予以抽象、转换后呈现出来，打破实体的物理限制）</p>
</li>
<li><p>云计算应用可以按需地通过动态扩展来提高计算存储能力，具备良好的灵活性、兼容性、可靠性、可扩展性以及性价比</p>
</li>
</ul>
<h1 id="设施模型"><a href="#设施模型" class="headerlink" title="设施模型"></a>设施模型</h1><p>云计算存在如下不同的设施模型</p>
<ul>
<li><p>公有云</p>
<ul>
<li>是为广大用户、个人或企业提供的云基础设施，是可以通过互联网访问的虚拟环境中的服务器空间</li>
<li>所有硬件、软件和其他支持性基础结构均为云提供商所拥有和管理，不同用户会共享相同的硬件、存储和网络设备（通过虚拟化技术进行隔离），可以使用 Web 浏览访问服务和管理账户</li>
<li>成本低，无需用户维护，无限扩展，可靠性高</li>
</ul>
</li>
<li><p>私有云</p>
<ul>
<li>是为一个企业或组织提供的专用的云环境（也被视为是一种企业云），可以由企业或组织内部的 IT 团队在该组织的防火墙后面进行内部操作</li>
<li>组织可以更好地控制其计算资源，物理上可以位于组织的现场数据中心，也可由第三方服务提供商托管，服务和基础结构始终在私有网络上进行维护，硬件和软件专供组织使用</li>
<li>可以更加方便地自定义资源，具备更高的灵活性、安全性，费用和维护成本也很高</li>
</ul>
</li>
<li><p>混合云</p>
<ul>
<li>是通过安全连接（如 VPN 连接或点对点专用连接）组合一个或多个公有云和私有云得到的云环境，允许在内部不同的云环境之间共享数据和应用程序</li>
<li>当在私有云上运行的应用程序遇到使用高峰时，可以自动突发到公有云环境已获得额外的按需容量（这被称为云爆发），因此无需担心提前配置硬件以满足高峰需求</li>
<li>整合了公有云和私有云的优势，但目前支持混合云的服务厂商并不多，技术方案也不是很成熟</li>
</ul>
</li>
</ul>
<h1 id="服务模式"><a href="#服务模式" class="headerlink" title="服务模式"></a>服务模式</h1><p>根据用户所需的服务模式的不同，云计算可分为三类，这种云计算服务构建堆栈，位于彼此之上，因此又称为云计算堆栈</p>
<ul>
<li><p>基础设施即服务（IaaS）</p>
<ul>
<li>指把 IT 基础设施作为一个服务通过网络对外提供，并根据用户对资源的实际使用量或占用量进行计费的一种服务模式</li>
<li>用户可以在云服务提供商提供的基础设施上部署和运行任何软件，包括操作系统和应用软件</li>
<li>但用户没有权限管理和访问底层基础设施，如服务器、交换机、硬盘等</li>
</ul>
</li>
<li><p>平台即服务（PaaS）</p>
<ul>
<li>指把运算平台和解决方案作为一个服务对外提供</li>
<li>用户可以使用由云服务提供商支持的编程语言、库、服务以及开发工具来创建、开发应用程序并部署在相关的基础设施上</li>
<li>用户无需管理底层的基础设施，包括网络、服务器、操作系统或存储，只能控制部署在基础设施中操作系统上的应用程序，配置应用程序所托管的环境的可配置参数</li>
</ul>
</li>
<li><p>软件即服务（SaaS）</p>
<ul>
<li>指把软件作为一个服务通过网络对外提供</li>
<li>用户通过轻量的客户端接口（如 Web 浏览器，基于 Web 的电子邮件）或程序接口从各种客户端设备访问应用程序</li>
<li>用户无需管理或控制底层云基础架构，包括网络、服务器、操作系统、存储以及单独的应用程序功能等，不同可能会有有限的用户特定应用程序配置设置</li>
</ul>
</li>
</ul>
<h1 id="Serverless"><a href="#Serverless" class="headerlink" title="Serverless"></a>Serverless</h1><p>Serverless 是一种云计算架构模式</p>
<ul>
<li><p>主要思想是开发者可以通过第三方提供的服务直接实现应用程序的构建和部署，不同于以往应用程序的概念，Serverless 应用程序实际会被分解为无状态的函数，这些函数被云平台统一管理</p>
</li>
<li><p>开发者只需要关注业务逻辑和函数的编写，无需关注底层的服务器和基础架构的管理，包括底层的服务器、网络、存储、安全等，此外，云平台还提供自动扩展、负载均衡，监控和日志等服务，支持多种编程语言和框架</p>
</li>
<li><p>可以实现高可用性、高弹性、高兼容性以及灵活性的函数开发，被广泛应用于 Web 应用程序、移动应用程序、数据处理和分析、物联网等领域</p>
</li>
<li><p>Serverless 应用不会提前启动，应用后端服务是按需自动启动和停止的，当没有请求时，服务不会占用任何资源或运行任何进程，只有在请求到达时，相应的功能才会被触发并执行，执行完毕后资源会被释放，这意味着 Serverless 应用的启动速度要求很高</p>
</li>
<li><p>云原生环境下，企业通常按使用量付费，应用的快速启动和停止一方面意味着可以根据实际需求调整资源使用，从而优化运营成本，另一方面意味着可以快速实时更新并动态扩展那些基于微服务和容器化的应用，从而可以在应用出现问题时快速回滚、发布、更新，保证应用的稳定性和可用性</p>
</li>
</ul>
<h1 id="服务等级协议"><a href="#服务等级协议" class="headerlink" title="服务等级协议"></a>服务等级协议</h1><p>服务等级协议（SLA，Service Level Agreement）是指供应商和客户之间达成的一份正式协议，通常用于云计算、SaaS、PaaS 等服务领域，制定合适的 SLA 旨在确保供应商向客户提供高质量、高可靠性、高安全性、可量化和可监控的服务，便于在供应商和客户之间维护良好的业务合作关系。</p>
<p>SLA 规定了供应商应该向客户提供的常见指标如下</p>
<ul>
<li><p>可用性，指服务在一定时间范围内能够正常使用的时间比例，通常以百分比表示，例如四个九（99.99%）可用性要求 99.99 % 的时间内服务要正常可用</p>
</li>
<li><p>响应时间，指服务请求的响应时间，通常以毫秒或秒为单位表示</p>
</li>
<li><p>吞吐量，指系统在单位时间内能够处理的请求量，通常以每秒处理的请求数（QPS）或每分钟处理的请求数（RPM）为单位</p>
</li>
<li><p>故障处理时间，指故障发生之后系统能够恢复正常运行的时间，通常以分钟或小时为单位</p>
</li>
<li><p>数据可靠性，指系统能够保证数据的完整性、一致性、可用性和安全性，例如集群中采用主从同步、冗余备份等手段来保证数据可靠性</p>
</li>
<li><p>服务支持，指服务提供商提供的技术支持、客户服务等方面的指标，例如要求提供商提供 24 小时客户服务等</p>
</li>
<li><p>其他指标，根据具备业务需求和服务类型，还可以定义其他指标，如数据保密性、可扩展性等指标</p>
</li>
</ul>
]]></content>
  </entry>
  <entry>
    <title>Accident -</title>
    <url>/2022/07/02/accident/</url>
    <content><![CDATA[<div class="hbe hbe-container" id="hexo-blog-encrypt" data-wpm="Oh, this is an invalid password. Check and try again, please." data-whm="OOPS, these decrypted content may changed, but you can still have a look.">
  <script id="hbeData" type="hbeData" data-hmacdigest="2899e96fb831df67ee1adea2b78fe067d919a433a4af982641dcad7992a388f5">a99f2d1cd7f89812758242c57c62a59f509e29389d12d829af183998e66625bb5ea792e452aa793c7be28fc944b92799eeb0c75c91c456aaeabc146e386262de7e08b90b3393797f457cbe5da93c115e9c609b37762e4756ee1734a5120d7db9673e8b52fb83deee4d63e419356690e139c77d082209c90cdf87a54ec9d968b9f3ad5f4f0024c0efe3d92868e48966c286c202f971589cfa2ada5384153ad7e26ade3de9be910531613ae2f43b929e948931c4ff6222b02dbc9d6415bebe13e49d0259aa1ca4564230fc55eb8d72be768bed7b281bc16461f5e4417d63d40fc1a35850606dcb76cd99931de1ce54ff7606ab925876e5ecbe0812db0124eff1eaa7492a3d302770cf779e21df410bf291ce0032ffb42650ba40d58043e52e92b565d1926dc6e3b1598dd1d76e9da7091b929d5e5cef9f9127db075fc9bef304308f420db923332a5acdf3fdba296f384f0d96441a2abceb4ae23fbbb0294dd56c9b38f253eabe64b4293e12decc733ef1448647d6acf76241cd33eca8530cd7f96f879122c46f8cf40a21b371d8d851369217cb1de94951f27e6308d20b035ab93db9b2bfcef35b65f196cd363ecd1914df84afcc4403289be58fc2d62d5c8baea14536c35e34f764f8ff20756e8c82f824e91dd919004eb29990df52ac4f43411f8d70a1235c4e5bd953c54dc15ab0082925e01b003a10fe3ef0d39f870978f1a88d0b82f9009befb5ed97dc093dbc23b59eecc8671638e0164cf4b8e8c38f284cc470bb5182e916956ccf92b394e1658223823e30a4c228fdf87349885eedd6cb0744ea28a851614c62b11f9e0ca22c9005a31e815682fb94007d5b5b976ea106306bedcc1d2101c8369d671b2778109471729670505d06f88ab07b7e9b7acabbd24a6120a7e00c316307a6baae7e6fc342446453c286222f939208d745ad2e1f254e18714eafe4f69826747ccf1d4119b047d207b19ee1fea34d8ae28c13b1d3f9b820b626420b35cc6ee0bafc627065b7fef7756f14750ad28cbf851cadc4bb388189d57b99fac1a4916799de94e04a78d92e84ddefc58f3eacb06219aba5b942bbd0a09747f36cf4b821f1efef08ba0edd8c3567b97d55ed1f86e2111f822da6b4f997256e0ba64d940504c1c950aa289ae5d517bf29aa99b7dcfb3be24213a4e7c26e70f60f4ee9f1972e223976cda03a7e42cdb3dcca35a8caa47e1a1de542b4a69376d10ef209b1f4d441f3d3fdd67aaaa393ece634a19c18008daad237eee5e3fced233f7e2d464d3e0e7c0247534aa523a27cd73d291adc6228e919140d2a429206340c6424afabe476df75124682590ced3f1593d8eeb5aa28c62fcda72fdc4171014f493cf64f043b1672a9fccc22e3382413a88fa3dd4a92f1104233ee1a555f6bd19eeffb1ad85b8009aa325da60d201636c85b1547f3d0c6a398660d0374819040fadcea613a421132f92e0cca3f207a21b6b69a16bc10e8164fc05b7982ac1f402a34f58c1d1f440306842b9522c82123b66a3dd15e56d8513359b3baa631a790ab0fe7f27f4712bc1c28805495f906133733d3634ccdc5ba3206629aa49cc5c5d398ca3864fc4a42ff259ec57e51e84dcfecefd63dc06f5102d2d5cbb07b2c1fafdf3d5ab4932abd1d7f58a6920903216a1aaa45fde1473413f7f63e32cba9ae5026b2e2dc26a7607f524fbad9214fb9bcc10dfd65cb1ae023095174d3d56d79653a4bfa32bb36790121fd8e2453b497bd0f9b84e4ab71341083bc7797c58eeea3b01403ec3e252deac37644ecf69f9565303b46d0502b4b9a1948d8fdfcb9bbeecb776aa9029cdd75c3fb7d05e412270770b35219ce11bed7b3df0a18ff22a2736c7c5f0facb907aebdf5162c9eaac1de3cd40bf6fccd86ea3b2f8d6cb0621ce82437d7b97944b49f3937b5a18b2ad7cc81601b761107de43b3bbfb2788c051f1d033ad0dd43b387de5f1330b58b4d1f916e308ac97954d42de1b4c0d6053caa2bac5003600133f7788c6c70fe8a3c4386320e886d9400e9b0f318fc85b926ae065bc9bc7905d7216c58e3ebb197dd71205b6a73ecd011a24fb0425144f706918690c0c3c6d37007c0dd13a4c52f6b35dbce601e923f0c0bfb2f907f570814308012ddbbea3a59d7e8aa989271f5d820e1678c409620f8c5ae6bc586d9c2f679a196d53cb503599c494341a1651c5bb1c0e1a206a0443aee0218820a98788f49758b56800ebee82b9b7ae2077ab27545571c824b0e82f15daa7d270503d26628fa7d53c0c8aabd83f7bbd3821ad83af3ae8036f92b270433f9a233e0c771475134fe77f38312801bc5252988792248de3f546d6ee77b9efd22600c5d253d2324da069472bfc0bacfafc8eeda51a8ced0b01bfe36af4f2a7593f342d9df6cf3f8f95b3601d6601192b5dabc9358f1ec7e80e3bf90aaa438028a349dfadf81011b283148e3cd467ee9863d4f6e0b9dabf3225c866bdb9098037227c62da9778eeb6afd9078325e7941e894580ef98699013eeced3957bddcb83ecf82877372e6bbe9b4409a4d6ba9f49674c4a84a3098ba43cc5c834c26aa4865019bd331c5e3ea342d1f29642e05ffc29a0a1c71c1c87501b6a42d4a31b0709d4b1354d39987b56187fe65ef0950a88d9f1bbe53b362e84fc1af8f634cb0ae0eec941b5bd3bb97ccfa50ed33870d556325255a26bc173a8f04d2c4e46c731333d490fad28cf28bb243dfc0c2a028907262fbf1f956b609354660c85fc3d60336d5ba5472b5d2b11eb6d92e0e71d453cd450aefed04017da3b3f82fd4994a61e941975858ccd3325e904be7d2dbcf178cfa4cb14a314e78ce527b6a368828d23977155747e7a974452c22ead3dc02cc8676cbbb1fe1d3051d597bca4083150254ec207f892e477b6351d619bd378e931681b221bec728d6c371c233b8b74b98b2e17b4d0b3124e1117f6b1043ea6fa0a988f232ef98c008bf25b996a9dab8a403bfeaedd9059966cdb52b87ffa718a1a0fe79a559b17bfdd92f69b58b75adae11757fcd356de36aae4a45dbcb71874256c802a7c51d1f823dc06bac8b6b077d98027d935e29a7c984e26f19793039ab8c594a29b70040797c14c041cba1f601eebd22b485187bae79b6ac8c96ba61823b9f7443a47dd2fa53b6116e42396a2bc359f609357a7e8a57c0da2ee2b494902efaf460b7fb209f4dadf21715e561aa9d2d28034a2635248630ec9d686c5c5402bef1f280e1bfc372fb3c85a10d8ac1a2c04a82fef222fbe0354584b1e49da9c241905e2dbf5fb10cd7b8155eedc8501a8beb94b985d5ff81bff828581a48c93e8d1a6512d727110617bd040c2eb58186afd74edf592f20080ee9f64e9e829fb5e81265a2f20fe7631f7f836afda8927c8543cfa6fcf464e60595811668b0f36c2b31719df229ded06c9ba0a0916435f4c272ec85a3e10779daff060bafa540fcb22ec3358d66fa3af195a96c2e8f1c9d49e2c46aef4546ce8f1599c366ccb16cb19699c22bf92039a88ea6489f5cf40b023ea2a93dc4dad4a82dfbe424ca83ff18a58aa0654e93a81d297cf6f253c92a0fd4740f1824c97f828806beab9b790f1bb67f03be2e3765537ee676dea6e03db243ddfc97fddfcc42496b268e691774938e5353de09f4ff758b8800960856b6cde87c96364990e0663aecb1304cce30b8a04c58c572c466c5b381ca7b9fa742d185bf02314644a5cad715b56fbfcd965f346014d940ed69063d99cfd661e510dfc1713253d0ee18a9858966286b5</script>
  <div class="hbe hbe-content">
    <div class="hbe hbe-input hbe-input-default">
      <input class="hbe hbe-input-field hbe-input-field-default" type="password" id="hbePass">
      <label class="hbe hbe-input-label hbe-input-label-default" for="hbePass">
        <span class="hbe hbe-input-label-content hbe-input-label-content-default">Hey, password is required here.</span>
      </label>
    </div>
  </div>
</div>
<script data-pjax src="/lib/hbe.js"></script><link href="/css/hbe.style.css" rel="stylesheet" type="text/css">]]></content>
  </entry>
  <entry>
    <title>Domain Driven Design</title>
    <url>/2024/03/16/ddd/</url>
    <content><![CDATA[<h1 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h1><p>领域驱动设计（Domain Driven Design, DDD）是一种软件开发方法论，强调将业务（而不是技术）作为软件设计的核心，开发人员应当与业务人员密切合作，了解业务需求，理解业务模型，通过领域建模、领域驱动架构、领域事件将业务模型映射到软件系统中，从而开发出更符合业务需求的软件系统，这样软件系统易于维护和重构，可以更好地满足业务需求并支持业务迭代。</p>
<ul>
<li><p>领域建模是指通过领域对象、领域服务、领域事件等概念来对业务进行抽象与建模，进而实现业务需求</p>
<ul>
<li><p>领域模型是用来描述业务领域的核心概念、业务规则和业务流程的一种图形化表示方式，由实体、值对象、聚合、领域服务和时间等元素组成</p>
</li>
<li><p>实体通常指具有唯一标识的具体对象或事务，具有自己的生命周期，可以被创建、修改和删除，通常对应数据库表中的一行记录，每个实体具有唯一的标识符（通常是主键）</p>
</li>
<li><p>值对象通常指没有唯一标识符的对象或数据类型，值对象通常不可变，一旦被创建就不能修改，只能通过创建新的值对象来替换原来的值对象，通过对应数据库表中的一组字段</p>
</li>
<li><p>聚合是指将多个相关的对象或实体组合在一起形成一个具有单一标识符的单独的整体，这个整体代表了一组相关的子对象或属性，在整个系统中具有特定的上下文和含义</p>
</li>
<li><p>聚合根是聚合中的唯一标识符，控制着聚合中其他对象的生命周期，是整个聚合的唯一入口点，所有对聚合的操作都是通过聚合根来进行的</p>
</li>
</ul>
</li>
<li><p>领域驱动架构是指将应用程序从上到下依次划分为用户接口层、应用层、领域层、基础设施层这四个层次来实现业务领域的清晰分离，层级调用关系是上层调用下层单向调用</p>
<ul>
<li><p>用户接口层包含用户界面展示、Web 服务调用</p>
</li>
<li><p>应用层提供应用服务来处理用户请求并协调领域对象的交互</p>
</li>
<li><p>领域层包含聚合（实体和值对象）和领域服务</p>
</li>
<li><p>基础设施层负责提供数据持久化、事件总线、API 网关、缓存、第三方工具以及其他基础组件等</p>
</li>
</ul>
</li>
<li><p>领域事件是领域模型发生一些状态或行为时向外发出的一个通知，这个通知被定义为领域事件</p>
<ul>
<li>不同于 MQ 中的事件，领域事件一般不会在分布式系统之间传递，只会在单个微服务内部传递，作用在于解除领域之间的耦合</li>
<li>领域事件驱动是指通过领域事件的发布和订阅机制来在各个领域模块之间传递信息，实现各个领域模型之间的解耦</li>
</ul>
</li>
</ul>
<p>DDD 是一种复杂的方法论，需要较长的学习周期和更多的开发成本，并不适用于所有的项目团队，应用 DDD 之前需要评估项目的适用性。</p>
<h1 id="实现流程"><a href="#实现流程" class="headerlink" title="实现流程"></a>实现流程</h1><ul>
<li><p>确定业务领域</p>
<ul>
<li><p>需要明确软件系统需要解决的业务问题，并确定业务领域的边界</p>
</li>
<li><p>业务领域是指具有内在一致性和自治性的业务范畴，包含了业务规则和业务流程</p>
</li>
</ul>
</li>
<li><p>设计领域模型</p>
<ul>
<li><p>根据业务领域来设计领域模型，实时确保领域模型和业务需求的一致性</p>
</li>
<li><p>建立统一语言以确保所有团队成员都能够理解和共享业务知识</p>
</li>
</ul>
</li>
<li><p>设计领域架构</p>
<ul>
<li><p>将应用程序从上到下依次划分为用户接口层、应用层、领域层、基础设施层这四个层次来实现业务领域的清晰分离</p>
</li>
<li><p>架构模型可以不同的表现形式，但都是以领域模型为中心的微服务架构，设计思想都是高内聚低耦合原则</p>
</li>
</ul>
</li>
<li><p>实现领域模型</p>
<ul>
<li><p>将设计好的领域模型转化为实际代码</p>
</li>
<li><p>领域对象封装到聚合类中，实现领域服务以实现领域模型之间的交互和协作，使用领域事件来传递领域对象之间的消息</p>
</li>
</ul>
</li>
</ul>
<h1 id="充血-贫血模型"><a href="#充血-贫血模型" class="headerlink" title="充血/贫血模型"></a>充血/贫血模型</h1><p>充血模型和贫血模型都是面向对象的软件设计方法</p>
<ul>
<li><p>充血模型</p>
<ul>
<li><p>强调将业务逻辑封装在领域对象中，领域对象自身包含业务逻辑</p>
</li>
<li><p>易于理解和扩展，具有良好的封装性和可维护性，可以避免过度依赖外部服务，提高系统的稳定性</p>
</li>
<li><p>需要对模型具备良好理解才能开发，上手成本高，对象间的协议更加复杂，对象的状态可能会变得不一致</p>
</li>
<li><p>适用于较大的应用系统或者复杂的业务流程</p>
</li>
</ul>
</li>
<li><p>贫血模型</p>
<ul>
<li><p>强调行为与数据分离，领域对象仅持有数据，业务逻辑行为由外部服务提供</p>
</li>
<li><p>对象复杂度低，代码的重用性和可测试性高，可以更好地利用现有的服务和框架</p>
</li>
<li><p>对象缺乏封装性，易于出现耦合性和脆弱性，业务逻辑被分散在各个类中，过度依赖外部服务，可能导致系统的不稳定</p>
</li>
<li><p>适用于较小的应用系统或简答的业务流程</p>
</li>
</ul>
</li>
</ul>
]]></content>
  </entry>
  <entry>
    <title>DevOps</title>
    <url>/2022/09/06/devops/</url>
    <content><![CDATA[<h1 id="CI-CD"><a href="#CI-CD" class="headerlink" title="CI/CD"></a>CI/CD</h1><p>持续集成 (Continuous Integration) 和持续部署 (Continuous Deployment) 是一种软件开发实践，CI 要求开发者每次提交代码变更后立即集成其变更，每次集成都通过自动化的构建（包括编译，发布，自动化测试）来尽早地发现错误，验证一组变更是否能够正确地和原有代码集成在一起，CD 在 CI 的基础上，通过自动化的构建、测试和部署循环来将集成后的代码部署到更贴近真实运行环境的类生产环境和生产环境，以快速可靠地交付高质量的产品。</p>
<h1 id="DevOps"><a href="#DevOps" class="headerlink" title="DevOps"></a>DevOps</h1><p>DevOps 是一个软件开发生命周期，具备 CI/CD 工作流（意味着最少的人为干预），强调软件开发和 IT 运维的紧密结合（甚至直接由开发自己做运维），以实现更快速、更频繁、更可靠的软件交付，提高应用程序的可靠性和可维护性。</p>
<h1 id="Jenkins"><a href="#Jenkins" class="headerlink" title="Jenkins"></a>Jenkins</h1><p>Jenkins 是一个基于 Java 的 MIT 许可下的开源 CI/CD 工具，Jenkins 本身并不是流水线，不执行任何功能，但能够和许多不同的服务器和工具联合使用并统一安排起来，比如版本控制管理工具 <a href="../../../../2022/05/07/git/">Git</a>，自动化构建工具 <a href="../../../../2022/05/07/maven/">Maven</a>，网页应用服务器 Tomcat，代码测试框架、代码质量改进工具、Docker 容器以及容器编排工具 <a href="../../../../2022/10/03/kubernetes/">Kubernetes</a> 等。</p>
<h1 id="蓝绿部署"><a href="#蓝绿部署" class="headerlink" title="蓝绿部署"></a>蓝绿部署</h1><p>在部署新版本时，准备两套完全相同的生产环境，成为蓝环境和绿环境，初始状态下用户的请求全部都被路由到蓝环境，绿环境处于闲置，当新版本在绿环境部署完成并通过测试后，流量逐步从蓝环境切换到绿环境，在这个过程中，一旦需要回滚则直接将流量重新切回蓝环境即可。缺点在于有闲置环境的机器资源是被浪费的。</p>
<h1 id="灰度发布"><a href="#灰度发布" class="headerlink" title="灰度发布"></a>灰度发布</h1><p>灰度发布（又称金丝雀发布）、蓝绿部署都是软件部署和发布中常用的一些策略和技术，用于在生产环境中逐步更新和验证新版本，主要目标是降低部署风险、确保服务稳定性，实现快速、高效的软件发布。但是灰度发布不需要一组闲置的服务器，而是在整个服务集群中挑选一部分机器进行灰度发布，发布会直接对外提供服务，通过给这些机器引流来验证服务是否正常。缺点在于回滚更难做一点。</p>
<h1 id="快速回滚"><a href="#快速回滚" class="headerlink" title="快速回滚"></a>快速回滚</h1><p>在应用发布前记录基线，即把应用相关的内容，如环境、容器、war 包等全部记录下来，在需要回滚时就根据这个基线进行快速部署。</p>
]]></content>
  </entry>
  <entry>
    <title>Distributed System</title>
    <url>/2024/02/06/distributed-system/</url>
    <content><![CDATA[<h1 id="1、引言"><a href="#1、引言" class="headerlink" title="1、引言"></a>1、引言</h1><p>单体集中式应用是最传统的架构模式，整个系统有一个统一的数据中心，各个功能模块显式进行相互依赖，随着应用变得越来越庞大，流量负载越来越高，单体应用在可扩展性和容错性上都存在致命缺陷，则倾向于使用一组互相独立且富余的服务器系统（云服务），而非单体服务来运行应用。分布式是把一个集中式系统拆分成多个系统，每一个系统单独对外提供部分功能，整个分布式系统整体对外提供一整套服务，用户对这种拆分是无感知的。分布式还意味着可以采用更多的没有空间限制的计算机组成分布式集群对外提供服务，计算机越多，集群的资源也就越丰富，能够处理的用户流量就越大。与此同时，分布式也引入了一些需要考虑的问题，比如机器与机器之间的通信问题，数据一致性问题等。</p>
<h1 id="2、分布式架构"><a href="#2、分布式架构" class="headerlink" title="2、分布式架构"></a>2、分布式架构</h1><p>分布式架构的具体实现有很多种，比如 C/S 架构、P2P 架构、SOA 架构、微服务架构、Serverless 架构等。</p>
<ul>
<li>C/S 架构中，客户端应用程序通过网络连接到一个或多个服务器，服务器负责处理客户端的请求并返回相应的结果，服务器会成为性能瓶颈，C/S 架构常见于 Web 应用、数据库系统等</li>
<li>P2P 架构中，网络的每个参与者既是服务提供者又是服务消费者，每个节点的地位都是对等的，常见应用是 BT、迅雷等</li>
<li>SOA 架构是面向服务的架构，将应用根据系统维度、功能维度、读写维度或者模块维度进行划分，成为各个独立的服务组件，组件之间通过一个约定的方式进行通信，并通过一个统一的数据中心或调度中心来基于流量压力实时管理集群容量，这种 SOA 架构利用可拔插的中间件以及消息队列来完成服务与服务之间的解耦，但对总线结构的依赖也使得服务的独立性并没有剥离，没有完全去中心化</li>
<li>微服务架构是一种将单体应用开发为一套微小服务的方法论，这些微小服务是围绕业务功能构建的，每个微小服务都在自己的进程中运行，服务各自都可以使用不同的编程语言、不同的数据存储技术，并通过自动化的方式独立部署，服务之间通过轻量的通信机制通信，无需集中式管理</li>
<li>Serverless 架构是一种将应用程序逻辑交给云服务提供商管理的架构形式，应用程序通过事件驱动的方式触发，适用于快速开发、弹性扩展和按需收费的场景</li>
</ul>
<h2 id="2-1-SOA-架构"><a href="#2-1-SOA-架构" class="headerlink" title="2.1 SOA 架构"></a>2.1 SOA 架构</h2><p>SOA 是面向服务的，相互独立的软件片段将自身的功能通过服务提供给其他应用，包含标准化的服务契约、服务的松耦合、服务的抽象、服务的可重用性、服务的自治性、服务的无状态性、服务的可发现性、服务的可组合性、服务的可编排性、服务的可协同性，最终提高更大范围的业务敏捷度。</p>
<p>Service 是一种按照既定“接口“来访问一个或多个软件功能的机制（这种访问要符合“服务描述”中策略和限制）。面向对象和面向服务都尽可能追求抽象、封装和低耦合，但面向对象的接口基本只被团队内的有限人通过内部特定的客户端在进程内使用，需要通过提供细粒度接口和复杂参数类型以追求使用的使用灵活性和功能的强大性，而面向服务旨在远程应用于范围无限制的客户端（不同部门不同企业甚至不同国家），采用的原则如下，两者适用场景和原则完全相反。</p>
<ul>
<li><strong>远程过程调用</strong>：由于 service 通常要被远程访问，而网络传输，对象序列化 / 反序列化等开销都远远超过本地 Object 访问几个数量级，所以选择高性能的远程调用方式对于加快系统的响应速度、减少带宽占用和提高吞吐量是很重要的，远程调用方式往往受限于具体的业务和部署环境（比如内网、外网、同构平台、异构平台等），以及对诸如分布式事务，消息级别签名 / 加密，可靠异步传输等方面的支持程度（这些方面通常被称为 SLA：service level agreement），从性能上讲，TCP 协议 + 二进制序列化更适合内网应用，从兼容性、简单性上来说，HTTP 协议 + 文本序列化更适合外网应用，此外，基于 HTTP 协议的 REST 也可以看作是一种轻量级远程调用方式</li>
<li><strong>消除冗余数据</strong>：由于 service 的远程调用开销很高，所以在它的输入参数和返回结果中，还要尽量避免携带当前业务用例不需要的冗余的字段，来减少序列化和传输的开销，此外，去掉冗余字段也可以简化接口，避免给外部用户带来不必要的业务困惑</li>
<li><strong>粗粒度契约</strong>：同样由于远程调用开销高，同时 service 的外部使用者对特定业务流程的了解也比不上组织内部的人，所以 service 的契约（接口）通常需要是粗粒度的，其中的一个操作就可能对应到一个完整的业务用例或者业务流程，这样既能减少远程调用次数，同时又降低学习成本和耦合度（而 OO 接口通常可以是非常细粒度的，提供最好的灵活性和重用性），对外网客户来说，多次跨网的远程调用变成了一次跨网调用 + 多次内网调用</li>
<li><strong>通用契约</strong>：由于 service 不假设用户的范围，一般要支持不同语言和平台的客户端，但各种语言和平台在功能丰富性上有很大差异，这就决定了服务契约必须取常见语言、平台以及序列化方式的最大公约数，才能保证 service 广泛兼容性，服务契约中不能有某些语言才具备的高级特性，参数和返回值也必须是被广泛支持的较简单的数据类型（比如不能有对象循环引用）</li>
<li><strong>隔离变化</strong>：虽然 OO 和 SO 都追求低耦合，但 SO 由于使用者范围极广，就要求了更高程度的低耦合性和内外系统隔离，内部的重构不能能影响到外部的用户，把内部系统变化对外部的冲击减少到最小程度</li>
<li><strong>契约先行</strong>：Service 是往往涉及不同组织之间的合作，而按照正常逻辑，两个组织之间合作的首要任务，就是先签订明确的契约（WSDL 或者 IDL），详细规定双方合作的内容，合作的形式等等，这样才能对双方形成强有力的约束和保障，同时大家的工作也能够并行不悖，不用相互等待</li>
<li><strong>稳定和兼容的契约</strong>：基于契约先行的方式，以后频繁更改契约也导致开发人员要不断重做契约到目标语言映射，非常麻烦，因此契约在公开发布之后就要保证相当的稳定性，不能随便被重构，即使升级也要考虑尽可能的向下兼容性（计划式设计），这一点与敏捷软件开发的拥抱变化，持续重构完全相反（演进式设计），计划式设计和演进式设计并不绝对矛盾，可以将 SOA 层和面向对象应用相对隔离，分而治之</li>
<li><strong>契约包装</strong>：在较理想的 SOA 设计中，可以考虑包装远程 service 访问逻辑，消费端自己主导定义接口和参数类型，并将调用转发给真正的 service 客户端生成代码，从而对它的使用者完全屏蔽了服务契约，这些使用者甚至不知道这个服务到底是远程提供的的还是本地提供的</li>
</ul>
<p>面向服务并不是用来取代传统的面向对象设计，而是引入一个额外的很薄的 SOA 层次来补充传统的面向对象设计，将面向对象应用或者其他遗留性应用加以包装和适配以帮助它们成为面向服务应用，其实就是面向对象的 service 提供端程序 + SOA 层（契约包装、契约）后形成真正的远程 service 提供端并发布，面向对象的 service 消费端程序 + SOA 层（契约包装、契约）后形成真正的远程 service 消费端并远程过程调用已发布的远程 service 提供端。</p>
<h2 id="2-2-微服务架构"><a href="#2-2-微服务架构" class="headerlink" title="2.2 微服务架构"></a>2.2 微服务架构</h2><p>微服务可以理解为 SOA 的传承，本质区别在于微服务是真正分布式的、去集中式、去中心化的，不再强调传统 SOA 架构中的 ESB 企业服务总线，是比 SOA 更彻底的拆分，通过有效地拆分应用，也更便于实现敏捷开发和部署，一些拆分方式比如按照业务功能进行拆分、按照应用类型进行拆分、按照技术体系进行拆分等，要注意的是应当根据拆分后的系统架构来重建人员组织架构，两者应当保持一致。</p>
<p>合理解耦的微服务架构可以独立地进行水平伸缩扩展，可以动态调整机器数量，并且不会陷入单个机器资源上限问题，这相对于传统架构中升级硬件资源这种垂直扩展具备更大的优势，微服务架构的复杂性在于</p>
<ul>
<li><strong>API Gateway</strong>：微服务一般在后台 N 个服务和前台之间有一个代理（又称 API Gateway），这个 API Gateway 提供统一的服务入口，聚合后台的服务，让微服务对前台透明，也提供安全、过滤、控流等 API 管理功能，不过 API Gateway 可能成为单点故障或者性能瓶颈</li>
<li><strong>服务间调用</strong>：单体应用中各个模块间的通信可以直接使用本地方法调用或通过内部事件发布机制，而当使用微服务架构时，每个服务都有自己独立的数据模型而不依赖于某个中心系统，服务间的通信必须通过网络远程调用，常用的方式是基于 HTTP 的 RESTful、RPC，而对于一些实时性要求不高，又耗时较长的通信场景，经常使用消息队列</li>
<li><strong>服务发现</strong>：微服务架构中的每个服务都有多个拷贝实例，每个服务实例随时都有可能下线，也随时会有新的服务实例上线，基本是通过 zookeeper 等类似技术做服务注册信息的分布式管理，当服务上线时，服务提供者将自己的服务信息注册到 zookeeper（或类似框架），并通过心跳维持长连接，实时更新连接信息，服务调用者通过 zookeeper 寻址找到一个服务，还可以将服务信息缓存在本地以提高性能，当服务下线时，zookeeper 会发通知给服务客户端</li>
<li><strong>服务容错</strong>：重试、限流、降级（本地缓存）、熔断、负载均衡（Ribbon、Nginx）</li>
<li><strong>服务部署</strong>：Container、Cloud、Docker、CI/CD、DevOps、K8S、ECS、Openshift</li>
<li><strong>服务监控</strong>：对服务调用链路进行追踪和监控，以及对服务性能进行评估和优化</li>
<li><strong>数据调用</strong>：使用数据持久层将业务中使用到的数据进行存储和管理，可以令应用层无状态化，便于应用层进行水平伸缩扩展和实现容错机制（关系型数据库不利于伸缩和业务扩展，利用 NoSQL 数据库可以得到更好的扩展性、可用性和性能）</li>
<li><strong>数据一致性</strong>：事件驱动模型被实践证明可以用于实现数据的最终一致性，事件驱动模型以订阅者-消费者形式进行应用程序各服务间的解耦，在各个应用不同数据系统的微服务组件之间共享事件流数据，核心就是将应用程序每一次状态变化当做一个事件记录下来，数据是通过一连串事件流存储起来的，数据库事务日志和版本控制就是应用事件驱动模型最出名的两个例子，此外还可以用于读写分离场景，提升读写性能</li>
<li><strong>可伸缩资源配置</strong>：Elastic Containe Service (ECS) 基于虚拟化技术，在云环境中提供了高可用的服务器计算资源，其中包括通用型、计算型、内存型、磁盘型等适用于各种不同应用场景需求的虚拟机实例（运行容器），用户可以根据需要选择，这种资源调整的灵活性和弹性很好的解决了微服务架构所面临的低成本资源伸缩的需求，此外，ECS 还提供了数据备份、安全控制、性能监控、海量日志数据分析和报警等一系列管理功能</li>
<li><strong>循环依赖</strong>：可以通过系统架构图或者调用链路追踪来确认是否存在服务系统间的循环依赖，循环依赖会导致流量放大、时延延长、级联故障、发布困难，一旦出现循环依赖就说明设计不合理，需要重新设计，比如将互相调用依赖改为异步消息消费、或者抽取共享库等方式来解耦依赖</li>
</ul>
<h2 id="2-3-单元化架构"><a href="#2-3-单元化架构" class="headerlink" title="2.3 单元化架构"></a>2.3 单元化架构</h2><p>单元是指一个能完成所有业务操作的自包含集合，这个集合中包含了所有业务所需的所有服务，以及分配给这个单元的数据。单元化架构就是把单元作为系统部署的基本单位</p>
<ul>
<li>部署的单元数目不定，分为多个单元和一个中心，任意一个单元都部署了系统所需的所有应用（是一整套业务），一次用户操作可以在一个单元内封闭执行完成，不需要跨单元执行，可以大大降低网络延迟</li>
<li>每个单元之间都是互相独立的，但是单个单元内的数据不是完整的，多个单元组合在一起才构成了完整的全量数据，全量数据就存放在中心上，也会有一部分用户会路由到中心进行业务操作</li>
<li>单元化架构可以非常方便地进行扩容，单元内部的快速扩容不会影响到其他单元，也可以直接增加更多的新的单元，多个单元可以天然地实现异地多活，具有很好的容灾性，用户访问时也可以根据就近原则来得到更快的响应</li>
<li>单元化需要全链路改造，在整个业务环节中，一旦有某个环节没有做单元化全链路改造，业务走到这个环节时就必须跨单元并路由到中心，进而导致更高的网络延迟，也给中心带来更高的流量负载</li>
<li>用户的路由需要更多的考虑，需要在路由到就近单元还是固定单元做权衡，需要确定路由指向的单元内有该用户的数据</li>
<li>单元化架构的成本很高，并且可能会衍生出强单元化、弱单元化、非单元化等链路，系统会变得更加复杂</li>
</ul>
<h2 id="2-4-三层架构"><a href="#2-4-三层架构" class="headerlink" title="2.4 三层架构"></a>2.4 三层架构</h2><p>三层架构是一种软件架构模式/代码分层结构，包含表示层、业务逻辑层、数据访问层，通常用于构建大型应用程序，如企业级应用或 Web 应用，目的在于将不同的关注点分离，以便实现更简单更易维护的应用，提供更好的可扩展性和重用性。</p>
<p>MVC 是一种设计模式，通常用于用户界面开发，重点在于用户界面和用户交互，而三层架构强调业务逻辑和数据处理，MVC 和三层架构并不是互斥的，可以结合使用，例如三层架构中的表示层就可以使用 MVC 来处理用户界面部分。</p>
<h2 id="2-5-康威定律"><a href="#2-5-康威定律" class="headerlink" title="2.5 康威定律"></a>2.5 康威定律</h2><blockquote>
<p>Organizations which design systems are constrained to produce designs which are copies of the communication structures of these organizations. - Melvin Conway (1967)</p>
<p>系统架构设计就是组织沟通方式的复制，企业的组织形式就决定了整个系统架构</p>
</blockquote>
<ul>
<li>第一定律<ul>
<li>Communication dictates design，组织沟通方式会通过系统设计表达出来</li>
<li>沟通的问题，会带来系统设计的问题，进而影响整个系统的开发效率和最终产品结果</li>
</ul>
</li>
<li>第二定律<ul>
<li>There is never enough time to do something right, but there is always enough time to do it over，时间再多一件事情也不可能做的完美，但总有时间做完一件事情</li>
<li>一个微服务组成的系统，每一个微服务都可能挂掉，这是常态，解决方法不是消灭问题，而是容忍问题并保证足够的冗余和备份，在问题发生时，能自动恢复即可，和持续集成、敏捷开发、弹性设计/高可用设计一个道理</li>
</ul>
</li>
<li>第三定律<ul>
<li>There is a homomorphism from the linear graph of a system to the linear graph of its design organization，线型系统和线型组织架构间有潜在的异质同态特性，想要什么样的系统，就搭建什么样的团队</li>
<li>微服务的团队理念是定义好系统的边界和接口，为一个系统去搭建一个团队，通过令团队内全栈自治，将沟通的成本维持在系统内部，每个子系统也会更加内聚，彼此的依赖耦合能变弱，降低跨系统的沟通成本</li>
</ul>
</li>
<li>第四定律<ul>
<li>The structures of large systems tend to disintegrate during development, qualitatively more so than with small systems，大的系统组织总是比小系统更倾向于分解，微服务就是一种分解结果</li>
</ul>
</li>
</ul>
<h1 id="3、分布式性能"><a href="#3、分布式性能" class="headerlink" title="3、分布式性能"></a>3、分布式性能</h1><h2 id="3-1-一致性"><a href="#3-1-一致性" class="headerlink" title="3.1 一致性"></a>3.1 一致性</h2><p>分布式系统中的一致性模型是一组管理分布式系统行为的规则，决定了分布式系统中如何访问和更新数据，以及如何将这些更新提供给客户端，分布式系统的一致性模型可大致分为</p>
<ul>
<li>强一致性模型：<ul>
<li>线性一致性：是最强的一致性模型，强调系统在任意时间点的读操作都返回最近的写操作的结果，客户端始终看到相同的数据视图，强调实时性和顺序性</li>
<li>顺序一致性：相较于线性一致性放宽了一些限制，系统维护一个全局的操作顺序，确保客户端看到的操作顺序都是一致性的，即不保证每个时间点所有客户单都具有相同的数据视图，但客户端读取到的一定是他最后一次更新的内容，只强调顺序性而不强调实时性</li>
</ul>
</li>
<li>弱一致性模型：允许系统在不同节点之间的数据访问之间存在一定程度的不一致，以换取更高的性能和可用性</li>
<li>最终一致性模型：是在最大程度上放宽了一致性要求，允许系统在发生分区或网络故障后一段时间达到最终一致性状态，也意味着系统会在一段时间内存在数据不一致的情况，既不强调实时性，也不强调顺序性，是弱一致性的特殊情况</li>
</ul>
<h2 id="3-2-稳定性"><a href="#3-2-稳定性" class="headerlink" title="3.2 稳定性"></a>3.2 稳定性</h2><p>限流、降级、熔断和预热是几种常用的系统稳定策略，在高并发和高负载场景下尤为重要</p>
<p>限流的目的是控制系统的并发流量，通过限制请求流量的速率或数量来防止过度流量击穿系统，一般用于应用突发流量高峰，一般发生在被调用方，但也可以发生在调用方。滑动窗口、漏桶、令牌桶都是限流算法。</p>
<p>降级是当系统过载时主动关闭一些非核心功能，以确保核心功能的正常运行，一般用于在系统资源有限或响应时间过长时，通过降低服务质量保障核心服务正常运行，可以发生在调用方或者被调用方。可通过自动开关或人工开关来控制某些功能降级。</p>
<p>熔断是在检测到下游服务异常时，自动停止向该服务发送请求，并在一定时间后尝试恢复，这是为了防止系统因某个服务的故障而整体崩溃，一般发生在调用方。</p>
<p>预热一般指缓存预热，是在系统启动之前或者系统达到高峰之前预先将常用数据加载到缓存中，以提高缓存命中率和系统性能，平滑流量峰值，定期预热可以保证缓存数据的时效性，避免缓存击穿和缓存雪崩（缓存为空的启动称为冷启动，冷启动可能导致首次请求处理缓慢）。</p>
<h2 id="3-3-CAP-理论"><a href="#3-3-CAP-理论" class="headerlink" title="3.3 CAP 理论"></a>3.3 CAP 理论</h2><blockquote>
<p>一个分布式系统最多只能满足一致性、可用性和分区容错性这三项中的两项</p>
</blockquote>
<p>一致性（Consistency）：每次读取都会收到最新的写入数据或错误信息（是强一致性）</p>
<p>可用性（Availability）：每个请求都是收到非错误性的正常响应（但不能保证响应包含最新的写入数据），一般用停机时间来衡量</p>
<p>分区容错性（Partition Tolerance）：尽管某些节点或网络分区出现故障，网络节点之间丢弃或延迟任意数量的消息，但系统仍能够继续运行</p>
<p>其实 CAP 三者之间，P 是基本要求，目标是在 C 和 A 两者之间做权衡并尽可能提升 P。支付宝等涉及金钱的业务以及很多分布式数据库都是设计成 CP 而舍弃 A 的，淘宝、12306 等业务系统都是设计成 AP 而舍弃 C 的（舍弃的是强一致性，最终一致性肯定是必须要满足的）。</p>
<p>网络分区故障是指网络被划分为两个或多个互不通信的区域，这种故障是不可避免的，那么针对 P 这一基本要求，可以采取一下措施来减少网络分区故障的发生频率，并在网络分区故障发生后减轻其对系统的影响</p>
<ul>
<li>在关键的网络节点之间使用多条冗余的物理连接，以避免单点故障及单个连接故障</li>
<li>使用高性能的路由器和链路交换机，减少硬件故障的概率</li>
<li>持续监控网络的状态，包括流量、延迟、丢包率等</li>
<li>设置自动警报机制，在检测到网络异常时及时通知</li>
<li>系统设计时就要考虑到网络分区的情况，并设置应对策略来确保系统可以在网络分区期间系统提供服务</li>
</ul>
<h2 id="4-4-BASE-理论"><a href="#4-4-BASE-理论" class="headerlink" title="4.4 BASE 理论"></a>4.4 BASE 理论</h2><p>基本可用（Basically Available）：出现故障允许损失部分可用性，保证核心可用，比如使用降级和熔断策略</p>
<p>软状态（Soft State）：允许系统存在中间状态，该中间状态不会影响系统整体可用性，比如使用重试机制，重试过程中一直处于中间状态</p>
<p>最终一致性（Eventual Consistency）：即使无法做到强一致性，但应用可以采用合适的方式达到最终一致性</p>
<p>BASE 理论是对 CAP 理论的延伸，支持大型分布式系统，和 ACID 是完全相反的设计哲学。</p>
<h1 id="4、分布式事务"><a href="#4、分布式事务" class="headerlink" title="4、分布式事务"></a>4、分布式事务</h1><h2 id="4-1-XA-规范"><a href="#4-1-XA-规范" class="headerlink" title="4.1 XA 规范"></a>4.1 XA 规范</h2><p>分布式事务指在分布式系统重涉及到多个数据库或多个应用程序之间的事务处理，这些数据库或应用程序可能分布在不同的物理节点上，需要确保所有参与者的事务操作都能够保持一致性，即所有参与者的事务要么全部提交成功，要么全部回滚。</p>
<p>X/Open 组织定义了分布式事务处理模型，模型中主要包括应用程序 AP、事务管理器 TM、资源管理器 RM、通信资源管理器 CRM 等四个角色。常见的 TM 是交易中间件，常见的 RM 是数据库，常见的 CRM 是消息中间件。通常把一个数据库内部的事务处理看作为本地事务，分布式事务处理的对象则不是一个数据库内部的本地事务，而是可能涉及多个数据库的全局事务。</p>
<p>XA 规范就是 X/Open DTP 定义的交易中间件和数据库之间的接口规范（由数据库厂商提供的实现），交易中间件用它来通知数据库事务的开始、结束、提交以及回滚等</p>
<h2 id="4-2-柔性事务"><a href="#4-2-柔性事务" class="headerlink" title="4.2 柔性事务"></a>4.2 柔性事务</h2><p>柔性事务是相较于数据库本地事务的 ACID 特性来说的，不同于完全遵循 ACID 的刚性事务，柔性事务只是部分遵循 ACID（严格遵守原子性和持久性，一致性被放宽为最终一致性，事务的中间可见性被放宽，仅保证并行事务间不可互相影响），保证的是基本可用，最终一致，其实也就是基于 BASE 理论的事务。</p>
<p>要实现柔性事务，应当满足一些基础条件</p>
<ul>
<li><p>全局性，每一个服务的每一次调用都需要有一个全局唯一的标识 ID 以及完整的操作时间信息记录</p>
</li>
<li><p>幂等性，指使用相同参数重复执行可以获得相同结果的函数，一个幂等操作多次重复执行所产生的影响与执行一次产生的影响是相同的（不保证幂等的操作无法重试）</p>
</li>
<li><p>可补偿，操作的可补偿对应分布式事务的可回滚，补偿操作也需要满足幂等性</p>
</li>
</ul>
<h2 id="4-3-2PC-和-3PC"><a href="#4-3-2PC-和-3PC" class="headerlink" title="4.3 2PC 和 3PC"></a>4.3 2PC 和 3PC</h2><p>Two-Phase-Commit (2PC) 和 Three-Phase-Commit (3PC) 都是根据 XA 规范衍生出来的，是实现 XA 分布式事务的关键。</p>
<p>2PC 的第一阶段是准备阶段/投票阶段，第二阶段是提交阶段/执行阶段，整个步骤可以概括为参与者将操作失败通知协调者，再由协调者根据所有参与者的反馈情报决定各参与者是否要提交操作还是中止操作。</p>
<p>2PC 在提交和回滚阶段需要协调者和参与者之间进行多次通信，这个事务处理过程较为复杂，需要处理网络、节点故障等异常情况，异常处理复杂度很高，存在同步阻塞问题、单点故障问题、（协调者和参与者都宕机时可能会出现）数据不一致问题等。</p>
<p>3PC 是将 2PC 的第一阶段继续一分为二，从而组成了三阶段提交，3PC 的第一阶段只是询问所有参与者是否可以执行事务操作，并不在本阶段执行事务操作（不锁定资源），当协调者收到所有参与者都返回肯定之后，在第二阶段才执行事务操作，然后在第三阶段执行提交或回滚。</p>
<p>3PC 解决了 2PC 在协调者和参与者都宕机时可能会出现的数据不一致问题，但依旧存在网络原因导致的数据不一致问题，<a href="https://www.yuque.com/hollis666/niq4hm/du7xnm">参考</a>。</p>
<h2 id="4-4-TCC"><a href="#4-4-TCC" class="headerlink" title="4.4 TCC"></a>4.4 TCC</h2><p>Try-Confirm-Cancel (TCC) 采用了基于业务逻辑的补偿机制，将整个分布式事务分解为若干个子事务，每个子事务都有 try、confirm、cancel 三个分段操作，通过这些操作以及事务协调器来实现分布式事务的执行和回滚。</p>
<ul>
<li>Try 阶段：参与者尝试执行本地事务，并对全局事务预留资源，每个执行 Try 阶段的参与者都会返回一个成功/失败标识</li>
<li>Confirm 阶段：如果所有参与者的 Try 阶段都执行成功，则协调者通知所有参与者在本地提交事务并释放全局事务资源，如果有参与者在 Confirm 阶段执行失败，则需要执行 Cancel 操作并将之前预留的资源释放掉</li>
<li>Cancel 阶段：如果任何一个参与者在 Try 阶段执行失败，则协调者通知所有参与者在本地回滚事务并释放全局事务资源，如果 有参与者在 Cancel 阶段失败了，可以尝试记录日志、发送警报、自动重试、人工干预等手段</li>
</ul>
<p>TCC 无需太多的网络通信，异常处理相对简单，既可以实现强一致性又可以最终一致性要求，能够根据业务逻辑实现精细的事务控制，适用于不同类型的业务场景，通过分布式锁来保证分布式事务的一致性和可用性，支持横向扩展，具备比 2PC 更好的性能，可以适应更多的并发访问和业务场景。</p>
<p>TCC 实现复杂，每个操作都需要实现正确的业务逻辑和补偿机制，代码实现比较复杂，存在代码入侵问题、悬挂事务问题（整体先 try 后 cancel 的流程可能由于网络延迟导致部分参与者接收到的是先 cancel 再 try，而这种参与者后续 try 所占用的资源则无法释放）、空回滚问题（Try 阶段本来就执行失败的参与者由于存在其他子事务失败而依旧需要执行 Cancel 进行空回滚）。</p>
<p>通过引入分布式事务记录表可以解决悬挂事务和空回滚问题，每个参与者都可以在本地事务执行的过程中同时记录一次分布式事务的操作记录。</p>
<h2 id="4-5-MQ"><a href="#4-5-MQ" class="headerlink" title="4.5 MQ"></a>4.5 MQ</h2><p>基于 MQ 实现的分布式事务可以分为</p>
<ul>
<li>可靠消息<ul>
<li>大致流程是：事务的发起方执行本地事务，事务的发起方向事务参与方发送 MQ 消息，事务的参与方接收到 MQ 消息后执行自己的本地事务</li>
<li>MQ 消息会可能会由于网络等原因导致丢失，一般通过本地消息表（本地事务 + 重试）或事务消息（MQ 自身的事务消息机制，也用到了重试）来保证消息可靠（两种方案可以互相替换），即消息一定被消费</li>
<li>本地消息表：将分布式事务拆分为本地事务和消息事务，本地事务在本地数据库中进行提交或者回滚，消息事务作为消息被写入到消息中间件中，写入消息操作是本地事务的一部分，事务的原子性可以确保本地操作成功则写消息也一定成功，此外还需要一个定时任务对本地消息表进行轮询（负责重试）</li>
<li>事务消息：要求 MQ 本身支持事务消息机制，对业务代码有侵入性，原本只需要发送一次的消息改成发送两次 half 消息，还需要提给 MQ 提供一个反查的接口</li>
<li>基于本地消息表和事务的消息消费的可靠性较高，可扩展性好，适用范围广，但实现复杂度高，需要设计复杂的事务协议和消息发送机制，需要设计相应的异常处理和补偿机制，本地消息表和事务也会带来额外的存储开销和网络通信成本，可能会影响系统性能，甚至出现消息堆积</li>
</ul>
</li>
<li>最大努力通知<ul>
<li>一般只是单纯依赖重试机制来尽最大努力通知分布式事务的参与者，需要注意这种机制既可能出现消息重复发送，也可能出现消息丢失</li>
<li>需要根据实际业务需求和风险承受能力来确定最大努力通知的策略、消息去重方式以及重试次数，针对消息丢失的情况，一般业务中会有延时的对账机制（可能会有人工介入）来进行兜底</li>
</ul>
</li>
</ul>
<p>如果业务只需要保证最终一致性则以上三种方案都可以，若业务可以接受丢消息，则首选最大努力通知方案，若业务要求可靠消息，则排除最大努力通知方案，接着分析若 MQ 支持事务消息，则首选事务消息方案，若 MQ 不支持事务消息，则首选本地消息表方案。</p>
<h2 id="4-6-Seata"><a href="#4-6-Seata" class="headerlink" title="4.6 Seata"></a>4.6 Seata</h2><p>Seata 是阿里开源的分布式事务框架，定义了以下三种类型的组件</p>
<ul>
<li>Transaction Coordinator (TC)，是一个独立的 JVM 进程，不包含任何业务代码，负责维护整个分布式事务的全局状态，负责通知 RM 执行回滚或提交</li>
<li>Transaction Manager (TM)，指一个聚合服务（即将不同微服务组合起来构成一个业务流程），负责开启或提交或回滚一个全局事务</li>
<li>Resource Manager (RM)，指具体的微服务，负责执行每个事务分支操作</li>
</ul>
<p>Seata 支持以下四种模式</p>
<ul>
<li><p>XA 模式，可以保证强一致性，实现完全隔离，无代码入侵，性能较差，适用于一致性和隔离性要求较高的场景</p>
</li>
<li><p>AT 模式，只能保证弱一致性，可以实现基于全局锁隔离，无代码入侵，性能较好，适用于基于关系型数据库的大多数分布式事务场景</p>
</li>
<li><p>TCC 模式，只能保证弱一致性，可以实现基于资源预留隔离，存在代码入侵（需要编写 TCC 三个接口），性能非常好，适用于对性能要求高的，存在非关系型数据库参与事务的场景</p>
</li>
<li><p>Saga 模式，只能保证最终一致性，无隔离，存在代码入侵（需要编写状态机以及补偿代码），性能非常好，适用于业务流程长且多，参与者包含外部接口或者遗留接口，无法做 TCC 模式的场景</p>
</li>
</ul>
<h2 id="4-7-方案选择"><a href="#4-7-方案选择" class="headerlink" title="4.7 方案选择"></a>4.7 方案选择</h2><p>如果需要实现强一致性则必须要引入一个协调者，通过协调者来协调所有参与者进行提交或者回滚，这类方案包括 TCC 、基于 XA 规范的二阶段提交（2PC）、三阶段提交（3PC）、Seata 等。如果只要求实现最终一致性，那么方案就可以更简单一些，这类方案包括 TCC 、基于可靠消息（本地消息、事务消息）、最大努力通知、Seata 等。应该以实际业务情况为依据来做选择</p>
<ul>
<li>依据项目开发和维护的难度：TCC 和 2PC 的实现成本最高，业务侵入性也比较大</li>
<li>依据一致性要求：2PC 可以保证强一致性的，TCC 既可以保证强一致性也可以保证最终一致性，其他方案是最终一致性方案</li>
<li>依据可用性要求：对于需要保证高可用性的业务，就无法保证强一致性，只能选择最终一致性方案</li>
<li>依据数据规模：消息中间件不合适业务数据量很大的场景，有可能出现严重的消息堆积，此时可以考虑 Seata 这种分布式事务框架</li>
</ul>
<h1 id="5、其他应用"><a href="#5、其他应用" class="headerlink" title="5、其他应用"></a>5、其他应用</h1><h2 id="5-1-分布式锁"><a href="#5-1-分布式锁" class="headerlink" title="5.1 分布式锁"></a>5.1 分布式锁</h2><p>普通的锁主要用于单机环境，用于控制同一 JVM 进程中多个线程对共享资源的互斥访问，而分布式锁则用于分布式环境，协调多个计算机或多个进程之间对共享资源的全局互斥访问，确保分布式系统的一致性</p>
<ul>
<li><p>分布式锁应当保证在分布式部署的应用集群中，同一个方法在同一时间只能被一台机器上的一个线程执行，应当是可重入的、高可用、高性能的互斥锁</p>
</li>
<li><p>分布式环境中的网络延迟、节点故障等会使得死锁出现的概率更高，因此分布式锁一般都会设置一定的超时机制和死锁检测策略</p>
</li>
<li><p>分布式锁根据加锁失败后是否阻塞持续自旋加锁（业务需要）应当可以设置为阻塞或非阻塞，一般非阻塞锁用的更多一些</p>
</li>
</ul>
<p>分布式锁的实现一般有如下方式</p>
<ul>
<li><p>基于数据库</p>
<ul>
<li>创建一张专门的锁表，通过在该表中增加记录来标识锁住某个资源，通过删除该记录来标识释放某个资源</li>
<li>这种分布式锁会高度依赖数据库的可用性，存在单点故障，此外还需要额外通过某种定时任务来实现锁的超时失效，需要额外通过程序不断重试 INSERT 来实现获取锁的阻塞等，或者也可以直接使用数据库自带的排他锁，但是使用排它行锁的前提是使用了索引，可是否使用索引又取决于优化器而不是 SQL</li>
</ul>
</li>
<li><p>基于缓存</p>
<ul>
<li>基于分布式缓存的分布式锁性能较好，不存在单点故障，常见的是基于 Redis 实现的一种非常高效的非阻塞互斥锁，详细参见 <a href="../../../../2024/02/18/redis/">Redis</a> 的 4.3 小节</li>
</ul>
</li>
<li><p>基于协调服务</p>
<ul>
<li>基于分布式协调服务的分布式锁性能差于缓存，不存在单点故障，详细参见 <a href="../../../../2024/02/24/zookeeper/">Zookeeper</a></li>
</ul>
</li>
</ul>
<h2 id="5-2-分布式-ID"><a href="#5-2-分布式-ID" class="headerlink" title="5.2 分布式 ID"></a>5.2 分布式 ID</h2><p>分布式 ID 需要保证全局唯一，高性能、高可能，保证 ID 的生成是稳定且高效的，有的业务可能会要求生成的 ID 呈递增趋势</p>
<ul>
<li><p>UUID，性能比较高，不依赖网络，本地即可生成，使用简单，但是长度过长，且没有任何含义</p>
</li>
<li><p>数据库自增 ID，仅在单库单表中才能保证 ID 自增且不重复，此外高并发访问时还会引起阻塞问题，也存在数据库单点故障问题</p>
</li>
<li><p>号段模式，每次去数据库中取 ID 时会取出一批放在缓存中，下一次生成新 ID 时就直接去缓存中取，给每个客户端发送的 ID 号按号段分开，从而防止冲突，同一个客户端在自己的号段中生成的 ID 是递增的，也不需要频繁地访问数据库，性能较好，但无法保证全局递增，也存在数据库单点故障问题</p>
</li>
<li><p>Redis，可以依赖 Redis 的 incr 命令实现 ID 的原子性自增，可以借助集群解决单点故障问题，基于内存的性能也较好，但存在数据丢失问题</p>
</li>
<li><p>雪花算法</p>
<ul>
<li>核心思想是将一个 64 位的 ID 划分成符号位、时间戳、数据中心表示、机器标识、序列号等多个不同含义的部分，业务可以根据自定义的含义来识别 ID 所对应的一些信息，可以轻松的生成大量自增 ID，生成时不依赖数据库，完全在内存中生成，具备高可用、高性能、高吞吐</li>
<li>需要依赖 Zookeeper 来协调各个节点的 ID 生成，而 Zookeeper 本身也可能成为系统瓶颈</li>
<li>需要依赖系统时间一致性，如果系统时间被回拨或者不一致，就可能出现重复 ID（这就是时钟回拨问题），或者直接抛出异常拒绝 ID 生成请求</li>
</ul>
</li>
</ul>
<p>可以直接使用分布式 ID 来为分布式资源命名，命名服务是为了对资源更好地进行定位，资源包括但不限于计算机名、计算机地址、应用地址、远程对象等，JNDI，Java 命名和目录接口（Java Naming and Directory Interface, JNDI）规范是一种 Java 的命名服务。</p>
<h2 id="5-3-分布式-Session"><a href="#5-3-分布式-Session" class="headerlink" title="5.3 分布式 Session"></a>5.3 分布式 Session</h2><p>当用户连续多次请求路由到服务集群中的不同的机器时，需要一个分布式 Session 来提供用户首次请求时的登录信息</p>
<ul>
<li><p>客户端存储，将 Session 信息保存在客户端中，存在安全风险</p>
</li>
<li><p>分布式存储，将 Session 信息保存在分布式存储系统（如分布式文件系统、分布式数据库等）中，服务集群共享该分布式存储，通过 Session ID 查找对应的 Session 数据</p>
</li>
<li><p>粘性 Session，将来自同一个用户的请求固定路由到指定的机器上，只需在该机器中保存该用户的 Session 即可，可能存在单点故障问题</p>
</li>
<li><p>Session 复制，当用户在某个机器上产生 Session 后，将该 Session 信息复制到其他机器中，可能存在延迟问题</p>
</li>
</ul>
<h2 id="5-4-分布式数据库"><a href="#5-4-分布式数据库" class="headerlink" title="5.4 分布式数据库"></a>5.4 分布式数据库</h2><p>与传统关系型数据库相比，分布式数据库在亿级别以下性能略逊色，而在亿级别以上性能更高，完全支持云原生，通过副本冗余的方式提升整个集群可靠性，可以近乎无限地进行水平扩展，但无法严格且完全地实现真正意义上的 ACID，事务隔离级别弱，不支持单机部署，基本不适合小业务量的应用。</p>
<h1 id="6、相关技术"><a href="#6、相关技术" class="headerlink" title="6、相关技术"></a>6、相关技术</h1><h2 id="6-1-一致性哈希"><a href="#6-1-一致性哈希" class="headerlink" title="6.1 一致性哈希"></a>6.1 一致性哈希</h2><p>一致性哈希是一种用于分布式系统中数据分片和负载均衡的算法，目标是在节点动态增加或删除时，尽可能地减少数据迁移和重新分布的成本</p>
<ul>
<li><p>一致性哈希算法首先构造一个哈希环，将哈希环划分为固定数量的虚拟节点，分布式系统中的每一个节点在哈希环上都有一个对应的虚拟节点</p>
</li>
<li><p>当有数据需要存储时首先计算数据的哈希值，然后顺时针或者逆时针在哈希环上找到最近的虚拟节点，就可以得到该数据应当存放的节点</p>
</li>
<li><p>当需要增加或删除节点时，只有少量的数据需要迁移，大部分数据不会受到影响</p>
</li>
<li><p>当节点较少时，节点的分布可能不够均匀，这会导致数据倾斜，进而导致节点变化时的数据迁移成本可能会很高，可能通过将一个节点映射为多个虚拟节点来将数据分散的更加均匀一些</p>
</li>
</ul>
<h2 id="6-2-负载均衡"><a href="#6-2-负载均衡" class="headerlink" title="6.2 负载均衡"></a>6.2 负载均衡</h2><p>负载均衡负责将负载（工作任务，访问请求）平衡地分摊到多个操作单元（服务器，组件）上执行，是解决高性能，高可用，水平伸缩的终极解决方案。负载均衡技术可用于 OSI 七层模型中的不同层次，可以根据负载均衡技术所在的层级将其称为 x 层负载均衡，常用的层级如下</p>
<ul>
<li>七层负载均衡，负载均衡器在接收到请求后，通过修改数据包的地址信息（IP + 端口号）将流量转发到应用服务器，此外，还可以根据 URL、浏览器类别、语言等信息来决定是否进行负载均衡，Nginx 和 HAProxy 都常用于七层负载均衡</li>
<li>四层负载均衡，负载均衡器在接收到请求后，通过修改数据包的地址信息（IP + 端口号）将流量转发到应用服务器，LVS (Linux Virtual Server) 是一个常用于四层负载均衡的软件</li>
<li>三层负载均衡，负载均衡器对外一个虚 IP，集群中不同的机器采用不同的 IP 地址，当负载均衡器接收到请求之后，根据不同的负载均衡算法，将请求转发至 IP 不同的真实服务器</li>
<li>二层负载均衡，负载均衡器对外提供一个虚 IP，集群中不同的机器采用相同的 IP 地址（但 MAC 地址不同），当负载均衡器接收到请求之后，通过改写报文的目标 MAC 地址来将请求转发到目标机器实现负载均衡</li>
</ul>
<p>负载均衡器的核心是负载均衡算法，负载均衡算法可分为静态负载均衡（轮询、比率、优先权）和动态负载均衡（最少连接数、最快响应速度、观察模式、预测模式、动态性能分配、动态服务器补充、服务质量、服务类型、规则模式）</p>
<ul>
<li>轮询，顺序循环将请求依次顺序循环地连接每个服务器</li>
<li>比率，给每个服务器分配一个加权值为比例，根据这个比例将请求分配到每个服务器</li>
<li>优先权，给所有服务器分组，给每个分组定义优先权，请求分配给优先权最高的服务器组（同一组内使用轮询或比率），当最高优先级中的所有服务器出现故障时，请求才会被分配到次优先级的服务组</li>
<li>最少连接数，将请求连接到那些进行最少连接处理的服务器</li>
<li>最快响应速度，将请求连接到那些响应最快的服务器</li>
<li>观察模式，以连接数目和响应时间的最佳平衡为依据来选择服务器</li>
<li>预测模式，利用收集到服务器当前性能，进行预测分析，选择一台可以在下一个时间片内令性能达到最佳的服务器</li>
<li>动态性能分配，根据收集到应用程序和应用服务器的各项性能参数来动态调整流量分配</li>
<li>动态服务器补充，当主服务器集群中因故障导致可用机器数量减少时，动态地将备份服务器补充至主服务器集群</li>
<li>服务质量，按不同的优先级对数据流进行分配</li>
<li>服务类型，按不同的服务类型对数据流进行分配</li>
<li>规则模式，针对不同的数据流设置导向规则</li>
</ul>
<h2 id="6-3-冷备、热备、暖备"><a href="#6-3-冷备、热备、暖备" class="headerlink" title="6.3 冷备、热备、暖备"></a>6.3 冷备、热备、暖备</h2><p>冷备、热备、暖备表示备份和恢复方案的不同类型和不同级别</p>
<ul>
<li><p>冷备是指在关闭系统服务后将数据备份到离线介质中的一种备份方式，恢复时需要将备份和数据还原到系统中并启动系统，在备份和恢复过程中，系统服务不可用，恢复时间长，成本相对较低（一般是在系统低峰期使用）</p>
</li>
<li><p>热备是指在系统服务运行期间对数据进行备份的一种备份方式，在备份过程中，系统仍然可以提供服务，热备的恢复时间相对较短，但需要额外的资源来支持备份和恢复，成本相对较高（数据库的主从同步就是热备的一种实现）</p>
</li>
<li><p>暖备是介于冷备和热备之间的备份方式，备份数据和原始数据之间的同步是定期进行的，数据备份与恢复的时间通常比热备长，但比冷备短，这是因为需要将备份数据还原到原来的位置并进行一些必要的同步操作（一般是在应用的特定功能模块关闭或限制访问的情况下进行备份）</p>
</li>
</ul>
<p>如果数据要求高可用和实时性，应该采用热备；如果数据要求高一致，但可用性和实时性要求较低，可以采用暖备，如果数据没啥要求，可以采用冷备，应该根据具体的业务需求和资源限制来进行综合考虑。</p>
<h2 id="6-4-异地多活-同城容灾"><a href="#6-4-异地多活-同城容灾" class="headerlink" title="6.4 异地多活/同城容灾"></a>6.4 异地多活/同城容灾</h2><p>异地多活可以让多个数据中心在不同地理位置提供相同的服务，每个数据中心都具有可以提供服务的完整的应用程序和数据副本，多个数据中心通过高速网络连接进行数据同步和负载均衡，能够实现数据实时同步和故障切换，通常用于在全球范围内提供高可用性和低延迟的应用程序，通常需要采用分布式数据库、消息队列、负载均衡器、DNS 解析等技术支持。</p>
<p>同城容灾相比于异地多活更加适用于数据中心距离较近的情况，可以通过复制、镜像、数据同步等技术来实现数据的备份和容灾，可以提供低延迟和高带宽的网络连接，以支持高吞吐量、高可用、高可靠的应用程序。</p>
<h2 id="6-5-链路追踪"><a href="#6-5-链路追踪" class="headerlink" title="6.5 链路追踪"></a>6.5 链路追踪</h2><p>在微服务架构中，一次业务请求一般要经过几个微服务调用才能完成，需要在请求入口处生成一个全局唯一的 traceId 并在该请求所经历的所有系统中始终把这个 traceId 传下去（一般会放在 RPC 的请求头、HTTP 的请求头、MQ 消息的消息头中），从而实现全链路追踪。</p>
<p>每一次调用中的重要信息被记录在 span 中，一个完整的 span 通常具有如下属性</p>
<ul>
<li><p>Operation Name：描述当前接口的行为语义，比如具体是哪个接口，哪个 URL 地址</p>
</li>
<li><p>SpanId/ParentSpanId：接口调用的层级标识，用于还原 Trace 内部的层次调用关系</p>
</li>
<li><p>Start/FinishTime：接口调用的开始和结束时间</p>
</li>
<li><p>StatusCode：响应状态，标识当前调用结果</p>
</li>
<li><p>Tags/Events：调用附加信息</p>
</li>
</ul>
<h2 id="6-6-全链路压测"><a href="#6-6-全链路压测" class="headerlink" title="6.6 全链路压测"></a>6.6 全链路压测</h2><p>压测是一种常见的性能评估手段，可以帮助发现系统瓶颈以及系统整体水位，但需要注意做好流量识别和数据隔离，流量识别是指需要区分出真正参与压测的流量，数据隔离是指将压测过程中产生的写数据和真实的业务数据隔离开。常用的压测工具包括 <a href="../../2023/02/11/jmeter/">Apache JMeter</a>、Apache Bench 等，可以帮助自动化执行压测脚本，提供详细的测试报告和性能分析。</p>
<p>在分布式场景中，一个业务流程涉及到上下游太多太复杂，单链路压测时往往只关注单个系统，不可避免地会忽略掉一些资源竞争及外部干扰，只有在全链路压测中才能真正地暴露出真实环境中的各种问题。全链路压测可以从网络到 Nginx 反向代理、应用服务器、系统间依赖、数据库、缓存、磁盘等全方位地找出系统瓶颈。常用的全链路压测工具有 Takin、Quake、Rhino、ForceBot。</p>
<h2 id="6-7-限流算法"><a href="#6-7-限流算法" class="headerlink" title="6.7 限流算法"></a>6.7 限流算法</h2><ul>
<li>漏桶<ul>
<li>系统请求先进入漏桶，桶的容量是固定的，底部会以一个固定的速率把桶内请求流出并执行，请求的执行速率就是流出速率，是固定不变的，超过流出速率的请求将无法及时被执行，当桶满时，请求将被拒绝或延迟处理</li>
<li>适用于需要限制数据的平均传输速率并确保数据传输平滑性的场景，无法应对突发流量</li>
</ul>
</li>
<li>令牌桶<ul>
<li>系统请求会得到一个令牌，令牌会进入令牌桶，桶内有请求令牌时就会从令牌桶中取出令牌并执行，桶内没有令牌时就阻塞</li>
<li>令牌桶与漏桶的区别在于令牌桶的底部不是漏的，不会以固定的速率流出令牌，只会以固定的速率向桶中添加令牌（会控制令牌桶中的令牌数量），请求执行并不受限于某个固定速率</li>
<li>令牌桶较漏桶更加灵活，既适用于需要限制数据的平均传输速率的场景，又允许一定程度的突发流量</li>
</ul>
</li>
<li>令牌环<ul>
<li>与令牌桶类似，但是会在多个令牌桶之间形成环形结构，以便在不同的请求处理速率之间进行平衡</li>
</ul>
</li>
<li>滑动窗口<ul>
<li>基于一个固定大小的时间窗口，该窗口内的请求数若不超过设定的阈值则允许执行，超出阈值的请求则被拒绝或进入等待队列或执行其他限流操作，窗口随着时间的推移不断滑动，以适应不同时间段内的请求流量</li>
<li>可以在一段时间内平滑地控制流量，而不是简单地设置固定的请求数或速率，可以更加灵活地应对突发流量或峰值流量，不会因为固定速率的限制而浪费资源或降低系统性能</li>
</ul>
</li>
</ul>
<h2 id="6-8-分区分表分库"><a href="#6-8-分区分表分库" class="headerlink" title="6.8 分区分表分库"></a>6.8 分区分表分库</h2><ul>
<li>分区<ul>
<li>当数据规模增大使得单个读写性能变差时，可以考虑表分区，分区后的表依旧是一张表，表名不变，只是数据被保存在不同的位置，数据库会自己去阻止各个分区的数据</li>
<li>水平分区是将表根据行划分成多个分区表，垂直分区是将表根据字段划分成多个数据表，每个数据表用于存储不同业务场景的数据，MySQL 支持的分区类型是水平分区</li>
<li>常见的分区原则有：按照系统负载分区、按照应用程序查询模型分区、按照时间分区、按照哈希值分区、按照范围查询的范围分区</li>
</ul>
</li>
<li>分表<ul>
<li>在数据量规模很大，即便使用了分区，单个读写性能依旧成为瓶颈时，就需要考虑分表，不同于分区，分表使得原本的一张表变为多张表，数据库操作时需要指定具体的表名，比分区更加复杂</li>
<li>分表后单表的数据量小，页缓存率更高，I/O 读写性能更优，锁阻塞更少，事务、备份以及恢复的处理效率更高，具有更高的横向扩展性，分表可以在分区的基础上进一步减少查询时的系统开销</li>
<li>一般是单表行数超过 500 万行或者单表容量超过 2 GB 之后，才需要考虑分表，否则建议通过其他优化手段来解决性能问题，分表时需要根据实际业务情况慎重选择分表字段（shardingKey），注意避免数据倾斜（有的表数据量很大，有的表数据量很小）</li>
<li>选择了分表字段后就可以根据分表算法来准确地将数据分到某一张表中，分表字段取值相同的数据都在同一张表上（不是给分表字段的每个取值都单独分配一张表，取值和表是多对一映射），常见的分表算法有直接取模、hash 取模、自定义映射、一致性 hash（可以解决分表还是表太大，需要二次分表时的数据迁移问题）等</li>
</ul>
</li>
<li>分库<ul>
<li>在高并发情况下，有限的数据库连接数可能会成为瓶颈，当数据库的读写 QPS 过高导致数据库连接数不足时，就需要考虑分库来提供更多可用的数据库连接</li>
<li>比如把各个业务线数据分别放到单独的数据库中（纵向拆分），将历史数据放到单独的历史库中（横向拆分）等等</li>
</ul>
</li>
<li>分库和分表<ul>
<li>当既存在数据库连接不够，又存在单个读写本身就很慢的情况时，就需要既分库又分表了</li>
</ul>
</li>
</ul>
<p>分库分表导致的问题如下</p>
<ul>
<li>分表后多张单表的自增键会发生冲突，不具备全局唯一性，无法作为唯一主键，常见的全局唯一 ID 方案可参见 5.2 小节</li>
<li>读写操作需要明确指定库名表名，不指定就需要全表扫描多个物理表，</li>
<li>分库后跨库事务需要使用分布式事务，分库分表后也无法跨库跨表使用排序和分页</li>
</ul>
<p>分库分表框架如下</p>
<ul>
<li>ShardingSphere<ul>
<li>是轻量级的 Java 框架，在 Java 和 JDBC 层提供额外服务，使用客户端直连数据库，以 jar 包形式提供服务，无需额外部署和依赖，可以理解为增强版的 JDBC 驱动，兼容 JDBC 和各种 ORM 框架</li>
</ul>
</li>
<li>TDDL<ul>
<li>TDDL 是淘宝开源的一个用于访问数据库的中间件，集成了分库分表，读写分离，权重调配，动态数据源配置等功能，封装 JDBC 的 DataSource 给用户提供统一的基于客户端的使用</li>
</ul>
</li>
<li>Mycat<ul>
<li>Mycat 是分布式关系型数据库中间件，支持分布式 SQL 查询，兼容 MySQL 通信协议，以 Java 生态支持多种后端数据库，通过数据分片提供数据查询处理能力</li>
</ul>
</li>
</ul>
<h1 id="7、参考资料"><a href="#7、参考资料" class="headerlink" title="7、参考资料"></a>7、参考资料</h1><ul>
<li><a href="https://www.infoq.cn/article/micro-soa-1">https://www.infoq.cn/article/micro-soa-1</a></li>
<li><a href="https://www.infoq.cn/news/micro-soa-2">https://www.infoq.cn/news/micro-soa-2</a></li>
<li><a href="https://developer.aliyun.com/article/2764">https://developer.aliyun.com/article/2764</a></li>
<li><a href="https://developer.aliyun.com/article/8611">https://developer.aliyun.com/article/8611</a></li>
</ul>
]]></content>
  </entry>
  <entry>
    <title>Docker</title>
    <url>/2022/09/06/docker/</url>
    <content><![CDATA[<h1 id="英文版"><a href="#英文版" class="headerlink" title="英文版"></a><a href="../../../../2023/09/01/week-53/">英文版</a></h1><h1 id="问题与解决"><a href="#问题与解决" class="headerlink" title="问题与解决"></a>问题与解决</h1><p><strong>容器</strong>：应用可以被部署并运行在 VM 上，但是考虑到 VM 需要使用过多的硬件资源来运行一整套操作系统（是对硬件的封装隔离），而容器则仅包含一些应用运行所必要的软件和配置来运行一个进程（是对进程的封装隔离），实现了比 VM 更宽松的隔离特性，更加充分的硬件资源利用以及更快速轻量的应用运行环境，应用在容器中的运行性能接近于在物理平台上的性能。</p>
<p><strong>云服务</strong>：单体应用是最传统的架构模式，整个系统有一个统一的数据中心，各个功能模块显式进行相互依赖，随着应用变得越来越庞大，流量负载越来越高，单体应用在可扩展性和容错性上都存在致命缺陷，则倾向于使用一组互相独立且富余的服务器系统（云服务），而非单体服务来运行应用。</p>
<p><strong>Docker</strong>：考虑到在每一个服务机器上都进行应用环境配置是很繁琐的工作，版本更新以及更换平台时还需要重新配置。因此，考虑在发布一个项目时，将项目应用带上环境安装一起打包，即发布的 jar 包中是包含环境的，这就是现在的 Docker 镜像（image）。</p>
<h1 id="Docker"><a href="#Docker" class="headerlink" title="Docker"></a>Docker</h1><p>Docker 是一个可以在云平台上构建，运行以及管理容器的软件框架，采用了 <code>C/S</code> 架构，包括客户端和服务端。</p>
<p>Docker 守护进程（<code>Daemon</code>）作为服务端接受来自客户端的请求，并处理这些请求（创建、运行、分发容器）一般在宿主主机后台运行，Docker 客户端则为用户提供一系列可执行命令，用户用这些命令实现跟 Docker 守护进程交互。客户端和服务端既可以运行在一个机器上，也可通过 <code>socket</code> 或者 <code>RESTful API</code> 来进行通信。</p>
<p>基于 Docker：</p>
<ul>
<li>不再需要费力配置应用环境、交付、部署、迁移、运维、升级和扩容都变得更加快速便捷；</li>
<li>简化了容器的创建和维护，并实现了进一步的封装和共享，比如容器间独立的文件系统，网络隔离，共享的操作系统，网络互联等；</li>
<li>镜像非常小巧，只包含必要的核心环境，生成的容器运行轻便，占据较少的硬件资源，性能接近原生，秒级启动。</li>
</ul>
<h1 id="镜像与容器"><a href="#镜像与容器" class="headerlink" title="镜像与容器"></a>镜像与容器</h1><p>镜像就是一个轻量级、可执行的独立软件包，用来打包软件的完整运行环境和基于运行环境开发的软件，它包含某个软件所需的所有内容（代码、库、环境变量和配置文件），但不包含任何动态数据，其内容在构建之后不会被改变。一般使用<code>&lt;仓库名&gt;:&lt;标签&gt;</code>的格式来指定具体是哪个软件哪个版本的镜像。</p>
<p>Docker 镜像实际上由一层一层的文件系统组成，这种层级的文件系统称为联合文件系统（Union File System）。所有的 Docker 镜像都起始于一个基础镜像层（rootfs），当进行修改或者增加新的内容时，就会在当前镜像层之上，创建新的镜像层，而非修改现有镜像。每一个镜像层与它之下的镜像层都可以组成一个镜像，镜像与镜像之间会复用一些镜像层，这也意味着应当尽可能令镜像保持轻量，避免镜像中包含任何不必要的数据。</p>
<p>Docker 镜像和容器（container）之间的关系就像是类和对象，Docker 镜像是容器的静态定义，容器是镜像的动态运行实例。Docker 镜像都是只读的，当通过镜像新建容器并启动时，一个新的可写层被加载到镜像的顶部，这一层就是容器存储层（可用于存储容器运行时产生的临时数据），容器之下都叫镜像层。当开发者对容器存储层的操作结束后，可以将容器层与容器之下的镜像层一起打包发布自己定义的新镜像（但尽量不用使用这种方式来定制镜像）。</p>
<p>容器是一种对进程进行隔离的软件运行环境，包含了应用代码以及代码正常运行所需的所有内容，完全隔离并抽象了底层基础设置和操作系统，还提供了对运行进程进行资源控制的功能。一个应用进程对应一个容器（不建议在一个容器中运行多个应用），各个应用程序在各自的容器内互不干扰的独立运行，容器能够对运行中进程所使用的资源进行干预。</p>
<p>容器化/容器虚拟化是一种对软件进行构建、打包以及部署的方法，运行在容器虚拟化中的应用程序直接运行于宿主机的内核，其运行效率与真实运行在物理平台上的应用程序不相上下，远超虚拟机等其他虚拟化技术实现。</p>
<h1 id="Dockerfile"><a href="#Dockerfile" class="headerlink" title="Dockerfile"></a>Dockerfile</h1><p><code>Dockerfile</code>是用于自动化构建 Docker 镜像的指令脚本，脚本中的每一个指令都对应一层镜像，不管是开发还是运维都能通过<code>Dockerfile</code>来清晰的理解应用运行条件及环境，实现透明化的构建流程。开发者通过 Dockerfile 来打包 Docker 镜像，可以实现低版本环境的持续集成（CI），基于 Docker 镜像，容器实例的创建成为轻松廉价的行为，可以根据实际需要来进行容器创建和关闭之间的无缝衔接，运维者通过 Docker 镜像部署容器内运行的服务，可以实现高版本环境的持续部署（CD）。</p>
<p>编写<code>Dockerfile</code>脚本指令时：</p>
<ul>
<li><p>一般使用空目录或者项目根目录作为上下文目录，仅仅将构建镜像所以的文件放置于上下文目录中，不要引入无关文件</p>
</li>
<li><p>每个保留关键字（指令）都必须是大写字母</p>
</li>
<li><p>指令执行顺序从上到下，每个指令都会创建一个新的镜像层</p>
</li>
<li><p>镜像层数应尽可能少，通过<code>&amp;&amp;</code>将可以合并的多条指令合并为一条指令（过长的指令通过<code>\</code>换行）</p>
</li>
<li><p>确保每一层只添加真正需要的添加的东西，任何无关的东西都应该清理掉</p>
</li>
</ul>
<p>通过<code>docker build xxx .</code>构建镜像时：</p>
<ul>
<li><p>在Docker 服务器端（也就是 Docker 引擎）中构建，并非是在本地 Docker 客户端构建</p>
</li>
<li><p>当前目录<code>.</code>被指定为上下文目录，目录下的所有内容会被打包发送至 Docker 引擎</p>
</li>
<li><p>Docker 引擎就根据上下文目录中的内容来构建 Docker 镜像</p>
</li>
</ul>
<h1 id="容器数据卷"><a href="#容器数据卷" class="headerlink" title="容器数据卷"></a>容器数据卷</h1><p>如果容器存储层中的数据是临时数据，会随着容器的死亡而消失，容器中的临时数据的持久化依赖于挂载，挂载实现了本地与容器，容器与容器之间的数据同步与共享。在 Docker 中，通过挂载来进行数据共享或持久化的文件或目录，都称为容器数据卷（volume），数据卷的生存周期独立于容器，也没有针对数据卷的自动清理机制。</p>
<p>在挂载时，可以给该挂载指定名字（容器内路径一定要指定），指定名字的挂载称为具名挂载，没有指定名字的挂载称为匿名挂载。没有被任何容器所使用的数据卷可以删除。具名挂载可以通过名字来删除数据卷，而匿名挂载的数据卷可以看成它们与对应的容器产生了绑定，因此可以在容器删除时将它们一并删除。</p>
<p>可以专门用一个容器来做其他容器之间的数据共享与备份，这个容器称为数据卷容器。数据卷容器没有具体指定的应用，也不需要运行，使用它的目的就是为了定义一个或多个数据卷那并持有它们的引用。</p>
<h1 id="Docker-网络"><a href="#Docker-网络" class="headerlink" title="Docker 网络"></a>Docker 网络</h1><p>对于大部分的程序来说，它们的运行都不会是孤立的，而是要与其他程序进行交互的，网络通讯是目前最常用的一种程序间的数据交换方式。</p>
<p>当启动 Docker 服务时，它会创建一个默认的 bridge 网络，容器在不专门指定网络的情况都会连接到这个网络上。</p>
<p>Docker 可以对每个容器的网络进行配置，可以在容器间建立虚拟网络来包裹多个容器并与其他网络环境隔离，让应用从宿主机操作系统的网络环境中独立出来，形成容器自由的网络设备。</p>
<h1 id="Docker-Compose"><a href="#Docker-Compose" class="headerlink" title="Docker Compose"></a>Docker Compose</h1><p>一个相对完整的应用系统往往由数十个甚至上百个应用程序或微服务组成，需要多个应用（多个容器）协作完成工作。</p>
<p>如果说<code>Dockerfile</code>是将容器内运行环境的搭建固化下来，那么 Docker Compose 就可以理解为一个管理容器的工具，是将多个相关联容器的合作运行的方式和配置固化下来。</p>
<p>Docker Compose 的配置文件是一个基于 YAML 格式的文件，version 这一配置代表当前<code>docker-compose.yml</code>文件内容所采用的版本（建议使用最新的版本），services 这一配置是整个<code>docker-compose.yml</code>的核心部分，其中每个 service 里的配置代表的是一个应用集群（多个相同镜像的容器）的配置。</p>
<p>Docker Compose 能够对这个集群做到黑盒效果，让其他的应用和容器无法感知它们的具体结构。</p>
<h1 id="Docker-Swarm"><a href="#Docker-Swarm" class="headerlink" title="Docker Swarm"></a>Docker Swarm</h1><p>当使用 Docker Compose 来定义集群时，可以通过 Docker Swarm 来部署和编排集群。对于 Docker Swarm 来说，每个 Docker daemon 实例都可以成为集群中的一个节点。</p>
<p>在任意一个 Docker 实例上都可以通过<code>docker swarm init</code>来初始化集群，初始化后，这个 Docker 实例就自动成为了集群的管理节点，而其他的 Docker 实例可以通过运行<code>docker swarm join</code>来加入集群，逐渐建立出用于服务开发的 Docker 集群。</p>
<p>在 <code>Swarm</code> 集群中也可以使用 <code>compose</code> 文件 （<code>docker-compose.yml</code>） 来配置、启动多个服务。</p>
<p>Docker Swarm 是 Docker 的原生容器集群编排工具，此外，<a href="../../../10/03/kubernetes/">Kubernetes</a> 同样可以解决这一系列的容器编排问题，在 K8S 被设计为与 Docker 配合良好之后，Docker 提供了自己的集成 K8S 发行版来代替 Docker Swarm 作为 Docker Enterprise 的默认容器编排工具。</p>
<p>一个<code>Dockerfile</code>用于定义一个 Docker 镜像，一个Docker 镜像用于部署基于同一个镜像的多个容器，一个<code>docker-compose.yml</code>用于定义基于不同镜像的一系列互相合作的容器所构成的集群，即一个项目或者说业务单元，Docker Swarm/K8S 用于部署编排各种容器集群。</p>
<h1 id="入门命令"><a href="#入门命令" class="headerlink" title="入门命令"></a>入门命令</h1><ul>
<li><p><code>docker version</code></p>
<ul>
<li>显示所安装docker的版本信息</li>
</ul>
</li>
<li><p><code>docker info</code></p>
<ul>
<li>显示docker的系统信息，包括镜像和容器的数量</li>
</ul>
</li>
<li><p><code>docker system df</code></p>
<ul>
<li>查看镜像、容器、数据卷所占用的空间</li>
</ul>
</li>
<li><p><code>docker images</code></p>
<ul>
<li><p>查看本地主机上的所有镜像</p>
</li>
<li><p><code>-q</code>只显示镜像的Id</p>
</li>
</ul>
</li>
<li><p><code>docker search xxx</code></p>
<ul>
<li>搜索docker镜像</li>
</ul>
</li>
<li><p><code>docker pull xxx</code></p>
<ul>
<li>下载docker镜像</li>
</ul>
</li>
<li><p><code>docker rmi xxx</code></p>
<ul>
<li>删除docker镜像</li>
</ul>
</li>
<li><p><code>docker image prune</code></p>
<ul>
<li>删除因同名而被取消名称的旧镜像</li>
</ul>
</li>
<li><p><code>docker run</code></p>
<ul>
<li><p>本机寻找镜像，没有的话去Docker Hub上下载镜像到本地，Docker Hub上找不到的话返回错误，找到后使用本地镜像新建容器并运行</p>
</li>
<li><p><code>-it</code>交互式操作终端</p>
</li>
<li><p><code>--rm</code>容器退出后将其删除</p>
</li>
<li><p><code>-d</code>后台运行</p>
</li>
<li><p><code>-p</code>端口映射</p>
</li>
<li><p><code>-v</code>数据卷挂载（必须使用绝对路径，不能使用相对路径）</p>
</li>
<li><p><code>-e</code>环境配置</p>
</li>
<li><p><code>--name</code>容器名字</p>
</li>
<li><p><code>--volumes-from xxx</code>挂载备份<code>xxx</code>容器中的数据</p>
</li>
<li><p><code>--expose xxx</code>端口暴露</p>
</li>
<li><p><code>--net xxx</code>指定容器走得网络</p>
</li>
<li><p><code>--link xxx</code>指定容器要连接的容器（只能连接同一网络中的其他容器）</p>
</li>
</ul>
</li>
<li><p><code>exit</code></p>
<ul>
<li>停止运行当前容器并退出</li>
</ul>
</li>
<li><p><code>Ctrl + P + Q</code></p>
<ul>
<li>退出当前容器但不停止运行</li>
</ul>
</li>
<li><p><code>docker ps</code></p>
<ul>
<li><p>查看正在运行的容器</p>
</li>
<li><p><code>docker ps -a</code>查看所有状态的容器</p>
</li>
</ul>
</li>
<li><p><code>docker rm xxx</code></p>
<ul>
<li><p>删除容器，但不能删除正在运行的容器</p>
</li>
<li><p><code>docker rm -f</code>删除所有容器，包括正在运行的容器</p>
</li>
</ul>
</li>
<li><p><code>docker container prune</code></p>
<ul>
<li>删除所有处于终止状态的容器</li>
</ul>
</li>
<li><p><code>docker start/restart/stop/kill xxx</code></p>
<ul>
<li>启动/重启/停止/强制停止容器</li>
</ul>
</li>
<li><p><code>docker logs xxx</code></p>
<ul>
<li>查看容器日志</li>
</ul>
</li>
<li><p><code>docker top xxx</code></p>
<ul>
<li>查看容器进程信息</li>
</ul>
</li>
<li><p><code>docker inspect xxx</code></p>
<ul>
<li>查看容器的元数据</li>
</ul>
</li>
<li><p><code>docker exec -it xxx</code></p>
<ul>
<li><p>进入当前正在运行的容器，并开启一个新的终端</p>
</li>
<li><p><code>docker attach xxx</code>进入容器，不会启动新的终端</p>
</li>
</ul>
</li>
<li><p><code>docker cp 容器id: 容器内路径 目的地</code></p>
<ul>
<li>从容器内拷贝文件到主机上</li>
</ul>
</li>
<li><p><code>docker volume rm xxx</code></p>
<ul>
<li><p>删除指定名称的数据卷</p>
</li>
<li><p><code>-v xxx</code>删除容器关联的数据卷</p>
</li>
<li><p><code>docker volume prune</code>删除没有被容器引用的数据卷</p>
</li>
</ul>
</li>
<li><p><code>docker network create</code></p>
<ul>
<li><p>创建自定义的docker网络，连接不同的容器</p>
</li>
<li><p>与网络相关的命令都以<code>docker network</code>开头</p>
</li>
</ul>
</li>
<li><p><code>docker commit</code></p>
<ul>
<li>提交修改后的容器，获得一个新的自定义镜像</li>
</ul>
</li>
<li><p><code>docker build xxx .</code></p>
<ul>
<li>根据编写的dockerfile文件构建一个镜像</li>
<li><code>.</code>表示当前目录，这个路径用于指定上下文路径</li>
</ul>
</li>
<li><p><code>docker push</code></p>
<ul>
<li>发布自己构建的镜像</li>
</ul>
</li>
<li><p><code>docker history xxx</code></p>
<ul>
<li>查看镜像是如何生成的（会给出dockerfile中的所有指令）</li>
</ul>
</li>
<li><p>Dockerfile脚本中的常用指令如下</p>
<ul>
<li><p><code>FROM</code>指定基础镜像</p>
</li>
<li><p><code>MAINTAINER</code>指定镜像的作者</p>
</li>
<li><p><code>RUN</code>指定镜像构建时需要运行的命令</p>
</li>
<li><p><code>COPY</code>指定需要复制到镜像中的文件</p>
</li>
<li><p><code>ADD</code>指定需要向镜像中添加的文件（适合用于需要自动解压缩的场合，不需要自动解压则使用<code>COPY</code>更佳）</p>
</li>
<li><p><code>WORKDIR</code>指定镜像的工作目录</p>
</li>
<li><p><code>USER</code>指定执行<code>RUN</code>、<code>CMD</code>等这类命令的身份</p>
</li>
<li><p><code>VOLUME</code>指定镜像挂载的宿主机目录</p>
</li>
<li><p><code>EXPOSE</code>指定对外暴露的端口</p>
</li>
<li><p><code>CMD</code>指定容器启动时主程序需要执行的启动命令，替换式</p>
</li>
<li><p><code>ENTRYPOINT</code>指定容器启动时需要执行的初始化相关的命令，追加式</p>
</li>
<li><p><code>ENV</code>指定构建镜像时需要设置的环境变量</p>
</li>
<li><p><code>ARG</code>与<code>ENV</code>同理，但<code>ARG</code>所设置的变量在将来容器运行时是不会存在的，并且可以在构建命令<code>docker builder</code>中用<code>--build-arg &lt;参数名&gt;=&lt;值&gt;</code>来覆盖变量值</p>
</li>
</ul>
</li>
</ul>
<h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><ul>
<li><a href="https://juejin.cn/book/6844733746462064654">开发者必备的Docker 实践指南- 有明- 掘金小册</a></li>
<li><a href="https://yeasy.gitbook.io/docker_practice/">Docker — 从入门到实践</a></li>
<li><a href="https://www.bilibili.com/video/BV1og4y1q7M4?spm_id_from=333.337.search-card.all.click&amp;vd_source=0b01a9c17ef5ab558386031fc8124c56">https://www.bilibili.com/video/BV1og4y1q7M4?spm_id_from=333.337.search-card.all.click&amp;vd_source=0b01a9c17ef5ab558386031fc8124c56</a></li>
<li><a href="https://linux.cn/article-11307-1.html">使用开源工具构建 DevOps 流水线的初学者指南</a></li>
<li><a href="https://opensource.com/resources/what-docker">https://opensource.com/resources/what-docker</a></li>
<li><a href="https://docs.docker.com/engine/reference/builder/">https://docs.docker.com/engine/reference/builder/</a></li>
</ul>
]]></content>
  </entry>
  <entry>
    <title>Computer Networking</title>
    <url>/2023/11/06/computer-networking/</url>
    <content><![CDATA[<h1 id="1、概述"><a href="#1、概述" class="headerlink" title="1、概述"></a>1、概述</h1><p><strong>因特网</strong>是一个世界范围的计算机网络，互联了遍及全世界的数十亿计算设备，是网络的网络。因特网所连接的这些设备（不一定是计算机）称为<strong>主机 host 或端系统</strong>，因特网应用就运行在这些端系统上（分布式应用涉及多个相互交互数据的端系统），端系统提供了一个套接字接口，该接口规定了运行在一个端系统上的应用程序向运行在另一个端系统上的特定应用交付数据的方式。</p>
<p><strong>端系统</strong>通过<strong>通信链路和分组交换机</strong>的网络连接到一起，通信链路由不同类型的物理媒介（同轴电缆、铜线、光纤和无线电频谱）组成，这些通信链路能够以不同的传输速率（以比特/秒 bps 度量）传输在端系统之间交换报文，发送端系统将报文划分为较小的数据块（称为分组 packet），分组交换机从它的一条入通信链路接收到达的 packet，根据 packet 的目的地的 IP 地址等首部字段和转发表找到对应的出通信链路，转发该 packet，packets 在目的端系统被装配成初始数据。</p>
<p>大多数<strong>分组交换机</strong>在链路的输入端使用存储转发传输机制，即在向输出端链路传输该 packet 的第一个比特之前，必须接收到整个 packet。分组交换机对于每条相连的链路都具有一个输出缓存，用于存储准备发往该链路的 packet，因此，除了存储转发时延以外，packet 还要经历输出缓存的排队时延，排队时延是变化的，变化的程度取决于网络的拥塞等级，此外由于缓存的大小是有限的，当缓存空间已满时，新到的 packet 或者已经在排队的 packet 就会被丢弃。如今常见的分组交换机是路由器（网络层设备）和链路层交换机（链路层设备），路由器通常用于网络核心，将各个局域网互相连接起来或者接入互联网，链路层交换机通常用于接入网中，用于接入组建局域网。</p>
<p><strong>接入网</strong>指将端系统物理连接到其边缘路由器（边缘路由器是端系统到任何其他远程端系统的路径上的第一台路由器）的网络。很多公司、校园以及家庭端使用局域网（LAN，地理上集中的网络）将端系统连接到边缘路由器，以太网是目前最流行的有线局域网接入技术。在基于 IEEE 802.11 技术的无线 LAN（又称 WiFi）环境中，无线用户从/到一个 WiFi 接入点发送/接收分组，该 WiFi 接入点与企业网/链路层交换机（很可能是通过有线以太网链路）连接，企业网再与有线因特网相连，无线 LAN 用户通常必须位于距离接入点几十米的范围内。用户在移动环境中采用广域（WAN）无线/蜂窝接入网（3G、LTE 4G 和 5G），即通过蜂窝网提供商运营的基站来发送和接收分组，用户仅需位于距离基站数万米范围内。</p>
<p><strong>因特网服务提供商（ISP）</strong>是一个由多台分组交换机和多段通信链路组成的网络，是端系统和更大的因特网之间的桥梁。每个 ISP 网络都是独立管理的（比如希望按自己的意愿运行网络中的各个路由器），ISP 与 ISP 之间都是互联的，较低层的 ISP 通过较高层的 ISP 互联，较高层的 ISP 通过高速光纤链路彼此直接互联，接入网就是位于最底层的接入 ISP，各种接入 ISP 为端系统提供了不同类型的网络接入，我国每个城市有接入 ISP，再往上可以是区域 ISP、省级 ISP、国家级 ISP 以及全球传输的第一层 ISP。较低层的 ISP 和较高层的 ISP 之间是客户和提供商之间的付费关系，除第一层 ISP 以外的任何 ISP 都可以通过多宿（与多个提供商 ISP 相连）来增强稳定性，位于相同层级的邻近的一对 ISP 能直接相连实现对等，从而避免它们之间的流量向上层传输，多个 ISP 可以以因特网交换点（IXP）作为汇合点来一起实现对等，对等的 ISP 之间无需付费。</p>
<p>计算机网络必定要限制在端系统之间的<strong>吞吐量（bps）</strong>，会在端系统之间引入<strong>时延</strong>，且不可避免的会<strong>丢失 packet</strong>。所有的 packet 在每个节点上都经受了几种不同类型的时延，比较重要的是节点处理时延（检查 packet 并找到出链路）、排队时延（排队等待传输，过大则丢包）、传输/发射时延（将 packet 的所有比特推向链路）以及传播时延（比特从起点到下一跳所需要的时间），这些时延累加起来是节点总时延。吞吐量指端与端之间交付比特的速率，为了避免流量在某一个节点上堆积，因此比特从源向目的地的流动速率/吞吐量取决于所有途径的链路中的最小的链路速率以及链路上的干扰流量，今天因特网中对吞吐量的限制因素通常是接入网。</p>
<p>为了处理这些吞吐量、时延以及丢包问题，所有的因特网部件都要运行多个<strong>协议</strong>，这些协议定义了通信实体之间交换的报文的格式和顺序，以及报文的发送和接收等事件所采取的操作，从而控制着因特网中信息的接收和发送（主要协议统称为 TCP/IP 协议，因特网标准由 IETF 研发，IETF 的标准文档称为 RFC）。网络设计者以分层的方式组织协议，每个协议属于这些层次之一，每层协议通过自身执行某些操作或使用直接下层的服务来向上一层提供服务，各层的所有协议被称为协议栈，因特网的协议栈由物理层、链路层、网络层、运输层和应用层组成。</p>
<ul>
<li>应用层是网络应用程序及它们的应用层协议存留的地方，应用层协议分布在多个端系统上，提供应用程序之间的交互，端系统的应用程序使用协议与另一个端系统中的应用程序交换分组（称为报文），提供应用程序之间的交互</li>
<li>表示层负责数据格式的转换和数据加密解密，确保应用层数据的格式一致</li>
<li>会话层提供会话管理功能，负责建立、维护和结束会话，实现不同计算机之间的会话控制，为高层协议提供一个数据传输的会话环境</li>
<li>运输层在应用程序端点之间传送分组（称为报文段），提供端到端的传输服务，包括数据传输控制、流量控制等</li>
<li>网络层负责在主机和主机之间传送分组（称为数据报），解决数据在网络中的传输问题，包括 IP 寻址、路由选择等</li>
<li>链路层沿着路径在物理节点之间传递分组（称为帧），包括对数据进行分帧，差错校验、链路管理等处理</li>
<li>物理层在物理传输媒介上移动帧的一个个比特，规定了传输介质的传输方式，包括电信号、电压、光脉冲等</li>
</ul>
<p>在每一层，一个分组具有首部字段和有效载荷字段（上一层的分组）这两种类型的字段。五层模型就是在七层的基础上，将应用层、表示层和会话层合并为应用层，四层模式就是在五层模型的基础上将链路层和物理层合并为网络接口层。一个协议层能够用硬件、软件或两者结合来实现，应用层、运输层这样的高层协议几乎总是在端系统中用软件实现，网络层通常是硬件和软件实现的混合体，数据链路层、物理层通常在给定链路相关联的网络接口卡中实现。主机实现了所有层次的协议，路由器实现了网络层以及以下的协议，链路层交换机实现了链路层及以下的协议。</p>
<h1 id="2、应用层"><a href="#2、应用层" class="headerlink" title="2、应用层"></a>2、应用层</h1><h2 id="2-1-基本原理"><a href="#2-1-基本原理" class="headerlink" title="2.1 基本原理"></a>2.1 基本原理</h2><h3 id="2-1-1-网络应用程序"><a href="#2-1-1-网络应用程序" class="headerlink" title="2.1.1 网络应用程序"></a>2.1.1 网络应用程序</h3><p>网络应用是计算机网络存在的理由，<strong>虽然网络体系结构是固定的（为应用程序提供了特定的服务集合），但应用体系结构由应用程序研发者设计</strong>，这规定了如何在各种端系统上组织该应用程序，主流的应用体系结构是 C/S（典型例子包括 FTP、电子邮件、Web 应用等，服务器一般设为托管大量主机的能够保证提供服务的数据中心）和 P2P（典型例子是 BitTorrent）。</p>
<p>网络应用程序由成对的运行在不同端系统（可能具有不同的操作系统）上的进程组成，这些进程通过一个称为<strong>套接字</strong>的软件接口向网络发送报文和从网络接收报文，从而跨越计算机网络交换报文而相互通信。套接字是同一台主机内应用层与运输层之间的可编程接口（也称为应用程序和网络之间的 API），应用程序开发者可以控制套接字在应用层端的一切，但对运输层的控制仅限于选择运输层协议和设定一些如最大缓存和最大报文段长度的运输层参数（此外，应用程序开发者对该套接字的运输层端几乎没有控制权），一旦应用层报文进入套接字，该报文就脱离了应用层控制并进入运输层控制。</p>
<h3 id="2-1-2-应用层协议"><a href="#2-1-2-应用层协议" class="headerlink" title="2.1.2 应用层协议"></a>2.1.2 应用层协议</h3><p><strong>应用层协议</strong>定义了交换的应用层报文类型（例如请求还是响应）、各种报文类型的语法（例如报文的各个字段）、字段的语义、发送和响应报文的规则、与该协议关联的周知端口号等，公用的应用层协议由 RFC 文档定义。<strong>应用进程的地址</strong>包含主机的地址和进程标识符，在因特网中，主机的地址为 IP 地址，进程标识符为端口号。端口号是一个 16 比特的数（范围是 0 ~ 65535），当应用使用由 RFC 文档定义的公用应用层协议时，应当使用与该协议关联的周知端口号（范围是 0 ~ 1023），而当应用使用专有的独立应用层协议时，应当避免使用这些周知端口号。</p>
<p>运输层协议需要为应用程序的数据传输提供<strong>可靠与否、吞吐量、定时和安全性</strong>这四个方面的服务。比如电子邮件、文件传输等应用要求可靠交付，但不要求特定吞吐量（属于弹性应用），多媒体应用则对吞吐量有特殊要求（属于带宽敏感应用），电话、视频会议、多方游戏等应用有严格的时间限制。因特网为应用程序提供 UDP 和 TCP 这两个运输层协议，<strong>UDP 提供尽最大努力不确保可靠交付服务，TCP 提供面向连接服务和可靠交付服务</strong>；TCP 和 UDP 都<strong>不提供对吞吐量和定时方面的保证性服务</strong>（但通常能够为带宽敏感和时间敏感应用<strong>提供满意的服务</strong>）；也<strong>不提供任何安全性服务</strong>，<strong>安全性由应用层的 TLS 提供</strong>，TLS 有它自己的套接字 API，类似于传统的 TCP 套接字 API，当一个应用使用 TLS 时，发送进程向 TLS 套接字传递明文数据，发送主机中的 TLS 则加密该数据，并将加密的数据传递给 TCP 套接字，加密的数据经由因特网传送到接收进程中的 TCP 套接字，该接收套接字将加密数据传递给 TLS，由其进行解密，最后 TLS 套接字将明文数据传递给接收进程。</p>
<h3 id="2-1-3-套接字编程"><a href="#2-1-3-套接字编程" class="headerlink" title="2.1.3 套接字编程"></a>2.1.3 套接字编程</h3><p>在应用程序研发阶段，开发者需要先确定应用程序是运行在 TCP 上还是 UDP 上，对于基于 UDP 的应用来说</p>
<ul>
<li>发送报文进入客户端套接字时，应用程序代码应当显式地将目的进程地址附上，源进程地址则由底层操作系统自动将其附上（无需由应用程序代码显式处理）</li>
<li>在服务器端接收到客户端所发送报文之前，应用程序代码应当显式地为服务器端套接字绑定一个接收端口号，那么该套接字即可接收到任何向位于服务器的 IP 地址的该端口所发送的报文</li>
<li>客户端套接字在连接结束后关闭，服务器端套接字始终开启不会关闭，UDP 套接字是由一个包含目的进程地址的二元组来标识的</li>
</ul>
<p>对于基于 TCP 的应用来说</p>
<ul>
<li>在建立 TCP 连接时，客户端创建一个 TCP 套接字并指定服务器“欢迎”套接字地址，源进程地址则由底层操作系统自动将其附上（无需由应用程序代码显式处理）</li>
<li>服务器端会为每个来自客户端的 TCP 连接请求生成一个“新生”套接字用于后续与该客户端进行通信，运输层的三次握手令客户端套接字就和服务器端“新生”套接字关联起来，后续传输数据时无需再由应用程序显式附上目的地址</li>
<li>客户端套接字和服务器端“新生”套接字在连接结束后关闭，服务器端“欢迎”套接字始终开启不会关闭，TCP 套接字是由一个包含源进程地址和目的进程地址的四元组来标识的</li>
</ul>
<h2 id="2-2-Web-应用-HTTP"><a href="#2-2-Web-应用-HTTP" class="headerlink" title="2.2 Web 应用 HTTP"></a>2.2 Web 应用 HTTP</h2><h3 id="2-2-1-HTTP-特性"><a href="#2-2-1-HTTP-特性" class="headerlink" title="2.2.1 HTTP 特性"></a>2.2.1 HTTP 特性</h3><p>Web 应用使用 C/S 应用程序体系结构，Web 应用使用的应用层协议是 HTTP（[REC 1945]、[REC 7230]、[REC 7540]），Web 应用通过交换报文来向 Web 服务器请求 Web 页面，Web 服务器总是打开的，具有一个固定的 IP 地址。<strong>Web 页面</strong>（又称文档）由对象组成，一个对象就是一个文件（例如 HTML 文件、JPEG 文件、JavaScript 文件、CSS 样式表文件、视频文件等），每个对象文件都可通过一个 URL 寻址，URL 由存放对象的服务器主机名和对象的路径名组成。</p>
<p>HTTP 由运行在不同端系统中的客户程序和服务器程序这两个程序实现，定义了在 Web 浏览器（实现了 HTTP 客户端）和 Web 服务器（实现了 HTTP 服务器端）之间请求和传送 Web 页面的方式，是一种用于分布式、协作式和超媒体信息系统的<strong>无状态</strong>应用层协议，以 ASCII 码传输，使用 TCP 作为运输层协议支撑，默认使用 80 端口。无状态指 HTTP 服务器端仅仅只是向客户发送被请求的对象文件，而不存储任何关于该客户的状态信息，这简化了服务器的设计，允许 Web 服务器同时处理数千个 TCP 连接。客户端可能以规则的间隔周期性地或者间断性的发出一些列请求，若所有的请求/响应对分别经过一个单独的 TCP 连接发送则称为非持续连接，若所有的请求/响应对都经过同一个 TCP 连接流水线式的发送则称为持续连接，HTTP <strong>默认使用持续连接</strong>，但也能通过配置使用非持续连接。</p>
<h3 id="2-2-3-HTTP-报文"><a href="#2-2-3-HTTP-报文" class="headerlink" title="2.2.3 HTTP 报文"></a>2.2.3 HTTP 报文</h3><p><strong>HTTP 请求报文</strong>的第一行叫作请求行（request line），请求行有方法、URL 和 HTTP 版本这三个字段；请求行之后是一些首部行（header line），首部行可以指明请求对象所在的主机（这是 Web 代理高速缓存所要求的）、是否使用非持续连接、用户代理（即发送请求的浏览器的类型）等；首部行后为实体体（entity body）。GET 方法的实体体为空，POST 方法的实体体为一些和请求相关的内容（所请求的 Web 页面的特定内容依赖于该实体体中的内容），HEAD 方法并不请求具体 Web 对象，仅仅只需要服务返回一个 HTTP 报文进行响应，常用于调试跟踪，PUT 方法允许上传对象到指定的 Web 服务器上指定的路径，常用于与 Web 发行工具联合使用，DELETE 方法允许删除 Web 服务器上的对象。</p>
<p><strong>HTTP 响应报文</strong>的第一行叫作初始状态行（status line），状态行有 HTTP 版本、状态码和状态信息这三个字段；初始状态行之后是一些首部行，首部行指明了发送完报文后是否关闭该 TCP 连接，服务器产生并发送响应报文的时间、服务器代理、对象创建或最后修改的时间、被发送对象中的字节数，对象类型等；首部行之后为实体体，实体体是报文的主要部分，包含了所请求的对象本身。301 代表请求的对象已经被永久转移了，新的 URL 定义在响应报文的“Location：”首部行中；400 是一个通用差错代码，服务器不能理解该请求；404 代表请求的文档不在服务器上；505 代表服务器不支持请求报文所使用的 HTTP 版本。</p>
<p>HTTP 规范中定义了很多<strong>首部行</strong>，这些首部行可以被浏览器、Web 服务器和网络缓存服务器插入，客户端和服务器端的具体使用产品、版本和配置都会影响到首部行的内容。</p>
<h3 id="2-2-4-用户状态"><a href="#2-2-4-用户状态" class="headerlink" title="2.2.4 用户状态"></a>2.2.4 用户状态</h3><p>HTTP 作为一个无状态协议可以通过 <strong>cookie</strong> 在允许站点对用户进行跟踪，用户首次访问一个站点时，可能需要提供一个用户标识，站点会产生一个唯一识别码并以此作为索引在后端数据库中产生一个表项，接下来会在 HTTP 响应报文中定义一个“Set-cookie：”首部行（包含有该识别码），客户端系统会管理一个 cookie 文件（小型文本文件）并存储在客户端浏览器中，当接收到包含该识别码的响应报文时，会在其 cookie 文件中添加一行，在后续的 HTTP 请求报文中也都会定义一个“Cookie：”首部行（包含有该识别码），针对后续的请求，服务器端通过读取 cookie 并查询后端数据库来获取该用户在该站点的历史活动，从而进行用户信息识别以及一些个性化处理（购物车），因此 cookie 可以在无状态的 HTTP 之上建立一个用户会话层。每个 cookie 都会绑定单一的域名，cookie 不可跨域，无法在别的域名下获取使用，一级域名和二级域名之间是允许共享使用的，每个域名下的 cookie 的数量也是有限的。</p>
<p><strong>Session</strong> 是服务器端创建和管理的一种会话机制，当用户首次访问网站时，服务器会为该用户创建一个唯一的 Session ID，通常通过 cookie 在客户端进行存储，会话标识符在后续的请求中用于标识具体是哪个用户，通常情况下，session 是基于 cookie 实现的，sessionId 存储在客户端的 cookie 中（如果某些网站禁用 cookie，可以将 sessionId 作为参数附加在 URL 中，或者在页面的表单中添加一个隐藏字段来存储 sessionId），session 存储在服务器端，因此，session 较 cookie 更加安全，此外，session 允许存任意数据类型，而 cookie 只支持字符串数据；session 可存储更大的数据量（但是会占用过多的服务器资源），而单个 cookie 保存的数据不能超过 4K；session 一般失效时间较短，客户端关闭或 session 超时都会失效，cookie 则可以设置为长时间保持（比如默认登录）。</p>
<p><strong>Token</strong> 是一种代表用户身份验证和授权的令牌，常用于 Web 应用程序中的身份验证，当用户成功登录时，服务器会基于某种加密算法来为该用户生成一个 Token 令牌，客户端在后续的请求中将 Token 包含在请求头或请求参数中，服务器接收到 Token 后，会进行验证和解析，以确定用户的身份和权限，是一种无状态、可扩展、安全的身份验证和授权机制，可以轻松灵活地在不同平台和设备之间共享和传递，而无需依赖特定的 session 机制或 cookie 支持，非常适用于现代应用架构。虽然 cookie 和 session 也可以使用身份验证，但在一些不适合使用 cookie 和 session 的场景（跨域请求、分布式请求、非 HTTP 的 API 请求、跨平台应用）中，就需要使用 Token</p>
<p><strong>Web 缓存器</strong>（又称代理服务器）有自己的磁盘存储空间，并在存储空间中保存最近请求过的对象的副本，可以通过配置令用户浏览器的 HTTP 请求首先指向 Web 缓存器，若 Web 缓存器存储有请求需要的对象，则直接响应该请求，若没有，则由 Web 缓存器向服务器发送 HTTP 请求，得到响应后在本地存储空间存储一份副本，并向客户浏览器响应。Web 缓存器通常由 ISP 购买并安装到该 ISP 网络中，将该 ISP 网络上的用户浏览器配置为通过高速局域网直接指向 Web 缓存器而非通过低速公共因特网指向服务器，由于客户和服务器之间的瓶颈带宽远低于客户和 Web 缓存器之间的瓶颈带宽，可以大大减少对客户请求的响应时间。HTTP 允许通过<strong>条件 GET</strong>（请求报文中包含“If-modified-since：”首部行）来证实请求对象是最新的，当浏览器请求的对象在缓存器中缓存时间较久时，会向服务器发送条件 GET 请求执行最新检查。</p>
<p>Web 缓存器是一个<strong>正向代理</strong>，即代理服务器代理了客户端去和目标服务器进行交互，目标服务器并不直到真正的客户端是谁，代理是由客户端架设的代理，帮助客户端访问无法/不便于直接访问的服务器资源。<strong>反向代理</strong>是指由代理服务器来接收因特网上的连接请求，然后将请求转发给内部网络上的服务器，并将从服务器上得到的结果返回给因特网上请求连接的客户端，即代理服务器代理了目标服务器去了客户端交互，客户端并不知道真正的目标服务器是谁，代理是由服务器架设的代理，帮助服务器做负载均衡、安全防护等，比如 NGINX 负载均衡就是一个反向代理服务器。正向代理和反向代理均能提高访问速度。</p>
<h3 id="2-2-5-协议版本"><a href="#2-2-5-协议版本" class="headerlink" title="2.2.5 协议版本"></a>2.2.5 协议版本</h3><p>HTTP 协议的主要版本有 HTTP/1.0、HTTP/1.1 和 HTTP/2。<strong>HTTP/1.0</strong> 规定浏览器和服务器只保持短暂的连接，连接无法复用，服务器不跟踪用户也不记录历史请求，浏览器的每次请求都需要与服务器建立一个 TCP 连接，服务器完成请求处理后立即断开 TCP 连接，由于 TCP 三次握手很耗费时间，因此 HTTP/1.0 性能比较差。<strong>HTTP/1.1</strong> 在持续 TCP 连接上使用请求管道（在响应到达之前可以继续发送后续的请求），允许经单一 TCP 连接将一个 Web 页面（涉及多个 HTTP 请求和响应）从服务器发送到客户，由于每个 Web 页面仅用一个 TCP 连接，所传送的每个 Web 页面平等共享网络带宽，但此时同一个 TCP 连接中位于请求队首的大对象会阻塞后面的小对象，为了避免该阻塞需要打开多个并行的 TCP 连接，此时，小对象到达并呈现在浏览器上的速度要快很多，可以减小用户感知时延，HTTP/1.1 一直延用至今。<strong>HTTP/2</strong> 在应用层和传输层之间加了一层二进制分帧层，在二进制分帧层中，HTTP/2 会将每个报文分成更小的帧并采用二进制格式的编码，对 Header 进行压缩，在同一 TCP 连接上以 stream 的方式乱序交错发送请求和响应报文对应的二进制帧并在接收端将其装配起来，允许客户为正在请求的响应确定优先次序，此外还允许服务器自行根据用户的一个请求内容来主动推送多个相关的资源而无需等待用户来发送其余相关请求，这些设计避免了小对象阻塞，减小了感知时延，摆脱了 HTTP/1.1 的并行 TCP，减小了 TCP 数量，服务器的套接字数量被压缩。</p>
<p>HTTP/1.1 的请求管道要求服务端必须按照与请求相同的顺序回送 HTTP 响应，存在 HTTP 队头阻塞问题（如果个响应返回发生了延迟，那么后续的响应都会被延迟），HTTP/2 废弃了管道化的请求方式，而是将 HTTP 消息分解为互不依赖的帧并乱序发送，避免了 HTTP 队头阻塞问题，但仍然存在 TCP 队头阻塞的问题，且相比于基于多个并行 TCP 连接的 HTTP/1.1，基于同一 TCP 连接的 HTTP/2 的 TCP 队头阻塞问题会更加严重，为了避免这一问题，<strong>HTTP/3（原 QUIC 协议）</strong>采用基于 UDP 的运输层协议，通过应用层协议自身的数据包重传、拥塞控制、传输节奏调整等特性来提供可靠传输（UDP 是不可靠传输协议），实现了无序、并发字节流传输以及快速握手，还采用了 TLS 1.3 来提供安全性相关的能力。</p>
<p>HTTPS 和 HTTP 是两种协议，HTTP 是明文传输的，数据在传输过程中并不加密，容易被攻击或窃取，HTTPS 经由 HTTP 进行通信，但利用 SSL/TLS 来加密数据包（因此被称为 HTTP over SSL/TSL），需要使用由信任的第三方机构（如 Certificate Authority）所颁发的数字证书来验证网站的身份，而加密和解密操作所带来的计算开销使得 HTTPS 比 HTTP 的性能更低一些，因此对于不涉及敏感信息的静态内容来说，HTTP 是比 HTTPS 更好地选择。</p>
<h3 id="2-2-6-HTTP-请求"><a href="#2-2-6-HTTP-请求" class="headerlink" title="2.2.6 HTTP 请求"></a>2.2.6 HTTP 请求</h3><p>当浏览器输入某个网址回车之后，</p>
<ul>
<li><p>浏览器对 URL 进行解析，检查长度，查看浏览器是否缓存了该页面</p>
</li>
<li><p>若无页面缓存，则依次通过浏览器缓存、操作系统 hosts 缓存，路由器缓存，ISP 缓存和根域名服务器查询对应的 IP</p>
</li>
<li><p>浏览器将请求封装为 HTTP 报文，与服务器建立 TCP 连接，并将报文经由网关和路由器发送给 server</p>
</li>
<li><p>服务器如果使用 NGINX 做负载均衡，则 NGINX 采用默认的轮询算法将报文发送给 servlet 容器</p>
</li>
<li><p>servlet 容器解析请求行，请求提，请求头，然后交给 MVC 处理</p>
</li>
<li><p>DispatcherServlet 接收到请求后，通过请求路径返回相应的拦截器和 Controller</p>
</li>
<li><p>Controller 通过调用下层的 Service 以及持久层进行数据的 CRUD，并返回 Model 和 View</p>
</li>
<li><p>ViewResolve 对 Model 和 View 进行处理，返回 View 视图，对 View 进行渲染之后，产生 HTTP Response</p>
</li>
<li><p>浏览器接受到 HTTP Response 之后对其进行缓存和解码，并渲染页面</p>
</li>
</ul>
<h3 id="2-2-7-网络安全"><a href="#2-2-7-网络安全" class="headerlink" title="2.2.7 网络安全"></a>2.2.7 网络安全</h3><p><strong>拒绝服务（DoS，Denial of Service）</strong>指某个攻击者利用大量合理的服务请求来占用服务资源，从而使得合法用户无法得到服务响应，<strong>分布式拒绝服务（DDoS，Distributed Denial of Service）</strong>是指大量身份不断变化的攻击者都进行 DoS 攻击，DDoS 攻击可以具体分为带宽消耗型以及资源消耗型。如果能够识别出攻击源（如攻击者的机器 IP 等），可以在防火墙服务器上放置一份 ACL（访问控制列表）来阻断来自这些 IP 的访问；此外，针对带宽消耗型，可以增加带宽；针对资源消耗型，可以增加负载均衡，多地部署等。</p>
<p><strong>跨站请求伪造（CSRF/XSRF，Cross Site Request Forgery）</strong>指攻击者盗用了正常用户的身份，以正常用户的名义发送恶意请求，比如发送邮件，购买商品，转账等造成个人信息泄露，财产损失等，防止 CSRF 攻击的方式有：1）验证记录了 HTTP 请求来源地址的 HTTP Referer 字段；2）在 HTTP 请求地址中添加 Token 并验证；3）在 HTTP 头中自定义属性并验证。</p>
<p><strong>跨站脚本攻击（XSS，Cross Site Scripting）</strong>指攻击者向 Web 页面中插入恶意 HTML 代码，当用户浏览该网页时，嵌入其中的恶意代码会被执行，从而攻击用户，防止 XSS 的方式就是始终不应相信用户的输入，始终对用户的输入进行过滤等处理。</p>
<p><strong>DNS 污染</strong>指一个 DNS 服务器被恶意修改，导致该 DNS 服务器不再返回错误的 DNS 记录，<strong>DNS 劫持</strong>指攻击截获 DNS 请求，并代替 DNS 服务器提供错误的 DNS 记录，DNS 污染和DNS 劫持都可以将用户错误地引导至恶意站点，需要选择可靠的 DNS 服务商，使用 VPN 来保护网络连接等。</p>
<p><strong>水平越权</strong>指攻击者尝试访问与当前用户具有相同权限的其他用户资源，比如对于以自增键为主键的用户信息，可以尝试访问临近自身自增键的其他用户信息，可以通过对关键参数进行加密混淆，限制单位时间内的请求频次，避免使用自增键等方式来避免。</p>
<p><strong>对称加密</strong>指加密和解密使用相同的密钥，<strong>非对称加密</strong>指加密和解密使用一对配对的不同的密钥，公钥加密后的数据只有通过该公钥对应的私钥才能解密，私钥加密后的数据只有通过该私钥对应的公钥才能解密。</p>
<p><strong>MD5</strong> 是一种散列函数，不是加密算法，作用是对数据进行单向不可逆的压缩，生成一个固定长度的字符串作为该数据的数字指纹/消息摘要，以验证数据的完整性和一致性，但无法对加密后的数字指纹进行解密得到原始数据，由于哈希值的长度是固定的，因此 MD5 算法存在碰撞的可能，因此不能保证安全。</p>
<p><strong>SHA-256</strong> 是一种密码散列函数，常被用于对数据进行签名或生成信息摘要，同样不能逆向解密，由于计算中使用了大量的位运算、逻辑运算和移位运算等，计算生成的消息摘要非常长，因此结果具有很强的随机性，发生碰撞的概率很低，是安全可靠的。</p>
<p><strong>中间人攻击</strong>指攻击者与通讯两端分别建立独立的联系，使得通讯的两端认为他们在于对方进行直接联系，实际上整个会话都完全被中间人攻击者所控制。</p>
<p><strong>SQL 注入</strong>指攻击者通过在应用程序的用户输入中插入恶意的 SQL 代码，进行未经授权的恶意数据查询与操作，因此应用程序应当使用预编译或参数化的 SQL 语句，从而始终将用户输入的参数视为数据，而不会解释为 SQL 语句的一部分；尽量使用 ORM 框架来尽可能避免手动拼接 SQL；始终对用户输入的信息进行验证过滤等处理；为数据库用户分配最小必要的权限；避免向用户泄漏敏感信息。</p>
<p><strong>撞库</strong>指攻击者通过收集互联网已泄露的用户和密码信息，生成对应的字典表，尝试批量登录其他网站，找到一系列登录确定网络的用户信息；<strong>拖库</strong>指攻击者通过技术手段（SQL 注入等）窃取数据库中的信息；<strong>洗库</strong>指攻击者通过技术手段将有价值的用户数据归纳分析，售卖变现。</p>
<h2 id="2-3-电子邮件-SMTP"><a href="#2-3-电子邮件-SMTP" class="headerlink" title="2.3 电子邮件 SMTP"></a>2.3 电子邮件 SMTP</h2><p>电子邮件是一个异步通信媒介，使用了多个应用层协议，因特网电子邮件系统由用户代理、邮件服务器和 SMTP 这三个部分组成，<strong>用户代理</strong>允许用户阅读、回复、转发、保存和撰写报文；<strong>邮件服务器</strong>上有一个邮箱，用于管理和维护发送给自身的报文；<strong>SMTP</strong> 是因特网电子邮件中主要的应用层协议。</p>
<p><strong>SMTP</strong> 使用 TCP 可靠数据传输服务，运行在发送方邮件服务器的客户端和接收方邮件服务器的服务器端，这意味双方的邮件服务器必须使用保持开机。SMTP 不使用中间邮件服务器发送邮件，而是发送方邮件服务器和接收方邮件服务器直接相连，这意味着邮件并不在某个中间邮件服务器中留存。SMTP 限制邮件报文的体部分（不只是其首部）只能采用简单的 7 比特的 ASCII 表示，即在用 SMTP 传送邮件之前，需要将二进制多媒体数据编码为 ASCII 码，并且在使用 SMTP 传输后要求将相应的 ASCII 码邮件解码还原为多媒体数据。邮件的环境信息（双方地址、日期等）包括在一系列首部行中，首部行和 ASCII 格式的报文体用空行（回车 CR 和换行 LF）进行分隔。</p>
<p>发送方将撰写完成的邮件通过 SMTP/HTTP 从用户代理传输到发送方的邮件服务器（邮件放置在邮件服务器的外出报文队列中），通过 SMTP 再传输到接收方的邮件服务器，邮件接收者可以调用自己的用户代理通过 HTTP/IMAP 在自己的邮件服务器的邮箱中取得该报文（取报文是拉操作，SMTP 是推协议，故不能使用 SMTP）。当发送方的邮件服务器经过多次重试失败而确认接收方的邮件服务器存在故障时，发送方邮件服务器会删除该报文并以电子邮件的形式通知发送方，这种确保交付的机制必须依赖于发送方邮件服务器这一中继，因此邮件不能直接由发送方用户代理直接传输到接收方邮件服务器。典型的用户通常与其他用户共享总是保持开机的<strong>共享邮件服务器</strong>，在本地 PC 上运行用户代理程序来访问共享邮件服务器上的邮箱。</p>
<h2 id="2-4-域名系统-DNS"><a href="#2-4-域名系统-DNS" class="headerlink" title="2.4 域名系统 DNS"></a>2.4 域名系统 DNS</h2><p>因特网主机可以通过主机名或者 IP 地址进行标识，DNS 是一个能进行因特网主机名/主机别名（人类好记的名字）到 IP 地址转换的<strong>目录服务</strong>，此外还基于冗余服务器（相同主机名对应一系列多个 IP 地址）提供<strong>负载均衡</strong>分配功能（返回不同的 IP 地址）。大多数用户不直接与 DNS 打交道，而是通过其他应用间接使用它，比如浏览器需要通过 DNS 将服务器名转换为服务器 IP 地址之后再向该 IP 地址发起 TCP 连接。DNS 由 DNS 服务器所实现的<strong>分布式数据库</strong>（是分布式数据库的精彩范例）和使得主机能够查询分布式数据库的<strong>应用层协议</strong>组成。</p>
<p><strong>DNS 服务器</strong>通常是运行 BIND 软件的 UNIX 机器，大量分布于全球并以层次结构组织，该层次结构中存在根 DNS 服务器、顶级域 DNS 服务器和权威 DNS 服务器这三种类型的 DNS 服务器。本地 DNS 服务器（又称默认名字服务器）并不属于 DNS 服务器的层次结构，但每一个 ISP 都有一台本地 DNS 服务器，当主机与某个 ISP 连接时，该 ISP 提供一台主机的 IP 地址，该主机具有一台或多台其本地 DNS 服务器的 IP 地址，主机的本地 DNS 服务器就是“邻近” DNS 服务器。主机的 DNS 请求都被转发到本地 DNS 服务器上，本地 DNS 服务器会首先与根服务器之一联系，获得请求域名所在的顶级域名服务器的 IP 地址，接着与顶级域名服务器之一联系，获得请求域名所在的权威域名服务器的 IP 地址，接着与权威域名服务器之一联系，获得请求域名所对应的 IP 地址，最后本地 DNS 服务器将获得的 IP 地址返回给请求主机。</p>
<p>想通过 DNS 获得的 IP 地址一般缓存在一个“邻近”DNS 服务器中，<strong>DNS 缓存</strong>有助于减少 DNS 的网络流量和 DNS 的平均时延，在一个 DNS 请求链中，当某 DNS 服务器接收到一个 DNS 回答（包含某主机名到 IP 地址的映射）时，就将映射缓存在本地存储器中，由于这种映射并不是永久的， DNS 服务器在一段时间（通常为两天）后将丢弃缓存的信息。</p>
<p>共同实现 <strong>DNS 分布式数据库</strong>的所有 DNS 服务器存储了<strong>资源记录</strong>，每个 DNS 回答报文包含了一条或多条资源记录，资源记录提供了主机名到 IP 地址的映射，包含 Name、Value、Type、TTL 这四个字段。TTL 是该资源记录的生存时间，决定了资源记录应当从缓存中删除的时间，Name 和 Value 的意义取决于 Type。如果 Type = A，那么 Name 为主机名，Value 为主机名对应的 IP 地址；如果 Type = NS，那么 Name 为域，Value 为知道如何获得该域中主机 IP 地址的权威 DNS 服务器的主机名（用于沿着查询链来路由 DNS 查询）；如果 Type = CNAME，那么 Name 为主机别名，Value 为规范主机名；如果 Type = MX，那么 Name 为邮件服务器别名，Value 为邮件服务器规范主机名。注册登记机构是一个验证域名唯一性的商业实体，会将域名以及域名所在的权威 DNS 服务器的名字和 IP 地址输入 DNS 数据库，对提供的服务收取少量费用。</p>
<p><strong>DNS 协议</strong>运行在 UDP 之上，如果没有接收到响应，则要么试图向另一个 DNS 服务器发送查询，要么通知调用的应用程序它不能获得响应。DNS 查询报文和回答报文具有相同的格式，报文中分别有首部区域（标识了该查询以及当前是查询报文还是回答报文等信息）、问题区域（包含了正在进行的查询信息）、回答区域（包含了对最初请求的名字的所有资源记录）、权威区域（包含了其他权威服务器的记录）、附加信息（包含了其他有帮助的记录）。</p>
<h2 id="2-5-视频流-HTTP-DASH"><a href="#2-5-视频流-HTTP-DASH" class="headerlink" title="2.5 视频流 HTTP/DASH"></a>2.5 视频流 HTTP/DASH</h2><p>视频是以一种恒定速率来展现的一系列图像，图像由像素阵列组成，每个像素由一些比特编码来表现亮度和颜色，可以用比特率来权衡视频质量，比特率越高，图像质量越好，用户的总体视觉感受越好。在<strong>流式视频应用</strong>中，预先录制的视频放置在服务器上，用户按需向这些服务器发送请求来观看视频，流式视频最为重要的性能度量是平均端到端吞吐量。</p>
<p>在 HTTP 流中，视频只是存储在 HTTP 服务器中作为一个普通的文件，当服务器在响应报文中发送该视频文件对象，客户侧不断将字节收集在客户应用缓存中，一旦该缓存中的字节数量超过预先设定的门限，客户应用程序就开始播放，流式视频应用周期性地从客户应用程序缓存中抓取帧，对这些帧解压缩并在用户屏幕上展现，此时，即便是拥有不同可用带宽的客户，客户接收的都是相同版本的视频压缩文件。而在 <strong>DASH</strong> 中，视频编码为几个比特率不同的版本文件（具备不同的 URL，对应不同的质量水平），在客户与服务器建立 TCP 连接后，服务器会先向客户发送具有 URL 列表的告示文件，客户即可动态地请求来自不同版本且长度为几秒的视频数据块（在请求报文中指定 URL 和字节范围），当客户可用带宽较高时，客户自然选择来自高速率版本的块，当可用带宽较低时，客户选择来自低速率版本的块，这种机制允许客户使用不同的接入速率流式播放具有不同编码速率的视频，即在不同质量等级之间自由切换。</p>
<p>为了应对向分布于全世界用户分发巨量视频数据的挑战，几乎所有主要的视频流公司都利用<strong>内容分发网 CDN</strong>，CDN 管理着分布在多个地理位置上的服务器集群（边缘节点，离用户更近），这些集群中存储着视频（各种静态资源）的副本，一般被安置在接入 ISP 或 IXP。CDN 通过 DNS 来截获用户请求，并根据用户的本地 DNS 服务器的 IP 地址来试图将用户请求都重定向到一个将提供最好用户体验的 CDN 集群节点位置 。</p>
<h2 id="2-6-文件分发-BitTorrent"><a href="#2-6-文件分发-BitTorrent" class="headerlink" title="2.6 文件分发 BitTorrent"></a>2.6 文件分发 BitTorrent</h2><p>在 P2P 体系结构下，受用户控制的主机彼此直接通信，无需依赖于总是打开的基础设施服务器。在 P2P 文件分发中，每个对等方能够向任何其他对等方重新分发它已经收到的该文件的任何部分，从而协助分发过程。到 2020 年至，最为流行的 P2P 文件分发协议是 <strong>BitTorrent</strong>。BitTorrent 将参与一个特定文件分发的所有对等方的集合被称为一个洪流，在一个洪流中的对等方彼此下载等长度的文件块（典型的块长度为 256 KB），每个<strong>洪流</strong>具有一个基础设施节点，称为追踪器。</p>
<p>当一个对等方首次加入一个洪流时会向追踪器注册自己并周期性地通知洪流它仍在该洪流中，追踪器会随机地从参与对等方的集合中选择对等方的一个子集并将该子集中对等方的 IP 地址发送给新加入的对等方，新对等方会试图与该子集中的所有对等方创建并行的 TCP 连接，所有这样与新对等方成功创建 TCP 连接的对等方称为邻近对等方，每个对等方的邻近对等方会随时间而变化。对等方会随时间逐渐累积了越来越多的文件块，下载块的同时也为其他邻近对等方上载块。对等方随时可以离开洪流，可以离开后重新加入洪流，也可以一直留在洪流中。</p>
<p>对等方会周期性地询问每个邻近对等方它们所具有的块列表，并对自己当前还没有的块在邻居中决定出最稀缺的块（就是那些在邻居中副本数量最少的块）发出请求，最稀缺的块得到更为迅速的重新分发，从而大致均衡每个块在洪流中的副本数量。对等方对于每个邻居都持续地测量接收到比特的速率，并确定以最高速率流入的 4 个邻居（被称为疏通），对等方会周期性重新计算流入速率并可能修改疏通，也会周期性随机选择疏通以外的邻居（被称为试探）并向其发送数据块，除了疏通和试探这 5 个对等方以外，所有其他的邻居对等方均被阻塞，这种关于交换的激励机制使得对等方能够以趋向于找到彼此的协调的速率上载。</p>
<h1 id="3、运输层"><a href="#3、运输层" class="headerlink" title="3、运输层"></a>3、运输层</h1><h2 id="3-1-基本原理"><a href="#3-1-基本原理" class="headerlink" title="3.1 基本原理"></a>3.1 基本原理</h2><h3 id="3-1-1-多路复用-分解"><a href="#3-1-1-多路复用-分解" class="headerlink" title="3.1.1 多路复用/分解"></a>3.1.1 多路复用/分解</h3><p><strong>运输层</strong>为运行在不同主机上的应用进程提供逻辑通信，多个同时运行的应用进程分别对应不同的套接字（也可以令同一进程的多个线程对应不同套接字），发送端运输层通过发送端各个不同的套接字接收来自发送端各个应用进程的报文，将这些报文划分为小块并为每个数据块分别加运输层首部从而转换成报文段（这称为<strong>多路复用</strong>），这些报文段被传递到发送端的网络层，网络层将报文段封装为数据报传递到网络中，数据报在网络中途径的所有中间主机和网络路由器仅作用于该数据报的网络层字段，而不检查封装在该数据报中的运输层报文段，接收端网络层从数据报中提取运输层报文段，并将该报文段向上交给接收端运输层，接收端运输层从接收到的报文段中找到套接字标识，从而将报文段递交给特定的接收端套接字，报文段由此被定向到接收端特定应用进程（这称为<strong>多路分解</strong>）。</p>
<p>运输层的多路复用与多路分解源自于单一的<strong>运输层协议</strong>需要为高层的多个协议提供统一的服务，这也要求每个<strong>报文段都有特殊字段（源端口号和目的端口号）</strong>来指示该报文段所对应的发送接收套接字。运输层协议只在发送端系统和接收端系统中工作而对分组在发送接收端以外如何移动并不关心，发送接收端以外的其他端系统以及中间路由器也不识别分组中的运输层首部。虽然运输层协议所能够提供的服务常常受制于网络层协议所提供的服务，且网络层协议往往是不可靠的（比如丢失、篡改、乱序等），但是因特网为应用程序提供的 UDP 和 TCP 这两个运输层协议依旧能为应用程序提供某方面可靠的（比如确保交付、差错检查等）数据传输服务 。</p>
<h3 id="3-1-2-运输层协议"><a href="#3-1-2-运输层协议" class="headerlink" title="3.1.2 运输层协议"></a>3.1.2 运输层协议</h3><p>由于不能保证所有的通信链路都提供差错检测，也不能保证数据在某台主机或者路由器的内存中没有引入差错，因此需要由运输层协议提供<strong>端到端的差错检测</strong>，UDP 和 TCP 都可以通过在其报文段首部中包括差错检查字段（检验和）而提供<strong>完整性检查</strong>。UDP 只是做了运输层协议能够做的最少工作，仅提供进程到进程的数据交付和差错检查这两种最低限度的运输层服务，并不确保完整无缺的数据交付，对检测出的差错报文段直接丢弃而无恢复能力，也无法控制流量。TCP 在不可靠的（IP）端到端网络层之上提供<strong>可靠、完整、正确、按序的数据交付</strong>，此外还为整个因特网提供<strong>拥塞控制</strong>服务，防止任何一条 TCP 连接用过多流量来淹没通信主机之间的链路和交换设备，力求为每个通过一条拥塞网络链路的连接平等地共享网络链路带宽。</p>
<p>由于 UDP 在传输数据时不具备流量控制和拥塞控制，会将应用层数据处理后立即将其传递给网络层，而 TCP 在传输数据之前需要先经过三次握手建立连接，流量控制、拥塞控制以及超时重传都会拉长数据交付的时延，主动降低自身的发送速率，因此 UDP 发送数据的时间控制则更为准确，能够以非公平的方式占据链路带宽，压制同一条链路上的 TCP 流量；由于 UDP 是无连接的，无需像 TCP 那样维护众多连接状态信息，也不跟踪各种收发参数，UDP 首部开销较 TCP 更小，因此运行在 UDP 之上的应用程序所在服务器往往能支持更多的活跃用户；此外，即便 UDP 没能提供某种可靠服务，依旧可以通过应用程序自身或新型应用层协议来建立可靠性机制，此时，基于 UDP 的应用程序既可以进行可靠通信，也无须受制于 TCP 拥塞控制机制强加的传输速率限制。综上所述，<strong>TCP 并非总是首选的</strong>。</p>
<h3 id="3-1-3-可靠数据传输"><a href="#3-1-3-可靠数据传输" class="headerlink" title="3.1.3 可靠数据传输"></a>3.1.3 可靠数据传输</h3><p>网络层及以下的底层信道模型往往复杂且不可靠，基于差错检测、肯定确认以及否定确认的<strong>自动重传请求（ARQ）</strong>协议可以确保完整、正确的数据交付，即由接收方根据差错检查的结果返回不同的反馈，针对出现比特受损的情况，接收方就可以通过发送 NAK 来要求发送方重传，当发送方收到含糊不清的 ACK 或者 NAK 时都会重传当前的分组，发送方只有准确接收到 ACK 时才能继续发送新数据。此外，几乎现在所有的数据传输协议都会在分组中添加分组编号，因此，接收方可以通过检查分组号来确定接收到的分组是否为重传从而处理冗余，也可以根据分组号的排序来确保按序的数据交付，发送方可以通过一定时间是否接收到某分组号的 ACK 来判断是否丢包是否重传该分组，这也要求发送方在每次发送一个分组时便启动一个定时器。</p>
<p>为了提高数据交付的时延，发送方可以在还未接收到 ACK 时就发送发送一定数量限制的多个分组（称为窗口），这种发送流水线要求发送方发送的每个非重传的分组必须有唯一的序号（TCP 的分组号是按字节流中的字节进行计数的），发送方和接收方分别都维持一个大小为 N 的窗口（<strong>回退 N 步</strong>，N 必须小于等于序号空间大小的一半），发送窗口的 send_base 为最小的已发送未接收 ACK 的分组序号，接收窗口的 rcv_base 为最小的正确按序接收到的分组序号。发送方需要缓存那些已发送但还未接收到 ACK 的分组，每个已发送但未 ACK 的分组都拥有自己的定时器，并在超时时重传该分组（<strong>选择重传（SR）</strong>），接收方对于正确接收到的分组，若分组序号大于等于 rcv_base - N 则无论是否按序是否重复均发送针对当前分组的 ACK，若分组序号等于 rcv_base（按序）则交付上层，若大于 rcv_base（失序）则被缓存直到所有序号更小的分组皆被收到时一起交付上层，对于所有其他情况（分组序号小于 rcv_base - N 或分组比特受损）均丢弃分组。</p>
<h2 id="3-2-传输控制协议-TCP"><a href="#3-2-传输控制协议-TCP" class="headerlink" title="3.2 传输控制协议 TCP"></a>3.2 传输控制协议 TCP</h2><h3 id="3-2-1-可靠传输"><a href="#3-2-1-可靠传输" class="headerlink" title="3.2.1 可靠传输"></a>3.2.1 可靠传输</h3><p>TCP 报文段由<strong>首部字段</strong>和一个<strong>数据字段</strong>组成，数据字段包含一块应用数据，数据字段长度不能超过最大报文段长度 <strong>MSS</strong>（MSS 根据最初确定的由本地发送主机所能发送的最大链路层帧长度 MTU 来设置），首部包括源端口号（多路复用）、目的端口号（多路分解）、检验和字段（差错检测）、<strong>序号字段</strong>、<strong>确认号字段</strong>、接收窗口字段、首部长度字段（TCP 首部长度是可变的）、选项字段（发送方和接收方协商 MSS）、标志字段。TCP 将序号建立在传输的字节流之上（<strong>隐式地对数据流中每个字节编号，编号的起始可以随机产生</strong>），一个报文段的序号是该报文段中首个字节的字节流编号，确认号是该主机期望从对方接收到的下一个字节的字节流编号，从而代表确认号之前的字节均已经 ACK（由于 TCP 只确认流中第一个丢失字节为止的字节，所以 TCP 被称为提供<strong>累计确认</strong>），<strong>序号（数据顺序和数据重复）、确认号字段和超时重传（数据完整）以及检验和（数据篡改）是提供可靠数据传输的关键</strong>。</p>
<p>这种面向字节流的传输使得发送方可能会将多个小的数据包粘合在一起发送，接收方可能将这些粘合在一起数据包拆分成多个小的数据包进行接收，从而导致数据接收出现错误或者数据粘连的问题，因此需要对每个包都固定长度（比如 512 个字节大小），每个包的末尾使用固定的分隔符，报文段的首部字段中保存整个报文段的长度，只有在读取到足够长度的消息之后才算是接收到一个完整的报文段。</p>
<p>TCP 使用<strong>单一的重传定时器</strong>，当 TCP 收到上层应用数据或首次接收到针对某报文段的 ACK 时，重启定时器并将超时间隔设为估算往返时间（RTT）。TCP 报文段的样本 RTT 是从报文段被交给网络层到对该报文段的 ACK 被收到之间的时间量，在任意时间，仅为一个已发送且是首次发送的但目前尚未 ACK 的报文段产生一个新样本 RTT 值，进而计算一个估算 RTT。当定时器超时时，TCP 发送方重传最小的已发送但未 ACK 的报文段，重启定时器并将下一次超时间隔设为先前值的两倍（报文段的超时间隔应当始终大于等于估算的 RTT）。此外，TCP 接收方接收到一个正确的报文段时，总是对当前最后一个按序报文段发送冗余 ACK（并不丢弃失序报文段），当 TCP 发送方收到针对某报文段的冗余的 ACK 数量达到 3 个时，TCP 就对该报文段的下一个报文段进行<strong>快速重传</strong>，避免等待过长的超时周期。</p>
<p>TCP 重传率是一个衡量 TCP 网络性能的重要指标，过高的重传率意味着网络质量问题，如网络拥塞、链路不稳定/质量差，进而导致网络吞吐量下降和延迟增加，可以通过查看 TCP 重传率到定位网络问题<a href="https://www.yuque.com/hollis666/niq4hm/tk8w4sg1gw9cd0gg">参考</a>。</p>
<h3 id="3-2-2-连接管理"><a href="#3-2-2-连接管理" class="headerlink" title="3.2.2 连接管理"></a>3.2.2 连接管理</h3><p>TCP 连接是一条<strong>全双工、点对点的逻辑连接</strong>，TCP 连接的建立会显著地增加人们感受到的时延。在 TCP 连接建立阶段，连接的双方都将初始化与 TCP 连接相关的许多 TCP 状态（比如双方所选择的字节流起始编号），这些状态仅保留在两个通信端系统的 TCP 程序中，在这两个端系统之间的网络元素（路由器、交换机和中继器）没有为该连接分配任何缓存和变量。</p>
<p>发起连接的进程称为客户进程，另一个进程称为服务器进程，客户进程首先通知客户运输层自身想与服务器上的一个进程建立连接，客户运输层发送一个首部 SYN 标志位被置为 1 的特殊的 TCP 报文段（被称为 SYN 报文段），并随机选择一个客户端起始序号 client_isn 放置于该报文段的序号字段，客户进程验证自身的发送能力正常；服务器接收到 SYN 报文段后为该 TCP 分配 TCP 缓存和变量，并用另一个特殊的 TCP 报文段来响应，该报文段的 SYN 标志位依旧被置为 1，确认号字段被置为 client_isn + 1，并随机选择一个服务器端起始序号 server_isn 放置于该报文段的序号字段中（被称为 SYNACK 报文段），服务器进程验证客户进程的发送能力正常，验证自身的发送和接收能力也都正常；客户接收到 SYNACK 报文段后为该连接分配缓存和变量，再用 ACK 报文段作为响应，该报文段的 SYN 标志位被置为 0，确认号字段被置为 server_isn + 1，序号字段被置为 client_isn + 1，客户进程验证自身和服务器进程的发送和接收能力都正常，这就是 <strong>TCP 三次握手</strong>，其中，前两个报文段不承载有效载荷（即不包含应用层数据），第三个报文段可以承载有效载荷，在之后的每个报文段中的 SYN 标志位都被置为 0。</p>
<p>如果服务器在发送 SYNACK 后没有接收到来自客户的 ACK，那么通常在一分多钟后终止该半开连接并回收资源，这就导致当服务器收到 <strong>SYN 洪泛攻击</strong>（仅发送 SYN 来建立连接但不使用连接发送数据）时，大量资源浪费在从未使用的 TCP 连接上，而无法为真正合法的用户分配连接资源。为了避免该攻击，服务器在接收到 SYN 后并不分配资源，仅仅只是根据一个复杂函数生成一个与源和目的的进程地址有关的起始序号（称为 cookie）并发送 SYNACK，服务器也不记忆该 cookie 或任何对应于 SYN 的其他状态信息，一个合法的用户会为 SYNACK 生成 ACK，服务器接收到来自用户的 ACK （验证用户和自身的发送和接收能力都正常）后用相同的方式重新计算 cookie，验证用户 ACK 的合法性，若合法，才为该 TCP 连接分配资源。<strong>只有三次握手才有足够的上下文来让客户和服务器双方都确认双方的发送和接收能力都正常，确认当前连接既不是来自非合法用户，也不是合法用户的历史连接。</strong></p>
<p>参与一条 TCP 连接中的两个进程中的任何一个都能终止该连接，当客户进程希望关闭连接时，会向服务器进程发送一个 FIN 标志位被置为 1 的特殊报文段（称为 FIN 报文段），当服务器接收到 FIN 报文段后，就向发送方回送一个 ACK 确认报文段，接着服务器终止前的处理处理工作准备好之后发送自己的 FIN 报文段（FIN 标志位被置为 1 ），接着客户对来自服务器的 FIN 报文段回送一个 ACK 确认报文段，等待一段时间（一般是两倍的最大报文生存时间 2MSL，确保网络中的所有剩余数据报文段都被丢弃，防止旧的数据报文段在之后的连接中引发混淆）后连接正式关闭，这就是 <strong>TCP 四次挥手</strong>，当连接结束时，客户和服务器中的关于该连接的资源都被释放。</p>
<p><strong>由于 TCP 是全双工通信，在主动关闭方停止发送数据并发送 FIN 报文段后，被动关闭方可能还要继续发送数据，被动关闭方接收到主动关闭方的 FIN 报文段后不能立即关闭被动关闭方到主动关闭方的数据通道，只能先回送一个 ACK 确认报文段，等自身无需再发送数据时再发送 FIN 报文段，所以才需要四次挥手。</strong></p>
<h3 id="3-2-3-流量控制"><a href="#3-2-3-流量控制" class="headerlink" title="3.2.3 流量控制"></a>3.2.3 流量控制</h3><p>一旦建立好一条 TCP 连接，两个应用进程之间就可以互相发送数据了，TCP 连接的每一端都有各自的<strong>发送缓存</strong>和<strong>接收缓存</strong>（在三次握手期间被设置）。客户进程通过套接字传递到运输层的数据流被 TCP 引导至 TCP 发送缓存中，TCP 在方便的时候会从发送缓存中取出长度小于等于 MSS 的应用层数据配上一个 TCP 首部就形成 TCP 报文段，TCP 报文段被传递到网络层，网络层将其封装在 IP 数据报中，然后这些数据报就被发送到网络中，当 TCP 在另一端接收到一个报文段后，该报文段的数据就被放入 TCP 接收缓存中。</p>
<p>相关联的应用进程会从 TCP 接收缓存中读取数据，但并不是数据刚一到达就立即读取，如果应用读取的数据比较缓慢，而发送方发送的数据太多太快，接收缓存就容易溢出，因此，发送方的发送速率需要与接收方应用程序的读取速率相匹配（<strong>流量控制</strong>）。TCP 报文段首部的<strong>接收窗口字段 rwnd</strong> 是接收方告知发送方关于自身剩余可用接收缓存空间大小的指示，发送方会令自身已发送但未 ACK 的数据量小于等于接收方的接收窗口，从而确保接收方接收缓存不会溢出，有个例外情况是，当接收方接收窗口为 0 时，发送方依旧向接收方发送一个只有一个字节数据的报文段，从而确保接收方在出现新的剩余缓存空间时能通过对该报文段发送 ACK 向发送方更新自身的接收窗口（接收方只有在有应用数据或者有 ACK 要发时才会发送报文段给发送方）。</p>
<h3 id="3-2-4-拥塞控制"><a href="#3-2-4-拥塞控制" class="headerlink" title="3.2.4 拥塞控制"></a>3.2.4 拥塞控制</h3><p>运输层向网络中发送报文段的速率越接近链路容量，平均时延就会越来越大甚至变为无穷大，即当分组的到达速率接近链路容量时，分组经历巨大的排队时延，因超时而导致的重传又会进一步加重网络负载，进一步导致时延增大甚至丢包，因此，除了流量控制，在网络拥塞时同样需要调整发送方的发送速率（<strong>拥塞控制</strong>）。因特网版本的 IP 层默认不提供明确的涉及网络拥塞的反馈，此时，TCP 采用<strong>端到端拥塞控制</strong>，端系统通过对网络行为的观察（如分组丢失）来推断拥塞程度，发送方将报文段的丢失（超时或 3 次冗余 ACK）以及往返时延的增加视作是网络拥塞的一个迹象，会相应地减小其拥塞窗口长度，减小其发送速率；发送方将首次接收到的 ACK 视作网络不拥塞的标志，会增加拥塞窗口长度，增加其发送速率（这样也是为了探测拥塞开始出现的速率）。</p>
<p>当一条 TCP 连接建立完成，cwnd 通常初始设置为一个 MSS，此时初始发送速率较小（大约为 MSS/RTT ），接着每当传输的报文段首次被 ACK 时，cwnd 的值就增加一个 MSS，并以新的 cwnd 值继续发送报文段（cwnd 以指数增长的速度不断翻倍），这就是<strong>慢启动状态</strong>。当存在一个<strong>以超时指示的丢包事件</strong>时，将慢启动域值 ssthresh 重设为 cwnd/2，并将 cwnd 重新设为一个 MSS，重新开始慢启动。每当 cwnd 达到 ssthresh 时进入<strong>拥塞避免状态</strong>，每次进入拥塞避免状态时，cwnd 的值是上次遇到拥塞时的值的一半（cwnd 不可以再继续翻倍），此时每当传输一个窗口大小的字节流中的所有报文段都被 ACK 时，cwnd 的值就增加一个 MSS，并以新的 cwnd 值继续发送总共一个窗口大小的多个报文段（cwnd 以线性增长的速度不断增加一个 MSS）。当存在一个<strong>以 3 个冗余 ACK 指示的丢包事件</strong>时，同样将 ssthresh 重设为 cwnd/2，但 cwnd 被设为一个 cwnd/2 + 3*MSS，进入<strong>快速恢复状态</strong>，接着，每当接收到一个冗余 ACK，cwnd 的值增加一个 MSS，一旦接收到丢失报文段的 ACK，cwnd 被重设为 ssthresh 并进入拥塞避免状态。</p>
<p>TCP 端到端拥塞控制方法就由慢启动、拥塞避免以及快速恢复这三个主要部分组成，核心思想是快速增加发送速率至丢包速率（慢启动/快速恢复），接着慢慢增加发送速率谨慎探测带宽（拥塞避免）。其中，慢启动和拥塞避免是 TCP 的强制部分，两者的差异在于对收到的 ACK 做出反应时增加 cwnd 的长度的方式，慢启动比拥塞避免能更快的增加 cwnd 的长度，快速恢复是推荐部分并非必需，如果不采用快速恢复，那么对于丢包事件的统一处理方式（不区分是以超时指示的还是以 3 个冗余 ACK 指示的）是将 ssthresh 重设为 cwnd/2，将 cwnd 重新设为一个 MSS，重新开始慢启动。将拥塞控制与流量控制相结合，TCP 发送方跟踪拥塞窗口变量 cwnd 和接收方的接收窗口变量 rwnd，<strong>并确保自身已发送但未 ACK 的数据量不会超过 cwnd 和 rwnd 之间的最小值</strong>。</p>
<p>基于 TCP 端到端拥塞控制方法，TCP 趋于在竞争的多条具备<strong>相同 RTT 的 TCP 连接之间提供对一段瓶颈链路带宽的平等分享</strong>（特殊情况是如果一个应用使用多个并行的 TCP 连接，那么该应用显然会获得链路中较大比例的带宽），而对于竞争的多条不同 RTT 的 TCP 连接来说，那些具有<strong>较小 RTT 的连接可以在链路空闲时较快地打开其拥塞窗口，更快的抢到可用带宽，享用更高的吞吐量</strong>。当端系统远离服务器数据中心时，RTT 会很大，会由于 TCP 慢启动潜在地导致低劣的响应时间，因此可以考虑部署邻近用户的前端服务器，客户向邻近前端连接一条 TCP 连接，并且该前端以非常大的窗口向数据中心维护一条 TCP 连接，这种基于前端服务器的 <strong>TCP 分岔</strong>可以分裂 TCP 连接，极大的改善远离数据中心的用户感受到的时延，也有助于减少因特接入网丢包引起的 TCP 重传时延，CDN 就是一个这样的执行 TCP 分岔前端服务器。</p>
<p>在一些<strong>网络辅助的 TCP 拥塞控制方法变种</strong>中，网络层 IP 数据报服务类型字段中有两个ECN 比特被用于指示该路由器是否正在历经拥塞，这种 IP 数据报将指示发送给目的主机，再由目的主机通知发送主机，发送方根据接收方的 TCP ACK 报文段中的 ECE 比特得知拥塞指示，做出相应处理（拥塞窗口减半），这种数据报拥塞控制协议提供了一种低开销的类似 UDP 的不可靠服务，在较早的阶段（报文段丢失前）就提前通知发送方拥塞要开始了，避免费时费力的丢包和重传。在一些<strong>基于时延的 TCP 拥塞控制方法变种</strong>中，发送方对所有 ACK 测量源到目的路径的 RTT，并记录一个最小的 RTT（视作没有拥塞的基准），当测量的 RTT 接近最小的 RTT 时，意味着发送速率可以继续增加，当测量的 RTT 远大于最小的 RTT 时，意味着处于拥塞，需要减小发送速率。</p>
<h1 id="4、网络层"><a href="#4、网络层" class="headerlink" title="4、网络层"></a>4、网络层</h1><h2 id="4-1-基本原理"><a href="#4-1-基本原理" class="headerlink" title="4.1 基本原理"></a>4.1 基本原理</h2><h3 id="4-1-1-数据-控制平面"><a href="#4-1-1-数据-控制平面" class="headerlink" title="4.1.1 数据/控制平面"></a>4.1.1 数据/控制平面</h3><p>网络层将报文段封装成数据报并向目的地发送，为不同主机提供逻辑通信。网络中每一台主机和路由器中都有一个网络层部分，每台主机和路由器都至少有一个网络层地址（IP 地址，是可以屏蔽物理地址差异的逻辑地址）。网络服务模型定义了分组在发送和接收主机之间的端到端传输特性以及网络层所能提供的服务特性，因特网的网络层提供了<strong>尽力而为服务</strong>这一单一的服务，即传送的分组不能保证它们的最终按序交付、端到端时延，以及占据最小带宽，这种尽力而为服务模型与适当带宽供给和带宽自适应应用级协议（如 DASH）的结合已被证明足够，能够用于大量的应用。</p>
<p>网络层可以被分解为两个相互作用的数据平面部分和控制平面部分，<strong>数据平面</strong>指网络层中每台路由器的功能，决定了到达路由器输入链路之一的数据报如何<strong>转发</strong>到该路由器的输出链路之一的（是路由器本地操作，通常用硬件来实现），涉及到基于数据报目的地址的传统的 IP 转发和基于数据报首部控制的通用的转发，数据报也可能被路由器<strong>阻挡</strong>（例如源主机是已知的恶意主机，目的主机是被禁止的主机，或者数据报是冗余的并经过多条链路发送等）；<strong>控制平面</strong>指网络范围的逻辑，不仅控制了数据报沿着从源主机到目的主机的端到端路径中路由器之间的路由方式（是网络范围处理，通常用软件实现），涉及到各种<strong>路由选择</strong>算法/协议，还控制网络层组件和服务如何配置和管理。</p>
<p>传统上，数据平面和控制平面在路由器中作为统一的整体一起实现，<strong>每台路由器中都可以包含转发和路由选择这两种功能</strong>，转发功能所涉及到的路由器关键元素是<strong>转发表</strong>，路由器检查到达分组首部的一个或多个字段值，这些值对应存储在转发表项中的值，进而可以使用这些首部值在其转发表中索引，找到该分组将被转发的路由器的输出链路接口；控制功能指路由器可以运行<strong>自己的路由选择算法</strong>，此时单个路由器中的路由选择算法会通过路由选择协议与其他路由器中的路由选择算法通信（交换包含路由选择信息的选择报文），以计算出它的转发表的值，从而决定插入该路由器转发表的内容；路由器转发表的内容也可以人工配置，此时路由器无需自己执行路由选择算法，除了人工配置以外，还可以使用<strong>软件定义网络 SDN</strong> 作为一个远程控制器来控制每台路由器的转发表，此时控制平面的路由选择功能作为一种单独服务，与物理的路由器是分离的，即路由选择设备仅执行转发，而远程控制器计算并分发转发表，数据平面和控制平面是分离的（SDN 可能实现在具有高可靠性和冗余的远程数据中心中，并可能由 ISP 或某第三方管理和改进）。</p>
<h3 id="4-1-2-路由器组成-功能"><a href="#4-1-2-路由器组成-功能" class="headerlink" title="4.1.2 路由器组成/功能"></a>4.1.2 路由器组成/功能</h3><p>路由器由输入端口、输出端口、交换结构以及路由选择处理器这四种组件组成，输入输出端口是指物理端口，而非软件 API（企业路由器具有数量较少的端口，位于某 ISP 边缘的路由器具有极多的端口），路由器的输入输出端口和交换结构所具备的功能几乎总是用硬件实现，而路由选择处理器所具备的功能是由软件实现的。</p>
<ul>
<li><strong>输入端口</strong><ul>
<li>执行终结入物理链路的物理层功能，与位于入链路远端的数据链路层交互的数据链路层功能，还要执行查找功能确定分组的输出端口</li>
<li>输入端口必须对分组进行物理层和链路层处理，接着会检查分组的版本号、检验和、以及寿命字段，重写后两个字段，更新用于网络管理的计数器（如接收到的 IP 数据报的数目）</li>
<li>一个分组的转发基于分组的目的地址和分组的首部字段来决定，对于携带了路由选择协议信息的控制分组，输入端口会将其转发到路由选择处理器，对于非控制分组，输入端口会基于分组的目的地址和最长前缀匹配来查询转发表决定分组输出端口并发送进交换结构（“匹配加操作”抽象）</li>
<li>输入端口基于转发表在每个线路卡的影子副本，在本地即可做出转发决策，无须基于每个分组调用集中式路由选择处理器，避免了集中式处理的瓶颈</li>
<li>如果有分组当前正在使用交换结构，那么后面的分组可能会在进入交换结构时被暂时阻塞，一个被阻塞的分组必须要在输入端口处排队，等待稍后被及时调度以通过交换结构</li>
</ul>
</li>
<li><strong>交换结构</strong><ul>
<li>完全包含在路由器之中，位于路由器的核心部位，是路由器中的网络</li>
<li>接收由输入端口发送的已确定输出端口的分组，并将其交换/转发到输出端口，交换可以通过内存交换、经单一共享总线交换以及经互联网交换等技术实现</li>
<li>经内存交换就像是操作系统中的 I/O 操作一样，由于一次仅能执行一个内存读写，不能同时转发多个分组；经单一共享总线交换，同样由于一次只能有一个分组跨越总线，不能同时转发多个分组；经互联网交换可以看作是有多条总线，只要输出端口不同，就允许同时转发多个分组</li>
</ul>
</li>
<li><strong>输出端口</strong><ul>
<li>存储从交换结构接收到的分组，在排队后通过执行必要的链路层和物理层功能在输出链路上传输这些分组（当一条链路是双向的时，输出端口通常与该链路的输入端口成对出现在同一线路卡上）</li>
<li>输入端口和输出端口都可以形成分组队列，排队的位置和程度将取决于流量负载、交换结构的相对速率和线路速率，出入队的规则取决于具体的分组调度机制（可以为不同类别的流量提供不同级别的服务）</li>
<li>随着队列的增长，路由器的缓存空间将会耗尽，一旦耗尽，就会出现丢包，更大的缓存使得路由器有能力承受分组到达率的更大波动，降低分组丢失率，但也意味着更长的排队时延，更低的 TCP 发送速率</li>
</ul>
</li>
<li><strong>路由选择处理器</strong><ul>
<li>通常是一种传统的 CPU，执行控制平面功能和网络管理功能</li>
<li>在传统的路由器中，路由选择处理器执行路由选择协议，维护路由选择表与关联链路状态信息，并为该路由器计算转发表</li>
<li>在 SDN 路由器中，路由选择处理器负责与远程控制器通信，接收由远程控制器计算的转发表项</li>
<li>经独立总线将转发表复制到输入输出线路卡，即在该路由器的输入端口安装这些表项</li>
</ul>
</li>
</ul>
<h3 id="4-1-3-路由选择算法"><a href="#4-1-3-路由选择算法" class="headerlink" title="4.1.3 路由选择算法"></a>4.1.3 路由选择算法</h3><p>路由选择算法的一些分类方式如下</p>
<ul>
<li>分为集中式路由选择算法和分散式路由选择算法<ul>
<li>集中式路由算法由一个具备完整全局网络状态知识（连通性和链路开销）的集中点来计算出从源到目的地之间的最低开销路径，这种具备全局状态信息的算法常被称作链路状态算法（LS 算法），LS 算法通过令每个节点<strong>向网络中所有其他节点广播自身与邻居节点的直接链路开销</strong>，保持网络拓扑和链路开销被所有节点已知</li>
<li>分散式路由选择算法由各个路由器以迭代、信息交换、分布式的方式计算出最低开销路径，每个节点仅有与其直接相连链路的开销知识即可开始工作，距离向量算法（DV 算法）就是一种分散式路由选择算法，DV 算法令每个节点维护自身到网络中所有其他节点的距离向量并<strong>向邻居节点发送自身与网络中所有节点的距离向量</strong>，节点会根据从邻居接收到的距离向量来更新自身的距离向量</li>
<li>LS 算法无论何时一条链路开销改变时，都必须向所有节点发送新的链路开销，DV 算法仅当新的链路开销导致与该链路相连节点的最低开销路径发生变化时，才传播已改变的链路开销；LS 算法收敛速度快，DV 算法收敛速度慢，且在收敛时会遇到路由选择环路以及无穷计数问题</li>
</ul>
</li>
<li>分为静态路由选择算法和动态路由选择算法<ul>
<li>静态路由选择算法由于路由随时间的变化非常缓慢，通常是人工进行配置</li>
<li>动态路由选择算法随着网络流量负载或拓扑发生变化而运行，同时也更容易受诸如路由选择循环、路由振荡之类问题的影响</li>
</ul>
</li>
<li>分为负载敏感算法和负载迟钝算法<ul>
<li>负载敏感算法会通过链路开销动态变化以反映出底层链路的当前拥塞水平，并趋向于避开高开销的拥塞链路</li>
<li>当今的因特网路由选择算法都是负载迟钝的，链路的开销不明确反映该链路的近期拥塞水平</li>
</ul>
</li>
</ul>
<h3 id="4-1-4-OSPF-和-BGP"><a href="#4-1-4-OSPF-和-BGP" class="headerlink" title="4.1.4 OSPF 和 BGP"></a>4.1.4 OSPF 和 BGP</h3><p>由于如今因特网主机和路由器数目巨大，涉及路由选择信息的通信、计算和存储的开销高得不可实现，考虑将路由器组织进<strong>自治系统（AS）</strong>，一个 AS 由其全局唯一的 AS 号所标识，每个 AS 由一组通常处在相同管理控制下的路由器组成，位于 AS 边缘的是<strong>网关路由器</strong>，其余的是<strong>内部路由器</strong>，网关路由器直接连接自身 AS 的内部路由器和其他 AS 的网关路由器，内部路由器仅连接自身 AS 的主机和路由器。可以将一个 ISP 中的一组路由器作为一个 AS，此时 ISP 可以很方便地按自己的意愿在网络中运行它所选择的某种路由选择算法，对外部隐藏自己网络的内部组织面貌，也具备能将自身网络与其他外部网络连接起来的能力，某些 ISP 还会将自身网络划分为多个互联的 AS。</p>
<p>在同一 AS 中的所有路由器都运行相同的路由选择算法并且有彼此的信息，在一个 AS 中运行的路由选择算法叫做自治系统内部路由选择协议，<strong>开放最短路优先（OSPF）</strong>路由选择协议是一种 LS 协议，被广泛用于因特网的 <strong>AS 内部路由选择</strong>。基于 OSPF，一台路由器构建了关于整个 AS 系统的完整拓扑图并在本地运行 Dijkstra 的最短路径算法，以确定一个以自身为根节点到所有子网的最短路径树（各链路开销由网络管理员配置），路由器周期性地（以及某条链路状态发生变化时）向 AS 系统中所有其他路由器广播路由选择信息，OSPF 报文直接由 IP 承载，OSPF 协议需要自己实现诸如邻居是否可达、可靠报文传输、链路状态广播、路由器信任鉴权等功能。</p>
<p>不同 AS 的通信必须运行相同的 AS 间路由选择协议，用于跨越多个 AS 的路由选择算法叫做自治系统间路由选择协议，<strong>边界网关协议（BGP）</strong>是一种类似于 DV 协议的分布式和异步的协议，被广泛用于因特网的<strong>多个 AS 之间的路由选择</strong>，比如互联数以千计的 ISP 网络（常被称为因特网的黏合剂）。在 BGP 中，分组并不是路由到一个特定的目的地址，而是路由到一个子网或一个子网的集合，每个子网都可以向因特网的其余部分通告它的存在，每个 AS 从邻居 AS 获得关于某个子网的可达性信息从确保每个子网被所有 AS 已知，每对路由器通过使用 179 端口的半永久 TCP 连接交换路由选择信息，一个 AS 可能已知多条到达特定子网的不同路由，AS 会在本地运行一个 BGP 路由选择过程来确定最好的路由。</p>
<p><strong>AS 内部路由选择是面向性能的</strong>，一切都是在相同的管理控制名义下进行的，不需要考虑策略问题，也不需要太关注可扩展性，一旦一个 AS 区域变得太大则可以将其分成多个 AS 并在新的 AS 之间执行 AS 间路由选择，<strong>AS 间路由选择是面向策略的</strong>，比如要求一个给定 AS 产生的流量不允许穿过另一个特定 AS 等策略问题，此时路由性能反而是次要问题。</p>
<h2 id="4-2-数据平面协议"><a href="#4-2-数据平面协议" class="headerlink" title="4.2 数据平面协议"></a>4.2 数据平面协议</h2><h3 id="4-2-1-网际协议"><a href="#4-2-1-网际协议" class="headerlink" title="4.2.1 网际协议"></a>4.2.1 网际协议</h3><p>因特网网络层只有网际协议（IP 协议）这一个协议，IP 协议的服务模型是尽力而为的交付服务，但并不做任何确保。IP 协议版本 4 简称为 IPv4，对于 IPv4 来说，每个 IP 地址长度为 32 比特/4 字节，通常按点分十进制记法书写，即每个字节用它的十进制形式，各字节间以句点隔开，但由于新的子网和 IP 节点以惊人的增长率连接到因特网上，32 比特的 IP 地址即将用尽，因此研发了 IP 协议版本 6（简称为 IPv6）。IPv6 将 IP 地址长度增加到了 128 比特/16 字节，通常按冒号分十六进制记法书写，即每两个字节为一组，一组用4个十六进制数书写（一个十六进制数表示 4 比特位），各组间以冒号隔开，IPv6 在 IP 数据报中加入了流标签（便于为不同的流提供不同的服务），并在单播和多播地址的以外引入了任播地址，任播地址可以使数据交付给一组主机中最近的（“最近的”由 BGP 路由选择算法所确定）那一个，比如将 DNS 请求路由到一组根 DNS 服务器中最近的一个。</p>
<p>IPv4 数据报中的关键字段为：版本号（规定了 IP 协议版本）、首部长度（用于确定载荷实际开始的地方）、服务类型（便于确定流量服务等级）、数据报长度（首部加上数据的总长度）、与 IP 分片有关的标识、标志、片偏移字段、寿命（确保数据报不会永远在网络中循环）、协议号（指示数据部分应交付给哪个运输层协议）、首部检验和（帮助路由器检测数据报首部中的比特错误）、源 IP 地址、目的 IP 地址、选项字段（可选，允许 IP 首部被扩展，这也导致首部长度可变）、数据（有效载荷，包含需要交付的运输层报文段）。IPv6 数据报在 IPv4 数据报的基础上增加了流量类型、流标签、有效载荷长度、跳限制，去掉了片偏移（IPv6 不允许在路由器上对 IP 数据报进行分片）、首部检验和以及选项（不允许 IP 首部被扩展，首部长度固定）字段，因此 IPv6 报头比 IPv4 更简单。IPv4 使用 ARP 来查找与 IPv4 相关联的 MAC 地址，IPv6 使用 ICMPv6 将查找 MAC 地址的功能嵌入到 IP 自身作为无状态自动配置和邻居节点发现算法的一部分（不存在 ARP6），IPv6 使能系统能够兼容 IPv4，即能发送、路由和接收 IPv4 数据报，但已部署的 IPv4 使能系统不能够处理 IPv6 数据报。</p>
<p>一台主机通常只有一条链路连接到网络来发送该主机的 IP 数据报，路由器则至少有两个或更多条链路与自身相连，主机/路由器与物理链路之间的边界叫做接口，<strong>一个接口与一个全球唯一的 IP 地址相关联（IP 地址并不是与包括该接口的主机或路由器相关联）</strong>，因此，主机通常有一个 IP 地址，而路由器则至少有两个或更多的 IP 地址。IP 地址并不是自由选择的，一个接口的 IP 地址的一部分需要由其连接的子网（也称为 IP 网络）来决定，分开主机和路由器的每个接口，所产生的一些隔离的网络中的每一个都叫做一个子网，一个具有以太网段和点对点链路的组织将具有多个子网。</p>
<h3 id="4-2-2-动态主机配置协议"><a href="#4-2-2-动态主机配置协议" class="headerlink" title="4.2.2 动态主机配置协议"></a>4.2.2 动态主机配置协议</h3><p>因特网的地址分配策略称为无类别域间路由选择（CIDR），CIDR 将 IP 地址划分为两部分，第一部分是 IP 地址的网络前缀，第二部分用于区分组织内部设备，同一组织内部设备的 IP 地址共享相同的<strong>网络前缀</strong>，此时无须关心该组织内部是否还细分有不同的子网，只需根据该网络前缀来统一标识该组织（包括组织内部的多个网络），这称为地址聚合/路由聚合/路由摘要。因特网名字和编号分配机构（ICANN）向 ISP 分配 IP 地址和 AS 号、管理 DNS 根服务器、分配域名以及解决域名纷争，当一个组织希望获取一块 IP 地址块时，可以首先与该组织的 ISP 联系，由 ISP 从自身的大地址块中提供一些地址给该组织。</p>
<p><strong>动态主机配置协议（DHCP 协议）</strong>具有将主机连接到一个网络的网络相关方面的自动化能力（常被称为即插即用协议或零配置协议），广泛用于住宅因特网接入网、企业网、无线局域网这种主机频繁加入和离开的网络。一旦组织获得了一块地址，就可以通过 DHCP 为本组织内的主机与路由器接口分配 IP 地址（也可以通过网络管理工具来手工逐个配置），DHCP 允许主机自动获取一个 IP 地址以及其他信息，例如它的子网掩码、第一跳路由器地址（常称为默认网关）、本地 DNS 服务器地址等，此外，网络管理员也能够通过配置 DHCP 来令某给定主机每次与网络连接时能得到一个相同的 IP 地址，或者令某主机每次都被分配一个不同的临时的 IP 地址。</p>
<p>DHCP 是一个基于 <strong>UDP</strong> 的 <strong>C/S 结构</strong>的应用层协议，每个子网都具有一台 DHCP 服务器或一个 DHCP 中继代理，客户指新到达网络的主机，它的首要任务是通过源地址为 0.0.0.0 目的地址为广播地址 255.255.255.255 的 <strong>DHCP 发现报文</strong>来尝试发现一个与自身交互的 DHCP 服务器，DHCP 服务器收到一个 DHCP 发现报文后，使用 <strong>DHCP 提供报文</strong>（包含收到的发现报文的事务 ID、向客户推荐的 IP 地址、网络掩码、IP 地址租用期/有效时间量）向该子网的所有节点广播，客户从一个或多个 DHCP 服务器响应中选择一个，并向选中的 DHCP 服务器用 <strong>DHCP 请求报文</strong>进行响应，回显配置的参数，DHCP 服务器使用 <strong>DHCP ACK 报文</strong>再次进行响应，证实所要求的参数，一旦客户收到 DHCP ACK 后，交互便完成了，客户获得了包括自身使用的 IP 地址在内的网络配置信息。</p>
<p><strong>网络地址转换（NAT）</strong>运行在网络层并具有与路由器十分不同的功能，可支持超过 60000 个并行使用路由器 WAN 端单个 IP 地址的连接，NAT 使能的路由器运行一个 DHCP 服务器，该 DHCP 服务器为该路由器的所有接口都提供一个一致的对外的单一 IP 地址，并为该路由器控制的专用网络中的设备提供 IP 地址（专用网络中的设备 IP 仅对该网络中的设备有意义，不同专用网络中的 IP 地址空间就可以有重合）。该路由器对外界的行为就如同一个具有单一 IP 地址的单一设备，而不像是一台路由器，所有离开该路由器流向更大因特网的数据报都以该路由器的单一 IP 地址作为统一的源 IP 地址，所有进入该路由器所控制的专用网络的数据报都以该路由器的单一 IP 地址作为统一的目的 IP 地址，该路由器通过维持一张<strong>记录着路由器单一 IP、端口号（WAN 端）和路由器所控制的专用网络设备 IP、端口号（LAN 端）之间的映射的 NAT 表</strong>来确定应将流入的分组转发给哪个网络内部设备。</p>
<h2 id="4-3-控制平面协议"><a href="#4-3-控制平面协议" class="headerlink" title="4.3 控制平面协议"></a>4.3 控制平面协议</h2><h3 id="4-3-1-OpenFlow-协议"><a href="#4-3-1-OpenFlow-协议" class="headerlink" title="4.3.1 OpenFlow 协议"></a>4.3.1 OpenFlow 协议</h3><p>路由器的传统转发通过匹配目的地址来将分组转发到路由器的一个输出端口，<strong>泛化转发</strong>通过匹配涉及各种不同协议的多个首部字段，将分组转发到路由器的一个或多个输出端口、跨越多个通向服务的离开接口进行负载均衡、像 NAT 这样重写首部值、像防火墙这样阻挡/丢弃某个分组等、像 CDN 这样进行 TCP 分岔、像 Web 缓存这样的内容缓存等，即在路由器的传统转发功能的基础上增加了一些<strong>中间盒功能</strong>。由于泛化转发的匹配策略可能使用网络层或链路层的源地址和目的地址，所以使用泛化转发的设备被更准确地描述为<strong>分组交换机</strong>（简单但快速的设备），而不是网络层的路由器或链路层的交换机，泛化转发所涉及的匹配加操作是基于分组交换机中的一张匹配加操作表完成的，匹配加操作表由远程<strong>逻辑集中控制器</strong>计算、安装和更新，逻辑集中是指即使出于容错和性能扩展的原因设置多个分布式服务器，但这些服务器从外部依旧被看作是单一的整体式服务点。</p>
<p><strong>OpenFlow 协议</strong>开创并引领了匹配加操作转发抽象和 SDN 控制器功能抽象，是最早的也是现在仍在使用的用于 SDN 控制器与被控设备之间的基于 TCP 的通信协议。匹配加操作表在 OpenFlow 中称为<strong>流表</strong>，流表可以看作是一个用于编程分组交换机行为（进而编程网络范围的行为）的 API 抽象，流表的每个表项包括首部字段值的集合、计数器集合、操作集合（转发、丢弃、修改字段等）。入分组会与流表项的首部字段值进行匹配，匹配不上的分组则被丢弃或发送到远程控制器，匹配上的流表项的计数器会被更新，并对分组执行该流表项所指定的操作，分组匹配多个流表项时会选择优先权最高的流表项作为匹配结果。<strong>从 SDN 控制器流向受控设备的报文</strong>有配置报文（允许控制器查询并设置交换机的配置参数）、修改状态报文（用于增加/删除交换机中的流表项以及设置交换机端口特性）、读状态报文（用于控制器统计交换机的数据）、发送分组报文（用于受控交换机向控制器发送信息，比如删除流表项、端口状态变化以及接收到无法与任务流表项匹配的分组）。</p>
<p>当受控设备只需与 SDN 控制器通信并按控制器命令行事，各个受控设备之间既不直接相互交互，也不主动参与计算流表时，数据平面与控制平面相互分离，<strong>数据平面由分组交换机组成</strong>，各个分组交换机在各种的流表中执行“匹配加操作”的规则，<strong>控制平面由逻辑集中的 SDN 控制器以及若干可编程的网络控制应用程序组成</strong>，计算、管理和安装所有分组交换机中的流表项，通过可编程的应用程序，可以很方便地修改路由选择算法，生成更新后的流表项并安装到受控设备中，调整受控设备在接收到分组后所采取的匹配方式和操作内容。</p>
<h3 id="4-3-2-网际控制信息协议"><a href="#4-3-2-网际控制信息协议" class="headerlink" title="4.3.2 网际控制信息协议"></a>4.3.2 网际控制信息协议</h3><p>因特网控制报文协议（ICMP）用于主机和路由器之间沟通网络层信息，ICMP 协议在体系结构上位于 IP 协议之上，ICMP 报文是作为有效载荷承载在 IP 分组中的，ICMP 报文中含有类型字段、编码字段以及引起该 ICMP 报文首次生成的 IP 数据报的首部和前 8 个字节（以便发送方能确定引发该差错的数据报）。如当路由器无法找到一条通往目的主机的路径时就会生成一个类型 3 编码 1 的 ICMP 报文并发送给源主机从而告知目的主机不可达），用于需要测试某个主机是否可达的 ping 程序就是发送一个 ICMP 类型 8 编码 0 的回显请求报文到指定主机，目的主机发回一个类型 0 编码 0 的 ICMP 回显回答报文（ping 程序并不是一个进程，可以直接由操作系统支持，是一个应用层直接使用网络层协议而不使用运输层协议的例子）。</p>
<table>
<thead>
<tr>
<th align="center"></th>
<th align="center"></th>
<th align="center"></th>
<th align="center"></th>
<th align="center"></th>
<th align="center"></th>
</tr>
</thead>
<tbody><tr>
<td align="center">ICMP 类型</td>
<td align="center">编码</td>
<td align="center">描述</td>
<td align="center">ICMP 类型</td>
<td align="center">编码</td>
<td align="center">描述</td>
</tr>
<tr>
<td align="center">0</td>
<td align="center">0</td>
<td align="center">回显回答（对 ping 的回答）</td>
<td align="center">3</td>
<td align="center">0</td>
<td align="center">目的网络不可达</td>
</tr>
<tr>
<td align="center">3</td>
<td align="center">1</td>
<td align="center">目的主机不可达</td>
<td align="center">3</td>
<td align="center">2</td>
<td align="center">目的协议不可达</td>
</tr>
<tr>
<td align="center">3</td>
<td align="center">3</td>
<td align="center">目的端口不可达</td>
<td align="center">3</td>
<td align="center">6</td>
<td align="center">目的网络未知</td>
</tr>
<tr>
<td align="center">3</td>
<td align="center">7</td>
<td align="center">目的主机未知</td>
<td align="center">4</td>
<td align="center">0</td>
<td align="center">源抑制（拥塞控制）</td>
</tr>
<tr>
<td align="center">8</td>
<td align="center">0</td>
<td align="center">回显请求（ping 命令发出的请求）</td>
<td align="center">9</td>
<td align="center">0</td>
<td align="center">路由器通告</td>
</tr>
<tr>
<td align="center">10</td>
<td align="center">0</td>
<td align="center">路由器发现</td>
<td align="center">11</td>
<td align="center">0</td>
<td align="center">TTL 过期</td>
</tr>
<tr>
<td align="center">12</td>
<td align="center">0</td>
<td align="center">IP 首部损坏</td>
<td align="center"></td>
<td align="center"></td>
<td align="center"></td>
</tr>
</tbody></table>
<h3 id="4-3-3-简单网络管理协议"><a href="#4-3-3-简单网络管理协议" class="headerlink" title="4.3.3 简单网络管理协议"></a>4.3.3 简单网络管理协议</h3><p><strong>网络管理</strong>包括了硬件、软件和人类元素的设置、综合和协调，以监视、测试、轮询、配置、分析、评价和控制网络及网元资源，用合理的成本满足实时性、运营性能和服务质量的要求。<strong>管理服务器</strong>是一个运行在集中式网络管理工作站上的应用程序，通常需要网络管理员的参与，从而执行网络管理活动，控制网络管理信息与命令的收集、处理、分析及显示，发起配置、监视和控制网络的被管设备的操作，一个网络可能由几个这样的管理服务器。<strong>被管设备</strong>是驻留在被管网络上的某种网络设备（包括它的软件），可能是主机、路由器、交换机、中间盒、调制解调器、温度计或其他联网设备。<strong>网络管理代理</strong>是运行在被管设备上的一个软件进程，它与管理服务器通信，在管理服务器的命令和控制下载被管设备上执行本地操作。<strong>网络管理协议</strong>运行在管理服务器和被管设备之间，允许管理服务器查询被管设备的状态，并经过其代理间接地在这些被管设备上执行操作，与此同时，代理能够使用网络管理协议向管理服务器通知异常事件（网络管理协议自身并不具备管理网络的能力，只是辅助管理服务器和网络管理员进行网络管理）。</p>
<p>简单网络管理协议（SNMP）是一个应用层协议，用于在管理服务器和网络管理代理之间传递网络管理控制和信息报文，通常是基于 UDP 的。SNMP 最常用的事请求响应模式，SNMP 管理服务器向 SNMP 代理发送一个用于查询或修改的请求，代理接收到请求后执行某些操作，然后对请求发送一个回答，此外，SNMP 的第二种功能是代理向管理服务器发送陷阱报文（非请求报文），通知管理服务器一个异常情况（比如一个链路接口启动或关闭），陷阱报文是异步产生的，即它们不是为了响应接收到的请求，而是为了响应管理服务器需求通告的事件，代理发出陷阱报文并不要求从管理服务器得到响应。</p>
<p><a href="https://www.yuque.com/hollis666/niq4hm/us7bsygf7z1ocgd5">排查网络问题</a></p>
<h1 id="5、链路层"><a href="#5、链路层" class="headerlink" title="5、链路层"></a>5、链路层</h1><h2 id="5-1-基本原理"><a href="#5-1-基本原理" class="headerlink" title="5.1 基本原理"></a>5.1 基本原理</h2><h3 id="5-1-1-链路层协议"><a href="#5-1-1-链路层协议" class="headerlink" title="5.1.1 链路层协议"></a>5.1.1 链路层协议</h3><p>链路层的任务是在相同链路或局域网之间更局域化地移动分组（链路层帧），在大多数情况下，链路层大部分是在称为<strong>网络适配器的硬件芯片</strong>（也称为网络接口控制器 NIC）上实现的，但有部分是在<strong>运行于主机 CPU 上的软件</strong>中实现的，即软件和硬件的结合体，是协议栈中软件和硬件交接的地方。在发送端，控制器取得了由网络层生成并存储在主机内存中的数据报，在链路层帧中封装该数据报（填写帧的各个字段），遵循链路接入协议将该帧传进通信链路中，在接收端，控制器接收了整个帧，抽取出网络层数据报，链路层的软件组件会组装链路层寻址信息、激活控制器硬件、响应控制器中断、处理差错条件和将数据报向上传递给网络层。</p>
<p>运行链路层协议的任何设备均可称为<strong>节点</strong>，节点包括主机、路由器、交换机和 WiFi 接入点，连接相邻节点的通信信道称为<strong>链路</strong>，主要的链路层信道可分为广播信道和点对点信道，<strong>广播信道</strong>常用于连接无线/有线局域网、卫星网和混合光纤同轴电缆接入网中的多台主机，多台发送方和接收方使用相同的、单一的、共享的广播信道，<strong>点对点信道</strong>经常出现在诸如长距离链路连接的两台路由器之间或用户办公室计算机与邻近以太网交换机之间，信道的一端仅有一个发送方、另一端仅有一个接收方。</p>
<p>点对点协议（PPP）和高级数据链路控制（HDLC）协议都是为点对点链路设计的，而在使用广播链路时，多个发送节点同时通过广播信道传输帧时就会在接收节点处发生<strong>碰撞</strong>，此时没有一个接收节点能够有效地获得任何传输的帧，涉及此次碰撞的所有帧都丢失了，需要通过<strong>多路访问控制（MAC）协议</strong>来协调多个发送接收节点对一个共享广播信道的访问/帧传输问题。多路访问协议应该是简单的、实现代价低的、去中心化的、节点公平共享带宽且不浪费带宽的，可划分为信道划分协议（TDMA、FDMA、CDMA）、随机接入协议（ALOHA、CSMA）、轮流协议（蓝牙轮询协议、令牌传输协议），以太网是一种流行并广泛部署的 CSMA 协议。</p>
<p>链路层协议提供的<strong>可能服务</strong>包括成帧、链路接入、可靠交付以及差错检测和纠正。几乎所有的链路层协议都会将网络层数据报用链路层帧封装起来，帧的结构取决于具体链路层协议；MAC 协议规定了帧在链路上传输的规则，点对点链路的 MAC 协议比较简单甚至不存在，MAC 协议主要用于多个节点共享单个广播链路（多路访问）情况下的帧传输；链路层同样可以通过确认和重传来实现可靠交付，通常用于易于产生高差错率的无线链路，而对于低比特差错的光纤、同轴电缆等链路来说，可靠交付是一种不必要的开销。</p>
<h3 id="5-1-2-差错检测和纠正"><a href="#5-1-2-差错检测和纠正" class="headerlink" title="5.1.2 差错检测和纠正"></a>5.1.2 差错检测和纠正</h3><p>差错检测和纠正要保护的数据是网络层数据报和链路帧首部，接收方检测和纠正差错的能力被称为<strong>前向纠错 FEC</strong>，FEC 可以减少所需的发送方重发次数，降低时延，通常用于如音频 CD 这样的音频存储和回放设备中，但即便采用了差错检测，接收方依旧有可能没能检测出实际存在差错，差错检测方案致力于令这种可能性概率降低，一般方案越复杂，开销越大，这种可能性越低。</p>
<p>单个<strong>奇偶校验</strong>位是最简单的差错检测方式，发送方附加一个比特，使得初始信息加上这个校验比特中 1 的总数始终是偶数，接收方只需验证接收到的比特中 1 的个数即可（此时无法检测出偶数个比特差错），对每行和每列计算奇偶值的二维奇偶校验令接收方不仅可以检测到出现了单个比特差错，还可以利用存在奇偶检验差错的列和行的索引来实际识别单个差错比特并纠正它，此外还能检测（但不能纠正）偶数个比特差错。<strong>检验和</strong>是指将数据作为 16 比特的整数对待并求和，求和结果的反码作为携带在报文段首部的因特网检验和，接收方通过对接收的数据（包括检验和）的和取反码，检测结果一旦出现 0 则代表出错，TCP 和 UDP 的检验和只用了 16 比特，计算开销不大，是相对较弱的差错保护。<strong>循环冗余检测（CRC）</strong>是现今计算机网络中广泛应用的差错检测技术，对要发送的数据比特串进行算术操作生成多项式，在适配器中用专用的硬件实现，能够执行更加复杂的计算，是比检验和更强的差错保护。</p>
<h2 id="5-2-链路层寻址"><a href="#5-2-链路层寻址" class="headerlink" title="5.2 链路层寻址"></a>5.2 链路层寻址</h2><h3 id="5-2-1-链路层地址"><a href="#5-2-1-链路层地址" class="headerlink" title="5.2.1 链路层地址"></a>5.2.1 链路层地址</h3><p>主机和路由器的每个网络接口/适配器都具有一个与之相关联的<strong>链路层地址（又称 LAN 地址、物理地址、MAC 地址）</strong>，MAC 地址的长度为 6 字节，通常用十六进制表示法，每个字节被表示为一对十六进制数，MAC 地址具有扁平结构，忽略软件作用的前提下，MAC 地址可以看作是固定不变且唯一的（不同于 IP 地址的层次结构，随着连接网络的变化而变化）。位于链路层的交换机通过 MAC 地址来交换链路层帧（这个过程中并不识别网络层 IP 地址），由于<strong>链路层交换机的任务只是在主机和路由器之间透明地承载数据报，主机和路由器不必明确地将帧寻址到其间的交换机，因此链路层交换机本身并不具有与自身网络接口相关联的 MAC 地址</strong>，与此同时，这些帧到达交换机的任何输出接口之一的速率可能会暂时超过该接口的链路容量，因此交换机的输出接口设有缓存功能，这也令交换机的聚合带宽是该交换机所有接口速率之和，提供了比使用广播链路局域网高得多的性能改善。</p>
<p>当一台链路层交换机将一个入帧广播到它的所有接口时，<strong>一个适配器（可能是主机/路由器/链路层交换机）都可以接收到一个并非向它寻址的帧</strong>；当主机/路由器接收到一个入帧时，将检查该帧中的目的 MAC 地址，若与自身 MAC 地址或 MAC 广播地址（48 个连续的 1）匹配则沿协议栈向上传递，否则直接丢弃该帧；当一台链路层交换机接收到一个入帧时（<strong>会在交换机表中存储关于该入帧的表项</strong>），交换机查询交换机表中是否存在对应该帧目的 MAC 地址的表项，若不存在这样的表项则继续向除了接收该帧的输入接口之外的所有接口的广播该帧的副本，若存在这样的表项且该表项显示与该帧目的 MAC 地址相关联的接口就是接收该帧的输入接口则直接丢弃该帧，若存在这样的表项且表项显示存在其他与该帧目的地址相关联的接口则向该接口输出该帧的副本（<strong>交换机将链路彼此隔离，局域网中的不同链路能够以不同的速率运行并且能够在不同的媒介上运行</strong>）。</p>
<h3 id="5-2-2-地址解析协议"><a href="#5-2-2-地址解析协议" class="headerlink" title="5.2.2 地址解析协议"></a>5.2.2 地址解析协议</h3><p>当发送方主机/路由器需要向另一个主机/路由器发送一个数据报时，需要根据数据报的目的 IP在数据报封装帧中包含目的 IP 所对应的 MAC 地址。<strong>地址解析协议（ARP）</strong>用于根据 IP 地址解析得到其对应的 MAC 地址，仅服务于同一个子网上的主机和路由器接口，既可以看作是链路层协议，也可以看作是网络层协议。每台主机或路由器在其内存中具有一个 ARP 表，ARP 表包含 IP 地址到 MAC 地址的映射关系，单台主机或路由器中的表中的映射可能并不全或过期。</p>
<p>当源和目的地位于不同子网时，即便知道目的 IP 所对应的 MAC 地址，也不能在数据报封装帧中使用目的主机的 MAC 地址，否则发送方所在子网中的所有适配器都会由于自身 MAC 地址与帧的目的 MAC 不匹配而会直接丢弃该帧，此时应当在数据报封装帧中使用路由路径上的第一跳路由器的 MAC 地址，即<strong>发送方主机不可能通过一个链路直接将数据报发送给其他子网上的主机，至少应该先发送给当前子网中的路由器</strong>。当源和目的地位于同一子网时，若发送方从自身的 ARP 表中找不到目的 IP 所对应的 MAC 地址，发送方则构造一个 <strong>ARP 分组</strong>，发送方的适配器在链路层将这个 ARP 分组封装成帧并使用 MAC 广播地址作为帧的目的地址，从而询问子网上的所有其他主机和路由器，因此 ARP 是一种广播协议（RARP 不是），只有目标主机会响应这个广播请求。ARP 查询分组和响应分组具有相同的格式，都包含有源和目的的 IP 地址和 MAC 地址，区别在于 <strong>ARP 查询分组封装在一个广播帧中，而 ARP 响应分组封装在一个标准帧中</strong>。</p>
<h3 id="5-2-3-Web-页面请求"><a href="#5-2-3-Web-页面请求" class="headerlink" title="5.2.3 Web 页面请求"></a>5.2.3 Web 页面请求</h3><p>客户端主机通过一根以太网电缆连接到某个以太网交换机，以太网交换机与局域网的网关路由器相连，NAT 使能的网关路由器运行一个 DHCP 服务器，路由器还与一个 ISP 连接，ISP 中存在 DNS 服务器，因此 ISP 可以为这个局域网提供 DNS 服务。</p>
<p>客户端主机与网络连接时，运行主机本地的 DHCP 服务器生成 DHCP 请求报文，包含 DHCP 请求的广播以太网帧是客户端主机发出的第一个发送到以太网交换机的帧，该交换机在所有的出端口（包括连接到网关路由器的端口）广播入帧，网关路由器接收到该帧并从中获得 DHCP 请求报文，路由器上的 DHCP 服务器分配 IP 地址给客户端主机，以太网交换机通过自学习的方式记录了客户端主机所关联的输出端口以及网关路由器的 IP 地址，主机接收到包含 DHCP ACK 的以太网帧后获得自己的 IP 地址、网关路由器的 IP 地址以及 DNS 服务器的 IP 地址等。</p>
<p>客户端主机在浏览器中输入 Web 页面的 URL 后，客户端主机生成 ARP 查询报文来查询网关路由器 IP 地址所对应的 MAC 地址，接着向位于不同子网的 DNS 服务器发送 DNS 查询报文（目的 IP 为 DNS 服务器的 IP，目的 MAC 为网关路由器的 MAC），封装了 DNS 查询报文的 IP 数据报会经过各个路由器转发后到达 DNS 服务器，Web 浏览器获得 Web 页面所在的 Web 服务器的 IP 地址，并向服务器发送 TCP SYN 报文段（目的 IP 为 Web 服务器的 IP，目的 MAC 为网关路由器的 MAC），由此生成 TCP 套接字建立 TCP 连接，浏览器生成包含要获取的 URL 的 HTTP GET 报文，通过 TCP 连接被交付到 Web 服务器，包含有所请求 Web 页面的 HTTP 响应也通过 TCP 连接发送到 Web 浏览器。</p>
<h2 id="5-3-重要网络技术"><a href="#5-3-重要网络技术" class="headerlink" title="5.3 重要网络技术"></a>5.3 重要网络技术</h2><h3 id="5-3-1-以太网技术"><a href="#5-3-1-以太网技术" class="headerlink" title="5.3.1 以太网技术"></a>5.3.1 以太网技术</h3><p>以太网是第一个广泛部署的<strong>高速广播局域网</strong>，为网络层提供<strong>无连接</strong>、<strong>不可靠</strong>的服务（直接将封装着数据报的以太网帧发送到局域网中，不需要事先握手，也不需要事后 ACK），并<strong>可以以不同的速率传输承载着不同类型数据报的以太网帧</strong>，使用具有二进制指数回退的 CSMA/CD 多路访问协议来协调帧传输，是目前最流行的<strong>有线局域网技术</strong>，是链路层也是物理层的规范。以太网帧的负载/数据字段是 IP 数据报（以外也可以承载其他网络层分组），以太网的最大传输单元 MTU 是 1500 字节，当 IP 数据报超过 MTU 时，主机必须将该数据报分片，以太网帧的类型字段运行以太网复用多种网络层协议（除 IP 以外的其他网络层协议，比如 ARP 协议等），适配器接收到一个以太网帧时根据类型字段来判断应该将数据字段传递给哪个网络层协议。</p>
<p>基于总线拓扑结构的以太网将所有传输的帧传送到与总线连接的所有适配器并被处理；基于星形拓扑的以太网中，所有的主机和路由器直接与集线器相连，集线器是一种作用于比特（而不是作用于帧）的物理层设备，集线器始终将自己从一个接口接收到比特的副本发送到其他所有接口，那么当集线器从多个不同接口接收到同一个帧时就会发生碰撞，因此，集线器后来被无碰撞的链路层分组交换机所替代，交换机通过<strong>存储转发</strong>对接收到的帧进行分组交换，绝不会在相同的网段（即相同的接口）上同时传输多于一个帧，且由于现代交换机是全双工的，一台交换机和一个节点能够同时向对方发送帧而没有干扰，因此，基于交换机的星形拓扑以太网中<strong>不会有碰撞</strong>，那么也<strong>无需 MAC 协议</strong>来协调帧传输，此外，交换机还是一个可以通过<strong>自学习</strong>的方式建立自己的交换机表的<strong>即插即用设备</strong>，不需要来自网络管理员或配置协议的任何干预。</p>
<h3 id="5-3-2-虚拟局域网"><a href="#5-3-2-虚拟局域网" class="headerlink" title="5.3.2 虚拟局域网"></a>5.3.2 虚拟局域网</h3><p>支持虚拟局域网（VLAN）的交换机允许经一个单一的物理局域网基础设施定义多个虚拟局域网。交换机的接口由网络管理员划分为组，每个组构成一个 VLAN，在每个 VLAN 中的接口形成一个广播域，在一个 VLAN 内的主机彼此通信，将其他 VLAN 中的主机看作不存在，来自一个接口的流量仅能到达该接口所在的 VLAN 中的其他接口，从而将位于单一 PLAN 中的不同 VLAN 彼此隔离。当不同 VLAN 需要彼此通信时，就令交换机的一个接口与一台外部路由器相连，该接口称为干线接口，干线接口被配置为属于所有 VLAN，那么不同 VLAN 就可以通过干线接口和一个路由器来彼此通信（使用一种扩展的以太网帧格式）。</p>
<h3 id="5-3-3-数据中心"><a href="#5-3-3-数据中心" class="headerlink" title="5.3.3 数据中心"></a>5.3.3 数据中心</h3><p>大规模数据中心不仅连接着因特网，其内部还包括复杂的计算机网络（称为数据中心网络）用于连接内部数万至数十万台主机，一般是包括 CPU、内存和磁盘存储的商用主机（称为刀片），每个机架一般堆放 20~40 台刀片，每个机架顶部有一台交换机（称为机架顶部交换机 TOR）。TOR 一方面与机架上的刀片互联（通过以太网），另一方面与数据中心的其他底层交换机互联，底层交换机与高层交换机互联，高层交换机与负载均衡器和接入路由器互联，接入路由器与边界路由器互联连接到外部客户所在的因特网。所有的外部请求首先被定位到负载均衡器，负载均衡器会通过交换机来向主机分发请求从而平衡主机间的工作负载，此外还将外部 IP 地址转换为内部适当主机的 IP 地址，也就提供了类似 NAT 的功能，这可以防止外部客户直接接触主机，隐藏数据中心的内部网络结构。</p>
<h3 id="5-3-4-无线-移动网络"><a href="#5-3-4-无线-移动网络" class="headerlink" title="5.3.4 无线/移动网络"></a>5.3.4 无线/移动网络</h3><p>不同的无线链路技术具有可以自适应的不同的传输速率、传输范围以及比特差错率等，无线主机（可能移动也可能不移动）通过无线通信链路连接到一个基站，从而连接到更大的网络基础设施（通常是有线网络）中，基站负责向与之关联（即主机位于基站通信覆盖范围内并以基站作为中继来与更大网络通信）的无线主机发送数据分组和接收来自主机的数据，并协调与之关联的多个无线主机的传输，蜂窝网络中蜂窝塔和 802.11 无线局域网中的接入点都是基站的例子。当一台移动主机离开一个基站的覆盖范围而到达另一个基站的覆盖范围后，将改变与之关联的基站，接入更大网络的连接点（这个过程称为切换）。无线网络在链路层和网络层与有线网络有着重大区别。</p>
<p>IEEE 802.11 无线局域网（也称为 WiFi）一种十分重要的接入网技术，使用 CSMA/CA 多路访问协议，CRC 以及链路层确认/重传（ARQ）。802.11 体系结构的基本构件模块是基本服务集（BSS），BSS 包括一个或多个无线站点以及中央基站（称为接入点 AP），AP 通过交换机或路由器之类的互联设备连接到因特网中，部署 AP 的无线局域网称作基础设施无线局域网，每个无线站点在能够发送或者接收网络层数据（获得因特网接入）之前，必须与一个 AP 相关联，通常选择多个 AP 中信号强度最高的 AP 进行关联并加入该 AP 所属的子网中，进而获取在该 AP 子网中的一个 IP 地址。</p>
<p>当主机无法与任何一个 AP 相关联时，也可以选择更加迅速普及的蜂窝网络。蜂窝网络覆盖的区域被划分成许多地理覆盖区域，称为小区，每个小区都有一个基站向小区内的移动设备发送和接收信号。2G 蜂窝网络是一个电路交换的移动电话网络，只是用于语音而不是数据服务，3G 蜂窝网络支持电路交换语音服务和分组交换数据服务，是语音和数据结合网络，4G 长期演化（LTE）架构是一个全 IP 的架构，在两个端点之间建立具备唯一隧道端点标识符的隧道，用户数据通过隧道进行传输。</p>
<p>蓝牙网络的工作距离非常短，功耗低，成本低，被称为无线个人区域网络或微微网，采用 TDMA 和 TDMA 多路访问、随机回退、轮询、错误检测和纠正，不需要网络基础设施，是自组织网络。当主节点想要组成蓝牙网络时，通过邻居发现来确定哪些蓝牙设备在其覆盖范围内，接着通过蓝牙寻呼来邀请覆盖范围内的潜在客户，建立客户与蓝牙网络的连接。</p>
<h1 id="6、参考资料"><a href="#6、参考资料" class="headerlink" title="6、参考资料"></a>6、参考资料</h1><ul>
<li>《Computer Networking: A Top-Down Approach, Eighth Edition》</li>
</ul>
]]></content>
  </entry>
  <entry>
    <title>ElasticSearch</title>
    <url>/2024/03/09/elastic-search/</url>
    <content><![CDATA[<p>ElasticSearch 是一个分布式搜索和分析引擎，可以通过增加节点数量进行能力扩展，具备高性能、高可用、高可靠的搜索和分析能力，支持多种查询语言、数据结构、动态映射、实时处理以及备份和恢复，允许快速地调整模型以适应不同的需求，可以快速检索文档、商品、新闻，日志等数据，帮助监控数据变化，进行数据分析，保护数据安全等。</p>
<h1 id="快速查询"><a href="#快速查询" class="headerlink" title="快速查询"></a>快速查询</h1><p>ElasticSearch 基于以下特性来提供快速查询</p>
<ul>
<li><p>分布式存储，ElasticSearch 将数据存储在多个节点上，从而减少单个节点的压力</p>
</li>
<li><p>索引分片，ElasticSearch 把每个索引划分成多个分片，让查询操作并行化，从而提高查询速度</p>
</li>
<li><p>全文索引，ElasticSearch 使用全文索引技术，把文档转化成可搜索的结构化数据，从而提高搜索速度</p>
</li>
<li><p>倒排索引，ElasticSearch 通过倒排索引将文档中的每个词与该词出现在哪些文档中进行映射，并存储这些信息，从而快速查找包含所有搜索词的文档</p>
</li>
<li><p>索引优化，ElasticSearch 支持索引覆盖、索引下推等索引优化技术，从而提高查询速度</p>
</li>
<li><p>预存储结果，ElasticSearch 在插入数据时，对数据进行预处理，把结果预存储到索引中，避免查询时重新计算，从而提高查询速度</p>
</li>
<li><p>异步请求处理，ElasticSearch 使用了异步请求处理机制，能够在请求达到时立即返回，提高了用户体验</p>
</li>
<li><p>内存存储，ElasticSearch 使用了内存存储技术，能够在读写数据时大大减少磁盘访问次数，提高数据存储和查询效率</p>
</li>
</ul>
<p>ElasticSearch 在使用时可以通过以下措施来保持高效</p>
<ul>
<li><p>确保查询负载在集群中均衡分配</p>
</li>
<li><p>根据需要增加 CPU、内存或改善 I/O 性能</p>
</li>
<li><p>优化 JVM 设置，如堆大小，以提高性能</p>
</li>
<li><p>考虑数据量和硬件资源来合理设置分片数量（过多的分片数量可能会增加集群的管理开销和查询效率），经验是确保对于节点上配置的每个 GB，将分片数量保持在 20 以下</p>
</li>
<li><p>为每个字段指定正确的数据类型（text、keyword、date、integer 等），并选择合适的分析器（不同的数据类型有不同的存储、索引和分析方式），对于 text 类型的字段，可以指定分析器来定义文本如何被分割和索引，对于不需要全文搜索的字段，使用 keyword（用于精确值匹配、过滤、排序和聚合，不会被分析）来避免分析开销</p>
</li>
<li><p>对于不经常变化的数据，使用 ElasticSearch 的请求缓存机制，并定期清理不再需要的缓存，释放资源</p>
</li>
<li><p>利用 Kibana、Elasticsearch-head、Elastic HQ 等工具监控集群状态和性能</p>
</li>
<li><p>启用慢查询日志来识别和优化慢查询</p>
</li>
<li><p>优化查询语句，<a href="https://www.yuque.com/hollis666/niq4hm/otwmst9mkkktrbyk">参考</a></p>
</li>
</ul>
<h1 id="倒排索引"><a href="#倒排索引" class="headerlink" title="倒排索引"></a>倒排索引</h1><p>传统的索引结构是由文档构成的，每个文档包含了若干个词汇，根据这些词汇建立索引，而倒排索引是由词汇构成的，每个词汇对应了若干个文档，根据这些文档建立索引，生成倒排表，并对倒排表进行压缩处理再存储在磁盘中。</p>
<p>对于一个包含多个词汇的文档，倒排索引会将每个词汇作为一个关键字，记录下该词汇所在的文档编号以及该词汇在文档中的位置，那么就可以根据关键字快速找到包含该关键字的文档编号，然后通过文档编号再查找到对应的文档内容。</p>
<p>倒排索引的优点在于它可以快速定位包含关键字的文档，可以支持复杂的搜索操作，如词组搜索、通配符搜索等，此外词汇构成的倒排索引在数据分析和统计时也非常有效，因此被广泛用于搜索引擎、日志分析、推荐系统等领域。</p>
<h1 id="深度分页"><a href="#深度分页" class="headerlink" title="深度分页"></a>深度分页</h1><p>ElasticSearch 的检索机制决定了每次进行分页查询时需要先找到并处理所有位于当前页之前的记录，随着页码的增加，需要在内存中处理的数据量急剧增加，对这些数据进行排序等处理会消耗大量的 CPU 和内存资源，进而导致查询效率降低，查询响应时间显著增加，某些情况下可能超时，这就是 ElasticSearch 深度分页的问题。</p>
<p>Scroll API 通过保持一个游标来避免每次分页请求都重复地对所有的匹配的数据进行排序，减少了对 CPU 和内存的消耗，提高了初次搜索之后的翻页响应速度（初次搜索时的响应依旧是慢的），此外，Scroll API 还通过提供对数据的“稳定视图”，翻页时会保持初次搜索时刻的数据快照，即使在翻页过程中数据发生了变化，翻页结果仍然是一致的。Scroll API 适合处理需要访问大量数据的场景，如数据导出、备份或大规模数据分析，不适合快速访问特定页的这种小规模数据以及用户实时请求。</p>
<p>search_after 是 ElasticSearch 用于实现深度分页的一种机制，与传统的分页方式不同，search_after 允许基于上一次查询的结果（上页最后一条记录的排序值）来获取下一批数据，从而避免重复处理请求页之前的大量数据，显著提高查询效率，适合处理大量数据的场景，尤其是需要顺序遍历整个数据集时，不适用于随机页访问，要求使用一个全局唯一的字段进行精确排序，并在每次页请求中维护状态。</p>
<h1 id="数据一致性"><a href="#数据一致性" class="headerlink" title="数据一致性"></a>数据一致性</h1><p>业务中通常需要把数据库中的数据变更同步到 ElasticSearch 中，通常通过以下方式来保证数据库和 ElasticSearch 之间的数据一致性</p>
<ul>
<li><p>双写</p>
<ul>
<li>在代码中对数据库和 ElasticSearch 进行双写，先操作本地数据库，后操作 ElasticSearch，两步操作放在一个事务中</li>
<li>实现简单、实时性高，但对代码有侵入性，这种存在外调的事务会拖长数据库连接占用时间，影响吞吐量，此外，在写 ElasticSearch 超时导致事务回滚的情况下存在数据不一致</li>
</ul>
</li>
<li><p>MQ 异步消费</p>
<ul>
<li>每次需要更新数据就发布一个消息，数据库和 ElasticSearch 自行监听消息并进行对应的数据变更，若变更失败则基于消息进行重试</li>
<li>通过 MQ 实现了解耦和异步，但增加了复杂性，消息消费也可能存在延迟</li>
</ul>
</li>
<li><p>定时任务扫表</p>
<ul>
<li>若 ElasticSearch 中的数据变更的实时性要求性不高，可以通过定时任务扫表，然后批量更新 ElasticSearch</li>
<li>无侵入性，但实时性很差，定时任务轮询会给数据库带来压力，存在性能问题</li>
</ul>
</li>
<li><p>监听 BinLog</p>
<ul>
<li><p>监听数据库数据变更时产生的 BinLog ，从而更新 ElasticSearch，有成熟的框架可以做这个事情</p>
</li>
<li><p>无侵入性，解耦，依旧存在一定的毫秒级的延迟，是业务比较流行的方案</p>
</li>
</ul>
</li>
</ul>
]]></content>
  </entry>
  <entry>
    <title>Effective Product Control</title>
    <url>/2024/01/10/effective-product-control/</url>
    <content><![CDATA[<div class="hbe hbe-container" id="hexo-blog-encrypt" data-wpm="Oh, this is an invalid password. Check and try again, please." data-whm="OOPS, these decrypted content may changed, but you can still have a look.">
  <script id="hbeData" type="hbeData" data-hmacdigest="695145934066ff4f7d80c5fb659ae7b22a72bda9987ff5c24c58b265cd482788">a99f2d1cd7f89812758242c57c62a59f3cddf2750952f69ab8194f55b6df162cbc6f3939db37a37e454d2b5b2d167b17e386617c7c398c6cf84763d2a5aaafdf482d784f2f9cff72346c02cdf9f2cc7510582e8df1ae8f274abc2f539450b73eb195b6f05f2ab0b2efe7dbe422dfe1462e14089deaff39f50c42a530addefe4df7af09a95ffd62ca6e7d62a32925189ecf6793459aaefcd2b3f0facbfd593af7416f801ef3246537ae8760e1cc225c25d56c7b1e1834197d8dba7795091a8a86aa2fe3385cd7ea53dfe0b5c775d066a05cdad75b585b17165ccda74454123463a72fd35eff19b52d2b953cf0210d543169f598ce19361c40cce7e46446c065d3dabf25d7b5d706b09fe86334f441837e7a197427bd21abf751b14de10885be2b2e57a35654e1fe546334a6995976754bda345250d2fcf752803323c917c5513122500db9ece90d3a04461066837e295024a78c0fc4942c942f5dba46ad19bdf2edb4b1ad865623b3003d27c3653550c5e444ca20d409df1250a0b98b4dc5a4082b77814b20e0f25370e7afcad37f86f33869c39962b620d37d4b1981415a41b6ec2a6c03b2a71b10a0253eadfacb3824c08d3597d170e346f14dbef31a845faadddeeb48b1a62846bf93124f2fb7bee877be1b4784dc1af9e68838a30f2ea6c165f5f0f1fca07286ee9bc41e3d69da630feb2e7d5cafb72578bc51d4744a1aee83515b4c3c6841f02d1f1208ab54f05bf1661a1c26fe8f8e009847dbc47eaaa54b010e898c34b1849db69bbea4e6f333a3fa8826a6896231a37715a7c59a37a9dfc5e15bf598e134777bfb2564e6eeaa3ff7ba94e6138f25c9d47eb7e491f4c432a6b8c21339fd5a21381d3d423851ae00b56d9fd88224f8dab59888b6c9e9f23c59acb93788e564ea840935d234b2bf7a8d5b97b8164d7ee2b3326d6b39d5e9c20684f395f2890a4489c303eebc4f734728cf4ad97c977a732954f6013e2e2cdc3177b287e30c04d44dcf45736e04ffb0807c6a872098fd432a63490ba94188c89bce1e0dd6fdf8adbc5a873df80a035892ee0dba0c94932a2c0bffc95ed6c05973561f082ca56432d37f91945093a215d2a1681618557f47c901d9014eea02ab40df7018b03be4e380c562bc3f4d33880443c63d382fb399e7f7b8cb9d7a655fda88287b5c36f77e78f6129657c57b5ff232dfdc6f8e4de106fef46a4dee8a66e6cc382a4f1cb3cc116d83e535379b9797624e73d6059e6a9c5af7275f3441535aee23097a2ade2886d3a58cbfaf0cef3a0e77b1fe69b09c2631cb367a41d7daf372ba894a8512695cf10a551832945987c7fad2beede5c10b4a85d0c1c368be5a33311c03188cbd67700c97d3f34fbc1f0ecfcfa72f638c124b48bce1b5982bb5db76aaf54a5b21993385c1d62923103a2f674bfdf006625140e57e8f346d7ea86fac571069bbb4d0a14479eb27384c721159dbba33986f651fcb4fffe1dedf8f77ef8600c99ee2003ec1d8ea0353df9bcf73bcb253c0f5d564e75a3eceb610ceeb17c7ad8ca065107fb395d8cbb65915d4eb5bb305857116bd027b09511dc41538178033035fe4aefcdd2336e2ea9eb7f4fdf96d88689a23d141554891fe3457b825e2bade36da1ed9fdba8d7c115626cd237125135848b9ff4a0f2bb1793dce704501d0016b59b681b48e65a67fd3d13fca1aa8be24bb42b0f5419f494d3c55b5546c61c2ba6be6947928b38c39baf60218862bb16c2e059b0dd54b7cd99b3a20127541ff070b54164f46dd5aee29a848ab76a5c079af6e5a0cc282555bd3b0217d3f3c9b136f14f3f7966fdab8a517633ecc59e5132d3dde478fcdc391a0c5f491383b45b6b24660ce33ede18f5d694f11bf85c135bbae57b34e44b9d6e6c4b5f0f54a1f19bece5e31fc0b5ced3e7967fc15bf509491f7b1477cf1c92c475685c50f677184a9b3ba2216caa3c68b22c1a17cf476c322a457915c8f100345522d1c4904f3c5b09883601921ecdea9c287a7c0d62ec786d4a63fa49d42563200ee8dc5e9b5fb5eb39e7edf693a5646f80b94a1079fe798d949db510ec3f775ac3e51a362aea0150bb5763673d086dd8104167532c24b8f2bf977f3d4597ba85b1d4fc0734022613ca155866ea44ecebe880350d94dbc0918479e2f5932f4581d68924d3d06ce11259503659db1ce408326092785787ff6dbe6adb79384824080fbe83e87b8c7058b217f3d659dc040d1140adf07b258d5f088c4fe7f67a52f40324642dbe67d389e3c22ea6fdb550ab861776119827ff841109ec027aa547cec8bbaf20005880c0db6095363d20f773c0d8ced3bb525e4e90ba678807752e6008e0656b94ee80811d59ee789b10494dac20e8de945ad36963afff785c79fda1a8cb44bdf2747a2b614fc94de3a955f9dd4dd5bf17487b8d119d5986cf99fdea74556fd586050d59a0066868ac70031640b91f01b79d7acb35647ed815e6df87455cd91ae04663f8f96b5d63eb9dbc0f91893314c831dec5cb2c3641d648d4dcdb757aedcc06f21c13423efe31cdc1cad93954f22c4583acf6e9f604197674990f600251b776eb58aff614a662e57d93e984a3bd0b61ab064091ea729ba66ee0e044993307a9e7ff6a6ab5f0d9a4112cf72249d8da1c40424d26d5f058ff02ea0533f844828c5aff096bccc5c7dda0f605c416bcac9dd759fbc1feff5e906857d831c5727de682cc91497033b544a0e2d51cbc3f96de386417ab0f6b6987666d28f6ef50e2f195dbff94e84949abd7dda0d0c105eefae4595960adea820d01040285199cf36fdeeb3c6e69e1858e936550c58832d22f7fddd1e2e7574201e09e3bf67d41eb00f15c1f68c0812ceb9b2656c7dbb00f2592566df5dd72b11485a6f3bb9d42f8987744d9ce7c5ef9d5f1dab45c79b42f3706bec3212da021d9cdeb9c9b9b9738cfbf83eb322e7cc89221d339713fb0d2df1f2ebeb295db83925a1e3f505cd7e3610303f85f2bf01abeecf6bc9c509808c4b99a2302edaa041ad6fc578b6ed9405ce635437e3bb7d60da5d73ab5b27695eccc9d934a66af36497bd249f57a1d0c284b56668b4cff419fa31551d4fbd9b082455d5fd6f4b19b18de72a5efb1bad7ab4e1ef1b4a28ebe43b0bde165a1d0120de092a36cd49997ff548ff3bcffb7fcbf0478a622d4cc1fc967e3bbdd887b28800478b57fda7ffcd105a05d33a9c1e63df5d8ef41564510fe1b24f6553533500b7a1433332097b1c087d56bc6441359fdcf986453f6a8c1736f1858ccb3e2a73cfb7db008aed8e65f19e29b3cff2efa42d8063b7bf189dd380179c6c50001eeafd75c8fd47247159afac6211fb821d9aa3dd5a087c24079a8a3eca81f94565edfe876f1ae69f0c37efaede67c9d96f49e5f66c9c82f2f005746c5ed827d9aff550159d04240c281b002e1dc8e315ee5ab4d635825db05750c5f3c9b4e7fbdd89d57ddaba0da01b538e5a49805ed0b4a7f9ce457d2750e6d9a5ad5eb52793d1a63f18f96bad189d21da2cb7ccb1f060ddad2377f46ece666579e4a3e09318d28e3803c41b1c8fc9c0e449f46778a940067aff5f83aa1050d296ff7a7e274ff051a3291f89fc1f315bbc80c4f9eeba1444d37ae423f2e6bbed946336031575e4e99172b0999f1d9ea453060a8374b9a320ffe77ca4ded27eb1558be6b4a76c8ee17d10bf5887ebf9f65a92f86b2fcf1003ef6b651884ee4d585ceac46c0f5c393b4e9739b0079618fdbc9aeb8c7c12e6a6f94fcbd1724d12b0a36795c88ea6156020ca290539612764e804795f8c795cacb4847167b81309aa5cc50c637631e71e988d3d0067cc27990e11767ba256a9e543d6c64ba0e7422edc8886ca9bcb57d833c4400790e03a4fc8a9f1fbca534c146ac807a19487f7f90ec8c2b8ae0267a865a29f334973cd6cb5264213dcc4172404b32eb27c45ee04cf1892fa0e28f714e8faab967b44405ffd2fe4d0c86a34f01a1dc48c53d49ac69b201b3007bf1912f84cb3b76ec85cf29201127a51c32bed499643dba78e1afe74f146af29575bf646e15abaefbf104852eacf3875a960c7aa3228fdbf37a431af8070fbe40a2a41a00ba6bbdb6b08e32fc01c82547de0fd5285847412a1a2ea71325718ecfa1ec2a67080e386e3a9bc600aee77a3932cb8d0bc1c683631b3b3d1077184acf9fd56cf0322d099d27b573577c1d51b3aa304cff84bdb982a14046473f4293d9a3feac1dede8b4ec48c8642e7257bd60f1b300c8aeb8cfcf7f13d1acae4d93820f75d62086c566090f27658346eb11972cb5258b828eaaf8d252a879aef05f52b83fe7f6754407c1283809628c800dce8fc1a24e0a9596bb38d1c43ef252719fb67c956b0463876712c88fd53cf615667d9f30c5a97659f8494026dc5ca1ea1d46254bf0a244e3fe000117e0514055ed41c509e2d32cb1dbdc56ff18d3f1a940c0d9eeafa5f8ecc5572aeb0e5a25e64fda3dbfa919bf43b5db2b4144cb7e376fc534e82a1e71dcd0b1ab4b810ddfe72413942b258b5feeb2a125aa0621de28745b1c1eb9a0e5a68a68a1902e021c1195b43043b1aa4fa69e57447c762554353712ed84e3643b6d06cdeca27e5bb3d4e908cbd748831954afc277362fb4cf3071793a7fd6aa844c3879ffb75930bed6607719a95dec3104de9cba1cd4f9be20309993271bf9f7f9f7fa16d75527cd52c48b9606003232eced2e69cde68a3b43a71455965b1f7d48a2ee3ce9697105994962e782091ff99433a854c0781b13606565158f63e7e3a9b47760372cf4ab454462641dfb3cc67e5ca96dcb65f4a7161813b8ce616f4a27bf6bb13b4c543157a5f14ff0a21ef6d76867ac8ab709b99ecbe805bd729bd58a808a786ca22003ce6dad46a416a31fe34903b89db85a6140538080c8eb43bfb42fa5a3e72b29b51728f88a50dfe67a2c3c64cbbba99b34526fbcf76aa3085029223cbf5efc9e3a3d960b04fafe4e1d9a3baa75c74ca381df5693dc5add52f7af00023d1e874605923045af2fe3c22c49df429dfd4ff4d62da2d8328fe8ebe73bdd807b068dc56c0b2a4325eed27c94ccbb12af4072a3a9e3db83f26534e6ba7de32697fa0e61a779d2c06c97be4c315e1885b9011c2aca4255d922d8b4f1379fa590eededa24e4b39f1d4cd27b1cf2c32fc871521ffc587de65294ac5469967e4c4d09aabb946ed112fffbb499bf1742a03d1a0058a91f28eb1883449d51c36f068cd0afeb830b4dde1055156bf362546123849f06cdd9c6302d7b8f1c381e0f7b76b1158a9b2f0d7d905735d4c60995da9d2e84d3c74737911bfe10542ac3c4f0bb9ddc1a88e7505b6d414837f93579f1e1b4ebb62c58b8f9b2b57903ce2498b7907652d672ac275e67ccc4bfef989b2cacbeea36aa98700ac881a31bc12ed590a16923b8107aa0925aab03eadad170718189dafd7fb332599707ca232fedc881c33bb9afafff8803185b4795754aca89db3afb80fb8b768940097959dbdd7257da7a54864336fd0a4265200fda7a2f05bad876da602621b47c412f6d6b4beb3214a23043ada37b910bad07fc16d1cc468d5bcbc5b9c6be1a40e6272803586e507eb411ff6685560e87b8675d6f7903d0f9f430c80bfc5ae7d6dc3b823b54b4e2e59dd9070ca83192ed6c0141d578b11863145773b92ec3e59541cc80e913d6c611671210daf0f5ef81605a25702862484b0ed27b658dae5fc6b1e4d3691d73b38f668fad753b0310275a5ffc1972b39c0840df5bc043a1cd4388bac93178093349912ccf0441931739693187e8f213e7db1cf98416fb3eb8f17a241ed83b39b5c2a644ad1b7d60b71a6b0f3a5d4fa79433d96d804c9c89fa07f90867382b03abfc7165947e3b15b8926373c917406d9b8dfbcc68cf774e0a0a58f49402e8450fa4fa65f301e00141be8a4449d7214c88388c0e7f339356dd5679f44593e159a500710c0140b71e26d61a9a0f91c4645f984e50abbfd97b6f8da11d135b7bec9281c0c3c432095d4e3b519886bb62d8d9b10babe44acbc0a801d0367af007e77c79782da1579cc3872f35f0b5372016e4f381ab27e944545253c4a1fcb73700882265b1f4b40ef980b356d519ca7ecc4d93277108f495ad6100d06b473a6cf0ad22e5e973e285eedd45268fdaf5f62e490b554f3b90667bda4b14f4207992d835b61780374f81bc17dadb449837d1f4e723c5259b607ed994c7a0d3d24d00a358966e223bcfd194d9db408b04ce7707d5d730a70c94dae07fd719febcb1c0739bfa86147cf3819b61a83cdc825689366694da132dc91d6e22eb06288dffc62d4784fdfcf44f98033c4badae16ac3c2e9a0db5d8463b231671bb880dc642adb3e1363a2bd44fb29118fe5cb8bdf8afa70b52af8db7aec29cf8422e00bcd9991765f01eaf2c4013e5debe5d94ab1ff10e70bf05a18013bb5cb7feebef1a13b76ed096e5d6720f0fe8ac8c5015d194ddef65b88adb39c87e6d443a4ea35ec1de517d2aa4152b7c08f1df98554cff3721695e34e7903c24a1684bad253a7a18964e65a19bb3425b196733fa6777a9669c1a4dda408789ffbf8624b5a4e31c39630f3a251a271231a3eb3a9edfa6c30308a59cf6378e3477cc9884639d29ad7a96d86ecbdd926504ac1b6ae263c8a65d09a9064c2fc3ddbc0aed3021af9f0326713f660c1a7e0e5945b12c35d9dd2fb02b89ca7547d8156347c3220b07e0438528e2d6d593a5c0da0621cb75d449c622881a306a54c0c566540e98c0edfb8ef129dafa5923a31a824066c03ec010493d8d1e8e497e39dcfb14d2b5fd61f95326ccd219283421a30438ac11c1e1912e318417aedd3902d23f36d83ea388c739f139d6389ef6f9133d5d8b6b03c03c2696beca8842bc5d7aabb47e9562276d08d973a8251721c0e0432ef5e3bffebe9185f0f6686dc5c29fa5dc995c81b044bbf4bdb8fb78aa1f1e37f7d28dc02bffd336173342e73d7586a60b14066f07d13284c383ecaf282afa4d15b756832abdf38a32070ae2f0a1dd09b352b032e666d23d1a91132d61d7776e1cd17f83271ddaeae1f48eb39bf2caefb082eb8ab8e6e4bf891784b55ba23e5d6b1ed35de270fcb8d237fca6b90f2340b0011534e9e0ae09796ab9591ff507fbad1b6381a354674db5931f477881cdbaa6f1dceae53a3e6c802b969b908c427550e5e0d184e01d784c9c872cf04f426d0bb4f56ad2b8b0b8e0ec2fe6167584f07a1e68d9db8e04a18c0ed5b4d4bcb2781745636e07caf3100b130c20fa7d79e3f20282ddbec7df7e410d5ad4221ba2bc6f3a8916151f5e727597b2fe824fb0b6db8bb13881a2be171464d48d8b631c688cce1028f4c09ce4458484d762e61e2c0a2fd7179f3378890cec5e37d262bb0da0fd78ff865c61a3445cb38570c89e4bf464e5d943ffbe1505c3be520e224533e05c2675c140b7d8aa54a5f3e1398aa3a7924a0daf6bcd8a3a5916069c434a2ffda8a6b6b2ebb29b53d8cca04d69e39ad5b85b01f15e93c8fa6ac8e4a39efe6a4e14fc9dfdf1acc6d8ebfd33b1d429987083d2a539e23a24ebf33c742ebaf3e4622745aad5d45d62a686fa723026486535a4c5b92d26474ac349a9add668273f0159cbc901d329e485df1bf6379924761735dbe746427a75669df6ba6441f3a23adfe8e36afc80f6a206a11651113e53574b2dab1e3261769dc453c17ba1f0dec13a4b62e046875d69a54e788cbf494739356e26beab0467b206d0030e8bd4903db2268b2299b1d58a977980eb28d2d01a1bcd238497e4c314da5c42412988d764159b00dabc6ecbe7d65826c7a938c13fc28d05b865ae124c400528366cff29dabcf625ee804ecdccd9ff0e6fc7339082d1c766ee702c87d985ff4268a4bcc9c7bcc61555d67fca249b79836053a1de8766c57bb5b33da7030224d0ca91c44389c0ce9a9e91cbe0b0e2ccd07c3a7dd8ac87465967405c3f87dce0188e84b617673cc4c26f8a4e477d816a5ba3dbcdd6cc99f728f0e0079f64eec9ff7e477ddb4f67989fd62beeb84010b407e127e06b24dbd1b278b9d26983ee4cbd53e22295a1b5fa355a2c4e9af66e2877c69f2f67dad5b152ce0f9f81581a06f2cf6d06f4ae2ec655e50600da4c640927726f4585b34ab736fe1117b2856f2a73bdf8813beadf7a9415b095ac43fc9bf98fcadaa2d2d5589c634b62759a80cdce9339098c55722dc339c223e67516e9e6f302ff7beff187854d4807dbf8e6a1bb1b85bfda93d1902007504d7a3c44d1b29176ffd178e916b7ff79efe59e0688e23ed48c36e8e4b5dfa1770fcf9e6b638eab8603ca9d2eec25daa98c086eada55ec56a8982496914873a3e1a309a90ad97f8ff1fb6908e6db7d65d40464dd9803611e5944cbe78482cee4b99a3a224ddcd6a2b40b5b202cb7c77483198bea10ca1eb70869e56ad15767effbb02f361c9fde6ca9c5ef659647110d1dfc5e59e25d8affed666edf2b242eb8eb0f472d19e9c8ebd979f5caca0da07b96e866de387b8bd572c3f9e700c7759fa4dc8e7d0bcf3357fe4d285a8fc3fbf6bb7939be1cfc6ac94e8aa36e7214bf470f530c201fe076576c919205a9b64b73fb346e9c4f9f0566335a1814dee6a87adb9e9464094dcb770d43740d5728d459dc4b6304fef9471e922f46fc5254f3a5c8f9d11b0bcd9410a6fbff0f7c8d959564ecc2dd6ddfc1a2999c9893b8652282a6523782449bdecc376acc82608784f3281624c7816f7874d5eb301c60bfd15ba8125b97d758eb5fdf631a7fe21cd4168a7f74dac7513ea938d97324b02bbed9f39166c7d77509e35329a3c1158e84a7054aae1887019f5cb40bd0589c018e33a4757b9add62362d04d5ba60ed4fc8fcafd9eb705bcbef66c5f5c178b19a6c4871fd6e05b0eace85f89b220ba8883ba7a0f48688b7dd9f86231df041d3f673a114fe8d6596606039bf0495f974970c2b3c4f52a2ab5d6bfac683c18b06951c91c9561de52afea428c030feb741c7f4986fee9d8f70911074bb08df6c195cbfd28c779235f685a4023438dab018593c8a2638beef9108b421fd78bc59744be922ba6a523201907fe5ff0a2426284de14a9f01de6e139ee5371f26c4ad48be4791c7e2ccfda95efe025d5cb57950df4f456f23fb7b9f0357e78fa92b82c9201002409a3db5e59a2e3a6f74bed953a0cf35cfc1cfd313f9bf3402c93bdd61932092906d301141f2e77f3213983afa17a23d835b4f857fd06d207d0589571394f95697beaf8d452d994e0f9c22ad0728f63938ff7da9f9221cab6e9b344a3bc4abad770f21a8aa6eb5dcc9f9064f59f530b598cda5cde450e35bbdf6781779d05548493fb35ba87f446b2633972cf08cc9ad76f30acb311b197b731e6d8aa42c109ae4a19781f900d520a6a0362b8476717a7a8d7fe38f35982d536f8d351ba2d4bd88abc8738f3140ee5f63de032ba4bd5ce9d7fbc27e557e771ece63d7c074d5e7a69600e9c98de25eb9bc0b5436eb44a77dfacf12442b088af582ef9fa7551881d3af0c4d24de3fddeb76085b0d8ed2a93f873337c3a1ec9f0aa174b078f429cd0d25ca8fa9077ce9ed064959d9bfd266d4a283dfb0c336a43cefddcf6e43f45dd61096f8ba427cb463870d3320c610cd288f72f037fe829ba577606083ba6596a78219f8f8bf643ec89d878511ba828c81e82d689cd22408bda9a0552bc3f7a6e67895c15949d60e016f91329149a09a28864d1a015f21dc5dab9c3d5e60ec1dd3b55dc485bb044ecbadba99e0a32300317d2c73a83e10dc2ceece5c31ce046703d1fbc16f9b13c48966cfeb4446508b8cfab5c62ef6d7013d0637379dfced646159aa9ff152a55f86ce62836e55d8c3c94ba3ed2afad061f09484b584222333f23b8be999c6c3fb5ab03332e2f9240376ca01e0482f23dd8f303edab28dd0f41da743c8412e46a29ea358f324574d201e5aa42907773e499ab1e9f35b0221aad9589052b01a2fabb054f141f7cc275580a993db87ca1135eea11dd5c11b7286e553c429b09b1e7dc1a655ff7cfb3da89d2aac1ecd97f3e5a9bfed32a70e85124ccbba176ef43728cc550f2917aade8bed9e6192d1ce6036d3d2d12563abe40c49285f5a9cb17ae73ccd6e9bce7709569bc7dd4e41df10e337eac4ddc89b84e4f4591628af9704d95efffed0fbb99e659a9552c3eab7654b268dafe7a13c5a8c9b579040323bad1bb0518fd94d6951bc5381393569037fef53f33c9cf449f3436687c108001aa7cc356fa8374a34607d79c039e7c4c392b69c39a1c06bf7a46ae3f150644c91eb3d8cdc7d6b6d9e54327666fdef74eeef1b58089c38a81ba53d01604606184fb36ef5360d4bd993172c497594771d161197661319e8ad683da68d8a64d8275cc8ffbaf1438d887d730eb372bc9ec2b400f63e356a6be594a90c8c1f596a08aa7b9cdece6b1f4addd7d4f87acc8cf8cc95f64f5779947da67dadf1c8abe0d1b1024d653f6542346dfabd434e74f49e30970ac5d096440314ff485994cc213e3de9556e9d708b31bd2c7c9b2e3ca0c800cd3d9e78a58523f398988cbf2d7e3656f951547a3aeca7c1b7eaa27b9fa4031ded76e3db71f5f56d1551d6cb74bfa9f156899bad3bd5793987eb72676ab385be22567702072fa3ca44470f18557fbf0b61090bf55c58784d1147963014acdc771e91083fc50350008138e7c5c4f71ddac637fd1b3927525a3fdf2e5d2d7e3d62893ecd516966752b00918613b4b66954fd33d8f4936b1213c19187b3ea6164631cb78c373e0a266c301db681e2ef1bdacb918a4b01cb63593c9089b02ad108562ed6efeb3505140ba32577ff7aeaeee3cc57ab325611b74fb7fa42c8c2f2209c212ede3ba0506fda1921d88637c0fb311088e0240c5135610a42ba03e322c01afe7b100f71e8c82f943ccf79aace55918905326bc23f2794608b537cff474eb211e0af77a1a6f1e932cb0fee8aaf83cfd2ef80b157c7b502a1f6d3ff115ea195d859f63653cd22f5f014d347772de830be1817fe6530b02998c64d21ce06b49d938954786a41fecf3142589e5457a29f6c8c86cfc309aa9d3749de2408b3a8ef16bcf6bfcaae476715ac847ca5cf2bd1349b44a71dcc3f011ec089596d84beb46c2bd1d313b7d3b6d9c2b49653fbda9994da6030cc78fecd7efe8226d04fd465d44bc2a9a59707e9e25649a240383d23c1f428975faa36f7046cc2a4ed824483684f5ea9383fdd436ac3c9c51f121cbd93c75b9ecfec9c42134ce8db4ca765068e49c418b500be59b7f0b59db80c0ce6f0e577cdf383433ff1ef9ea366f9cd79df4c483bca15fd47ee1ad540133314fa90069419aa9e60fb25f9d56f6414fb97a093c88327208ae300de6a29ff452cbc930b34a8b4904622bfb1eceaa6d03a42fa8539646d19194ee8c3aac57ffd817583da8e13df071e82c426f4f87361770f5d351771888f717cb95df5a7ee92f770d9c716bcb79fb69e58fd126f6e0c159546dc36779b0f97200115520f1d279cd0dce2bb9c16c7cc31e22b8a60ddbc333e8df781041c35e4d7b4b54ab9c2bf3f3aa63848e21e9529e276e6b8542313529c5f0606eb0da499d7b694c76a32ac6844e41dc5f38ad1cb8a638021cd8b731c3e4bbbe48eb76bca9f8d77e23c64fa7053a67308c4e0adc470cc1e59330ee4b605d70a90ee0ec0d687ddc05aaa28afaefed537d69b6324cf11e42b5f633c6109ce612d0b1b413e7f49ff5405d0f949af62619f158cb13f28a55e98c33aadb22c82d89047ebd8d4472ff5a1fbe681754557d0bd489257f1904c4ccb885ebff2c08f800a4745682cb3f9468e67e405889f585dbb96f95a1b2b8fc9a576b6499686e90431aef73ddeb5cb1da300a14b75fa8d695e8d5a64ebb442341a093ab14c2134782009c9c4b42bc5ea38be7e95a9a68f44e4982e8d4c20de8c5dbb9ccd3ded7b1252fd28f834ff17baab602c4a8d18a367747045f86946dde79a3f39d9d0c3bdd0c3f38ac6c5e52b41aaf7ceac2ea5e59504169f6136bafff41f69591b1f28679bd3480a2996a891eec111dd267bef4e348e5bad043f64b9ff42cfca58c552762aafdba1b3cba182cc14ee0f178ec76402067f19142cd93698a7f18874c8f056da9adbfcac4674993eade5e085765e915fa962db187bd14c67de1a6a120b57aec0d1ba7173117e2503a7b111b7ee8ad5180004205ec2123491c61b651d5f5e8d9452841ef3e4f1253b76eee26558a0e74be54a770c95fbb0834c273558ba2292b76c8cb9e84020ecc8c39770f6cd98d75325d9617ee23e8005453c469eb8de8f5f3b1cba00eb913e5c41c3f5101c6cfb55a3fa43df3f70d7067a07f31ae5c95fd56694824cc34d4453a2108a3a66b21ba4d1eced2b3aeabdb970ec661c923c624a2413a57afcf4c8ec1adab3efa98b04e99b3186d2dc0b6915ef000d1848bd2b230ab197e8c4b4a00dbf8c22949f37d47d5c0f2dc379867a40881aa93c50ddef7c41a66ee21344456f12516c70dae54cfa4a3a6c4033f122d0f5112b852511c44604588d02fdf448666617a1a5d9137e03f3490b1d3dcff5baf34f9f41179605e78f7a2e607cb01c50ec5b2535a82632e764adb9e2067cc046731c04a88953b3047075ee65ee7a233c94bff86264794385a275a8cbaef38abca943195c964662df6d636246d8e30e504b9236baa4a71066e3a62797234fe3f38eb57ff0a9e983fe22be2f48dbc75263a102b2062acdd03f49a0aa2ef2c9af093e991bb770723e46ce6053ec8e86e2ae83769b2514e96a760d460e2da8ceb27ece67f2ad8eb344942df91560ebaaf5c277d598300fc341ccf44166af88c21c72a68803ba20c02e277dd24f59813d379620e991425dd0f3ab0e6fd5cfd40271db15381904585a4a4cbaf6f2239c6386a645cc9583d08b49c8858162cf27ee8ab53f075c5b11199f2991d485ec8db2b1e3c42d0f73f46c1058371a9ea1f145df9811b4922e163940b84dc52f5893b4569f4c8f579976a78a8205bf0a1a24a8caf35bfcc0f3bbf1be9747224d3088b30f5303339d3ff12a0aa8a6c2feca65b4675f927492fc826606464a68e6c0aba9a7bc4668f0c44f5119b4c5541007644745f0cc7b4e848ac56a8117c275ae263b482f554e222d54974a18cea42feca1d678c6c7ebe8b89feb51c12a8b11041d772b505827331887f13ac6c1e45a0e0432ae14c15a4d453158013fbaec4061fa00875eb7bac65093d7002fc20df42c7feb1914e44ddf0ab75d3102f9c4b218ce2fe5c984b07202e34cac0b172da2346ec8744af81869f1771f13e6e904e0532d4a6825c917e20a2eae1c585a6ce467cf5314c229075a900d54abb22fa2c2184c7bc2757f86cbd7b1736159ba95cb8edeee994e2be3eb8f9eba177661839276a4142b5c06b53026f60ae8e148b7e0c973ee4d283306c99e678aa9ec517fc0c0ae0592161ff4ef749166c3cbb7252408ad5c83c4c0b7e09b2b7caaf4393095f3386136906c04fff615a999ef76d0e7154da7d649fed8de115d6328fd63fa8f5151f925767cb81dfa12a6d4b1fda762cc05933410bbc638ba00ca74ba3bcb6cc46fdd72f9f67b7bbfa60670607311c191fab11e6e1e1d0500af714ad75eec2f7bf2007ae022ae9ccb72d950b20285bd71c4c4c23df623ac75464a58d6b5453c78fddbb18ee9562c6b9f47d627468d2cfc7c59f644127ce9629d53895f9824e0ae9de251967c8cc30241eff5c8a4a60ea5436443da9d4915a0fb430156991572bb5f830037e35e5bc761937e34dd0db39e97cc305d16acf66e16479624a75ed9e5be6909d7ee982f4bf2a847e2ae762c341e7c70b454542fef49e74ca303a358c4248055c5135c65a7653dd150edaf0c1f6eb5fdb319ee568854555b5597d7a687ea9718b6b1c155b4da1419de4b8e4ee1adcca95acb3c7a1f1aed035f24c8b07cb194dc63f15bf7bba5217a091e3b0846677e153e679499bcf442d1cb25592ddf8c7f4889e610f1e4e0c0835b4334e325cb028c8f6796d8e8645eb1075261db38d6e2ce2b8957cbcbd2407c2ceb56142eac9d45cfefd20a8e138c16e9d43bd7d837d70717dd129dde002d29051341ad131ddda75e2f5d9b95ceafddc35aa2dcb1b9719d3d85fc82f59a7f0532e9e2ced926ff7253611e913c3e5097ee66b6cade3f16c0cfa24924b70e58db85c6ed2ee3c8e2e04ce34eddfb44aaacb6285cdba964a411ed67cda6821c63630e65749d41c462211e80f19d1f0efbef69cf06f35cbc3ddb689524fb1d29ac88740a2163bb75dbb9e6a7eb43f061a069ae522712f1e320ddf53c23abb131e245c710318c559e430023734b33d081283011aa1396beb1077b5de7b231256dbf7bf24fb5f0d08304188a505d57dc5ea0699ef400615d95979b1dbfe46d968f32f1c9459438f96bc9732a0497443a616d3488177be16e9e4f1d3cd12e29e21a0582d014374735e044dda19d16ff594fedc9755b202a740869989312d932f527407fc5a96a9a52af54353cc6c4b13d16f6c4c9bb6d2f405b53c12d6363723f3285ce46144379bd1c4edca8191f6e5762928a7e17b96a06dcb95a6a662034fb60b7297f4c5432b9b298f02ed2b272f0b4bb70d82f59a2f7a2d609c68e9380a9534fe565d3947ba60f6a9cab5322821def39cffc8074417ab82d5af9405e02940918a49bba8298122f370cd9179a86f98c31100cd20b558940a0f9284fabaf3f1f048cb9d273</script>
  <div class="hbe hbe-content">
    <div class="hbe hbe-input hbe-input-default">
      <input class="hbe hbe-input-field hbe-input-field-default" type="password" id="hbePass">
      <label class="hbe hbe-input-label hbe-input-label-default" for="hbePass">
        <span class="hbe hbe-input-label-content hbe-input-label-content-default">Hey, password is required here.</span>
      </label>
    </div>
  </div>
</div>
<script data-pjax src="/lib/hbe.js"></script><link href="/css/hbe.style.css" rel="stylesheet" type="text/css">]]></content>
  </entry>
  <entry>
    <title>Effective Java</title>
    <url>/2022/05/06/effective-java/</url>
    <content><![CDATA[<h1 id="1、引言"><a href="#1、引言" class="headerlink" title="1、引言"></a>1、引言</h1><p>仅仅学会语言的结构及如何使用是不够的，还需要学习如何以<strong>惯用和高效的方式</strong>来表达；仅仅编写出能够有效工作能够被别人理解的代码是不够的，还必须把代码组织成<strong>易于修改的形式</strong>。本书关心如何编写出<strong>清晰、正确、可用、健壮、灵活和可维护的程序</strong>。</p>
<p>注：</p>
<ul>
<li><p>本书中所使用的术语“组件（Component）”指任何可重用的软件元素，从单个方法到包含多个包的复杂框架；</p>
</li>
<li><p>本书中所使用的术语“API元素”是指类、接口、构造器、成员和序列化形式，程序员可以通过API访问类、接口或者包；</p>
</li>
<li><p>本书中所使用的术语“继承”指实现继承（一个类扩展另一个类），不适用于接口继承（一个类实现一个接口，或者一个接口扩展另一个接口）。</p>
</li>
</ul>
<h1 id="2、创建和销毁对象"><a href="#2、创建和销毁对象" class="headerlink" title="2、创建和销毁对象"></a>2、创建和销毁对象</h1><h2 id="2-1-静态工厂方法代替构造器（1）"><a href="#2-1-静态工厂方法代替构造器（1）" class="headerlink" title="2.1 静态工厂方法代替构造器（1）"></a>2.1 静态工厂方法代替构造器（1）</h2><p>与公有构造器相比，静态工厂方法的优势在于：</p>
<ul>
<li><p>静态工厂方法有更能表达方法实际意义的名称，能通过命名合适的不同名称来实现多个相同参数列表的方法；</p>
</li>
<li><p>静态工厂方法不必在每次调用时都创建一个新对象，可以重复利用已经构建好的实例，也有助于类严格控制哪些实例应该存在；</p>
</li>
<li><p>静态工厂方法可以返回原类型的任何子类型的对象，则API可以通过静态工厂方法返回非公有类的对象，适用于基于接口的框架；</p>
</li>
<li><p>静态工厂方法所返回的对象所属的类，在编写该静态工厂方法时可以不存在。</p>
</li>
</ul>
<p>静态工厂方法的劣势在于：</p>
<ul>
<li><p>类如果不含有<code>public</code>或者<code>protected</code>的构造器，就不能被子类化，但这另一方面也鼓励了程序员使用复合而不是继承；</p>
</li>
<li><p>程序员难以发现静态工厂方法，API文档中没有明确标注出来；</p>
</li>
</ul>
<h2 id="2-2-存在多个构造器参数时使用生成器（2）"><a href="#2-2-存在多个构造器参数时使用生成器（2）" class="headerlink" title="2.2 存在多个构造器参数时使用生成器（2）"></a>2.2 存在多个构造器参数时使用生成器（2）</h2><p>静态工厂方法和构造器都不能很好地扩展到大量可选参数，面对存在多个构造器参数的情况，有以下几种解决方式：</p>
<ul>
<li><p>重叠构造器模式，但此时客户端代码难以编写和阅读；</p>
</li>
<li><p>JavaBean模式，但在构造过程中无法保证JavaBean的一致性，无法实现不可变类，需要额外开销来确保线程安全；</p>
</li>
<li><p>生成器模式（Builder），它可以有多个可变参数，既能保证像重叠构造器那样的安全性，也能保证像JavaBean模式那么好的可读性，此外Builder模式也适用于类层次结构。</p>
</li>
</ul>
<h2 id="2-3-通过枚举类型强化Singleton属性（3）"><a href="#2-3-通过枚举类型强化Singleton属性（3）" class="headerlink" title="2.3 通过枚举类型强化Singleton属性（3）"></a>2.3 通过枚举类型强化Singleton属性（3）</h2><p>当构造器设为私有时，可以通过<code>final</code>变量或者静态工厂可以实现Singleton，这种方式有两个问题需要注意：</p>
<ul>
<li><p>享有特权的客户端可以通过反射机制调用私有构造器，为了抵御这种攻击，可以令构造器在创建第二个实例时抛出异常；</p>
</li>
<li><p>需要通过<code>implements Serializable</code>实现可序列化，但每次反序列化一个序列化的实例时依旧会创建一个新的实例，为了防止这种情况，需要在Singleton类中增加一个<code>readResolve</code>方法。</p>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> Object <span class="title function_">readResolve</span> <span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> INSTANCE;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>除此以上实现Singleton的方式，还可以通过声明一个包含单个枚举元素的枚举类型来实现Singleton：</p>
<ul>
<li><p>这种方式更加简洁，无偿地提供了序列化机制，即使是在面对复杂的序列化或者反射攻击时，也绝对防止多次实例化；</p>
</li>
<li><p>如果Singleton类必须扩展一个超类，而不是扩展<code>Enum</code>时，不宜使用这种方法。</p>
</li>
</ul>
<h2 id="2-4-通过私有构造器强化不可实例化的能力（4）"><a href="#2-4-通过私有构造器强化不可实例化的能力（4）" class="headerlink" title="2.4 通过私有构造器强化不可实例化的能力（4）"></a>2.4 通过私有构造器强化不可实例化的能力（4）</h2><ul>
<li><p>一个静态工具类只包含静态方法和静态域，这种类不希望被实例化；</p>
</li>
<li><p>当一个类缺少显示构造器时，编译器会自动提供一个公有的无参缺省构造器，此时这个类是可以被实例化的。因此，只要让类包含一个私有构造器且该私有构造器一旦被调用就抛出异常，就能确保这个类不可被实例化；</p>
</li>
<li><p>这种做法的副作用是该类不可被子类化（子类都会显示或者隐式地调用超类的构造器）。</p>
</li>
</ul>
<h2 id="2-5-优先考虑依赖注入来引用资源（5）"><a href="#2-5-优先考虑依赖注入来引用资源（5）" class="headerlink" title="2.5 优先考虑依赖注入来引用资源（5）"></a>2.5 优先考虑依赖注入来引用资源（5）</h2><ul>
<li><p>不要使用Singleton类和静态工具类来实现需要引用底层资源的类，而是应该将资源或者资源工厂以依赖注入的方式传递给构造器或者静态工厂或者生成器，从而创建出需要引用资源的类；</p>
</li>
<li><p>过多的手动编写的依赖注入会导致大型项目凌乱不堪，不过这种凌乱可以通过依赖注入框架（比如Spring）得到解决。</p>
</li>
</ul>
<h2 id="2-6-避免创建不必要的对象（6）"><a href="#2-6-避免创建不必要的对象（6）" class="headerlink" title="2.6 避免创建不必要的对象（6）"></a>2.6 避免创建不必要的对象（6）</h2><ul>
<li>对于同时提供了静态工厂方法和构造器的不可变类，通常优先使用静态工厂方法；</li>
<li>如果需要重复的使用一些创建成本高的对象，可将该对象缓存起来重用；</li>
<li>优先使用基本类型而不是装箱基本类型，注意无意识的自动装箱；</li>
<li>并不是所有情况下都避免创建不必要的对象，要妥善权衡创建新对象的代价和维护单一对象的代价孰轻孰重。</li>
</ul>
<h2 id="2-7-消除过期的对象引用（7）"><a href="#2-7-消除过期的对象引用（7）" class="headerlink" title="2.7 消除过期的对象引用（7）"></a>2.7 消除过期的对象引用（7）</h2><h3 id="2-7-1-消除过期引用的方法"><a href="#2-7-1-消除过期引用的方法" class="headerlink" title="2.7.1 消除过期引用的方法"></a>2.7.1 消除过期引用的方法</h3><p>虽然Java语言具备垃圾回收功能，但程序员依旧需要考虑内存管理问题，比如消除过期的对象引用（过期引用指永远也不会被解除的引用）。消除过期引用最好的方法是让包含该引用的变量结束其生命周期，故应当在最紧凑的作用域范围内定义每一个变量。</p>
<h3 id="2-7-2-消除过期引用的好处"><a href="#2-7-2-消除过期引用的好处" class="headerlink" title="2.7.2 消除过期引用的好处"></a>2.7.2 消除过期引用的好处</h3><ul>
<li><p>如果过期引用被无意识的保留下来，那么垃圾收回不仅不会处理这个对象，也不会处理被这个对象所引用的所有其他对象。当这个对象被排除在垃圾回收机制之外，就会造成内存泄漏。这种问题的修复方法就是<strong>一旦对象引用过期，就立即消除这个引用</strong>；</p>
</li>
<li><p>如果过期引用以后又被错误的解除引用，程序会立即抛出空指针异常，而不是悄悄地错误运行下去。</p>
</li>
</ul>
<h3 id="2-7-3-内存泄漏的发生"><a href="#2-7-3-内存泄漏的发生" class="headerlink" title="2.7.3 内存泄漏的发生"></a>2.7.3 内存泄漏的发生</h3><p>内存泄漏的发生有以下几种来源：</p>
<ul>
<li><p>自己管理内存的类（比如<code>Stack</code>类）；</p>
</li>
<li><p>缓存（考虑用一个后台线程定期清理）；</p>
</li>
<li><p>监听器和其他回调（确保回调立即被当做垃圾回收的最佳方法是只保存它们的弱引用）。</p>
</li>
</ul>
<h2 id="2-8-避免使用终结方法和清除方法（8）"><a href="#2-8-避免使用终结方法和清除方法（8）" class="headerlink" title="2.8 避免使用终结方法和清除方法（8）"></a>2.8 避免使用终结方法和清除方法（8）</h2><p>终结方法（<code>finalizer</code>）和清除方法（<code>cleaner</code>）的缺点在于：</p>
<ul>
<li><p>不能被保证及时执行，从一个对象变得不可达到其终结方法被执行这段时间是任意长的，可能会随意地延迟对象的回收过程，一些重要操作无法及时执行，同时也带来时间性能上的损失；</p>
</li>
<li><p>正常情况下，未捕获的异常将会使线程终止，并打印出栈轨迹，但如果异常发生在终结方法中，则不会如此，甚至不会有警告打印出来。</p>
</li>
</ul>
<p>因此，当对象中封装的资源确实需要终止时，可以让类实现<code>AutoCloseable</code>，并要求客户端在每个实例不再需要时调用<code>close</code>方法。</p>
<p><code>finalizer</code>和<code>cleaner</code>的优点在于：</p>
<ul>
<li><p>当资源所有者忘记调用<code>close</code>方法时，<code>finalizer</code>和<code>cleaner</code>可以充当“安全网”（不一定释放资源总比一定不释放要好）；</p>
</li>
<li><p>空的<code>finalizer</code>方法可以避免恶意子类的攻击；</p>
</li>
<li><p><code>cleaner</code>方法适用于清除没有关键资源的本地对等体。</p>
</li>
</ul>
<h2 id="2-9-try-with-resources优先于try-finally（9）"><a href="#2-9-try-with-resources优先于try-finally（9）" class="headerlink" title="2.9 try-with-resources优先于try-finally（9）"></a>2.9 try-with-resources优先于try-finally（9）</h2><p><code>try-finally</code>语句的不足在于：</p>
<ul>
<li><p>客户端不一定记得编写<code>finally</code>块来释放资源，而充当“安全网”的<code>finalizer</code>和<code>cleaner</code>方法并不可靠；</p>
</li>
<li><p>当<code>finally</code>中发生异常时，<code>finally</code>中的异常会抹除<code>try</code>中发生的异常，在异常轨迹中完全没有<code>try</code>中异常的记录。</p>
</li>
</ul>
<p><code>try-with-resources</code>语句可以有效地避免以上问题，且代码更加简洁清晰。</p>
<h1 id="3、对于所有对象都通用的方法"><a href="#3、对于所有对象都通用的方法" class="headerlink" title="3、对于所有对象都通用的方法"></a>3、对于所有对象都通用的方法</h1><p>任何类在覆盖<code>Object</code>类的非<code>final</code>方法时都要遵守通用的约定，否则就无法与其他遵守约定的类一起正常工作。</p>
<h2 id="3-1-覆盖equals方法（10）"><a href="#3-1-覆盖equals方法（10）" class="headerlink" title="3.1 覆盖equals方法（10）"></a>3.1 覆盖equals方法（10）</h2><h3 id="3-1-1-何时覆盖"><a href="#3-1-1-何时覆盖" class="headerlink" title="3.1.1 何时覆盖"></a>3.1.1 何时覆盖</h3><p>不覆盖<code>equals</code>方法时，类的每个实例只与它自身相等，在满足以下任一情况时，不需要覆盖<code>equals</code>方法：</p>
<p>1）类的每个实例本质上都是唯一的；</p>
<p>2）类无需提供“逻辑相等”（不同于对象相等）的测试功能；</p>
<p>3）超类已经覆盖了<code>equals</code>，且超类的行为对这个类也是适用的；</p>
<p>4）类是私有的或者包级私有的，可以确保类的<code>equals</code>方法永远不会被调用。</p>
<p>当以上情况均不满足时，就需要覆盖<code>equals</code>方法，此时一般对应非单例的值类（一个表示值的类）</p>
<h3 id="3-1-2-如何覆盖"><a href="#3-1-2-如何覆盖" class="headerlink" title="3.1.2 如何覆盖"></a>3.1.2 如何覆盖</h3><p>覆盖<code>equals</code>方法时有以下约定：</p>
<p>1）自反性（reflexive）：对于任何非<code>null</code>的引用值<code>x</code>，<code>x.equals(x) = true</code>；</p>
<p>2）对称性（symmetric）：对于任何非<code>null</code>的引用值<code>x</code>和<code>y</code>，<code>x.equals(y) == y.equals(x)</code>；</p>
<p>3）传递性（transitive）：对于任何非<code>null</code>的引用值<code>x</code>、<code>y</code>和<code>z</code>，如果<code>x.equals(y) = true</code>且<code>y.equals(z) = true</code>，则<code>x.equals(z) = true</code>；</p>
<p>4）一致性（consistent）：对于任何非<code>null</code>的引用值<code>x</code>和<code>y</code>，只要<code>x</code>和<code>y</code>的值没有被修改，则<code>x.equals(y)</code>的返回值始终保持一致；</p>
<p>5）对于任何非null的引用值<code>x</code>，<code>x.equals(null) = false</code>。</p>
<h3 id="3-1-3-高质量覆盖"><a href="#3-1-3-高质量覆盖" class="headerlink" title="3.1.3 高质量覆盖"></a>3.1.3 高质量覆盖</h3><p>对于<code>XXX</code>类的<code>equals(Object o)</code>方法，可按照以下步骤实现高质量的<code>equals</code>方法覆盖：</p>
<p>1）<code>if (o == this) return true;</code></p>
<p>2）<code>if (!(o instanceof XXX)) return false;</code></p>
<p>3）<code>XXX x = (XXX) o;</code></p>
<p>4）对于<code>XXX</code>类中的每个域，检查参数中的域是否与<code>this</code>中对应的域相匹配域；</p>
<p>5）对于非<code>float</code>且非<code>double</code>的基本类型域，使用<code>==</code>操作符进行比较；对于引用类型域，可以递归地调用<code>equals</code>方法；对于<code>float</code>域，可以使用<code>Float.compare</code>方法进行比较；对于<code>double</code>域，使用<code>Double.compare</code>方法进行比较。</p>
<h3 id="3-1-4-注意事项"><a href="#3-1-4-注意事项" class="headerlink" title="3.1.4 注意事项"></a>3.1.4 注意事项</h3><p>1）在扩展可实例化的类时，无法同时增加新的值组件又保留<code>equals</code>约定；</p>
<p>2）与其扩展可实例化的类得到新类，不如将该可实例化的类作为一个私有域放入新类中（并提供一个视图方法返回该私有域），即复合优于继承；</p>
<p>3）可以在一个抽象类的子类中增加新的值组件且不违反<code>equals</code>约定；</p>
<p>4）不要使<code>equals</code>方法依赖于不可靠的资源；</p>
<p>5）域的比较顺序会影响<code>equals</code>方法的性能，应最先比较最有可能不一致的域或者是开销最低的域；</p>
<p>6）覆盖<code>equals</code>时总要覆盖<code>hashCode</code>；</p>
<p>7）不要重载<code>equals</code>；</p>
<p>8）让IDE或者框架自动生成<code>equals</code>和<code>hashCode</code>通常优于手工实现。</p>
<h2 id="3-2-覆盖hashCode方法（11）"><a href="#3-2-覆盖hashCode方法（11）" class="headerlink" title="3.2 覆盖hashCode方法（11）"></a>3.2 覆盖hashCode方法（11）</h2><h3 id="3-2-1-何时及如何覆盖"><a href="#3-2-1-何时及如何覆盖" class="headerlink" title="3.2.1 何时及如何覆盖"></a>3.2.1 何时及如何覆盖</h3><p>覆盖<code>equals</code>时总要覆盖<code>hashCode</code>，覆盖<code>hashCode</code>方法时有以下约定：</p>
<p>1）在应用程序执行期间，只要对象的<code>equals</code>方法的比较操作所用到的信息没有被修改，则该对象的<code>hashCode</code>方法的返回值保持一致；</p>
<p>2）在一个应用程序与另一个程序的执行过程中，执行<code>hashCode</code>方法的返回值可以不一致；</p>
<p>3）如果两个对象根据<code>equals</code>比较结果是相等的，则这两个对象的<code>hashCode</code>方法的返回值也必须相等；</p>
<p>4）如果两个对象根据<code>equals</code>比较结果是不相等的，则这两个对象的<code>hashCode</code>方法的返回值不要求必须不相等（但对于不相等的对象产生不相等的散列值有助于提高散列表的性能）。</p>
<h3 id="3-2-2-高质量覆盖"><a href="#3-2-2-高质量覆盖" class="headerlink" title="3.2.2 高质量覆盖"></a>3.2.2 高质量覆盖</h3><p>一个好的散列表应该把集合中不相等的实例均匀地分布到所有可能的<code>int</code>值上，可按照以下步骤来大致实现：</p>
<p>1）对对象中的每一个关键域都计算其散列码（关键域指会影响<code>equals</code>比较的域）；</p>
<p>2）基本类型的散列码为其装箱类型的散列码，值为<code>null</code>的引用类型的散列码为0（或者其他某个常数，但通常是零），数组中的每一个元素都要当做单独的域来计算其散列码；</p>
<p>3）声明一个<code>int</code>变量命名为<code>result</code>，并初始化为对象中的第一个关键域的散列码c；</p>
<p>4）将对象中所有域计算得到的散列码c整合到<code>result = 31 * result + c</code>中，最终得到的<code>result</code>即为对象的散列码。</p>
<h3 id="3-2-3-注意事项"><a href="#3-2-3-注意事项" class="headerlink" title="3.2.3 注意事项"></a>3.2.3 注意事项</h3><p>在散列码的计算过程中：</p>
<p>1）不要排除任何关键域的散列码来提升计算性能；</p>
<p>2）可以排除衍生域的散列码（衍生域指可以由其他域值计算得到的域）；</p>
<p>3）必须排除<code>equals</code>比较中没有用到的任何域的散列码；</p>
<p>4）乘数选择31是因为它是一个奇素数，如果乘数是偶数且乘法溢出时，信息会丢失，31有个很好的特性在于现代虚拟机可以自动用移位和减法来代替乘法<code>31 * i == (i &lt;&lt; 5) - i</code>，从而获得更好的性能；</p>
<p>5）如果一个类是不可变的，且计算散列码的开销较大，则应该将散列码缓存在对象内部；</p>
<p>6）可以让IDE或者框架自动生成<code>hashCode</code>。</p>
<h2 id="3-3-覆盖toString方法（12）"><a href="#3-3-覆盖toString方法（12）" class="headerlink" title="3.3 覆盖toString方法（12）"></a>3.3 覆盖toString方法（12）</h2><h3 id="3-3-1-何时及如何覆盖"><a href="#3-3-1-何时及如何覆盖" class="headerlink" title="3.3.1 何时及如何覆盖"></a>3.3.1 何时及如何覆盖</h3><p><code>Object</code>方法提供的<code>toString</code>方法返回的是<code>类的名称@散列码的无符号十六进制</code>，<code>toString</code>方法的通用约定要求：</p>
<p>1）被返回的字符串应当是一个简洁的但信息丰富、易于阅读的表达形式；</p>
<p>2）所有类都应该覆盖<code>toString</code>方法。</p>
<h3 id="3-3-2-高质量覆盖"><a href="#3-3-2-高质量覆盖" class="headerlink" title="3.3.2 高质量覆盖"></a>3.3.2 高质量覆盖</h3><p>提供好的<code>toString</code>方法可以使类使用起来更加舒适，使用了这个类的系统也更加易于调试。</p>
<p>1）在实际应用中，<code>toString</code>方法应返回对象中包含的所有值得关注的信息；</p>
<p>2）指定<code>toString</code>方法的返回值的格式使得它可以被用作一种标准的、明确的、适合人阅读的对象表示法；</p>
<p>3）一旦指定格式，就必须始终如一地坚持这种格式，程序员可以解析和产生这种格式的字符串并嵌入持久的数据中；</p>
<p>4）如果不指定格式，就可以保留灵活性，便于在将来发行版本中增加信息，或者改进格式。</p>
<h3 id="3-3-3-注意事项"><a href="#3-3-3-注意事项" class="headerlink" title="3.3.3 注意事项"></a>3.3.3 注意事项</h3><p>1）无论是否指定格式，都应该在文档中明确地表明你的意图；</p>
<p>2）不要在不可实例化的静态工具类以及枚举类型中编写<code>toString</code>方法；</p>
<p>3）在子类共享通过字符串表示法的抽象类中一定要编写<code>toString</code>方法；</p>
<p>4）在每一个可实例化的类中覆盖<code>toString</code>方法，除非已经在超类中覆盖了；</p>
<p>5）可以让IDE或者框架自动生成<code>toString</code>。</p>
<h2 id="3-4-覆盖clone方法（13）"><a href="#3-4-覆盖clone方法（13）" class="headerlink" title="3.4 覆盖clone方法（13）"></a>3.4 覆盖clone方法（13）</h2><h3 id="3-4-1-何时及如何覆盖"><a href="#3-4-1-何时及如何覆盖" class="headerlink" title="3.4.1 何时及如何覆盖"></a>3.4.1 何时及如何覆盖</h3><p><code>Cloneable</code>接口并没有包含任何方法，但如果一个类实现了<code>Cloneable</code>接口，类的<code>clone</code>方法就返回该对象的逐域拷贝。也就是说：类实现<code>Cloneable</code>接口是为了提供一个功能适当的公有的<code>clone</code>方法，表明这个类的对象允许克隆。</p>
<p>覆盖<code>clone</code>方法时有以下约定：</p>
<p>1）对于任何对象<code>x</code>，表达式<code>x.clone() != x</code>，<code>x.clone().getClass() == x.getClass()</code>，<code>x.clone().equals(x)</code>均返回true，但这也不是一个绝对的要求；</p>
<p>2）<code>clone</code>方法返回的对象应该不依赖于被克隆的对象，应该通过调用<code>super.clone</code>获得。</p>
<h3 id="3-4-2-高质量覆盖"><a href="#3-4-2-高质量覆盖" class="headerlink" title="3.4.2 高质量覆盖"></a>3.4.2 高质量覆盖</h3><p>1）类声明为实现<code>Cloneable</code>接口；</p>
<p>2）使用<code>try-catch</code>语句执行整个克隆过程；</p>
<p>3）调用<code>super.clone</code>并将返回类型转换为当前类；</p>
<p>4）逐项拷贝对象中的所有域，可以i）递归调用<code>clone</code>或者ii）深度拷贝或者iii）先将域设置成初始状态，然后调用高层的方法来重新产生对象的状态；</p>
<p>5）对于代表序列号或者其他唯一ID值的域需要修正域值。</p>
<h3 id="3-4-3-注意事项"><a href="#3-4-3-注意事项" class="headerlink" title="3.4.3 注意事项"></a>3.4.3 注意事项</h3><p>1）不可变的类永远都不要提供<code>clone</code>方法；</p>
<p>2）必须确保<code>clone</code>方法（另一个构造器）不会伤害到原始的对象；</p>
<p>3）确保能正确地创建被克隆对象的约束条件；</p>
<p>4）数组是<code>clone</code>方法唯一吸引人的用法；</p>
<p>5）在克隆对象时，需要从某些域中去掉<code>final</code>修饰符；</p>
<p>6）<code>clone</code>方法不能在构造的过程中调用可以覆盖的方法；</p>
<p>7）<code>Object</code>中的<code>clone</code>方法是受保护的，子类覆盖的<code>clone</code>方法是公有的；</p>
<p>8）公有<code>clone</code>方法不应有抛出异常的<code>throws</code>声明；</p>
<p>9）在编程线程安全的类时，应用<code>synchronized</code>修饰<code>clone</code>方法。</p>
<h3 id="3-4-4-clone的代替"><a href="#3-4-4-clone的代替" class="headerlink" title="3.4.4 clone的代替"></a>3.4.4 clone的代替</h3><p>与其实现<code>Cloneable</code>接口并覆盖<code>clone</code>方法，不如使用拷贝构造器或者拷贝工厂，其优势在于：</p>
<p>1）不依赖于一种很有风险的、语言之外的对象创建机制；</p>
<p>2）不要求遵守尚未制定好的文档的规范；</p>
<p>3）不会与<code>final</code>域的正常使用发生冲突；</p>
<p>4）不会抛出不必要的受检异常；</p>
<p>5）不需要进行类型转换</p>
<p>6）可以通过传入参数来选择希望拷贝成何种类型的对象。</p>
<p>因此，<strong>除了拷贝数组时使用<code>clone</code>方法，拷贝其他对象最好使用拷贝构造器或者拷贝工厂</strong>。</p>
<h2 id="3-5-实现Comparable接口（14）"><a href="#3-5-实现Comparable接口（14）" class="headerlink" title="3.5 实现Comparable接口（14）"></a>3.5 实现Comparable接口（14）</h2><h3 id="3-5-1-何时及如何实现"><a href="#3-5-1-何时及如何实现" class="headerlink" title="3.5.1 何时及如何实现"></a>3.5.1 何时及如何实现</h3><p><code>Comparable</code>接口中只有一个<code>compareTo</code>方法（不是<code>Object</code>类的方法），<code>compareTo</code>方法不但允许等同性比较，还允许执行顺序比较。类实现<code>Comparable</code>接口就表明该类的实例具有内在的排序关系。</p>
<p>覆盖<code>compareTo</code>方法时有以下约定：</p>
<p>1）当前对象小于、等于或大于指定对象时，<code>compareTo</code>分别返回一个负整数、零和正整数；</p>
<p>2）所有的<code>x</code>和<code>y</code>都满足当<code>x.compareTo(y)</code>抛出异常时<code>y.compareTo(x)</code>也抛出异常，当不抛出异常时<code>sgn(x.compareTo(y)) == -sgn(y.compareTo(x))</code>；</p>
<p>3）当<code>x.compareTo(y) &gt; 0</code>且<code>y.compareTo(z) &gt; 0</code>时，<code>x.compareTo(z) &gt; 0</code>；</p>
<p>4）当<code>x.compareTo(y) == 0</code>时，<code>sgn(x.compareTo(z)) == sgn(y.compareTo(z))</code>；</p>
<p>5）建议<code>(x.compareTo(y) == 0) == (x.equals(y))</code>，但这并非绝对必要，当这个条件不满足时，应给出明确说明。</p>
<p>在覆盖<code>compareTo</code>方法时，应<strong>依次从最关键的域开始比较</strong>，逐步进行到所有的重要域。</p>
<h3 id="3-5-2-注意事项"><a href="#3-5-2-注意事项" class="headerlink" title="3.5.2 注意事项"></a>3.5.2 注意事项</h3><p>1）<code>compareTo</code>不能跨越不同类型进行比较，如果当前对象与指定对象无法进行比较，则抛出异常；</p>
<p>2）所有值类和所有的枚举类型都实现了<code>Comparable</code>接口；</p>
<p>3）依赖于比较关系的类包括有序集合类<code>TreeSet</code>和<code>TreeMap</code>以及工具类<code>Collections</code>和<code>Arrays</code>，它们内部包含有搜索和排序算法；</p>
<p>4）在扩展可实例化的类时，无法同时增加新的值组件又保留<code>compareTo</code>约定；</p>
<p>5）与其扩展可实例化的类得到新类，不如将该可实例化的类作为一个私有域放入新类中（并提供一个视图方法返回该私有域），即复合优于继承；</p>
<p>6）比较域值时，不要使用关系操作符<code>&lt;</code>和<code>&gt;</code>；</p>
<p>7）对于基本数据类型域，使用其装箱类的静态的<code>compare</code>方法进行比较；</p>
<p>8）对引用数据类型域，可使用<code>Comparator</code>接口中的比较器。</p>
<h1 id="4、类和接口"><a href="#4、类和接口" class="headerlink" title="4、类和接口"></a>4、类和接口</h1><p>类和接口是Java语言的基本抽象单元。</p>
<h2 id="4-1-使类和成员和可访问性最小化（15）"><a href="#4-1-使类和成员和可访问性最小化（15）" class="headerlink" title="4.1 使类和成员和可访问性最小化（15）"></a>4.1 使类和成员和可访问性最小化（15）</h2><p>设计良好的组件会隐藏所有的实现细节，将API和实现清晰地隔离开来，组件之间只通过API进行通信。一个模块不需要知道其他模块的内部工作细节，这个概念被称为信息隐藏或封装。Java通过控制访问机制来决定成员的可访问性，从而协助信息隐藏。</p>
<h3 id="4-1-1-成员访问级别"><a href="#4-1-1-成员访问级别" class="headerlink" title="4.1.1 成员访问级别"></a>4.1.1 成员访问级别</h3><p>成员（域、方法、嵌套类、嵌套接口）有四种访问级别：</p>
<p>1）私有的（<code>private</code>）：只有在声明该成员的顶层类的内部才可以访问；</p>
<p>2）包级私有的（<code>default</code>）：声明该成员的包内部的任何类都可以访问；</p>
<p>3）受保护的（<code>protected</code>）：声明该成员的类的子类可以访问，声明该成员的包内部的任何类可以访问；</p>
<p>4）公有的（<code>public</code>）：任何地方都可以访问。</p>
<p>顶层的（非嵌套的）类和接口只有两种访问级别：</p>
<p>1）<code>default</code>：是包的实现的一部分，在以后的发行版本中，可以对其进行修改、替换或者删除，而无须担心会影响到现有的客户端程序；</p>
<p>2）<code>public</code>：是包导出的API，有责任永远支持它，以保持它们的兼容性。</p>
<h3 id="4-1-2-注意事项"><a href="#4-1-2-注意事项" class="headerlink" title="4.1.2 注意事项"></a>4.1.2 注意事项</h3><p>1）一个<code>default</code>的顶层类或接口如果只是在某一个类的内部使用，则应该使它成为唯一使用它的那个类的<code>private</code>嵌套类；</p>
<p>2）当同一个包内的另一个类真正需要访问一个<code>private</code>成员时，才应该删除<code>private</code>，使其成为<code>default</code>；</p>
<p>3）如果上一条中的情况经常出现，则应该重新检查系统设计，降低类之间的耦合度；</p>
<p>4）<code>protected</code>成员是类的导出的API的一部分，必须永远得到支持，应尽量少用<code>protected</code>成员；</p>
<p>5）当子类覆盖了超类中的方法时，子类中的访问级别不应低于超类中的访问级别，以确保任何可使用超类实例的地方也都可以使用子类的实例；</p>
<p>6）当一个类实现一个接口时，接口中的所有方法在这个类中都必须声明为<code>public</code>；</p>
<p>7）不能为了测试而将<code>private</code>或者<code>default</code>改成<code>protected</code>或者<code>public</code>，但可以将测试作为被测试的包的一部分来运行，从而使得测试能够访问被测试的<code>default</code>成员；</p>
<p>8）<code>public</code>类不应包含<code>public</code>域，并要确保<code>final</code>域所引用的对象是不可变的；</p>
<p>9）长度非零的数组总是可变的，类不应具备<code>public static final</code>数组域，不应具备返回这种域的访问方法，可以将这个数组域改为<code>private</code>，并给出一个返回这个数组域的拷贝的<code>public</code>方法。</p>
<h2 id="4-2-要在公有类而非公有域中使用访问方法（16）"><a href="#4-2-要在公有类而非公有域中使用访问方法（16）" class="headerlink" title="4.2 要在公有类而非公有域中使用访问方法（16）"></a>4.2 要在公有类而非公有域中使用访问方法（16）</h2><p>1）如果类可以在其所在的包之外进行访问，就提供访问方法，即<code>public</code>类不应暴露其数据域；</p>
<p>2）<code>default</code>类或者<code>private</code>嵌套类可以直接暴露其数据域。</p>
<h2 id="4-3-使可变性最小化（17）"><a href="#4-3-使可变性最小化（17）" class="headerlink" title="4.3 使可变性最小化（17）"></a>4.3 使可变性最小化（17）</h2><h3 id="4-3-1-不可变类"><a href="#4-3-1-不可变类" class="headerlink" title="4.3.1 不可变类"></a>4.3.1 不可变类</h3><p>不可变类指实例不能被修改的类（更加安全），实例中包含的所有信息必须在创建该实例时就提供，并在实例的整个声明周期内固定不变。</p>
<p>设计一个不可变类要遵循以下规则：</p>
<p>1）不提供任何设置方法；</p>
<p>2）保证类不会被扩展（可用<code>final</code>修饰）；</p>
<p>3）所有域都声明为<code>final</code>；</p>
<p>4）所有域都声明为<code>private</code>；</p>
<p>5）对于指向可变对象的域，不得提供该域的访问方法，不得使用客户端提供的对象来初始化该域，在构造器、访问方法和<code>readObject</code>方法中使用保护性拷贝技术。</p>
<h3 id="4-3-2-函数的（functional）方法"><a href="#4-3-2-函数的（functional）方法" class="headerlink" title="4.3.2 函数的（functional）方法"></a>4.3.2 函数的（functional）方法</h3><p>不可变类提供functional方法，该方法对操作数进行运算但并不修改它，在返回时会创建一个新的不可变类实例，而不是修改当前实例。functional方法的名称都是介词（如<code>plus</code>）而不是动词（如<code>add</code>），这是为了强调该方法不会改变实例的状态。</p>
<h3 id="4-3-3-注意事项"><a href="#4-3-3-注意事项" class="headerlink" title="4.3.3 注意事项"></a>4.3.3 注意事项</h3><p>1）不可变类是线程安全的，它们不要求同步，可以自由地被线程共享，永远不需要进行保护性拷贝，不要提供<code>clone</code>方法或者拷贝构造器；</p>
<p>2）客户端应尽可能地重用现有的实例，对于频繁用到的值，为其提供<code>public static final</code>常量，甚至可以提供静态工厂，将频繁被请求的实例缓存起来；</p>
<p>3）为了保证不可变类不会被扩展，除了可用<code>final</code>修饰，还可以通过让类的构造器都变成<code>private</code>或者<code>default</code>，并添加<code>public</code>静态工厂来代替<code>public</code>构造器；</p>
<p>4）不可变类唯一的缺点在于对于每个不同的值都需要一个单独的对象，而创建这些对象的代价可能很高；</p>
<p>5）针对上一条，可以为不可变类提供其<code>public</code>可变配套类，或者不可变类其实可以有一个或者多个非<code>final</code>的域，这些域用于存储一些开销昂贵的计算结果缓存，如果将来再次请求相同的计算，就直接返回这些缓存的值；</p>
<p>6）对于可变类，除非有令人信服的理由使域成为非<code>final</code>的，否则每个域都是<code>final</code>的，除非有令人信服的理由，不要在构造器或者静态工厂之外再提供<code>public</code>初始化方法。</p>
<h2 id="4-4-复合优先于继承（18）"><a href="#4-4-复合优先于继承（18）" class="headerlink" title="4.4 复合优先于继承（18）"></a>4.4 复合优先于继承（18）</h2><p>1）在包的内部使用继承是非常安全的，但进行跨越包边界的继承是非常危险的，继承破坏了封装性，当超类发生改变时，子类可能会遭到破坏；</p>
<p>2）可以考虑不扩展现有的类，而是在新的类中添加一个引用现有类的实例的<code>private</code>域，现有类变成了新类的一个组件，这种设计被称为“复合（composition）”；</p>
<p>3）装饰器模式用到了复合，装饰器在实现想要包装的接口的同时还将该接口添加为自己的一个域，通过扩展装饰器可以得到各种功能的包装类；</p>
<p>4）包装类几乎没有缺点，但是包装类不适用于回调框架；</p>
<p>5）在适合用复合的地方使用了继承会不必要地暴露实现细节，这样得到的API会被限制在原始的实现上，子类的性能也被限制了。</p>
<h2 id="4-5-设计可继承的类并提供文档说明（19）"><a href="#4-5-设计可继承的类并提供文档说明（19）" class="headerlink" title="4.5 设计可继承的类并提供文档说明（19）"></a>4.5 设计可继承的类并提供文档说明（19）</h2><p>对于专门为了继承而设计的类，应当具有良好的说明文档：</p>
<p>1）精准说明覆盖每个方法所带来的影响（即方法的自用性）；</p>
<p>2）指明<code>public</code>和<code>protected</code>方法或者构造器调用了哪些可覆盖的方法，可覆盖的方法指非<code>final</code>的<code>public</code>或者<code>protected</code>方法。</p>
<p>对于为了继承而设计的类，应当遵守以下限制：</p>
<p>1）通过编写子类来测试该类；</p>
<p>2）构造器决不能调用可被覆盖的方法，无论是直接调用还是间接调用；</p>
<p>3）构造器调用<code>private</code>、<code>final</code>和<code>static</code>方法是安全的，因为这些都是不可被覆盖的方法；</p>
<p>4）如果要实现<code>Cloneable</code>和<code>Serializable</code>接口，则<code>clone</code>和<code>readObject</code>方法都应遵守和构造器一样的限制；</p>
<p>5）对于不是为了继承而设计的类，应保证该类不会被子类化。</p>
<h2 id="4-6-接口优于抽象类（20）"><a href="#4-6-接口优于抽象类（20）" class="headerlink" title="4.6 接口优于抽象类（20）"></a>4.6 接口优于抽象类（20）</h2><p>抽象类的劣势在于：</p>
<p>1）为了实现抽象类定义的类型，类必须成为抽象类的一个子类，但因为Java只允许单继承，所以用抽象类作为类型定义受到了限制；</p>
<p>2）扩展抽象类时，抽象类就必须放到类型层次的高处，从而间接地伤害到类层次。</p>
<p>接口的劣势在于：</p>
<p>1）接口中不允许包含实例域，不允许包含非<code>public</code>的静态成员（<code>private</code>静态方法除外），这些域隐式地是<code>static</code>和<code>final</code>的；</p>
<p>2）不允许给<code>Object</code>方法提供缺省实现。</p>
<p>接口的优势在于：</p>
<p>1）接口允许构造非层次结构的类型框架；</p>
<p>2）接口可以安全地增强类的功能；</p>
<p>3）通过给接口提供一个抽象的骨架实现类，可以保留接口的优势并弥补接口的劣势，接口负责定义类型和一些缺省方法，骨架类负责实现非基本类型接口方法，骨架实现类（为继承而设计的类）的扩展则实现基本类型接口方法，这就是模板方法模式。</p>
<h2 id="4-7-为后代设计接口（21）"><a href="#4-7-为后代设计接口（21）" class="headerlink" title="4.7 为后代设计接口（21）"></a>4.7 为后代设计接口（21）</h2><p>在Java8发行之前并不允许给接口添加新的方法，在Java8之后可以通过添加缺省方法来给接口添加方法。</p>
<p>1）尽量避免使用缺省方法在现有接口上添加新的方法，应当慎重考虑缺省方法的缺省实现是否会破坏现有的方法实现；</p>
<p>2）在创建接口时，使用缺省方法来提供标准化的方法实现是非常方便的；</p>
<p>3）缺省方法不支持从接口中删除方法，不支持修改现有方法的签名；</p>
<p>4）测试接口时，应当以不同的方法实现每一个接口，编写多个客户端程序，利用每个新接口的实例来执行不同的任务。</p>
<h2 id="4-8-接口只用于定义类型（22）"><a href="#4-8-接口只用于定义类型（22）" class="headerlink" title="4.8 接口只用于定义类型（22）"></a>4.8 接口只用于定义类型（22）</h2><p>常量接口模式（只含有静态常量而任何没有方法的接口）是对接口的不良使用。接口应该只被定义类型，不应被用来导出常量。</p>
<p>常量接口可以修改为枚举类型或者不可实例化的工具类。</p>
<h2 id="4-9-类层次优于标签类（23）"><a href="#4-9-类层次优于标签类（23）" class="headerlink" title="4.9 类层次优于标签类（23）"></a>4.9 类层次优于标签类（23）</h2><p>标签类指带有多种风格实例的类，这种类过于冗长，效率低下。</p>
<p>将标签类修改为具备类层次的多个类可以使得代码清晰简单，反映类型之间本质上的层次关系，增强灵活性。基本没有适用标签类的场景。</p>
<h2 id="4-10-静态成员优于非静态成员（24）"><a href="#4-10-静态成员优于非静态成员（24）" class="headerlink" title="4.10 静态成员优于非静态成员（24）"></a>4.10 静态成员优于非静态成员（24）</h2><p>嵌套类指定义在另一个类内部的类，目的在于为它的外围类提供服务。如果嵌套类将来可能会用于其他的某个环境中，它就应该成为顶层类。</p>
<p>嵌套类可分为以下四种</p>
<p>1）静态成员类：可以看作是普通的类，只是恰好被声明在另一个类的内部，<strong>如果嵌套类的实例可以在它的外围类的实例之外独立存在，这个嵌套类就必须是静态成员类</strong>；</p>
<p>2）非静态成员类：非静态成员类的每个实例都与外围类的外围实例相关联，在没有外围实例的情况下，创建非静态成员类的实例是不可能的；</p>
<p>3）匿名类：匿名类不是外围类的成员，仅在使用时同时被声明和实例化，匿名类是动态创建小型函数对象和过程对象的最佳方式，匿名类必须保持简短（10行或者更少）来保证程序可读性；</p>
<p>4）局部类：局部类有名字，可以被重复使用，需要保持简短来保证程序可读性。</p>
<h2 id="4-11-限制源文件为单个顶级类（25）"><a href="#4-11-限制源文件为单个顶级类（25）" class="headerlink" title="4.11 限制源文件为单个顶级类（25）"></a>4.11 限制源文件为单个顶级类（25）</h2><p>1）顶级类应当分别放在独立的源文件中，从而确保编译时一个类时不会有多个定义；</p>
<p>2）如果一定要把多个顶级类放在一个源文件中，则可以考虑使用静态成员类。</p>
<h1 id="5、泛型"><a href="#5、泛型" class="headerlink" title="5、泛型"></a>5、泛型</h1><p>从Java5开始，泛型成为了Java编程语言的一部分，泛型可以令开发者告知编译器每个集合中接收那些对象类型，编译器在编译时会告知开发者是否插入了类型错误的对象，从而使得程序更加安全、清楚。</p>
<h2 id="5-1-不使用原生态类型（26）"><a href="#5-1-不使用原生态类型（26）" class="headerlink" title="5.1 不使用原生态类型（26）"></a>5.1 不使用原生态类型（26）</h2><p>声明中具有一个或者多个类型参数的类或者接口，就是泛型类或者接口，泛型类和接口统称为泛型，每一种泛型都定义一个原生态类型，即不带任何实际类型参数的泛型名称（例如<code>List&lt;E&gt;</code>的原生态类型为<code>List</code>）。原生态类型只是为了与引入泛型之前的遗留代码进行兼容和互用而提供的。</p>
<p>1）原生态类型虽然合法，但逃避了泛型检查，会失掉类型安全性，所以不要使用原生态类型；</p>
<p>2）原生态类型的安全替代是无限制的通配符类型（例如<code>List</code>的无限制通配符类型为<code>List&lt;?&gt;</code>，读作某个类型的<code>List</code>），无限制的通配符类型是安全的，可以持有任何类型的元素（除了<code>null</code>）；</p>
<p>3）在参数化类型上使用<code>instanceof</code>操作符是非法的，在原生态类型和无限制通配符类型上使用<code>instanceof</code>操作符是合法的。</p>
<h2 id="5-2-消除非受检的警告（27）"><a href="#5-2-消除非受检的警告（27）" class="headerlink" title="5.2 消除非受检的警告（27）"></a>5.2 消除非受检的警告（27）</h2><p>1）在用泛型编程时会遇到许多编译器提示的非受检警告，应当尽可能地消除每一个非受检警告；</p>
<p>2）<code>@SuppressWarning(&quot;unchecked&quot;)</code>注解可以禁止非受检警告，该注解可以用在任何粒度的级别中，但应当在尽可能小的范围内使用该注解，永远不要在整个类上使用该注解；</p>
<p>3）每次使用<code>@SuppressWarning(&quot;unchecked&quot;)</code>注解时都要通过注释说明为什么这么做是安全的。</p>
<h2 id="5-3-列表优于数组（28）"><a href="#5-3-列表优于数组（28）" class="headerlink" title="5.3 列表优于数组（28）"></a>5.3 列表优于数组（28）</h2><p>1）使用数组时，如果将错误类型的对象放入数组，直到代码运行时才能发现该错误，而列表使得编译时就能发现错误；</p>
<p>2）数组在运行时知道并强化元素类型，而列表泛型只是在编译时强化元素的类型并在运行时通过擦除来丢弃元素类型，从而使得泛型可以与没有使用泛型的代码兼容；</p>
<p>3）创建泛型数组是违法的，最好修改为<code>List&lt;E&gt;</code>而不是<code>E[]</code>，这样可能会损失一些性能，但具有更高的类型安全性和互用性。</p>
<h2 id="5-4-优先考虑泛型（29）"><a href="#5-4-优先考虑泛型（29）" class="headerlink" title="5.4 优先考虑泛型（29）"></a>5.4 优先考虑泛型（29）</h2><p>1）在使用数组时，依旧优先考虑将元素类型泛型化；</p>
<p>2）由于创建泛型数组是违法的，因此可以i）创建<code>Object</code>数组再装换为泛型数组类型；ii）创建<code>Object</code>数组，将从数组中获取到的元素转换为泛型类型，这两种方法都需要增加<code>@SuppressWarning(&quot;unchecked&quot;)</code>注解及注释来禁止警告；</p>
<p>3）Java并非生来就支持列表，有些泛型（比如<code>ArrayList</code>）必须在数组上实现。</p>
<h2 id="5-5-优先考虑泛型方法（30）"><a href="#5-5-优先考虑泛型方法（30）" class="headerlink" title="5.5 优先考虑泛型方法（30）"></a>5.5 优先考虑泛型方法（30）</h2><p>1）方法同样可以受益于泛型化，尤其是静态工具方法；</p>
<p>2）泛型方法需声明类型参数，方法的类型参数声明位于方法修饰符和返回值之间；</p>
<p>3）类型限制<code>&lt;E extends Comparable&lt;E&gt;&gt;</code>读作“针对可以与自身进行比较的每个类型<code>E</code>”。</p>
<h2 id="5-6-利用有限制通配符来提升API灵活性（31）"><a href="#5-6-利用有限制通配符来提升API灵活性（31）" class="headerlink" title="5.6 利用有限制通配符来提升API灵活性（31）"></a>5.6 利用有限制通配符来提升API灵活性（31）</h2><p>1）当某个参数既是生产者又是消费者时，泛型可以提供严格的类型匹配；</p>
<p>2）当某个参数是生产者或者消费者时，可通过有限通配符类型来提升参数；灵活性；</p>
<p>3）不要用有限通配符类型作为方法返回类型；</p>
<p>4）当类型参数只在方法中出现一次时，就可以用通配符取代它，无限制的类型参数就用无限制的通配符取代，有限制的类型参数就用有限制的通配符取代；</p>
<h2 id="5-7-谨慎并用泛型和可变参数（32）"><a href="#5-7-谨慎并用泛型和可变参数（32）" class="headerlink" title="5.7 谨慎并用泛型和可变参数（32）"></a>5.7 谨慎并用泛型和可变参数（32）</h2><p>1）显式创建泛型数组是违法的，但用泛型可变参数声明方法是合法的；</p>
<p>2）当调用一个可变参数方法时，会创建一个数组用于存放可变参数，<strong>将值保存在泛型可变参数数组参数中是不安全的，允许另一个方法访问该数组也是不安全的</strong>；</p>
<p>3）客户端每次调用带泛型可变参数的方法时都会产生警告，该方法的设计者可通过<code>@SafeVarargs</code>注解来禁止客户端的警告；</p>
<p>4）只有方法没有在可变参数数组中保存任何值，也不允许对数组的引用转义时，该带泛型可变参数的方法才是安全的，只有方法是安全的，才可以使用<code>@SafeVarargs</code>注解；</p>
<p>5）<code>@SafeVarargs</code>注解只能用于无法被覆盖的方法，即<code>static</code>和<code>final</code>实例方法；</p>
<p>6）不想使用<code>@SafeVarargs</code>注解时，也可用List参数代替可变参数。</p>
<h2 id="5-8-优先考虑类型安全的异构容器（33）"><a href="#5-8-优先考虑类型安全的异构容器（33）" class="headerlink" title="5.8 优先考虑类型安全的异构容器（33）"></a>5.8 优先考虑类型安全的异构容器（33）</h2><p>泛型常用于参数化了的容器（比如集合），从而限制容器的元素类型。但在数据库的场景下，希望能以类型安全的方法访问任意数量的列，此时就需要<strong>将键进行参数化</strong>而不是将容器参数化，然后将参数化的键提交给容器来插入或者获取值，如果该容器的所有键都是不同类型的，则该容器称为类型安全带异构容器。</p>
<h1 id="6、枚举和注解"><a href="#6、枚举和注解" class="headerlink" title="6、枚举和注解"></a>6、枚举和注解</h1><p>类是枚举类型，接口是注解类型。</p>
<h2 id="6-1-用enum代替int常量（34）"><a href="#6-1-用enum代替int常量（34）" class="headerlink" title="6.1 用enum代替int常量（34）"></a>6.1 用enum代替int常量（34）</h2><p>1）枚举类型是指由一组固定的常量值组成合法值的类型；</p>
<p>2）Java的枚举类是通过公有的静态<code>final int</code>域为每个枚举常量导出一个实例，枚举类型没有可以访问的构造器，是<code>final</code>类；</p>
<p>3）客户端无法创建枚举类型的实例，也无法对其进行扩展，只存在声明过的枚举常量；</p>
<p>4）枚举类型允许添加任意方法和域，允许实现任意接口；</p>
<p>5）每当需要一组固定常量，并在编译时就知道其成员时，就应该使用枚举；</p>
<p>6）当多个枚举常量同时共享相同的行为时，考虑策略枚举。</p>
<h2 id="6-2-用实例域代替序数（35）"><a href="#6-2-用实例域代替序数（35）" class="headerlink" title="6.2 用实例域代替序数（35）"></a>6.2 用实例域代替序数（35）</h2><p>所有的枚举都有一个<code>ordinal</code>方法，该方法可以返回每个枚举常量在类型中数字位置，即序数，但永远不要根据枚举的序数导出与枚举常量关联的值，即最好避免使用<code>ordinal</code>方法。</p>
<h2 id="6-3-用EnumSet代替位域（36）"><a href="#6-3-用EnumSet代替位域（36）" class="headerlink" title="6.3 用EnumSet代替位域（36）"></a>6.3 用EnumSet代替位域（36）</h2><p>1）如果一个枚举类型的元素主要用在集合中，通过位运算将几个常量合并到一个集合中，称为位域；</p>
<p>2）位域表示法具有很多缺点，难以遍历，不好确定<code>int</code>还是<code>long</code>型；</p>
<p>3）可以使用<code>java.util</code>包中的<code>EnumSet</code>类来有效地表达从单个枚举类型中提取的多个值的多个集合；</p>
<p>4）<code>EnumSet</code>类提供了丰富的静态工厂来创建集合，可以有效代替位域表示法。</p>
<h2 id="6-4-用EnumMap代替序数索引（37）"><a href="#6-4-用EnumMap代替序数索引（37）" class="headerlink" title="6.4 用EnumMap代替序数索引（37）"></a>6.4 用EnumMap代替序数索引（37）</h2><p>1）有时可能会见到利用<code>ordinal</code>方法来索引数组或列表的代码，这种情况下，使用<code>EnumMap</code>是一种更好的方法；</p>
<p>2）<code>EnumMap</code>内部使用了序数索引的数组，但对程序员隐藏了这种实现细节，集<code>Map</code>的安全与数组的快速于一身；</p>
<p>3）<code>EnumMap</code>的构造器采用键类型的<code>Class</code>对象，这是一个有限制的类型令牌，提供了运行时的泛型信息。</p>
<h2 id="6-5-用接口模拟可扩展的枚举（38）"><a href="#6-5-用接口模拟可扩展的枚举（38）" class="headerlink" title="6.5 用接口模拟可扩展的枚举（38）"></a>6.5 用接口模拟可扩展的枚举（38）</h2><p>1）由于枚举类型的可伸缩性会导致设计和实现的许多方面变得复杂，目前枚举类型是不可扩展的；</p>
<p>2）由于接口是可扩展的，因此可以用接口模拟扩展的枚举；</p>
<p>3）当枚举类型实现了某个接口时，枚举类型中不再需要声明抽象方法。</p>
<h2 id="6-6-标记注解优先于命名模式（39）"><a href="#6-6-标记注解优先于命名模式（39）" class="headerlink" title="6.6 标记注解优先于命名模式（39）"></a>6.6 标记注解优先于命名模式（39）</h2><p>1）使用特定格式命名方法（比如测试方法以<code>test</code>开头）并不一定能确保该方法按照希望的意图执行，但通过注解则可以解决该问题（比如<code>@Test</code>指定简单的测试）；</p>
<p>2）注解永远不会改变被注解代码的语义。</p>
<h2 id="6-7-坚持使用Override注解（40）"><a href="#6-7-坚持使用Override注解（40）" class="headerlink" title="6.7 坚持使用Override注解（40）"></a>6.7 坚持使用Override注解（40）</h2><p>1）<code>@Override</code>注解只能用在方法声明中，表示被注解的方法声明覆盖了超类型中的一个方法声明，使用该注解可以防止很多错误；</p>
<p>2）在编写非抽象，并且该类覆盖了超类的抽象方法时，可以不使用该注解。</p>
<h2 id="6-8-用标记接口定义类型（41）"><a href="#6-8-用标记接口定义类型（41）" class="headerlink" title="6.8 用标记接口定义类型（41）"></a>6.8 用标记接口定义类型（41）</h2><p>标记接口是指不包含方法声明的接口，用于指明一个类实现了具有某种功能属性的接口。</p>
<p>标记接口和标记注解的区别在于：</p>
<p>1）标记接口使得IDE在编译时就能捕捉到在使用标记注解的情况下要到运行时才能捕捉到的错误；</p>
<p>2）标记注解可以声明为应用于任意类或者接口，但标记接口可以被更加精确地进行锁定；</p>
<p>3）标记注解在那些支持注解错位编程元素之一的框架中同样具有一致性。</p>
<p>分别选择标记接口和标记注解的情况：</p>
<p>1）如果标记是应用于任何程序元素而不是类或者接口时，使用标记注解；</p>
<p>2）如果标记只应用于类和接口，当需要编写只接受带有标记的方法时使用标记接口，当不需要编写这种方法时使用标记注解；</p>
<p>3）如果标记是广泛使用注解的框架的一个组成部分，则应该选择标记注解。</p>
<h1 id="7、Lambda和Stream"><a href="#7、Lambda和Stream" class="headerlink" title="7、Lambda和Stream"></a>7、Lambda和Stream</h1><h2 id="7-1-Lambda优先于匿名类（42）"><a href="#7-1-Lambda优先于匿名类（42）" class="headerlink" title="7.1 Lambda优先于匿名类（42）"></a>7.1 Lambda优先于匿名类（42）</h2><p>1）函数类型指带有单个抽象方法的接口，函数类型的实例称为函数对象；</p>
<p>2）匿名类满足了面向对象的设计模式对函数对象的需求，但是使用起来过于繁琐，因此允许使用简洁的Lambda表达式来创建函数对象；</p>
<p>3）无需在Lambda表达式中指定参数类型，除非程序报错；</p>
<p>4）如果一个计算本身不是自描述的，或者超出了几行，那就不要将其放在一个Lambda中（一行是最理想的，不要超出三行）；</p>
<p>5）Lambda无法获得对自身的引用，在Lambda中，<code>this</code>指的是外围实例，在匿名类中，<code>this</code>指的是匿名类实例；</p>
<p>6）尽可能不要实例化一个<code>Lambda</code>或者匿名类实例，如果需要可序列化的函数对象，就是用私有静态嵌套类的实例。</p>
<h2 id="7-2-方法引用优先于Lambda（43）"><a href="#7-2-方法引用优先于Lambda（43）" class="headerlink" title="7.2 方法引用优先于Lambda（43）"></a>7.2 方法引用优先于Lambda（43）</h2><p>1）方法引用是比Lambda更简洁的创建函数对象的方法，即使用方法引用通常能得到更加简短、清晰的代码；</p>
<p>2）如果Lambda太长或过于复杂，可以从Lambda中提取代码放入一个新的方法中，再用该方法的引用替代Lambda；</p>
<p>3）当Lambda和方法引用处于同一个类中时，Lambda也可能会比方法引用更加简洁。</p>
<h2 id="7-3-坚持使用标准的函数接口（44）"><a href="#7-3-坚持使用标准的函数接口（44）" class="headerlink" title="7.3 坚持使用标准的函数接口（44）"></a>7.3 坚持使用标准的函数接口（44）</h2><p>1）时刻谨记用Lambda来设计API，API的输入应接收函数接口类型的参数，最好使用<code>java.util.function.Function</code>中提供的标准接口；</p>
<p>2）只要标准的函数接口能够满足需求，通常应该优先考虑，而不是专门再构建一个新的函数接口；</p>
<p>3）千万不要用带有包装类型的基础函数接口来代替基本函数接口；</p>
<p>4）<code>@FunctionalInterface</code>注解用于标注该接口是针对Lambda设计的，该接口不会编译，除非它只有一个抽象方法，避免后续维护人员不小心给该接口添加抽象方法；</p>
<p>5）不要编写同一个参数位置使用不同函数接口的重载。</p>
<h2 id="7-4-谨慎使用Stream（45）"><a href="#7-4-谨慎使用Stream（45）" class="headerlink" title="7.4 谨慎使用Stream（45）"></a>7.4 谨慎使用Stream（45）</h2><p>Stream API简化了串行或并行的大批量操作，其中，Stream（流）代表数据元素有限或无限的顺序，Stream pipeline（流管道）代表元素的一个多级计算。</p>
<p>1）一个Stream pipeline中包含一个源Stream，接着是0个或多个中间操作和1个终止操作，所有的中间操作都是将一个Stream转换成另一个Stream；</p>
<p>2）Stream pipeline都是lazy的，直到调用终止操作时才会开始计算，默认情况下，Stream pipeline都是按顺序串行执行的；</p>
<p>3）Stream可能使得程序更加简洁清晰，也可能使得程序变得混乱难以维护，在Stream pipeline中使用帮助性方法更有利于提升代码可读性；</p>
<p>4）Stream中的数据元素可以是对象引用或者<code>int</code>、<code>long</code>和<code>double</code>，不支持<code>char</code>，最好避免使用Stream来处理<code>char</code>值；</p>
<p>5）Stream pipeline利用函数对象（Lambda或者方法引用）来描述重复的计算，而迭代版代码利用代码块来描述重复计算；</p>
<p>6）代码块中可以读取或者修改范围内的任意局部变量，Lambda则只能读取<code>final</code>变量并且不能修改任意局部变量；</p>
<p>7）代码块可以从外围方法中<code>return</code>、<code>break</code>或者<code>continue</code>外围循环或者抛出该方法声明中要抛出的任何受检异常，Lambda中则完全无法完成这些事情；</p>
<p>8）根据代码块和Lambda的区别谨慎选择使用迭代还是Stream pipeline。</p>
<h2 id="7-5-优先选择Stream中无副作用的函数（46）"><a href="#7-5-优先选择Stream中无副作用的函数（46）" class="headerlink" title="7.5 优先选择Stream中无副作用的函数（46）"></a>7.5 优先选择Stream中无副作用的函数（46）</h2><p>1）Stream并不只是一个API，还是一种基于函数编程的模型，为了获得Stream带来的描述性、并行性和速度，必须采用泛型以及API；</p>
<p>2）传入Stream的操作的任何函数对象，无论是中间操作还是终止操作，都应该是无副作用的；</p>
<p>3）<code>forEach</code>操作应该只用于报告Stream计算的结果，而不是执行计算；</p>
<p>4）为了使用Stream，Collectors API是必须了解的接口，该接口是一个收集器，收集器产生的对象一般是一个集合，最重要的收集器工厂是<code>toList</code>、<code>toSet</code>、<code>toMap</code>、<code>groupingBy</code>和<code>joining</code>。</p>
<h2 id="7-6-Stream要优先用Collection作为返回类型（47）"><a href="#7-6-Stream要优先用Collection作为返回类型（47）" class="headerlink" title="7.6 Stream要优先用Collection作为返回类型（47）"></a>7.6 Stream要优先用Collection作为返回类型（47）</h2><p>1）在编写一个返回对象序列的方法时，如果该返回对象只在Stream pipeline中使用则返回<code>Stream</code>，如果返回序列只在迭代中使用，则应返回<code>Iterable</code>；</p>
<p>2）<code>Collection</code>接口是<code>Iterable</code>的一个子类型，有一个Stream方法，因此提供了迭代和stream访问；</p>
<p>3）对于公共的返回序列的方法，<code>Collection</code>或者适当的子类型通常是最佳的返回类型；</p>
<p>4）如果无法返回<code>Collection</code>，就返回<code>Stream</code>和<code>Iterable</code>中更合适的那个即可。</p>
<h2 id="7-7-谨慎使用Stream并行（48）"><a href="#7-7-谨慎使用Stream并行（48）" class="headerlink" title="7.7 谨慎使用Stream并行（48）"></a>7.7 谨慎使用Stream并行（48）</h2><p>1）Stream类库提供<code>parallel</code>方法来实现并行处理，但Stream类库并不知道如何并行某个pipeline，以及如何检测并行失败；</p>
<p>2）如果源头是<code>Stream.iterate</code>或者使用了中间操作的<code>limit</code>，那么并行pipeline也不可能提升性能，Stream pipeline的终止操作本质上也影响了并发执行的效率</p>
<p>3）由Stream的<code>collect</code>方法执行的操作，都是可变的减法，不是并行的最好选择；</p>
<p>4）在Stream上通过并行获得的性能，最好是通过<code>ArrayList</code>、<code>HashMap</code>、<code>HashSet</code>和<code>ConcurrentHashMap</code>实例，数组，<code>int</code>范围和<code>long</code>范围等；</p>
<p>5）这些数据结构的共性是i）可以被轻松分成任意大小的子范围，使并向线程中的分工变得更加轻松；ii）提供了优异的引用局部性，具有最佳引用局部性的数据结构是基本类型数组；</p>
<p>6）不要随意地并行Stream pipeline，可能会造成灾难性的后果。</p>
<h1 id="8、方法"><a href="#8、方法" class="headerlink" title="8、方法"></a>8、方法</h1><p>方法设计应考虑：如何处理参数和返回值，如何设计方法签名，如何为方法编写文档。</p>
<h2 id="8-1-检查参数的有效性（49）"><a href="#8-1-检查参数的有效性（49）" class="headerlink" title="8.1 检查参数的有效性（49）"></a>8.1 检查参数的有效性（49）</h2><p>1）应当在文档中指明方法参数的限制，并在方法开头处检查参数；</p>
<p>2）对于公有的和受保护的方法，要用Javadoc的<code>@throws</code>标签（tag）在文档中说明违反参数值限制时会抛出的异常；</p>
<p>3）对于未被导出的非公有的方法，应该确保只将有效的参数值传递进来，应该使用断言来检查它们的参数；</p>
<p>4）对于有些参数，方法本身没有使用，却被保存起来供以后使用，检验这类参数的有效性极为重要；</p>
<p>5）有时候有效性检查工作非常昂贵，甚至不切实际，有效性检查已隐含在计算过程中完成；</p>
<p>6）对方法参数的限制应该是越少越好，太多限制并不是一件好事。</p>
<h2 id="8-2-必要时进行保护性拷贝（50）"><a href="#8-2-必要时进行保护性拷贝（50）" class="headerlink" title="8.2 必要时进行保护性拷贝（50）"></a>8.2 必要时进行保护性拷贝（50）</h2><p>1）面对客户端可能有的一些不可预期的行为，应该编写面对不良行为依旧能保持健壮的类；</p>
<p>2）为了避免一个类在另一个类实例无意识的情况下修改了该实例的内部状态，攻击该实例的内部信息，应当对构造器的每个可变参数进行保护性拷贝，并使用备份实例作为该实例的组件，而不使用原始的实例，此时针对原始实例内部信息的攻击不再有效；</p>
<p>3）保护性拷贝是在检查参数的有效性之前进行的，有效性检查是针对拷贝之后的对象，而不是原始的对象，从而避免在“危险阶段”期间从另一个线程改变类的参数（“危险阶段”指从检查参数开始，知道拷贝参数之间的时间段）；</p>
<p>4）对于参数类型可以被不可信任方子类化的参数，不要在构造器中使用<code>clone</code>方法进行保护性拷贝，但访问方法中可以使用<code>clone</code>方法进行保护性拷贝；</p>
<p>5）参数的保护性拷贝并不仅仅针对不可变类，每当给自己的类编写方法或者构造器时，如果客户端提供的对象是可变的，该对象被允许进入到自己的类的内部数据结构中，但自己的类并不能容忍对象进行数据结构之后发生变化，则应对自己的类对象进行保护性拷贝；</p>
<p>6）在内部组件被返回到客户端之前，同样要进行保护性拷贝，而不是直接将一个指定内部可变组件的引用返回给客户端；</p>
<p>7）只要有可能就使用不可变对象作为对象内部的组件，这样就不必为保护性拷贝操心；</p>
<p>8）保护性拷贝可能会带来相关的性能损失，当类信任它的调用者不会修改内部的组件时（比如类及客户端都是同一个包的双方），那么可以不进行保护性拷贝，但需要在文档中进行说明。</p>
<h2 id="8-3-谨慎设计方法签名（51）"><a href="#8-3-谨慎设计方法签名（51）" class="headerlink" title="8.3 谨慎设计方法签名（51）"></a>8.3 谨慎设计方法签名（51）</h2><p>1）方法名称应该始终遵循标准的命名习惯，易于理解且与同一个包中的其他名称风格一致；</p>
<p>2）不要为类和接口提供太多的方法，只有当一项操作被经常用到时，才考虑提供快捷方式；</p>
<p>3）避免过长的参数列表（四个或四个以下），相同类型的长参数序列格外有害，可通过分解多个方法、创建辅助类（静态成员类）以及Builder模式来缩短过长的参数列表；</p>
<p>4）参数类型优先使用接口而不是类；</p>
<p>5）对于<code>boolean</code>参数，优先使用两个元素的枚举类型。</p>
<h2 id="8-4-慎用重载（52）"><a href="#8-4-慎用重载（52）" class="headerlink" title="8.4 慎用重载（52）"></a>8.4 慎用重载（52）</h2><p>1）调用哪个重载方法是在编译时决定的，调用哪个重写（覆盖）方法是在运行时决定的；</p>
<p>2）覆盖机制满足了用户对于方法调用行为的期望，而重载机制容易是的这些期望落空，应该避免胡乱使用重载机制；</p>
<p>3）永远不要导出两个具有相同参数数目的重载方法，而是给方法起不同的名字；</p>
<p>4）如果必须要导出多个具有相同参数的重载方法时，要确保所有重载方法的行为必须一致；</p>
<p>5）对于构造器（无法被覆盖，只能被重载），无法选择不同名称，于是可以选择导出静态工厂。</p>
<h2 id="8-5-慎用可变参数（53）"><a href="#8-5-慎用可变参数（53）" class="headerlink" title="8.5 慎用可变参数（53）"></a>8.5 慎用可变参数（53）</h2><p>1）可变参数接收零个或者多个指定类型的参数；</p>
<p>2）在使用可变参数之前，要先包含所有必要的参数；</p>
<p>3）每次调用可变参数都会导致一次数组分配和初始化，因此存在一定的性能影响。</p>
<h2 id="8-6-返回零长度的数组或者集合，而不是null（54）"><a href="#8-6-返回零长度的数组或者集合，而不是null（54）" class="headerlink" title="8.6 返回零长度的数组或者集合，而不是null（54）"></a>8.6 返回零长度的数组或者集合，而不是null（54）</h2><p>1）对于返回<code>null</code>而不是零长度数组或者集合的方法，每次使用该方法时都需要有额外的代码来处理<code>null</code>返回值；</p>
<p>2）不需要分配零长度的集合或者数组即可返回它们，无需担心分配所需的开销；</p>
<p>3）如果有证据表明分配零长度的集合损害了程序的性能，可以重复返回一个不可变的零长度集合，避免重复分配（不可变对象可以自由共享）。</p>
<h2 id="8-7-谨慎返回optional（55）"><a href="#8-7-谨慎返回optional（55）" class="headerlink" title="8.7 谨慎返回optional（55）"></a>8.7 谨慎返回optional（55）</h2><p>1）当需要编写一个在特定环境下无法返回值的方法时，不要选择抛出异常或者返回<code>null</code>，因为抛出异常的开销很高，而返回<code>null</code>会使得API变得难以使用；</p>
<p>2）针对上述情况可以返回<code>Optional&lt;T&gt;</code>类，它代表一个不可变的容器，可以存放单个非<code>null</code>的<code>T</code>引用，或者什么内容都没有；</p>
<p>3）在某些特定情况下，可以声明返回<code>Optional&lt;T&gt;</code>，它允许方法返回T或者空的结果，这样比抛出异常更加灵活简单，比返回null更加不容易出错；</p>
<p>4）<code>Stream</code>类型的许多终止操作都返回<code>optional</code>，使用Stream编程时，会经常遇到<code>Stream&lt;Optional&lt;T&gt;&gt;</code>；</p>
<p>5）容器类型（包括集合、映射、<code>Stream</code>、数组和<code>optional</code>）都不应该被包装在<code>optional</code>中，即直接返回空的容器，而不是空的<code>Optional</code>；</p>
<p>6）<code>Optional</code>是一个必须进行分配和初始化的对象，从<code>optional</code>中读取值时需要额外的开销，这使得<code>optional</code>并不适合注重性能的情况；</p>
<p>7）使用<code>OptionalInt</code>、<code>OptionalLong</code>、<code>OptionalDouble</code>而不是<code>Optional&lt;Integer&gt;</code>、<code>Optional&lt;Long&gt;</code>、<code>Optional&lt;Double&gt;</code>；</p>
<p>8）永远不要用<code>optional</code>作为映射值 几乎永远都不适合用<code>optional</code>作为键、值、集合或者数组中的元素；</p>
<p>9）尽量不要将<code>optional</code>作为返回值以外的任何其他用途。</p>
<h2 id="8-8-为所有导出的API编写文档注释（56）"><a href="#8-8-为所有导出的API编写文档注释（56）" class="headerlink" title="8.8 为所有导出的API编写文档注释（56）"></a>8.8 为所有导出的API编写文档注释（56）</h2><p>1）Java编程环境提供了Javadoc工具，Javadoc利用特殊格式的文档注释，根据源代码自动产生API文档；</p>
<p>2）为了正确地编写API文档，必须在每个被导出的类、接口、构造器、方法和域声明之间增加一个文档注释；</p>
<p>3）如果类是可序列化的，应该对它的序列化形式编写文档；</p>
<p>4）公有的类不能使用缺省的构造器，因为无法为它们提供文档注释；</p>
<p>5）方法的文档注释应该简洁地描述出它和客户端之间的约定，除了专门为继承而设计的方法之外，这个约定应说明这个方法做了什么、前提条件、后置条件以及副作用；</p>
<p>6）前提条件指为了使客户端能够调用这个方法而必须要满足的条件，是由<code>@throws</code>标签针对未受检的异常所隐含描述的；</p>
<p>7）后置条件指调用成功完成之后，哪些条件必须要满足；</p>
<p>8）副作用指系统状态中可以观察到的变化，不是为了获得后置条件而明确要求的变化，例如启动了后台线程；</p>
<p>9）方法的文档注释应该让每个参数都有一个<code>@param</code>标签，一个<code>@return</code>（除非返回类型为<code>void</code>）以及对于该方法抛出的每个异常都应有一个<code>@throws</code>标签；</p>
<p>10）按照惯例，<code>@param</code>和<code>@return</code>标签后面的文字应该是一个名词短语，描述这个参数或者返回值所表示的值，<code>@throws</code>标签之后的文字应该包含单词“if”，紧接着是一个名词短语，描述这个异常将在什么样的情况下抛出，这些标签后面的短语或者子句都用句点来结束；</p>
<p>11）对于专门为继承设计的类，使用<code>@implSpec</code>描述方法及其子类之间的约定；</p>
<p>12）文档注释在源代码和产生的文档中都应该是易于阅读的，如果无法同时满足，产生的文档的可读性要优于源代码的可读性；</p>
<p>13）同一个类或者接口中的两个成员或者构造器，不应该具有同样的概要描述（文档注释的第一句话或者一个名词性短语），因此要特别注意重载的情况；</p>
<p>14）为泛型编写文档时，要说明所有的类型参数；</p>
<p>15）为枚举类型编写文档时，要确保在文档中说明常量，以及任何公有的方法；</p>
<p>16）为注解类型编写文档时，要确保在文档中说明所有成员；</p>
<p>17）类或者静态方法是否线程安全，应该在文档中对它的线程安全级别进行说明；</p>
<p>18）Javadoc具有继承方法注释的能力，接口的文档注释优先于超类的文档注释。</p>
<h1 id="9、通用编程"><a href="#9、通用编程" class="headerlink" title="9、通用编程"></a>9、通用编程</h1><h2 id="9-1-将局部变量的作用域最小化（57）"><a href="#9-1-将局部变量的作用域最小化（57）" class="headerlink" title="9.1 将局部变量的作用域最小化（57）"></a>9.1 将局部变量的作用域最小化（57）</h2><p>1）较早的编程语言要求局部变量必须在代码块的开头进行声明，但Java语言中这个习惯应该改正，Java允许在任何可以出现语句的地方声明变量，从而将局部变量的作用域最小化，增强代码的可读性和可维护性，降低出错的可能性；</p>
<p>2）要使局部变量最小化，就在第一次使用它的地方进行声明，如果变量在使用之前进行声明，这只会造成混乱；</p>
<p>3）几乎每一个局部变量的声明都应该包含一个初始化表达式，例外情况与<code>try-catch</code>语句有关；</p>
<p>4）由于<code>for</code>循环（传统形式或者<code>for-each</code>形式）允许声明循环变量，它的作用域被限定在正好需要的范围之内，因此<code>for</code>循环优先于<code>while</code>循环；</p>
<p>5）要使局部变量最小化，还应该使方法小而集中，每个操作用一个方法来完成。</p>
<h2 id="9-2-for-each循环优先于传统的for循环（58）"><a href="#9-2-for-each循环优先于传统的for循环（58）" class="headerlink" title="9.2 for-each循环优先于传统的for循环（58）"></a>9.2 for-each循环优先于传统的for循环（58）</h2><p>1）<code>for-each</code>循环通过完全隐藏迭代器或者索引变量，避免了混乱和出错的可能，这种模式同时适用于集合和数组，也不会有性能损失；</p>
<p>2）如果需要遍历集合并删除选定的元素，或者需要遍历列表、数组并替换部分元素值，或者需要并行地遍历多个集合，就需要使用传统的<code>for</code>循环形式；</p>
<p>3）编写表示一组元素的类型时，应该坚决考虑让它实现<code>Iterable</code>接口，那么用户就可以利用<code>for-each</code>循环来遍历该类型。</p>
<h2 id="9-3-了解和使用类库（59）"><a href="#9-3-了解和使用类库（59）" class="headerlink" title="9.3 了解和使用类库（59）"></a>9.3 了解和使用类库（59）</h2><p>1）使用标准类库，可以充分利用这些编写标准类库的专家的知识，沿用前人的经验，比如使用<code>ThreadLocalRandom</code>产生高质量的随机数；</p>
<p>2）为了熟悉标准类库，应该熟悉<code>java.lang</code>、<code>java.util</code>、<code>java.io</code>及其子包中的内容；</p>
<p>3）如果在Java类库中找不到需要的功能，就去高级的第三方类库中去寻找，不要重复造轮子。</p>
<h2 id="9-4-需要精确答案时请避免使用float和double（60）"><a href="#9-4-需要精确答案时请避免使用float和double（60）" class="headerlink" title="9.4 需要精确答案时请避免使用float和double（60）"></a>9.4 需要精确答案时请避免使用float和double（60）</h2><p>1）<code>float</code>和<code>double</code>类型并没有提供完全精确的结果，尤其不适用于货币计算，面对货币问题时，应使用<code>BigDecimal</code>、<code>int</code>或者<code>long</code>进行货币计算；</p>
<p>2）使用<code>BigDecimal</code>时应使用<code>String</code>参数的构造器而不是<code>double</code>构造器，使用<code>int</code>或者<code>long</code>时，可以以分而不是元来作为单位进行计算；</p>
<p>3）综上，当数值范围没有超过9位十进制数字时，可以使用<code>int</code>，如果不超过18位数字，可以使用<code>long</code>，如果超过18位，必须使用<code>BigDecimal</code>。</p>
<h2 id="9-5-基本类型优先于装箱基本类型（61）"><a href="#9-5-基本类型优先于装箱基本类型（61）" class="headerlink" title="9.5 基本类型优先于装箱基本类型（61）"></a>9.5 基本类型优先于装箱基本类型（61）</h2><p>1）基本类型只有值，装箱基本类型具有与它们的值不同的同一性；</p>
<p>2）基本类型只有函数值，装箱基本类型除了它对应基本类型的所有函数值之外，还有个<code>null</code>（是未赋值前的初始值）；</p>
<p>3）基本类型通常比装箱基本类型更节省时间和空间；</p>
<p>4）对装箱基本类型运用<code>==</code>操作符时，是在做同一性比较，结果几乎总是<code>false</code>；</p>
<p>5）自动装箱和拆箱减少了使用装箱基本类型的繁琐性，但是并没有减少它的风险；</p>
<p>6）只有在作为集合中的元素，参数化类型以及反射的方法调用中，才必须使用装箱基本类型作为类型参数，除此之外，基本类型要优先于装箱基本类型。</p>
<h2 id="9-6-如果其他类型更合适，则尽量避免使用字符串（62）"><a href="#9-6-如果其他类型更合适，则尽量避免使用字符串（62）" class="headerlink" title="9.6 如果其他类型更合适，则尽量避免使用字符串（62）"></a>9.6 如果其他类型更合适，则尽量避免使用字符串（62）</h2><p>1）字符串不适合代替其他的值类型，字符串应该用于表示文本信息；</p>
<p>2）如果无法将字符串直接转换为其他类型，应简单地编写一个私有的静态成员类来描述这个字符串所表示的数据集；</p>
<p>3）尽可能编写更加适合的数据类型，尽量避免用字符串来表示对象。</p>
<h2 id="9-7-了解字符串连接的性能（63）"><a href="#9-7-了解字符串连接的性能（63）" class="headerlink" title="9.7 了解字符串连接的性能（63）"></a>9.7 了解字符串连接的性能（63）</h2><p>1）当想产生单独一行的输出，或者构造一个字符串来表示一个较小的、大小固定的对象时，使用连接操作符<code>+</code>是合适的；</p>
<p>2）由于字符串不可变，当两个字符串被连接在一起时，它们的内容都需要被拷贝；</p>
<p>3）连接n个字符串而重复地使用字符串连接操作符，需要n的平方级的时间，连接操作符不适用于大规模场景，不要用来合并多个字符串；</p>
<p>4）为了接收可以获得的性能，应该用<code>StringBuilder</code>代替<code>String</code>。</p>
<h2 id="9-8-通过接口引用对象（64）"><a href="#9-8-通过接口引用对象（64）" class="headerlink" title="9.8 通过接口引用对象（64）"></a>9.8 通过接口引用对象（64）</h2><p>1）如果有合适的接口类型存在，那么对于参数、返回值、变量和域来说，就都应该使用接口类型而不是类进行声明，程序会更加灵活；</p>
<p>2）只有在真正需要利用构造器创建某个对象的时候，才需要真正引用这个对象的类；</p>
<p>3）当对象属于一个框架时（框架的基本类型是类，不是接口），应该用相关的基类（往往是抽象类）来引用这个对象，而不是实现类；</p>
<p>4）值类（比如<code>String</code>和<code>BigInteger</code>）很少会用多个实现编写，经常是<code>final</code>的，很少有对应的接口，此时完全可以用类来引用对象；</p>
<p>5）当类实现了接口，但它也提供了接口中不存在的额外方法时，由于程序可能依赖这个额外的方法，这种类就应该只被用来引用它的实例。</p>
<h2 id="9-9-接口优先于反射机制（65）"><a href="#9-9-接口优先于反射机制（65）" class="headerlink" title="9.9 接口优先于反射机制（65）"></a>9.9 接口优先于反射机制（65）</h2><p>核心反射机制，<code>java.lang.reflect</code>包，提供了通过程序访问任意类的成员名称、域类型、方法签名等信息的能力，允许一个类访问另一个类，即当前类被编译时后者还不存在。</p>
<p>反射的缺点：</p>
<p>1）损失了编译时类型检查的优势，如果程序企图用反射方式调用不存在的或者不可访问的方法，等到运行时会失败；</p>
<p>2）执行反射访问所需要的代码非常笨拙和冗长；</p>
<p>3）反射方法调用比普通方法调用更慢，存在性能损失；</p>
<p>反射的优点：</p>
<p>1）通过接口引用对象时，就是用反射方式创建实例，然后通过它们的接口或者超类，以正常的方式访问这些实例；</p>
<p>2）功能强大，可用于分析和测试等；</p>
<p>3）如果正在编写的程序需要与编译时未知的类一起工作，应该仅仅使用反射机制来实例化对象，而访问对象时则使用编译时已知的接口或者超类。</p>
<h2 id="9-10-谨慎地使用本地方法（66）"><a href="#9-10-谨慎地使用本地方法（66）" class="headerlink" title="9.10 谨慎地使用本地方法（66）"></a>9.10 谨慎地使用本地方法（66）</h2><p>1）本地方法（native method）指用本地编程语言（比如C或者C++）来编写的方法，它们提供了访问本地遗留代码库的能力；</p>
<p>2）本地方法可以通过本地语言，编写应用程序中注重性能的部分，以提高系统的性能；</p>
<p>3）使用本地方法来提高性能的做法不值得提倡，本地语言是不安全的，是与平台相关的，会使得程序难以移植、难以调试，而JVM本身就已经可以提供高性能；</p>
<p>4）只有在极少数情况下才会使用本地方法，比如需要访问底层的资源或者遗留代码库。</p>
<h2 id="9-11-谨慎地进行优化（67）"><a href="#9-11-谨慎地进行优化（67）" class="headerlink" title="9.11 谨慎地进行优化（67）"></a>9.11 谨慎地进行优化（67）</h2><p>1）不成熟的优化弊大于利，不要为了性能牺牲合理的结构，要编写好的程序而不是快的程序；</p>
<p>2）要在API设计决策的过程中考虑性能问题，避免那些限制性能的设计决策；</p>
<p>3）一般而言，好的API设计也会带来好的性能，但不要为了获得好的性能而对API进行包装。</p>
<h2 id="9-12-遵守普遍接收的命名惯例（68）"><a href="#9-12-遵守普遍接收的命名惯例（68）" class="headerlink" title="9.12 遵守普遍接收的命名惯例（68）"></a>9.12 遵守普遍接收的命名惯例（68）</h2><p>1）包和模块的名称应该是层次状的，用句号分隔每个部分，鼓励使用有意义的缩写；</p>
<p>2）类和接口（包括枚举和注解类型）的名称，都应该包括一个或者多个单词，除了通用缩写外尽量避免缩写。</p>
<h1 id="10、异常"><a href="#10、异常" class="headerlink" title="10、异常"></a>10、异常</h1><h2 id="10-1-只针对异常的情况才使用异常（69）"><a href="#10-1-只针对异常的情况才使用异常（69）" class="headerlink" title="10.1 只针对异常的情况才使用异常（69）"></a>10.1 只针对异常的情况才使用异常（69）</h2><p>1）基于异常的模式比标准模式更慢，不应将异常用于正常的控制流；</p>
<p>2）设计良好的API不应该强迫它的客户端为了正常的控制流而是用异常。</p>
<h2 id="10-2-对可恢复的情况使用受检异常，对编程错误使用运行时异常（70）"><a href="#10-2-对可恢复的情况使用受检异常，对编程错误使用运行时异常（70）" class="headerlink" title="10.2 对可恢复的情况使用受检异常，对编程错误使用运行时异常（70）"></a>10.2 对可恢复的情况使用受检异常，对编程错误使用运行时异常（70）</h2><p>1）可抛出结构分为受检异常、运行时异常和错误；</p>
<p>2）方法中声明要抛出的每个受检异常，是对用户的一种潜在指示：与异常相关联的条件是调用这个方法的一种可能的结果，并要求调用者能够在一个<code>catch</code>子句中处理该异常或者将其传播出去；</p>
<p>3）API的设计者要求API的使用者面对受检异常，以强制用户从这个异常条件中恢复，受检异常往往指明了可恢复的条件；</p>
<p>4）运行时异常和错误都是不需要也不应该被捕获的可抛出结构，当程序抛出运行时异常和错误时，就是不可恢复的情况，会导致当前线程中断，并出现适当的错误消息；</p>
<p>5）大多数的运行时异常都表示前提违例，即API的用户没有遵守API规范建立的约定；</p>
<p>6）不要再实现任何新的<code>Error</code>的子类，程序员所实现的所有未受检的抛出结构都应该是<code>RuntimeException</code>的子类；</p>
<p>7）对于可恢复的情况，要抛出受检异常，对于程序错误，要抛出运行时异常，对于不确定是否可恢复的情况，要抛出未受检异常。</p>
<h2 id="10-3-避免不必要地使用受检异常（71）"><a href="#10-3-避免不必要地使用受检异常（71）" class="headerlink" title="10.3 避免不必要地使用受检异常（71）"></a>10.3 避免不必要地使用受检异常（71）</h2><p>1）受检异常强迫程序员处理异常的条件，过分使用受检异常会使得API使用起来非常不方便，抛出受检异常的方法不能直接在Stream中使用；</p>
<p>2）当正确使用API依旧不能阻止异常条件的产生，并且一旦产生异常，使用API的程序员可以立即采取有用的动作时，这种受检异常负担就被认为是正当的，否则更适合使用未受检的异常；</p>
<p>3）如果在<code>catch</code>语句中，程序员只能继续抛出异常或者只是打印异常信息而无法采取更好的措施，那么使用未受检的异常会更为合适；</p>
<p>4）如果方法可能抛出的受检异常只有一种，就导致<code>try-catch</code>语句的使用，并且不能在<code>Stream</code>中直接使用，那么这种额外负担是非常高的；</p>
<p>5）消除受检异常最容易的方法是返回一个零长度<code>optional</code>而不抛出受检异常，这样做的缺点是无法返回任何额外的信息来详细说明它无法执行想要的计算。</p>
<h2 id="10-4-优先使用标准的异常（72）"><a href="#10-4-优先使用标准的异常（72）" class="headerlink" title="10.4 优先使用标准的异常（72）"></a>10.4 优先使用标准的异常（72）</h2><p>1）代码重用是值得提倡的，异常也不例外，重用标准的异常使得API更易于学习使用，可读性更好，当异常类越少，内存占用也就越小，装载这些类的时间开销也越少；</p>
<p>2）不要重用<code>Exception</code>、<code>RuntimeException</code>、<code>Throwable</code>或者<code>Error</code>，对待这些类要像对待抽象类一样；</p>
<p>3）当子类化标准异常时，要记住异常也是可序列化的，如果没有非常正当的理由，千万不要自己编写异常类。</p>
<h2 id="10-5-抛出与抽象对象的异常（73）"><a href="#10-5-抛出与抽象对象的异常（73）" class="headerlink" title="10.5 抛出与抽象对象的异常（73）"></a>10.5 抛出与抽象对象的异常（73）</h2><p>1）当方法传递由底层抽象抛出的异常时，方法抛出的异常与它执行的任务没有明显的联系，这会污染具有实现细节的更高层的API；</p>
<p>2）高层的实现应该捕获低层的异常，同时抛出可以按照高层抽象进行解释的异常，这种做法称为异常转译；</p>
<p>3）一种特殊的异常转译形式称为异常链，如果低层的异常对于调试导致高层异常的问题非常有帮助，就很适合使用异常链，它允许抛出适当的高层异常，同时又能捕获低层的原因进行失败分析；</p>
<p>4）只有在不能阻止或者处理来自低层的异常时，才使用异常转译，但不能滥用它。</p>
<h2 id="10-6-每个方法抛出的所有异常都要建立文档（74）"><a href="#10-6-每个方法抛出的所有异常都要建立文档（74）" class="headerlink" title="10.6 每个方法抛出的所有异常都要建立文档（74）"></a>10.6 每个方法抛出的所有异常都要建立文档（74）</h2><p>1）始终使用<code>throws</code>关键字都要单独地声明受检异常，并利用Javadoc的<code>@throws</code>标签，准确记录下抛出每个异常的条件；</p>
<p>2）即便方法通常不会抛出非受检异常，但是它们通常代表编程上的错误，为它们建立文档是非常明智，让程序员了解这些错误有助于避免犯同样的错误，<strong>在文档中记录未受检异常是满足前提条件的最佳做法</strong>；</p>
<p>3）使用Javadoc的<code>@throws</code>标签记录方法可能抛出的每个未受检异常，但是不要使用<code>throws</code>关键字来声明未受检异常；</p>
<p>4）如果一个类中的许多方法出于同样的原因而抛出同一个异常，应该在该类的文档注释中对这个异常建立文档，而不是为每个方法单独建立文档。</p>
<h2 id="10-7-在细节消息中包含失败-捕获异常（75）"><a href="#10-7-在细节消息中包含失败-捕获异常（75）" class="headerlink" title="10.7 在细节消息中包含失败-捕获异常（75）"></a>10.7 在细节消息中包含失败-捕获异常（75）</h2><p>1）异常类型的<code>toString</code>方法应当尽可能多地返回有关失败原因的信息，信息应该包含“对该异常有贡献”的所有参数和域的值，以便程序失败时进行分析；</p>
<p>2）不要在错误信息中包含密码、密钥以及类似的信息；</p>
<p>3）为了确保异常的细节消息中包含足够的失败-捕获信息，一种办法是在异常的构造器而不是<code>toString</code>中引入这些信息。</p>
<h2 id="10-8-努力使失败保持原子性（76）"><a href="#10-8-努力使失败保持原子性（76）" class="headerlink" title="10.8 努力使失败保持原子性（76）"></a>10.8 努力使失败保持原子性（76）</h2><p>1）失败的方法调用应该使对象保持在被调用之前的状态，这种属性称为失败原子性；</p>
<p>2）不可变对象显然具有失败原子性，可变对象要获得失败原子性有以下几种方式：i）就在执行操作之前检查参数的有效性，使得对象在被修改之前，先抛出适当的异常，ii）将任何可能会失败的计算部分都在对象状态被修改之前发生，iii）在对象的一份临时拷贝上执行操作，iv）编写恢复代码，实现回滚；</p>
<p>3）错误通常是不可恢复的，因此方法抛出<code>Error</code>时，不需要努力去保持失败原子性；</p>
<p>4）如果方法无法保持原子性，那么API文档就应该清楚地说明对象在方法调用失败后会处于什么样的状态。</p>
<h2 id="10-9-不要忽略异常（77）"><a href="#10-9-不要忽略异常（77）" class="headerlink" title="10.9 不要忽略异常（77）"></a>10.9 不要忽略异常（77）</h2><p>1）当API的设计者声明一个方法将抛出某个异常时，也是在试图说明某些事情，所以不要忽略任何异常（无论是受检异常还是非受检异常）；</p>
<p>2）空的<code>catch</code>块会使得异常达不到应由的目的。</p>
<h1 id="11、并发"><a href="#11、并发" class="headerlink" title="11、并发"></a>11、并发</h1><h2 id="11-1-同步访问共享的可变数据（78）"><a href="#11-1-同步访问共享的可变数据（78）" class="headerlink" title="11.1 同步访问共享的可变数据（78）"></a>11.1 同步访问共享的可变数据（78）</h2><p>1）正确地使用同步可以保证没有任何线程会看到数据处于不一致的状态中，并且进入同步的每个线程都能看到由同一个锁保护的之前的所有修改效果；</p>
<p>2）语言规范保证线程在读取原子数据时不会看到任意的数值，需要保证对变量的读写满足原子性，保证线程间的数据访问是互斥的，从而解决数据不一致的问题；</p>
<p>3）单个读写原子数据的操作是满足原子性的，但对原子数据使用增量操作符或者多次读写原子数据都不满足原子性；</p>
<p>4）原子性是同步的必要不充分条件，仅仅满足原子性，只能是不会出现数据一致性问题，但并不保证一个线程写入的值对另一个线程将是可见的，这并不是真正的同步，也无法实现线程间可靠的通信；</p>
<p>5）如果将可变数据限制在单个线程中，就可以避免线程同步问题，此时，对该可变数据建立文档就很重要。</p>
<h2 id="11-2-避免过度同步（79）"><a href="#11-2-避免过度同步（79）" class="headerlink" title="11.2 避免过度同步（79）"></a>11.2 避免过度同步（79）</h2><p>1）在一个被同步的方法或者代码块中，永远不要放弃对客户端的控制，也就是说，在一个被同步的区域内部，不要调用外来方法，否则容易造成死锁；</p>
<p>2）外来方法指被设计成要被覆盖的方法，或者是由客户端以函数对象的形式提供的方法；</p>
<p>3）在同步区域之外被调用的外来方法称作“开放调用”，开放调用可以极大地增加并发性，避免并发失败；</p>
<p>4）外来方法的运行时间可能为任意时长，如果在同步区域内调用外来方法，其他线程对保护资源的访问就会遭到不必要的拒绝；</p>
<p>5）通常来说，应当在同步区域内做尽可能少的工作，如果必须执行某个耗时的动作，应该设法把这个动作移到同步区域外；</p>
<p>6）过度同步除了可能导致正确问题，还有可能导致性能问题，比如限制虚拟机优化代码执行的能力；</p>
<p>7）在这个多核的时代，过度同步的实际成本并不是获取锁所花费的CPU时间，而是指所失去的并行的机会成本以及需要确保每个核都有一个一致的视图而导致的延迟；</p>
<p>8）当不确定是否要使用同步类时，就不要使用同步类，并且建立文档，注明使用的类不是线程安全的，此时可以由客户端在必要的时候从外部进行同步；</p>
<p>9）如果方法修改了静态域，并且该方法很可能要被多个线程调用，那么就必须在内部同步对这个静态域的访问（比如使用线程安全的并发类）；</p>
<p>10）在设计一个可变类时，要考虑一下它们是否应该自己完成同步操作，只有存在足够的理由时才在内部同步类，并注明到文档当中。</p>
<h2 id="11-3-executor、task和stream优先于线程（80）"><a href="#11-3-executor、task和stream优先于线程（80）" class="headerlink" title="11.3 executor、task和stream优先于线程（80）"></a>11.3 executor、task和stream优先于线程（80）</h2><p>1）Java标准库提供了<code>ExecutorService</code>接口表示线程池，并通过<code>Executors</code>类以静态工厂的方法生成各种线程池（<code>ExecutorService</code>接口的实现类）；</p>
<p>2）针对轻量负载的服务器，可以使用<code>CachedThreadPool</code>线程池类，它不需要配置；</p>
<p>3）针对大负载的服务器，不适合用<code>CachedThreadPool</code>（它没有将被提交的任务排成队列，而是直接交给线程执行，当没有线程可用时，就会创建新线程），此时，最好使用<code>FixedThreadPool</code>或者<code>ThreadPoolExecutor</code>（几乎允许程序员控制线程池的每个方面）；</p>
<p>4）尽量不直接使用线程，也尽量不要编写自己的线程池，而是使用Java标准库中提供的线程池；</p>
<p>5）直接使用线程时，<code>Thread</code>既是工作单元，又是执行机制，而在<code>Executor Framework</code>中，工作单元和执行机制是分开的，此时工作单元称为任务，任务可以是<code>Runnable</code>或者<code>Callable</code>，执行任务的通用机制是<code>ExecutorService</code>接口的实现类。</p>
<h2 id="11-4-并发工具优先于wait和notify（81）"><a href="#11-4-并发工具优先于wait和notify（81）" class="headerlink" title="11.4 并发工具优先于wait和notify（81）"></a>11.4 并发工具优先于wait和notify（81）</h2><p>1）正确地使用<code>wait</code>和<code>notify</code>比较困难，应该用更高级的并发工具来代替；</p>
<p>2）<code>java.util.concurrent</code>中的并发工具分为三类：<code>Executor Framework</code>、并发集合（<code>Concurrent Collection</code>）以及同步器（<code>Synchronizer</code>）；</p>
<p>3）并发集合为了提高并发性，在内部自己管理同步，因此在使用并发集合时，不需要在外部将其锁定，只会拖累性能；</p>
<p>4）同步器是使线程能够等待另一个线程的对象，允许它们协调动作；</p>
<p>5）在维护以往使用了<code>wait</code>和<code>notify</code>遗留代码时，永远不要在循环之外调用<code>wait</code>方法，应始终使用<code>wait</code>循环模式来调用<code>wait</code>方法，那么即使<code>wait</code>线程被错误的唤醒，依旧能通过循环判断条件来选择是否继续等待；</p>
<p>6）几乎没有理由在新代码中使用<code>wait</code>和<code>notify</code>方法。</p>
<h2 id="11-5-线程安全性的文档化（82）"><a href="#11-5-线程安全性的文档化（82）" class="headerlink" title="11.5 线程安全性的文档化（82）"></a>11.5 线程安全性的文档化（82）</h2><p>1）当一个类被并发使用时，这个类的行为如何，是该类与其客户端建立约定的重要组成部分，避免客户端在使用时出现未同步或者过度同步的情况；</p>
<p>2）Javadoc并没在输出中包含<code>synchronized</code>修饰符，因为这个是实现细节，并不是导出API的一部分，并不一定表明这个API是线程安全的；</p>
<p>3）无条件的线程安全的类所使用的锁对象应声明为<code>private final</code>，使得客户端和子类均无法妨碍对象的同步；</p>
<p>5）有条件的线程安全的类不能使用私有的锁对象，而是应该在文档中说明在执行某些方法时客户端必须获取哪吧锁。</p>
<h2 id="11-6-慎用延迟初始化（83）"><a href="#11-6-慎用延迟初始化（83）" class="headerlink" title="11.6 慎用延迟初始化（83）"></a>11.6 慎用延迟初始化（83）</h2><p>1）就像大多数的优化一样，对于延迟初始化，除非绝对必要，否则就不要这么做，大多数情况下，正常的初始化都要优先于延迟初始化；</p>
<p>2）延迟初始化降低了初始化类或者创建实例的开销，却增加了访问被延迟初始化的域的开销，实际上是降低了性能的，也对多线程同步造成了困难；</p>
<p>3）当需要对域进行延迟初始化时，访问该域时需要使用同步访问方法以防止循环初始化，但也增加了访问成本；</p>
<p>4）当需要对实例域使用延迟初始化时，要将该域声明为<code>volatile</code>，并使用双重检查模式以防止循环初始化，也避免了过度同步（双重检查模式中如果使用局部变量可以提升性能，更加优雅）；</p>
<p>5）当需要对静态域使用延迟初始化时，要使用lazy initialization holder class模式（优于双重检查模式）来保证类要被用到时才会被初始化，此时，该域的静态访问方法不需要同步，不会因延迟初始化增加访问成本。</p>
<h2 id="11-7-不要依赖于线程调度器（84）"><a href="#11-7-不要依赖于线程调度器（84）" class="headerlink" title="11.7 不要依赖于线程调度器（84）"></a>11.7 不要依赖于线程调度器（84）</h2><p>1）当有多个处于Runnable状态的线程时，由操作系统的线程调度器决定哪些线程将会运行，以及运行多长时间；</p>
<p>2）任何依赖于线程调度器来达到正确性或者性能要求的程序，很有可能都是不可移植的；</p>
<p>3）尽量确保Runnable线程的平均数量不明显多于处理器的数量，此时，即使在根本不同的线程调用算法下，这些程序的行为也不会有很大的变化；</p>
<p>4）令每个Runnable线程都在做有意义的工作，没有做有意义工作时，应从Runnable转移至其他状态；</p>
<p>5）适当地规定线程池的大小，使任务保持适当大小且彼此独立，当任务太小时，分配的开销也会影响到性能；</p>
<p>6）线程不应该一直处于忙-等的状态，即不应该反复地检查一个共享对象以等待某些事情发生，这使得程序容易受到调度器的影响，增大了处理器的负担，降低了同一机器上其他进程的工作效率；</p>
<p>7）不要通过<code>Thread.yield</code>方法来修正程序，不要通过调整线程优先级来修正程序。</p>
<h1 id="12、序列化"><a href="#12、序列化" class="headerlink" title="12、序列化"></a>12、序列化</h1><p>序列化用于将对象编码成字节流，字节流编码可以在机器之间传递或者存储到磁盘上，反序列化时就能从字节流编码中重新构建对象。</p>
<h2 id="12-1-其他方法优先于Java序列化（85）"><a href="#12-1-其他方法优先于Java序列化（85）" class="headerlink" title="12.1 其他方法优先于Java序列化（85）"></a>12.1 其他方法优先于Java序列化（85）</h2><p>1）序列化的根本问题在于其攻击面过于庞大，无法进行防护，在新编写的任何系统中都没有理由再使用Java序列化；</p>
<p>2）为了避免Java序列化的风险，还有许多其他跨平台的结构化数据表示法（JSON和Protocol Bufffers）可以完成对象和字节序列之间的转化，它们比Java序列化更加简单、安全；</p>
<p>3）重新设计新系统时一定要使用跨平台的结构化数据表示法代替Java序列化，JSON是基于文本的，为JavaScript开发的，Protocol Bufffers是基于二进制的，为C++开发的；</p>
<p>4）当无法避免地要使用Java序列化时，下一步最好永远不要反序列化不被信任的数据；</p>
<p>5）当无法避免地要使用Java序列化，且无法保证反序列化数据的安全性时，就是用对象反序列化过滤，它可以在反序列化之前，拒绝黑名单，接收白名单，但它并不能确保阻止所有的攻击。</p>
<h2 id="12-2-谨慎地使用Serializable接口（86）"><a href="#12-2-谨慎地使用Serializable接口（86）" class="headerlink" title="12.2 谨慎地使用Serializable接口（86）"></a>12.2 谨慎地使用Serializable接口（86）</h2><p>1）当一个类实现了<code>Serializable</code>接口，它的字节流编码（包括私有的和包级私有的实例域）就变成了它导出的API的一部分，需要对此维护的长期开销是很高的；</p>
<p>2）为继承而设计的类应该尽可能少的实现<code>Serializable</code>接口，用户的接口应该尽可能少的继承<code>Serializable</code>接口，内部类不应实现<code>Serializable</code>接口，但静态成员类可以实现<code>Serializable</code>接口；</p>
<p>3）如果一个类将要加入到某个框架中，并且该框架依赖于序列化来实现对象传输或者持久化，那么这个类就必须实现<code>Serializable</code>接口；</p>
<p>4）如果一个类要成为另一个类的一个组件，并且后者必须实现<code>Serializable</code>接口，那么前者实现<code>Serializable</code>接口的话就能更易于被后者使用；</p>
<p>5）应该仔细设计一种高质量的能长期使用的序列化形式，这也许会给类的演变带来限制，但好于无法演变。</p>
<h2 id="12-3-考虑使用自定义的序列化形式（87）"><a href="#12-3-考虑使用自定义的序列化形式（87）" class="headerlink" title="12.3 考虑使用自定义的序列化形式（87）"></a>12.3 考虑使用自定义的序列化形式（87）</h2><p>1）不贸然接受默认的序列化形式，除非经过认真考虑后确认是安全的（此时还有提供一个<code>readObject</code>方法以保证约束关系和安全性）；</p>
<p>2）当在不恰当地使用默认的序列化形式时，会使得这个类的导出API永远地束缚在该类的内部表示法上，在序列化时会消耗过多空间，在反序列化时会引起递归栈溢出，并消耗过多时间；</p>
<p>3）无论是否使用默认的序列化形式，每一个可以被标记为<code>transient</code>的实例域都应该做上这样的瞬时标记，包括那些冗余的域以及依赖于JVM的域；</p>
<p>4）无论是否使用默认的序列化形式，如果在读取整个对象状态的任何方法上强制任何同步，则也必须在对象序列化上强制这种同步；</p>
<p>5）编写的每一个可序列化的类都要声明一个显式的序列化版本UID，在修改类时，不要修改序列版本UID，否则会破坏类现有的已被序列化实例的兼容性。</p>
<h2 id="12-4-保护性地编写readObject方法（88）"><a href="#12-4-保护性地编写readObject方法（88）" class="headerlink" title="12.4 保护性地编写readObject方法（88）"></a>12.4 保护性地编写readObject方法（88）</h2><p>1）<code>readObject</code>方法实际上相当于另一个公有的构造器，需要对不希望客户端获得引用的参数进行保护性拷贝，并检查参数有效性；</p>
<p>2）<code>readObject</code>方法和构造器一样，不可以调用可被覆盖的方法，无论是直接调用还是间接调用都不可以；</p>
<p>3）在编写<code>readObject</code>方法时，对于任何检查失败的约束条件，就抛出<code>InvalidObjectException</code>异常。</p>
<h2 id="12-5-对于实例控制，枚举类型优先于readResolve（89）"><a href="#12-5-对于实例控制，枚举类型优先于readResolve（89）" class="headerlink" title="12.5 对于实例控制，枚举类型优先于readResolve（89）"></a>12.5 对于实例控制，枚举类型优先于readResolve（89）</h2><p>1）单例模式的类实现了序列化接口后就不再是单例，因为<code>readObject</code>方法会返回一个新建的实例，而这个新建实例不同于该类初始化时创建的实例；</p>
<p>2）如果实现了序列化接口的类想要保持单例，那么就提供一个<code>readResolve</code>方法，该方法会在反序列化之后被调用，返回对象引用，取代新建的对象，从而忽略反序列化得到的对象；</p>
<p>3）如果依赖<code>readReslove</code>方法进行实例控制，带有对象引用类型的所有实例域都必须声明为<code>transient</code>，即所有实例域都为基本类型或者瞬时的；</p>
<p>4）应该尽可能地使用枚举类型来实施实例控制的约束条件，如果做不到，就提供一个<code>readReslove</code>方法；</p>
<p>5）应认真考虑<code>readReslove</code>方法的可访问性。</p>
<h2 id="12-6-考虑用序列化代理代替序列化实例（90）"><a href="#12-6-考虑用序列化代理代替序列化实例（90）" class="headerlink" title="12.6 考虑用序列化代理代替序列化实例（90）"></a>12.6 考虑用序列化代理代替序列化实例（90）</h2><p>1）为可序列化的类设计一个私有的静态嵌套类，精确表示外围类的实例的逻辑状态，这个嵌套类被称为序列化代理；</p>
<p>2）序列化代理的构造器的参数类型就是外围类，这个构造器只需从参数中复制数据，而不需要进行任何的保护性拷贝或者一致性检查；</p>
<p>3）序列化代理和外围类都需要声明实现<code>Serializable</code>接口，序列化代理的默认序列化形式就是外围类最好的序列化形式；</p>
<p>4）在外围类的<code>writeReplace</code>方法中，以<code>this</code>作为入参，返回一个新建的序列化代理的实例，从而代替外围类的实例，那么序列化系统永远不会产生外围类的序列化实例；</p>
<p>5）在外围类中<code>readReslove</code>方法中，返回外围类实例，导致序列化系统在反序列化时将序列外代理转变回外围类的实例；</p>
<p>6）序列化代理模式以增加序列化开销为代价，带来安全性上的提升，可以有效阻止攻击；</p>
<p>7）序列化代理模式允许反序列化实例有着与原始序列化实例不同的类（比如子类），但不能与可以被客户端扩展的类相兼容。</p>
]]></content>
  </entry>
  <entry>
    <title>Escape and Face -</title>
    <url>/2023/07/29/escape-and-face/</url>
    <content><![CDATA[<div class="hbe hbe-container" id="hexo-blog-encrypt" data-wpm="Oh, this is an invalid password. Check and try again, please." data-whm="OOPS, these decrypted content may changed, but you can still have a look.">
  <script id="hbeData" type="hbeData" data-hmacdigest="db9b921e7449f7343a40c6b7b67c4e6249bcc2c7e1e935d339e3ed902f498e09">a99f2d1cd7f89812758242c57c62a59f6e3d9de3f1f0ab4274e07e6901cb7555a4c8f5e3f038231b1ee3ec529851fb864fd2fd4ea36b7a032518467337ac950ded4fc1d675cb94264dd96039153848d01db0be6df6b212a169b520e58cb1ef67f7cd2fcacfe38957f31d820b4b266fb0b050a26e91eb3798476568330b291f973babecaba410e3ccdc5c89484288929926e9871b96bc704b235e2bb1d5bff73298125c41db6b0dd5d8ef0e982418f3581d479a49c69e08cd430992d422d507da6d102c1e64de4c7893c88b544cb05bd85cb6d0046c783e94d3a40f28784f1678b668959f03914fb827d7d6e90c74a38e8a2bd0491ed1ae94dd590e366cf132a20c3a204d0275fdbbf0949bc734b901d591b0584130c4712eebcf861e26aa5bac77c608f867c0d091653babfe5a3e044292338f02b251503800bdc8c3d71a8735cc7409d961a62a2fb5676b4799a5cf1c55aa5a6a4bc8b3812e679e2835ac745f501c9fac231d61a1b56ed39012093ab8e492c92dbae9f765c2bce97512b066d41c85911376e623d91b6eae03f4c4429fd0bad38068e1bdfa11ed43e8970f600974dd2d05e3355ed61004da550e607f6f327b482854547545916e5dc86ed120398036163e11aadc935cff63141f79172c364b48a25cdc0153e8f14d9ea453ed4cbf41ac121b0343af5a571d79fd8e81a50969bec4e341a7503fe9d9e1167562c99785003db6923f1618de8cd038b5a85e7838ef72e6c0f085b23407ffb18dd8acc9d115665113d7bc1f221d4e2fd2fe80863840fcdcc83bcdde74a03cdf95b313ef2e3c8b0a86fe6c03b0c135aaf49c39d9e76757e8bf2fc01ba7fff69fc8fbcfecffe3a7af684f9529850f0e2f33cd95d306f450aeead5fc940165b7b5830c1c16dd0f4b11fdcb7cb7d04ae274eca994acbeb5ff00307b7554140950d74d03782c16be3a4bd97eeaafeb7f7250a07c5a20cb830ece219864cdb99c38c56b00ba43232c95d9146835ac18f10840b1e9dce3b6651de5ce3731ad6908f8d0c6401956a66f238d3fb5403cc8a1542b7c3d0b58f92c7133c4b1dc7347e612e2db33579e550d15fe9d2fc85ef08a732fc474bd43cbac055c8fbb14a10f5fdf92196fea36893fa90e4c517aaf6757ba05d01da709ee45dca30eee5a4a5a4d06cbae0e3f97015e4955fb96241e655a80a8aa35b11011d1e4a580afb4435a532fadd8c8c1d14c365fca424bc7b7be935163b14b6dfa9070a6ee561a87a225dd089db0632177f52b77934fa5f00acb48fd4e48115b41b0ac0b107903ccd78641e2c7efa96c0ca92b56a504ec8d20352423ecfc87e76e55b46def9f65d64fefc08f44d969553e668d34c51d9a411a3ae1907a5b2382fb0e457fd7dba92beac9288ab7ba1e515195502ded198de64013113428c5d10ce07a9f645bc3cb3bad7aa5c40dd256d63bd253ca8f42200cae977c76b384ca05361ed77a2b8fbf3a86172a333bb73a0632f2166872d926b285a37ccf500afbb87c0c0acc2ef61b7605f60bf6d00f4ca3179a1fc917ae5de0aa708257cc5d124fb7f4ff179ce7c4099f991d418ed06e3a7d074f9837d2c835a88d038833eef68115bc317624735fad559bd3c1403683d72a58342c34724a0abc332b5d33b41276068fc59678100fd83e903257c4c2e9c5136b903b5c7b2d3165acca136435da0d5e748b89e99a740b810fa2ab2bb1c43a2a9ebba1db08a4d954bffb8446c482ab50f31e3d6795321b70dcc4d8e8d7e51836cbb41e8a00bdbafa1cca0267e72ddc0fba9908dc6a9b35623ec26c95d1fc837c261a0f7b49b5d7f9fd9ee5cb524f5ad2cf8122381041f2e69d8d03f8e0d4cabc652b3852ff63d0db0f1c022a27d8b2121a1dd2dc28b24b1390ebcfe39392217186e0fbac18cf26259c5a0f7f9205bde6590b1edf9f237a7df58d9341d7246c55e70e8226da3f7a143278044ceb3888a2243e3e05d5982455f5faa9782e58d966ca1e44d7c03966ce87e30432030fdbb35789ee403dada4ebf14b180567e11d628bbe28b0af67729f24f01448ff4d5060e3d7f61f36f018437579b600dc78496dd61e1a999470a8515b33dabad8fb99d5f3bef6d518fdf2d36427086fc08ab71871f9a4c7fe1d75482853d3b2d2097ccf44527aa2b1fc4ff77b0e9cfe92a6ebde0b1d9e044d14a9501a5aa29b575919ea63261d65a87b651926b214bddfdedcbca34a88e29346535dbe811c0598b3367def8f2b297e3f838b45a7d3ae1feec9b61c585128ae758024c7360785adc76410f48898f21966959880511187546fd9339916edc95460100b377ad989d2ac978dc97b907f70a2bb094636aeada5a04c9c4c215d30ff07160b3cf071cf0fba84271a4227b7ba07567d788588f40e7e88f6f63280814057237015cc5b5206f962242ffd621235c4617e2a069dd992bc5275982e89e911b86e9f04028258522977e642ae282c30383f2c2af2907ab87812b269e4b43f0abb14688b928c381a42347ce22d8a2df604b666d1c88208a46fe0d8ab10fb0de1844d684dc3d7681d85af175f5457595d821290a595025cb44795ea00d65119aa4bdf6fbd3ee320b4e70123c4cd2788db2598791819d35794f3a997be11b01427be7da41a84a0dccae6554eb36203d4ab9babb764c3cecbb84ace3fc3d685bd9379c27435ff52cce40300b633f8a07c9645ec62b96dea264681b016458fa372f27018ed8f7a2c9c457af76b0b050c6b1219572392d193d6ec9ab2653fb56119ddec43ab2c3c8bca850e6862278f1eb791f19f486021f7fd3b0b67659ea6d7ed071847b7655438a8f4042e4054ad6a6a728f9acfb0147574870b22c7da5b612c3ef0ae13aa3198302e7ddf2aebcfb6c8670c666ee1b5b3439fa68dd0752d7e2e787868d5928584849902a11984f96408bfdd9496fd09beb4d0dcb9791d570517e0f5b695f12207728acc8c1945ed9a77e27df941aa930960b6e9531e87262edb8e28a5bcc1bf88dba00cc81e253d39fa54c443df6c8b08f140535f4c940feea75147e1b58c2eb40c610d1bbc6f1d56086b0a853ad494cd78b61c486b2e7d0dc399988b438f2a485615672549f4f3b25e735095831d8007a4d57e7ea09405d68b80f2649ef9b2992c146802c53889fd3377b9b44e7da966717f1870869aa3524403adcb45bdc0941833c9bf26e6c913fb3c1fdc1f92c8a8b2d39e9c9749f1357a7ced40b9c46052261ce4b9c2c0c9ca7f4e632a6c82f9f2aa42d590fd7ce369ae4dac678eb9ea5caf2f2a1a87ff8ac93c8f3d14bbfe8cfb66d55a62d691aa1351d94fb4e4078ea8f0e66ccd4b402d42b80bd1420fe171a8af4e5c6a829308a684efc0b1c5f2efd456bbc060fb8f44cd09830792c38b28093f194e54220066412c48bfd73c2f58effb0b06e98f3389d3c3326c9aba68e5d148b26cd03493ccb91f998fa34c3de443a41548a4fe5cd0eab79087ed0e99361a39d027324ae4fdf4a14624487f80d3ab8ba98e8acb6828b3be1d886d3d2e7219134737caa85f644705340d709d7d7d85e5e19809d7ec513da0c78a235f7e5efc91a2e75a882c9066a45b9a6d1bc264852e122616dacd571451aeb2bb07558b6142e4a5116c275b2e49353408b98c49edf0412359aa1ed27aa641f5327f381c40efba410be2459d0776c979937696bea1d867af3aa32162561e683881b8ced3bad831c9a5fbe2f0bedd4fc0a678c1eadf21acd366d486f6490032c2435421541980f249d8544bdd4d9e99355c6e693666bb7a5397ee7bdca5c88040c3af21d5c3842d6b1a918dbad88f3573d7b3ea081210f7518f2e875769d32b8dd5c90613dd1d66980f837820ab0acf41b29889d7988da5cab1a1894b50e98767ac8a7668697336b6bd6a6a54f150e57570c5aac3a97661d9ba6446abeb405ac55eeca37967e48690bfcfcda6d0b65eae2885d68679ff63a0e526c048050c27651927cf1a253cf596db1790f42a7315fa378a5de694675623b9112cd4e8df7c2260d10e3ecb2c3729ccb78876a97e52a1a3e9a79f81043e6f70</script>
  <div class="hbe hbe-content">
    <div class="hbe hbe-input hbe-input-default">
      <input class="hbe hbe-input-field hbe-input-field-default" type="password" id="hbePass">
      <label class="hbe hbe-input-label hbe-input-label-default" for="hbePass">
        <span class="hbe hbe-input-label-content hbe-input-label-content-default">Hey, password is required here.</span>
      </label>
    </div>
  </div>
</div>
<script data-pjax src="/lib/hbe.js"></script><link href="/css/hbe.style.css" rel="stylesheet" type="text/css">]]></content>
  </entry>
  <entry>
    <title>English Expression -</title>
    <url>/2023/07/23/expression/</url>
    <content><![CDATA[<h1 id="Vocabulary"><a href="#Vocabulary" class="headerlink" title="Vocabulary"></a>Vocabulary</h1><p>I’m here to keep track of new words, new expression I’ve heard recently, and I don’t remove them until I can spontaneously use them in my daily expression and thoroughly memorized them in all aspects of listening, speaking, reading and sentence-making. I expect this can be a vocabulary buffer that I can write into my brain later with no hurry and no lose.</p>
<p><a href="../../../../2023/11/05/history-vocabulary">History Input</a></p>
<h1 id="Grammar"><a href="#Grammar" class="headerlink" title="Grammar"></a>Grammar</h1><p>Just want to help myself understand sentences better and learn how to make sentences.</p>
<h2 id="Clause-Elements"><a href="#Clause-Elements" class="headerlink" title="Clause Elements"></a>Clause Elements</h2><p>Simple sentence (can’t be split) is composed of the following elements.</p>
<ul>
<li><strong>Subject + Predicate Verb (intransitive )</strong></li>
<li><strong>Subject + Predicate Verb (mono-transitive)+ Object</strong></li>
<li><strong>Subject + Predicate Verb (ditransitive) + Object (indirect) + Object (direct)</strong></li>
<li><strong>Subject + Predicate Verb (complex-transitive) + Object + Object Complement</strong></li>
<li><strong>Subject + Predicate Verb (linking) + Predicative/Subject Complement</strong></li>
<li><strong>Attributive</strong> is generally used to modify <strong>Subject</strong> and <strong>Object</strong></li>
<li><strong>Adverbial</strong> is generally used to modify <strong>Predicate Verb</strong></li>
<li><strong>Appositive</strong> is generally used to repeat <strong>Subject</strong> or <strong>Object</strong> again with a different expression</li>
</ul>
<p>Simple sentences are simply superimposed to form <strong>compound sentences</strong>.</p>
<p>Simple sentences (main clause) contain simple sentences (<strong>subordinate clause</strong>) (nesting relationship), then form complex sentences.</p>
<p>All sentence elements other than the <strong>predicate verb</strong> can be replaced with a <strong>subordinate clause</strong>.</p>
<h2 id="Parts-of-Speech"><a href="#Parts-of-Speech" class="headerlink" title="Parts of Speech"></a>Parts of Speech</h2><p>Parts of speech and clause elements are completely different concepts, can’t draw equal signs between them. Clause elements can be served by different parts of speech.</p>
<table>
<thead>
<tr>
<th align="center"></th>
<th align="center"></th>
<th align="center"></th>
<th align="center"></th>
<th align="center"></th>
</tr>
</thead>
<tbody><tr>
<td align="center"><strong>Verbs</strong></td>
<td align="center"><strong>Nouns</strong></td>
<td align="center"><strong>Articles</strong></td>
<td align="center"><strong>Pronouns</strong></td>
<td align="center"><strong>Adjectives</strong></td>
</tr>
<tr>
<td align="center"><strong>Numerals</strong></td>
<td align="center"><strong>Adverbs</strong></td>
<td align="center"><strong>Prepositions</strong></td>
<td align="center"><strong>Interjections</strong></td>
<td align="center"><strong>Conjunctions</strong></td>
</tr>
</tbody></table>
<p>Verbs are the core of English grammar. In addition to serving as a <strong>predicate verb</strong>, a verb can also serve as other clause elements, which is called a <strong>non-predicate verb</strong>. </p>
<p><strong>Non-predicate verbs</strong> can almost replace all <strong>subordinate clauses</strong> so as to simplify the sentence.</p>
<ul>
<li>full infinitive: to + verb</li>
<li>bare infinitive: (to) verb</li>
<li>gerund: verb-ing (n)</li>
<li>present participle (active): verb-ing (adj)</li>
<li>past participle (passive): verb-ed (adj)</li>
</ul>
<h2 id="Verb-Tenses-and-Moods"><a href="#Verb-Tenses-and-Moods" class="headerlink" title="Verb Tenses and Moods"></a>Verb Tenses and Moods</h2><p><strong>Predicate verb</strong> indicate the time (present, past, future, past future) of the action and the state (simple, progressive, perfect, perfect progressive) of the action, which are collectively called <strong>tenses</strong>.</p>
<p><strong>Auxiliary verb</strong> is generally used in conjunction with <strong>Predicate verb</strong> to complete the expression of action <strong>tenses</strong> and <strong>moods</strong> (indicative, imperative, subjunctive). <strong>Non-predicate verb</strong> don’t have property of <strong>tenses</strong> and <strong>moods</strong>.</p>
<ul>
<li>Simple Present Tense express a fact, habit, expectation</li>
<li>Perfect Progressive Tense emphasis has been partially completed, and will continue</li>
<li>The tenses of the main clause and subordinate clause should keep consistent, except for unchanging objective facts</li>
<li>In contrast to the present fact, the subjunctive should be expressed in past tense (condition clause) and “would + verb” (main clause)</li>
<li>In contrast to the past fact, the subjunctive should be expressed in “had + verb-en” (condition clause) and “would/should/could/might + have + verb-en” (main clause) </li>
<li>In contrast to the future fact, the subjunctive should be expressed in “should/would/could/might/were to + verb” (condition clause) and “should/would/could/might + verb” (main clause)</li>
</ul>
]]></content>
  </entry>
  <entry>
    <title>Design Patterns</title>
    <url>/2022/05/11/design-patterns/</url>
    <content><![CDATA[<h1 id="1、类图"><a href="#1、类图" class="headerlink" title="1、类图"></a>1、类图</h1><h2 id="1-1-泛化关系（Generalization）"><a href="#1-1-泛化关系（Generalization）" class="headerlink" title="1.1 泛化关系（Generalization）"></a>1.1 泛化关系（Generalization）</h2><p>用于描述非抽象类的继承关系，关键字为<code>extends</code>。</p>
<img src="泛化.png" alt="泛化" style="zoom:70%;" />

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Vehicle</span> &#123;...&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Car</span> <span class="keyword">extends</span> <span class="title class_">Vehicle</span> &#123;...&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Motorcycle</span> <span class="keyword">extends</span> <span class="title class_">Vehicle</span> &#123;...&#125;</span><br></pre></td></tr></table></figure>

<h2 id="1-2-实现关系（Realization）"><a href="#1-2-实现关系（Realization）" class="headerlink" title="1.2 实现关系（Realization）"></a>1.2 实现关系（Realization）</h2><p>用于描述抽象类/接口的实现关系，关键字为<code>implements</code>。</p>
<img src="实现.png" alt="实现" style="zoom:70%;" />

 <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title class_">Vehicle</span> &#123;...&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Car</span> <span class="keyword">implements</span> <span class="title class_">Vehicle</span> &#123;...&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Motorcycle</span> <span class="keyword">implements</span> <span class="title class_">Vehicle</span> &#123;...&#125;</span><br></pre></td></tr></table></figure>

<h2 id="1-3-组合关系（Composition）"><a href="#1-3-组合关系（Composition）" class="headerlink" title="1.3 组合关系（Composition）"></a>1.3 组合关系（Composition）</h2><p>用于描述整体和部分之间的强依赖关系，整体不存在时部分也不存在。</p>
<img src="复合.png" alt="复合" style="zoom:70%;" />

<h2 id="1-4-聚合关系（Aggregation）"><a href="#1-4-聚合关系（Aggregation）" class="headerlink" title="1.4 聚合关系（Aggregation）"></a>1.4 聚合关系（Aggregation）</h2><p>用于描述整体和部分个体之间的非强依赖关系，整体不存在时部分个体依旧存在。</p>
<img src="聚合.png" alt="聚合" style="zoom:70%;" />

<h2 id="1-5-关联关系（Association）"><a href="#1-5-关联关系（Association）" class="headerlink" title="1.5 关联关系（Association）"></a>1.5 关联关系（Association）</h2><p>用于描述类对象之间的静态强关联关系，该关系与运行过程的状态无关，在运行前就可以确定。关联关系通常以成员变量（静态方法变量）的形式实现。</p>
<p>关联关系默认不强调方向，表示对象之间默认互相知道，如果特别强调方向（如下图），则表示A知道B，但B不知道A。</p>
<img src="关联.png" alt="关联" style="zoom:70%;" />

<h2 id="1-6-依赖关系（Dependency）"><a href="#1-6-依赖关系（Dependency）" class="headerlink" title="1.6 依赖关系（Dependency）"></a>1.6 依赖关系（Dependency）</h2><p>用于描述类对象之间的临时性动态关联关系，该关系与运行过程中的状态相关，在运行时确定。依赖应当总是单向的，要杜绝双向依赖及循环依赖的产生。依赖关系通常以类方法的传入传出参数（或局部变量）实现。</p>
<img src="依赖.png" alt="依赖" style="zoom:70%;" />

 <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Car</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> Offgas <span class="title function_">move</span><span class="params">(Gasoline G)</span> &#123;...&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Gasoline</span> &#123;...&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Offgas</span> &#123;...&#125;</span><br></pre></td></tr></table></figure>

<p><strong>耦合紧密程度：泛化 = 实现 &gt;组合 &gt; 聚合 &gt; 关联 &gt; 依赖</strong></p>
<h1 id="2、设计模式"><a href="#2、设计模式" class="headerlink" title="2、设计模式"></a>2、设计模式</h1><p>设计模式是解决一些固有问题的一系列通用解决方案，是经过无数的验证和经验积累的最佳实践，学习现有的设计模式可以做到经验复用，降低试错成本和迭代成本，提升开发速度，以及代码的可重用性、可维护性、可扩展性等。</p>
<p>设计模式总是试图令变化的事物与不变的事物相互分离，通过使用松耦合的对象之间的交互，使系统更容易进行扩展和修改，通过引入抽象和接口，可以将变化的部分隔离出来，而不影响整个系统的其他部分。</p>
<p>设计模式的七大基本原则如下</p>
<ul>
<li>单一职责原则（SRP），一个类应该只有一个引起变化的原因，即一个类应该只做一件事，SRP 鼓励将功能分解为小的、独立的单元</li>
<li>开放封闭原则（OCP），软件实体（类、模块、函数等）应该对扩展是开放的，而对修改是关闭的，这意味着应该通过扩展现有代码（而不是修改已有代码）来引入新功能</li>
<li>里式替换原则（LSP），任何一个父类出现的地方，都可以用它的子类来替代，不会导致程序的错误、异常或任何意外行为，LSP 强调继承关系的正确使用</li>
<li>依赖倒置原则（DIP），高层模块不应该依赖于低层模块，二者都应该依赖于抽象接口，而不是具体的实现，通过引入抽象接口或抽象类来将高层模块与低层模块解耦</li>
<li>接口隔离原则（ISP），客户端不应该依赖于它不需要使用的接口，一个类不应该强迫它的客户端依赖于它们不需要的方法，接口应该小而专注，不应该包含多余的方法，ISP 鼓励使用多个小的专门的接口，而不是使用一个大的总接口</li>
<li>迪米特法则（LoD），一个对象应该对其他对象有最少得了解，对象之间应该保持松耦合，LoD 鼓励将复杂系统分解为多个小的、独立的模块，模块之间交互通过最少的接口进行</li>
<li>组合/聚合复用原则（CARP），优先使用组合/聚合（而不是继承）来构建复杂的对象结构，实现代码复用</li>
</ul>
<h2 id="2-1-创建型"><a href="#2-1-创建型" class="headerlink" title="2.1 创建型"></a>2.1 创建型</h2><p>创建型的核心思想在于将对象的创建与使用相分离。</p>
<h3 id="2-1-1-单例（Singleton）"><a href="#2-1-1-单例（Singleton）" class="headerlink" title="2.1.1 单例（Singleton）"></a>2.1.1 单例（Singleton）</h3><p>确保在一个进程中一个类有且只有一个实例，并提供该实例的全局访问点，更方便对象的管理和控制。</p>
<p>1）线程安全（饿汉），在类刚初始化时就立即创建对象，私有且抛出异常的构造方法可以反射对单例的破坏；</p>
 <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Singleton</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Singleton</span> <span class="variable">INSTANCE</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Singleton</span>();</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title function_">getInstance</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> INSTANCE;</span><br><span class="line">    &#125;</span><br><span class="line">  </span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">Singleton</span><span class="params">()</span> &#123;</span><br><span class="line">      	<span class="keyword">if</span> (INSTANCE != <span class="literal">null</span>) &#123;</span><br><span class="line">          	<span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(<span class="string">&quot;Invalid&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>2）延迟加载（懒汉），只在真正需要的时候才会创建对象，使用同步访问方法以防止创建多个对象，线程安全但也增加了访问成本，性能不好；</p>
 <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Singleton</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">Singleton</span> <span class="variable">INSTANCE</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">static</span> Singleton <span class="title function_">getInstance</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (INSTANCE == <span class="literal">null</span>) &#123;</span><br><span class="line">            INSTANCE = <span class="keyword">new</span> <span class="title class_">Singleton</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> INSTANCE;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">  	<span class="keyword">private</span> <span class="title function_">Singleton</span><span class="params">()</span> &#123;</span><br><span class="line">      	<span class="keyword">if</span> (INSTANCE != <span class="literal">null</span>) &#123;</span><br><span class="line">          	<span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(<span class="string">&quot;Invalid&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>3）基于<code>volatile</code>（作用在于禁止对<code>INSTANCE</code>变量操作的指令重排）的双重校验锁，除了可以对静态字段实现延迟初始化外，还可以对实例化字段实现延迟初始化，线程安全，性能较上一种方式有所提升；</p>
<p>第 8 行代码的对象初始化并不是一个原子操作（包含多个指令），一旦对象初始化的多个指令被重排就可能出现其他线程拿到了一个未完全初始化的对象，因此需要<code>volatile</code>来避免指令重排；</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Singleton</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">static</span> <span class="type">Singleton</span> <span class="variable">INSTANCE</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title function_">getInstance</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (INSTANCE == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (Singleton.class) &#123;</span><br><span class="line">                <span class="keyword">if</span> (INSTANCE == <span class="literal">null</span>) &#123;</span><br><span class="line">                    INSTANCE = <span class="keyword">new</span> <span class="title class_">Singleton</span>();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> INSTANCE;</span><br><span class="line">    &#125;</span><br><span class="line">  	</span><br><span class="line">  	<span class="keyword">private</span> <span class="title function_">Singleton</span><span class="params">()</span> &#123;</span><br><span class="line">      	<span class="keyword">if</span> (INSTANCE != <span class="literal">null</span>) &#123;</span><br><span class="line">          	<span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(<span class="string">&quot;Invalid&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>4）基于 CAS 实现线程安全的单例，不需要使用传统的锁机制来保证线程安全，但长时间的死循环会对 CPU 造成比较大的执行开销；</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Singleton</span> &#123;</span><br><span class="line">  	<span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> AtomicReference&lt;Singleton&gt; INSTANCE = <span class="keyword">new</span> <span class="title class_">AtomicReference</span>&lt;&gt;();</span><br><span class="line">  </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> Singleton <span class="title function_">getInstance</span><span class="params">()</span> &#123;</span><br><span class="line">      	<span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">          	<span class="type">Singleton</span> <span class="variable">singleton</span> <span class="operator">=</span> INSTANCE.get();</span><br><span class="line">          	<span class="keyword">if</span> (singleton != <span class="literal">null</span>) &#123;</span><br><span class="line">              	<span class="keyword">return</span> singleton;</span><br><span class="line">            &#125;</span><br><span class="line">          	singleton = <span class="keyword">new</span> <span class="title class_">Singleton</span>();</span><br><span class="line">          	<span class="keyword">if</span> (INSTANCE.compareAndSet(<span class="literal">null</span>, singleton)) &#123;</span><br><span class="line">              	<span class="keyword">return</span> singleton;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">  	<span class="keyword">private</span> <span class="title function_">Singleton</span><span class="params">()</span> &#123;</span><br><span class="line">      	<span class="keyword">if</span> (INSTANCE.get() != <span class="literal">null</span>) &#123;</span><br><span class="line">          	<span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(<span class="string">&quot;Invalid&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>5）针对静态域的延迟加载，lazy initialization holder class模式，静态访问方法不需要同步，不会因延迟初始化增加访问成本，线程安全，性能好；</p>
 <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Singleton</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> Singleton <span class="title function_">getInstance</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> SingletonHolder.INSTANCE;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">  	<span class="keyword">private</span> <span class="title function_">Singleton</span><span class="params">()</span> &#123;</span><br><span class="line">      	<span class="keyword">if</span> (SingletonHolder.INSTANCE != <span class="literal">null</span>) &#123;</span><br><span class="line">          	<span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(<span class="string">&quot;Invalid&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">SingletonHolder</span> &#123;</span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Singleton</span> <span class="variable">INSTANCE</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Singleton</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>6）枚举类型是实现单例最好的方式，写法简单，绝对线程安全（源于 JVM 主导控制的线程安全的类加载过程），此外还可以避免被反序列化破坏（详细参见 <a href="../../../../2022/05/08/java-language/">Java Language</a> 的 5.6 小节）；</p>
 <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">enum</span> <span class="title class_">Singleton</span> &#123;</span><br><span class="line">    INSTANCE;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>7）一般不是通过<code>new</code>操作符，而是由框架（例如Spring）来创建装配从而获取单例，<code>@Component</code>注解默认将组件标注为单例。</p>
<h3 id="2-1-2-简单工厂（Simple-Factory）"><a href="#2-1-2-简单工厂（Simple-Factory）" class="headerlink" title="2.1.2 简单工厂（Simple Factory）"></a>2.1.2 简单工厂（Simple Factory）</h3><p>提供用于创建一个对象的简单工厂类/工厂接口，如下所示，<code>User</code>类关联<code>Product</code>接口和<code>SimpleFactory</code>工厂类，通过<code>SimpleFactory</code>简单工厂实现具体<code>Product</code>的实例化。<code>User</code>类可忽略具体<code>Product</code>（<code>ProductA</code>和<code>ProductB</code>）的细节，从而将<code>User</code>类与具体<code>Product</code>实现类解耦，一个工厂创建所有的具体产品，不符合 OCP。</p>
<img src="简单工厂.png" alt="简单工厂" style="zoom:70%;" />

 <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title class_">Product</span>&#123;...&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ProductA</span> <span class="keyword">implements</span> <span class="title class_">Product</span>&#123;...&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ProductB</span> <span class="keyword">implements</span> <span class="title class_">Product</span>&#123;...&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">SimpleFactory</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> Product <span class="title function_">createProduct</span> <span class="params">(<span class="type">int</span> type)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (type == <span class="number">1</span>) &#123;</span><br><span class="line">            retrun <span class="keyword">new</span> <span class="title class_">ProductA</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (type == <span class="number">2</span>) &#123;</span><br><span class="line">            retrun <span class="keyword">new</span> <span class="title class_">ProductB</span>();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">User</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span> <span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">SimpleFactory</span> <span class="variable">simpleFactory</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SimpleFactory</span>();</span><br><span class="line">        <span class="type">Product</span> <span class="variable">product</span> <span class="operator">=</span> simpleFactory.createProduct(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="2-1-3-工厂方法（Factory-Method）"><a href="#2-1-3-工厂方法（Factory-Method）" class="headerlink" title="2.1.3 工厂方法（Factory Method）"></a>2.1.3 工厂方法（Factory Method）</h3><p>简单工厂类可以改为工厂接口，如下所示，<code>User</code>类关联<code>Product</code>接口和<code>ProductFactory</code>接口，通过<code>ProductFactory</code>接口的具体类（<code>ProductFactoryImpl</code>）实现具体<code>Product</code>（<code>ProductA</code>）的实例化。<code>User</code>类可忽略真正的工厂（<code>ProductFactoryImpl</code>）和具体<code>Product</code>（<code>ProductA</code>）的细节，从而将<code>User</code>类与工厂类及具体<code>Product</code>实现类解耦，一个工厂只创建一个具体的产品，符合 OCP，但引入了系统复杂性。</p>
<img src="工厂方法.png" alt="工厂方法" style="zoom:70%;" />

 <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title class_">Product</span>&#123;...&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ProductA</span> <span class="keyword">implements</span> <span class="title class_">Product</span>&#123;...&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">ProductFactory</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">ProductFactory</span> <span class="variable">impl</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ProductFactoryImpl</span>();</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> ProductFactory <span class="title function_">getFactory</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> impl;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> Product <span class="title function_">factoryMethod</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ProductFactoryImpl</span> <span class="keyword">implements</span> <span class="title class_">ProductFactory</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> Product <span class="title function_">factoryMethod</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">ProductA</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">User</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span> <span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">ProductFactory</span> <span class="variable">factory</span> <span class="operator">=</span> ProductFactory.getFactory();</span><br><span class="line">        <span class="type">Product</span> <span class="variable">product</span> <span class="operator">=</span> factory.factoryMethod();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>以上所述工厂方法可化简为静态工厂方法（Static Factory Method），如下所示</p>
<img src="静态工厂.png" alt="静态工厂" style="zoom:70%;" />

 <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title class_">Product</span>&#123;...&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ProductA</span> <span class="keyword">implements</span> <span class="title class_">Product</span>&#123;...&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">ProductFactory</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Product <span class="title function_">factoryMethod</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (...) &#123;</span><br><span class="line">            <span class="comment">// return interface from cache</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">ProductA</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">User</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span> <span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Product</span> <span class="variable">product</span> <span class="operator">=</span> ProductFactory.factoryMethod();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这样做的好处在于<code>factoryMethod</code>方法可能会<code>new</code>一个新的<code>ProductA</code>实例，也可能直接返回一个缓存的实例，对于<code>User</code>类来说，无需知道<code>ProductA</code>创建的细节。</p>
<p>总结：</p>
<ul>
<li>对象的实例化是通过工厂实现的，工厂代替了<code>new</code>操作，从而封装了对象的实例化细节，最常用的是更简单的静态工厂方法；</li>
<li>工厂方法定义工厂接口和产品接口，但创建实际工厂和实际产品被推迟到子类实现，使得调用方只和抽象工厂和抽象产品打交道；</li>
<li>调用方尽量持有接口或者抽象类，避免持有具体类型的子类，以便工厂方法能随时切换不同的子类返回，而不影响调用方代码。</li>
</ul>
<h3 id="2-1-4-抽象工厂（Abstract-Factory）"><a href="#2-1-4-抽象工厂（Abstract-Factory）" class="headerlink" title="2.1.4 抽象工厂（Abstract Factory）"></a>2.1.4 抽象工厂（Abstract Factory）</h3><p>提供<strong>用于创建对象家族</strong>的工厂接口（对象家族指很多个必须一起创建出来的相关的对象），对象家族中的单一对象由工厂方法创建出来，即实例化操作由该工厂接口的具体实现类完成。</p>
<p>如下所示，<code>User</code>类关联<code>Product</code>接口、<code>Tool</code>接口以及<code>AbstractFactory</code>接口，通过<code>AbstractFactory</code>接口的具体类（<code>FactoryImplA</code>）实现具体<code>Product</code>（<code>ProductA</code>）和具体<code>Tool</code>（<code>ToolA</code>）的实例化。<code>User</code>类可忽略真正的工厂（<code>FactoryImplA</code>）、具体<code>Product</code>（<code>ProductA</code>）和具体<code>Tool</code>（<code>ToolA</code>）的细节，从而将<code>User</code>类与工厂类、具体<code>Product</code>实现类及具体<code>Tool</code>实现类解耦，一个工厂创建一个类型的具体产品家族，符合 OCP，复杂性低于工厂方法。</p>
<img src="抽象工厂.png" alt="抽象工厂" style="zoom:70%;" />

 <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title class_">Product</span> &#123;...&#125;</span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">Tool</span> &#123;...&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">AbstractFactory</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> AbstractFactory <span class="title function_">createFactoryA</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">FactoryImplA</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> Product <span class="title function_">createProduct</span><span class="params">()</span>;</span><br><span class="line">    <span class="keyword">public</span> Tool <span class="title function_">createTool</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ProductA</span> <span class="keyword">implements</span> <span class="title class_">Product</span> &#123;...&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ToolA</span> <span class="keyword">implements</span> <span class="title class_">Tool</span> &#123;...&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">FactoryImplA</span> <span class="keyword">implements</span> <span class="title class_">AbstractFactory</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> Product <span class="title function_">createProduct</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">ProductA</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> Tool <span class="title function_">createTool</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">ToolA</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">User</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span> <span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">AbstractFactory</span> <span class="variable">factoryA</span> <span class="operator">=</span> AbstractFactory.createFactoryA();</span><br><span class="line">        <span class="type">Product</span> <span class="variable">product</span> <span class="operator">=</span> factoryA.createProduct();</span><br><span class="line">        <span class="type">Tool</span> <span class="variable">tool</span> <span class="operator">=</span> factoryA.createTool();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="2-1-5-生成器（Builder）"><a href="#2-1-5-生成器（Builder）" class="headerlink" title="2.1.5 生成器（Builder）"></a>2.1.5 生成器（Builder）</h3><p>通过多个可选的步骤或者多个可选的零件来灵活创建一个复杂的对象。</p>
<p>Builder模式并不直接生成一个<code>Product</code>类的对象，而是让客户端调用生成器得到一个<code>Builder</code>对象，然后在<code>Builder</code>对象上调用类似于<code>setter</code>的方法来设置可选参数，最后调用无参的<code>builder</code>方法来生成真正需要的（通常是不可变类的）<code>Product</code>类对象。</p>
<p>如下所示，<code>Builder</code>类通常作为需要构建的类的静态成员类，<code>Builder</code>类的设置方法均返回<code>this</code>，以便<strong>将调用链接起来，得到一个流式的API</strong>。</p>
<img src="生成器.png" alt="生成器" style="zoom:70%;" />

 <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Product</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">int</span> requiredParameter;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">int</span> optionalParameter;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">Product</span><span class="params">(Builder builder)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.requiredParameter = builder.requiredParameter;</span><br><span class="line">        <span class="built_in">this</span>.optionalParameter = builder.optionalParameter;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Builder</span> &#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">int</span> requiredParameter;</span><br><span class="line">        <span class="keyword">private</span> <span class="type">int</span> optionalParameter1;</span><br><span class="line">        <span class="keyword">private</span> <span class="type">int</span> optionalParameter2;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">public</span> <span class="title function_">Builder</span><span class="params">(<span class="type">int</span> requiredParameter)</span> &#123;</span><br><span class="line">            <span class="built_in">this</span>.requiredParameter = requiredParameter;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">public</span> Builder <span class="title function_">setOptionalParameter1</span><span class="params">(<span class="type">int</span> optionalParameter1)</span> &#123;</span><br><span class="line">            <span class="built_in">this</span>.optionalParameter1 = optionalParameter1;</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">this</span>;</span><br><span class="line">        &#125;        </span><br><span class="line">        <span class="keyword">public</span> Builder <span class="title function_">setOptionalParameter2</span><span class="params">(<span class="type">int</span> optionalParameter2)</span> &#123;</span><br><span class="line">            <span class="built_in">this</span>.optionalParameter2 = optionalParameter2;</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">this</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">public</span> Product <span class="title function_">build</span><span class="params">()</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Product</span>(<span class="built_in">this</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">User</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span> <span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Product</span> <span class="variable">product</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Product</span>.Builder(requiredParameter)</span><br><span class="line">            .setOptionalParameter1(optionalParameter1)</span><br><span class="line">            .setOptionalParameter2(optionalParameter2)</span><br><span class="line">            .build();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="2-1-6-原型（Prototype）"><a href="#2-1-6-原型（Prototype）" class="headerlink" title="2.1.6 原型（Prototype）"></a>2.1.6 原型（Prototype）</h3><p>用原型实例指定创建对象的类型，并且通过拷贝这个原型来创建新的对象。</p>
<p>原型模式应用不是很广泛，因为很多实例会持有一些无法拷贝给另一个对象共享的资源，只有一些简单属性可以拷贝。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">Prototype</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">abstract</span> Prototype <span class="title function_">myClone</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ConcretePrototype</span> <span class="keyword">extends</span> <span class="title class_">Prototype</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String filed;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">ConcretePrototype</span><span class="params">(String filed)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.filed = filed;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Prototype <span class="title function_">myClone</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">ConcretePrototype</span>(filed);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">User</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Prototype</span> <span class="variable">prototype</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ConcretePrototype</span>(<span class="string">&quot;abc&quot;</span>);</span><br><span class="line">        <span class="type">Prototype</span> <span class="variable">clone</span> <span class="operator">=</span> prototype.myClone();</span><br><span class="line">        System.out.println(prototype == clone); <span class="comment">// false</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="2-2-行为型"><a href="#2-2-行为型" class="headerlink" title="2.2 行为型"></a>2.2 行为型</h2><p>行为型的核心思想在于通过对象之间的协作来灵活完成一个整体任务。</p>
<h3 id="2-2-1-责任链（Chain-of-Responsibility）"><a href="#2-2-1-责任链（Chain-of-Responsibility）" class="headerlink" title="2.2.1 责任链（Chain of Responsibility）"></a>2.2.1 责任链（Chain of Responsibility）</h3><p>将多个处理器连成一条链，并沿着这条链传递该请求，直到有一个处理器处理它为止，使得多个处理器都有机会处理请求，从而避免请求的发送者和接收者之间的耦合关系。</p>
<img src="责任链1.png" alt="责任链1" style="zoom:70%;" />

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">enum</span> <span class="title class_">RequestType</span> &#123;</span><br><span class="line">    TYPE1, TYPE2</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Request</span> &#123;...&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">enum</span> <span class="title class_">ResponseType</span> &#123;</span><br><span class="line">    TRUE, FALSE, NEXT</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Response</span> &#123;...&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Handler</span> &#123;</span><br><span class="line">    Response <span class="title function_">process</span><span class="params">(Request request)</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">HandlerImpl1</span> <span class="keyword">implements</span> <span class="title class_">Handler</span> &#123;...&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">HandlerImpl2</span> <span class="keyword">implements</span> <span class="title class_">Handler</span> &#123;...&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">HandlerChain</span> &#123;</span><br><span class="line">    <span class="comment">// 持有所有Handler:</span></span><br><span class="line">    <span class="keyword">private</span> List&lt;Handler&gt; handlers = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">addHandler</span><span class="params">(Handler handler)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.handlers.add(handler);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> Response <span class="title function_">processHandlers</span><span class="params">(Request request)</span> &#123;</span><br><span class="line">        <span class="comment">// 依次调用每个Handler:</span></span><br><span class="line">        <span class="keyword">for</span> (Handler handler : handlers) &#123;</span><br><span class="line">            <span class="type">Response</span> <span class="variable">response</span> <span class="operator">=</span> handler.process(request);</span><br><span class="line">            <span class="keyword">if</span> (response != <span class="literal">null</span> &amp;&amp; !ResponseType.NEXT.equals(response.getResponseType())) &#123;</span><br><span class="line">                System.out.println(response.getMessage());</span><br><span class="line">                <span class="keyword">return</span> response;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(<span class="string">&quot;Could not handle request: &quot;</span> + request);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">User</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">// 构造责任链:</span></span><br><span class="line">        <span class="type">HandlerChain</span> <span class="variable">chain</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">HandlerChain</span>();</span><br><span class="line">        chain.addHandler(<span class="keyword">new</span> <span class="title class_">HandlerImpl1</span>());</span><br><span class="line">        chain.addHandler(<span class="keyword">new</span> <span class="title class_">HandlerImpl2</span>());</span><br><span class="line">        <span class="comment">// 构造请求:</span></span><br><span class="line">        <span class="type">Request</span> <span class="variable">request</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Request</span>(RequestType.TYPE1);</span><br><span class="line">        <span class="comment">// 处理请求:</span></span><br><span class="line">        <span class="type">Response</span> <span class="variable">response</span> <span class="operator">=</span> chain.processHandlers(request);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>总结：</p>
<ul>
<li><p>责任链模式的好处在于添加新的处理器或者重新排列处理器非常容易，经常用在拦截、预处理、日志记录、异常处理、授权认证等；</p>
</li>
<li><p><code>Handler</code>的添加的顺序很重要，如果顺序不对，处理的结果可能就不是符合要求的；</p>
</li>
<li><p>也可以在<code>Handler</code>中添加成员<code>Handler</code>，从而指定每个<code>Handler</code>的下一个<code>Handler</code>并传递<code>Request</code>。</p>
<img src="责任链2.png" alt="责任链2" style="zoom:70%;" /></li>
</ul>
<h3 id="2-2-2-命令（Command）"><a href="#2-2-2-命令（Command）" class="headerlink" title="2.2.2 命令（Command）"></a>2.2.2 命令（Command）</h3><p>将一个请求命令封装为一个对象，使得：1）可用不同的请求对客户进行参数化，2）对请求排队，3）记录请求日志，4）支持可撤销的操作。</p>
<img src="命令.png" alt="命令" style="zoom:70%;" />

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Command</span> &#123;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">execute</span><span class="params">()</span>;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">undo</span><span class="params">()</span>;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">redo</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">XXXCommand</span> <span class="keyword">implements</span> <span class="title class_">Command</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> XXX receiver; <span class="comment">// 执行方对象:</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">XXXCommand</span><span class="params">(XXX receiver)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.receiver = receiver;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">execute</span><span class="params">()</span> &#123;</span><br><span class="line">        receiver.xxx();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">undo</span><span class="params">()</span> &#123;...&#125;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">redo</span><span class="params">()</span> &#123;...&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Invoker</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> List&lt;Command&gt; commands = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">addCommand</span><span class="params">(Command command)</span> &#123;</span><br><span class="line">        commands.add(command);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">invok</span><span class="params">(<span class="type">int</span> index)</span> &#123;</span><br><span class="line">        list.get(index).execute();        </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">undo</span><span class="params">(<span class="type">int</span> index)</span> &#123;</span><br><span class="line">        list.get(index).undo();        </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">redo</span><span class="params">(<span class="type">int</span> index)</span> &#123;</span><br><span class="line">        list.get(index).redo();        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">User</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Invoker</span> <span class="variable">invoker</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Invoker</span>();</span><br><span class="line">        invoker.addCommand(<span class="keyword">new</span> <span class="title class_">XXXCommand</span>(<span class="keyword">new</span> <span class="title class_">XXX</span>()));</span><br><span class="line">        invoker.invoke(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>总结：</p>
<ul>
<li><p>命令模式把命令的创建和执行分离，调用方<code>Invoker</code>只发送命令，而不关心执行方<code>receiver</code>具体执行命令的详细过程；</p>
</li>
<li><p>在执行方对象<code>receiver</code>比较简单时，命令模式增加了系统的复杂度；</p>
</li>
<li><p>当执行方对象<code>receiver</code>复杂到一定程度，并且需要支持Undo、Redo等功能时，命令模式通过封装<code>Command</code>对象，并通过<code>Invoker</code>将一系列已执行或未执行的<code>Command</code>保存起来，从而支持撤销、重做等操作。</p>
</li>
</ul>
<h3 id="2-2-3-解释器（Interpreter）"><a href="#2-2-3-解释器（Interpreter）" class="headerlink" title="2.2.3 解释器（Interpreter）"></a>2.2.3 解释器（Interpreter）</h3><p>根据某种语言来定义一个解释器，解释器通过抽象语法树实现对用户输入的解释执行。</p>
<p>比如用于匹配字符串的正则表达式（<code>java.util.regex.Pattern</code>）就是一个解释器。</p>
<p>解释器模式的实现通常非常复杂，且一般只能解决一类特定问题。</p>
<h3 id="2-2-4-迭代器（Iterator）"><a href="#2-2-4-迭代器（Iterator）" class="headerlink" title="2.2.4 迭代器（Iterator）"></a>2.2.4 迭代器（Iterator）</h3><p>提供一个用于顺序访问聚合对象中的各个元素的方法，并且不暴露该聚合对象的内部表示。</p>
<p>如下所示，实现Iterator模式的关键是返回一个<code>Iterator</code>对象，该对象知道集合的内部结构。</p>
<img src="迭代器.png" alt="迭代器" style="zoom:70%;" />

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Iterator</span>&lt;E&gt; &#123;</span><br><span class="line">    <span class="type">boolean</span> <span class="title function_">hasNext</span><span class="params">()</span>;</span><br><span class="line">    E <span class="title function_">next</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ConcreteIterator</span>&lt;E&gt; <span class="keyword">implements</span> <span class="title class_">Iterator</span>&lt;E&gt; &#123;</span><br><span class="line">    <span class="keyword">private</span> Object[] elements;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="variable">position</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">ConcreteIterator</span><span class="params">(Object[] elements, <span class="type">int</span> size)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.elements = Arrays.copyOf(elements, size);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">hasNext</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> position &lt; elements.length;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> E <span class="title function_">next</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> (E) elements[position++];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Iterable</span>&lt;T&gt; &#123;</span><br><span class="line">    Iterator&lt;T&gt; <span class="title function_">iterator</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Aggregate</span>&lt;E&gt; <span class="keyword">extends</span> <span class="title class_">Iterable</span>&lt;E&gt; &#123;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">add</span><span class="params">(E e)</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ConcreteAggregate</span>&lt;E&gt; <span class="keyword">implements</span> <span class="title class_">Aggregate</span>&lt;E&gt; &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="variable">size</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="variable">maxsize</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">private</span> Object[] elements = <span class="keyword">new</span> <span class="title class_">Object</span>[maxsize];</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Iterator&lt;E&gt; <span class="title function_">iterator</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">ConcreteIterator</span>&lt;E&gt;(elements,size);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">add</span><span class="params">(E e)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (size == maxsize) &#123;</span><br><span class="line">            maxsize *= <span class="number">2</span>;</span><br><span class="line">            elements = Arrays.copyOf(elements,maxsize);</span><br><span class="line">        &#125;</span><br><span class="line">        elements[size++] = e;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">User</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Aggregate</span> <span class="variable">aggregate</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ConcreteAggregate</span>();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">            aggregate.add(i);</span><br><span class="line">        &#125;</span><br><span class="line">        Iterator&lt;Integer&gt; iterator = aggregate.iterator();</span><br><span class="line">        <span class="keyword">while</span> (iterator.hasNext()) &#123;</span><br><span class="line">            System.out.println(iterator.next());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="2-2-5-中介者-调停者（Mediator）"><a href="#2-2-5-中介者-调停者（Mediator）" class="headerlink" title="2.2.5 中介者/调停者（Mediator）"></a>2.2.5 中介者/调停者（Mediator）</h3><p>用一个中介对象来封装一系列复杂的对象交互，将多方会谈改为多个双方会谈。</p>
<p>如下所示，模块可以通过调用中介者来间接调用相关模块。</p>
<img src="中介者.png" alt="中介者" style="zoom:70%;" />

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Mediator</span> &#123;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">doEvent</span><span class="params">(String eventType)</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Module</span> &#123;</span><br><span class="line">    <span class="comment">// 模块可以通过调用中介者来间接调用相关模块</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">onEvent</span><span class="params">(Mediator mediator)</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">fun</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ModuleA</span> <span class="keyword">implements</span> <span class="title class_">Module</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onEvent</span><span class="params">(Mediator mediator)</span> &#123;</span><br><span class="line">        mediator.doEvent(<span class="string">&quot;type1&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">fun</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;ModuleA.fun()&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ModuleB</span> <span class="keyword">implements</span> <span class="title class_">Module</span> &#123;...&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ModuleC</span> <span class="keyword">implements</span> <span class="title class_">Module</span> &#123;...&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ModuleD</span> <span class="keyword">implements</span> <span class="title class_">Module</span> &#123;...&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ConcreteMediator</span> <span class="keyword">implements</span> <span class="title class_">Mediator</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> Module a,b,c,d;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">ConcreteMediator</span><span class="params">(Module a, Module b, Module c, Module d)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.a = a;</span><br><span class="line">        <span class="built_in">this</span>.b = b;</span><br><span class="line">        <span class="built_in">this</span>.c = c;</span><br><span class="line">        <span class="built_in">this</span>.d = d;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">doEvent</span><span class="params">(String eventType)</span> &#123;</span><br><span class="line">        <span class="keyword">switch</span> (eventType) &#123;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&quot;type1&quot;</span>:</span><br><span class="line">                interact1();</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&quot;type2&quot;</span>:</span><br><span class="line">                interact2();</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">default</span>:</span><br><span class="line">                interact3();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">interact1</span><span class="params">()</span> &#123;</span><br><span class="line">        b.fun();</span><br><span class="line">        c.fun();</span><br><span class="line">        d.fun();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">interact2</span><span class="params">()</span> &#123;...&#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">interact3</span><span class="params">()</span> &#123;...&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">User</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Module</span> <span class="variable">a</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ModuleA</span>();</span><br><span class="line">        <span class="type">Module</span> <span class="variable">b</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ModuleB</span>();</span><br><span class="line">        <span class="type">Module</span> <span class="variable">c</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ModuleC</span>();</span><br><span class="line">        <span class="type">Module</span> <span class="variable">d</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ModuleD</span>();</span><br><span class="line">        <span class="type">Mediator</span> <span class="variable">mediator</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ConcreteMediator</span>(a,b,c,d);</span><br><span class="line">        <span class="comment">// 模块可以通过调用中介者来间接调用相关模块</span></span><br><span class="line">        a.onEvent(mediator);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>运行结果：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">ModuleB.fun()</span><br><span class="line">ModuleC.fun()</span><br><span class="line">ModuleD.fun()</span><br></pre></td></tr></table></figure>

<p>总结：</p>
<ul>
<li>中介使得各个组件不需要显式地相互引用，降低了组件间的耦合关系；</li>
<li>组件间的交互可以独立地进行改变而不影响其他的组件；</li>
<li>中介经常用在有众多交互组件的UI上，MVC模式可以看作是中介模式的扩展。</li>
</ul>
<h3 id="2-2-6-备忘录（Memento）"><a href="#2-2-6-备忘录（Memento）" class="headerlink" title="2.2.6 备忘录（Memento）"></a>2.2.6 备忘录（Memento）</h3><p>在不破坏封装性的前提下获得一个对象的内部状态，并在需要时将该对象恢复到之前的状态。</p>
<img src="备忘录.png" alt="备忘录" style="zoom:70%;" />

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Memento</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="title function_">getState</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MementoImpl</span> <span class="keyword">implements</span> <span class="title class_">Memento</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> state;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">MementoImpl</span><span class="params">(<span class="type">int</span> state)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.state = state;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getState</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> state;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Originator</span> &#123;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">setState</span><span class="params">(<span class="type">int</span> state)</span>;</span><br><span class="line">    <span class="type">int</span> <span class="title function_">getState</span><span class="params">()</span>;</span><br><span class="line">    Memento <span class="title function_">createMemento</span><span class="params">()</span>;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">setMemento</span><span class="params">(Memento memento)</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">OriginatorImp</span> <span class="keyword">implements</span> <span class="title class_">Originator</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> state;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setState</span><span class="params">(<span class="type">int</span> state)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.state = state;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getState</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> state;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Memento <span class="title function_">createMemento</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">MementoImpl</span>(state);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setMemento</span><span class="params">(Memento memento)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.state = memento.getState();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">User</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Originator</span> <span class="variable">originator</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">OriginatorImp</span>();</span><br><span class="line">        <span class="comment">// 原始状态</span></span><br><span class="line">        originator.setState(<span class="number">33</span>);</span><br><span class="line">        System.out.println(originator.getState());</span><br><span class="line">        <span class="comment">// 存储当前状态以备不时之需</span></span><br><span class="line">        <span class="type">Memento</span> <span class="variable">memento</span> <span class="operator">=</span> originator.createMemento();</span><br><span class="line">        <span class="comment">// 设置新状态</span></span><br><span class="line">        originator.setState(<span class="number">71</span>);</span><br><span class="line">        System.out.println(originator.getState());</span><br><span class="line">        <span class="comment">// 恢复上一个状态</span></span><br><span class="line">        originator.setMemento(memento);</span><br><span class="line">        System.out.println(originator.getState());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>运行结果：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="number">33</span></span><br><span class="line"><span class="number">71</span></span><br><span class="line"><span class="number">33</span></span><br></pre></td></tr></table></figure>

<p>总结：</p>
<ul>
<li><p>Java的序列化、Undo、Redo这些功能，都可以看作是备忘录模式；</p>
</li>
<li><p>对于简单的对象模型，用一个<code>String</code>就可以表示其状态，对于复杂的对象模型，通常会使用JSON、XML等复杂格式。</p>
</li>
</ul>
<h3 id="2-2-7-观察者-监听者（Observer-Listener）"><a href="#2-2-7-观察者-监听者（Observer-Listener）" class="headerlink" title="2.2.7 观察者/监听者（Observer/Listener）"></a>2.2.7 观察者/监听者（Observer/Listener）</h3><p>定义对象间的一种一对多的依赖关系，当一个对象的状态发生改变时，所有依赖于它的对象都得到通知并自动被更新，又称发布-订阅（Publish-Subscribe）模式，发布方和订阅方彼此分离，互不影响。</p>
<p>如下所示，观察者<code>Admin</code>和<code>Customer</code>与被观察者<code>Store</code>彼此分离，互不影响，被观察者将通知变成一个<code>Event</code>对象，观察者自己从<code>Event</code>对象中读取通知类型和通知数据。</p>
<img src="观察者.png" alt="观察者" style="zoom:70%;" />

 <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Observable</span> &#123;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">registerObserver</span><span class="params">(Observer observer)</span>;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">removeObserver</span><span class="params">(Observer observer)</span>;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">notifyObservers</span><span class="params">(Event event)</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Observer</span> &#123;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">onEvent</span><span class="params">(Event event)</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 商店是被观察者</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Store</span> implemets Observable &#123;</span><br><span class="line">    <span class="keyword">private</span> List&lt;Observer&gt; observers = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">registerObserver</span><span class="params">(Observer observer)</span> &#123;</span><br><span class="line">        observers.add(observer);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">removeObserver</span><span class="params">(Observer observer)</span> &#123;</span><br><span class="line">        observers.remove(observer);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">notifyObservers</span><span class="params">(Event event)</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (Observer observer : observers) &#123;</span><br><span class="line">            observer.onEvent(event);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 管理员是观察者</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Admin</span> implemets Observer &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onEvent</span><span class="params">(Event event)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Admin 接收到 &quot;</span> + event.toString() + <span class="string">&quot;事件&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 客户是观察者</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Customer</span> implemets Observer &#123;...&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">User</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span> <span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Store</span> <span class="variable">store</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Store</span>();</span><br><span class="line">        store.registerObserver(<span class="keyword">new</span> <span class="title class_">Admin</span>());</span><br><span class="line">        store.registerObserver(<span class="keyword">new</span> <span class="title class_">Customer</span>());</span><br><span class="line">        <span class="comment">// 商店给注册的管理员和客户发送商品消息</span></span><br><span class="line">        store.notifyObservers(<span class="string">&quot;来自 Store 的商品消息&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>总结：</p>
<ul>
<li><p>不推荐借助Java标准库中的<code>java.util.Observable</code>类和<code>Observer</code>接口来实现观察者模式；</p>
</li>
<li><p>不同的<code>Event</code>对象可以有着不同的通知 Topic，观察者可以自行订阅自己感兴趣的 Topic。</p>
</li>
</ul>
<h3 id="2-2-8-状态（State）"><a href="#2-2-8-状态（State）" class="headerlink" title="2.2.8 状态（State）"></a>2.2.8 状态（State）</h3><p>将不同状态下的行为逻辑分拆到不同的状态类中，允许对象在其内部状态改变时改变其行为。</p>
<img src="状态.png" alt="状态" style="zoom:70%;" />

 <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">State</span> &#123;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">handle</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">StateA</span> implemets State &#123;...&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">StateB</span> implemets State &#123;...&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">StateC</span> implemets State &#123;...&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Context</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">State</span> <span class="variable">state</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StateA</span>();</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">transfer</span> <span class="params">(String input)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (...) &#123;</span><br><span class="line">            state = <span class="keyword">new</span> <span class="title class_">StateA</span>();</span><br><span class="line">            state.handle();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (...) &#123;</span><br><span class="line">            state = <span class="keyword">new</span> <span class="title class_">StateB</span>();</span><br><span class="line">            state.handle();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            state = <span class="keyword">new</span> <span class="title class_">StateC</span>();</span><br><span class="line">            state.handle();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">User</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span> <span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Scanner</span> <span class="variable">sc</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Scanner</span>(System.in);</span><br><span class="line">        <span class="type">Context</span> <span class="variable">ctx</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Context</span>();</span><br><span class="line">        <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">            ctx.transfer(sc.nextLine());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>总结：</p>
<ul>
<li><p>状态模式常用于带有状态的对象中，增加新状态非常容易；</p>
</li>
<li><p>状态模式的关键在于状态转换，简单的状态转换可以直接由调用方指定，复杂的状态转换可以在内部根据条件触发完成。</p>
</li>
</ul>
<h3 id="2-2-9-策略（Strategy）"><a href="#2-2-9-策略（Strategy）" class="headerlink" title="2.2.9 策略（Strategy）"></a>2.2.9 策略（Strategy）</h3><p>定义一系列算法，这些算法被封装到一个对象中，策略模式使得这些算法在运行时可以互相替换，并且独立于使用这些算法的客户端。</p>
<img src="策略.png" alt="策略" style="zoom:70%;" />

 <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Strategy</span> &#123;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">handle</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">StrategyA</span> implemets Strategy &#123;...&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">StrategyB</span> implemets Strategy &#123;...&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">StrategyC</span> implemets Strategy &#123;...&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Context</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">Strategy</span> <span class="variable">strategy</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StrategyA</span>();</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setStrategy</span><span class="params">(Strategy strategy)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.strategy = strategy;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">apply</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.strategy.handle();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">User</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Context</span> <span class="variable">ctx</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Context</span>();</span><br><span class="line">        ctx.apply(); <span class="comment">//使用默认策略</span></span><br><span class="line">        </span><br><span class="line">        ctx.setStrategy(<span class="keyword">new</span> <span class="title class_">StrategyB</span>);</span><br><span class="line">        ctx.apply(); <span class="comment">//使用指定策略</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>总结：</p>
<ul>
<li><p>一个完整的策略模式要定义策略以及使用策略的上下文，策略模式的核心思想是在一个计算方法中把容易变化的算法抽出来作为“策略”参数传进去，使得新增策略不必修改原有逻辑；</p>
</li>
<li><p>状态模式与策略模式类似，都能够动态改变对象的行为，状态模式通过状态转移来改变<code>State</code>对象，而策略模式通过本身决策来改变所使用的算法；</p>
</li>
<li><p>状态模式主要是用于解决动态的状态转移问题，策略模式主要是用于动态地替换所使用的算法；</p>
</li>
<li><p>策略模式和Lambda表达式配合使用可极大提高程序灵活性，例如<code>Arrays.sort (T[] a, Comparator&lt;? Super T&gt; c)</code>方法就可根据lambda表达式所提供的比较策略<code>c</code>来实现不同比较策略下的排序。</p>
</li>
</ul>
<h3 id="2-2-10-模板方法（Template-Method）"><a href="#2-2-10-模板方法（Template-Method）" class="headerlink" title="2.2.10 模板方法（Template Method）"></a>2.2.10 模板方法（Template Method）</h3><p>定义一个操作中的算法框架，并将一些步骤的实现延迟到子类，使得子类可以在不改变算法结构的同时修改一些步骤的实现。</p>
<p>如下所示，清洗、调料以及烹饪这三步是固定的，但是可以在<code>RoastChicken</code>和<code>FriedChicken</code>子类中，定义<code>souse</code>和<code>cook</code>函数的具体实现。</p>
 <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">Chicken</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">make</span><span class="params">()</span> &#123;</span><br><span class="line">        clean();</span><br><span class="line">        souse();</span><br><span class="line">        cook();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">clean</span><span class="params">()</span> &#123;...&#125;</span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title function_">souse</span><span class="params">()</span>;</span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title function_">cook</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RoastChicken</span> <span class="keyword">extends</span> <span class="title class_">Chicken</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">souse</span><span class="params">()</span> &#123;...&#125;      </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">cook</span><span class="params">()</span> &#123;...&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">FriedChicken</span> <span class="keyword">extends</span> <span class="title class_">Chicken</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">souse</span><span class="params">()</span> &#123;...&#125;      </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">cook</span><span class="params">()</span> &#123;...&#125;      </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">User</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Chicken</span> <span class="variable">chicken1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">RoastChicken</span>();</span><br><span class="line">        chicken1.make();</span><br><span class="line">        <span class="type">Chicken</span> <span class="variable">chicken2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FriedChicken</span>();</span><br><span class="line">        chicken2.make ();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>总结：</p>
<ul>
<li><p>模板方法的核心思想是：父类定义骨架，子类实现某些细节；</p>
</li>
<li><p>为了防止子类重写父类的骨架方法，可以在父类中对骨架方法使用<code>final</code>关键字；</p>
</li>
<li><p>对于需要子类实现的抽象方法，一般声明为<code>protected</code>，使得这些方法对外部客户端不可见。</p>
</li>
</ul>
<h3 id="2-2-11-访问者（Visitor）"><a href="#2-2-11-访问者（Visitor）" class="headerlink" title="2.2.11 访问者（Visitor）"></a>2.2.11 访问者（Visitor）</h3><p>抽象出作用于一组复杂对象结构的操作，将对象结构与操作分离开，当需要增加新操作时无需改变现有结构。</p>
<p>如下所示，通过<code>ElementStructure</code>来组装对象结构，通过<code>Visitor</code>的实现类来定义作用于对象的操作，当需要增加新操作时只需增加<code>Visitor</code>的新实现类来完成新操作即可。</p>
<img src="访问者.png" alt="访问者" style="zoom:70%;" />

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Element</span> &#123;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">accept</span><span class="params">(Visitor visitor)</span>;</span><br><span class="line">    String <span class="title function_">getName</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ElementA</span> <span class="keyword">implements</span> <span class="title class_">Element</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">accept</span><span class="params">(Visitor visitor)</span> &#123;</span><br><span class="line">        visitor.visit(<span class="built_in">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getName</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;ElementA&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ElementB</span> <span class="keyword">implements</span> <span class="title class_">Element</span> &#123;...&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ElementStructure</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> List&lt;Element&gt; elements = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">handle</span><span class="params">(Visitor visitor)</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (Element element : elements) &#123;</span><br><span class="line">            element.accept(visitor);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">addElement</span><span class="params">(Element element)</span> &#123;</span><br><span class="line">        elements.add(element);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Visitor</span> &#123;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">visit</span><span class="params">(ElementA element)</span>;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">visit</span><span class="params">(ElementB element)</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">VisitorA</span> <span class="keyword">implements</span> <span class="title class_">Visitor</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">visit</span><span class="params">(ElementA element)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Visit &quot;</span> + element.getName() + <span class="string">&quot; by VisitorA&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">visit</span><span class="params">(ElementB element)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Visit &quot;</span> + element.getName() + <span class="string">&quot; by VisitorA&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">VisitorB</span> <span class="keyword">implements</span> <span class="title class_">Visitor</span> &#123;...&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">User</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">// 定义对象结构</span></span><br><span class="line">        <span class="type">ElementStructure</span> <span class="variable">es</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ElementStructure</span>();</span><br><span class="line">        es.addElement(<span class="keyword">new</span> <span class="title class_">ElementA</span>());</span><br><span class="line">        es.addElement(<span class="keyword">new</span> <span class="title class_">ElementB</span>());</span><br><span class="line">        <span class="comment">// 访问对象结构</span></span><br><span class="line">        es.handle(<span class="keyword">new</span> <span class="title class_">VisitorA</span>());</span><br><span class="line">        es.handle(<span class="keyword">new</span> <span class="title class_">VisitorB</span>());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>运行结果：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Visit ElementA by VisitorA</span><br><span class="line">Visit ElementB by VisitorA</span><br><span class="line">Visit ElementA by VisitorB</span><br><span class="line">Visit ElementB by VisitorB</span><br></pre></td></tr></table></figure>

<h2 id="2-3-结构型"><a href="#2-3-结构型" class="headerlink" title="2.3 结构型"></a>2.3 结构型</h2><p>结构型的核心思想在于通过继承、实现以及组合机制使得对象之间具备良好、灵活的结构。</p>
<h3 id="2-3-1-适配器（Adapter-Wrapper）"><a href="#2-3-1-适配器（Adapter-Wrapper）" class="headerlink" title="2.3.1 适配器（Adapter/Wrapper）"></a>2.3.1 适配器（Adapter/Wrapper）</h3><p>把一个抽象类/接口转换成另一个用户需要的抽象类/接口，使得不兼容的接口可以一起正常工作。</p>
<p>如下所示，<code>User</code>类通过<code>DogToCatAdapter</code>适配器将<code>Dog</code>接口转换成用户需要的<code>Cat</code>接口，经过转换，用户在调用<code>Cat</code>接口的<code>meow</code>方法时，实际间接调用的是<code>Dog</code>接口<code>bark</code>方法。</p>
<img src="适配器.png" alt="适配器" style="zoom:70%;" />

 <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title class_">Dog</span> &#123;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">bark</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">Cat</span> &#123;</span><br><span class="line">    <span class="keyword">void</span> meow ;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">DogToCatAdapter</span> <span class="keyword">implements</span> <span class="title class_">Cat</span> &#123;</span><br><span class="line">    Dog dog;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">DogToCatAdapter</span><span class="params">(Dog dog)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.dog = dog;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">meow</span><span class="params">()</span> &#123;</span><br><span class="line">        dog.bark();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">User</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Cat</span> <span class="variable">cat</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DogToCatAdapter</span>(<span class="keyword">new</span> <span class="title class_">Dog</span>());</span><br><span class="line">        cat.meow();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="2-3-2-桥接（Bridge）"><a href="#2-3-2-桥接（Bridge）" class="headerlink" title="2.3.2 桥接（Bridge）"></a>2.3.2 桥接（Bridge）</h3><p>将抽象部分与它的实现部分分离，使它们都可以独立地变化。</p>
<p>如下所示，<code>Abstraction</code>和<code>Implementor</code>互相分离，都可以独立的派生出子类，任何<code>Abstraction</code>的子类都可以和任何<code>Implementor</code>的实现类互相组合得到用户想要的类。</p>
<img src="桥接.png" alt="桥接" style="zoom:70%;" />

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Implementor</span> &#123;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">getImplementor</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ConcreteImplementor</span> <span class="keyword">implements</span> <span class="title class_">Implementor</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">getImplementor</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span>(<span class="string">&quot;ConcreteImplementor&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">Abstraction</span> &#123;</span><br><span class="line">    <span class="keyword">protected</span> Implementor implementor;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Abstraction</span><span class="params">(Implementor implementor)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.implementor = implementor;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title function_">getAbstraction</span><span class="params">()</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title function_">fun</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ConcreteAbstraction</span> <span class="keyword">extends</span> <span class="title class_">Abstraction</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">ConcreteAbstraction</span><span class="params">(Implementor implementor)</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>(implementor);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">getAbstraction</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span>(<span class="string">&quot;ConcreteAbstraction&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">fun</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;fun()&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;Abstraction:&quot;</span> + getAbstraction());</span><br><span class="line">        System.out.println(<span class="string">&quot;Implementor:&quot;</span> + implementor.getImplementor());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">User</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;        </span><br><span class="line">        <span class="type">Abstraction</span> <span class="variable">abstraction</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ConcreteAbstraction</span>(</span><br><span class="line">            <span class="keyword">new</span> <span class="title class_">ConcreteImplementor</span>());</span><br><span class="line">        abstraction.fun();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>总结：</p>
<ul>
<li>桥接模式通过将抽象部分和实现部分分离，使得设计可以按两个维度独立扩展；</li>
<li>直接继承可能会带来子类爆炸，不要过度使用继承，而是优先拆分某些部件，使用组合的方式来扩展功能。</li>
</ul>
<h3 id="2-3-3-组合（Composite）"><a href="#2-3-3-组合（Composite）" class="headerlink" title="2.3.3 组合（Composite）"></a>2.3.3 组合（Composite）</h3><p>将对象组合成树形结构以表示“部分-整体”的层次结构，使得用户对单个对象和组合对象的使用具有一致性。</p>
<p>如下所示，首先统一单个节点以及“组合”节点的抽象类（<code>Node</code>类），<code>Composite</code>类可以看作是树的中间节点，它可以有子节点（子节点可以是中间节点或者叶子节点），而<code>Leaf</code>类可以看作是树的叶子节点，它没有子节点，用户对<code>Composite</code>对象和<code>Leaf</code>对象的操作是具备一致性的。</p>
<img src="组合.png" alt="组合" style="zoom:70%;" />

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">Node</span> &#123;</span><br><span class="line">    <span class="keyword">protected</span> String name;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Node</span><span class="params">(String name)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title function_">print</span><span class="params">(<span class="type">int</span> level)</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">abstract</span> Node <span class="title function_">add</span><span class="params">(Node node)</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">abstract</span> Node <span class="title function_">remove</span><span class="params">(Node node)</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Composite</span> <span class="keyword">extends</span> <span class="title class_">Node</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> List&lt;Node&gt; children = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Composite</span><span class="params">(String name)</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>(name);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">print</span><span class="params">(<span class="type">int</span> level)</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; level; i++) &#123;</span><br><span class="line">            System.out.print(<span class="string">&quot;——&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">&quot;Composite:&quot;</span> + name);</span><br><span class="line">        <span class="keyword">for</span> (Node node : children) &#123;</span><br><span class="line">            node.print(level + <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">add</span><span class="params">(Node node)</span> &#123;</span><br><span class="line">        children.add(node);</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Node <span class="title function_">remove</span><span class="params">(Node node)</span> &#123;</span><br><span class="line">        children.remove(node);</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Leaf</span> <span class="keyword">extends</span> <span class="title class_">Node</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Leaf</span><span class="params">(String name)</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>(name);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">print</span><span class="params">(<span class="type">int</span> level)</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; level; i++) &#123;</span><br><span class="line">            System.out.print(<span class="string">&quot;——&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">&quot;left:&quot;</span> + name);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Node <span class="title function_">add</span><span class="params">(Node node)</span> &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">UnsupportedOperationException</span>(); </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Node <span class="title function_">remove</span><span class="params">(Node node)</span> &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">UnsupportedOperationException</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">User</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Node</span> <span class="variable">root</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Composite</span>(<span class="string">&quot;root&quot;</span>);</span><br><span class="line">        root.add(<span class="keyword">new</span> <span class="title class_">Leaf</span>(<span class="string">&quot;a&quot;</span>));</span><br><span class="line">        root.add(<span class="keyword">new</span> <span class="title class_">Composite</span>(<span class="string">&quot;A&quot;</span>)</span><br><span class="line">                 .add(<span class="keyword">new</span> <span class="title class_">Leaf</span>(<span class="string">&quot;b&quot;</span>)).add(<span class="keyword">new</span> <span class="title class_">Leaf</span>(<span class="string">&quot;c&quot;</span>)));</span><br><span class="line">        root.add(<span class="keyword">new</span> <span class="title class_">Composite</span>(<span class="string">&quot;B&quot;</span>)</span><br><span class="line">                 .add(<span class="keyword">new</span> <span class="title class_">Leaf</span>(<span class="string">&quot;d&quot;</span>)).add(<span class="keyword">new</span> <span class="title class_">Leaf</span>(<span class="string">&quot;e&quot;</span>)));</span><br><span class="line">        root.add(<span class="keyword">new</span> <span class="title class_">Leaf</span>(<span class="string">&quot;f&quot;</span>));</span><br><span class="line">        root.print(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>运行结果：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Composite:root</span><br><span class="line">——left:a</span><br><span class="line">——Composite:A</span><br><span class="line">————left:b</span><br><span class="line">————left:c</span><br><span class="line">——Composite:B</span><br><span class="line">————left:d</span><br><span class="line">————left:e</span><br><span class="line">——left:f</span><br></pre></td></tr></table></figure>

<h3 id="2-3-4-装饰器（Decorator）"><a href="#2-3-4-装饰器（Decorator）" class="headerlink" title="2.3.4 装饰器（Decorator）"></a>2.3.4 装饰器（Decorator）</h3><p>在运行期动态地给对象实例增加各种新的功能。</p>
<p>如下所示，抽象类<code>ProductDecorator</code>内复合了<code>Product</code>接口，通过扩展<code>ProductDecorator</code>可以得到各种具备不同功能的产品，用户可以叠加各种功能得到自己需要的产品。</p>
<img src="装饰器.png" alt="装饰器" style="zoom:70%;" />

 <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Product</span> &#123;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">fun</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ProductImplA</span> implemets Product &#123;...&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">ProductDecorator</span> implemets Product &#123;</span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">final</span> Product product;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">protected</span> <span class="title function_">ProductDecorator</span><span class="params">(Product product)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.product = product ;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">fun</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.product.fun();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AppearanceDecorator</span> <span class="keyword">extends</span> <span class="title class_">ProductDecorator</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">AppearanceDecorator</span><span class="params">(Product product)</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>(product) ;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">fun</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// 执行一些关于产品外观功能的操作</span></span><br><span class="line">        product.fun();</span><br><span class="line">        <span class="comment">// 执行一些关于产品外观功能的操作</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">EnduranceDecorator</span> <span class="keyword">extends</span> <span class="title class_">ProductDecorator</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">EnduranceDecorator</span><span class="params">(Product product)</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>(product);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">fun</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// 执行一些关于产品续航功能的操作</span></span><br><span class="line">        product.fun();</span><br><span class="line">        <span class="comment">// 执行一些关于产品续航功能的操作</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">User</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Product</span> <span class="variable">product</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ProductImplA</span>();</span><br><span class="line">        <span class="type">Product</span> <span class="variable">product1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AppearanceDecorator</span>(product);</span><br><span class="line">        <span class="type">Product</span> <span class="variable">product2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">EnduranceDecorator</span>(product);</span><br><span class="line">        <span class="type">Product</span> <span class="variable">product3</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">EnduranceDecorator</span>(</span><br><span class="line">            <span class="keyword">new</span> <span class="title class_">AppearanceDecorator</span>(product));</span><br><span class="line">            <span class="comment">// ...</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>总结：</p>
<ul>
<li><p>可以代替相同功能的子类，从而降低设计各种子类的工作量；</p>
</li>
<li><p>把核心功能和附加功能分开，两部分都可以独立地扩展，最后由调用方在运行期间动态地自由组合得到自己需要的功能；</p>
</li>
<li><p>Proxy让调用者认为获取到的是核心类接口，但实际上是代理类，而Decorator让调用者自己创建核心类（<code>ProductImpl</code>），然后在核心类上一层一层地叠加各种功能。</p>
</li>
</ul>
<h3 id="2-3-5-外观（Facade）"><a href="#2-3-5-外观（Facade）" class="headerlink" title="2.3.5 外观（Facade）"></a>2.3.5 外观（Facade）</h3><p>定义了一个高层接口，这个接口为子系统中的一组接口提供一个一致的界面，使得子系统更加容易使用。</p>
<p>如下所示，完成一道烤鸡需要清洗、调料以及烹饪这三个步骤，这些步骤都看做是以一个子系统中的一组接口，此时，可以通过<code>Facade</code>来一次性完成所有步骤，用户只需要关联<code>Facade</code>，而不关心清洗、调料以及烹饪这些步骤。</p>
<img src="外观.png" alt="外观" style="zoom:70%;" />

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Food</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Food</span><span class="params">(String name)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getName</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CleanSystem</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">clean</span><span class="params">(Food food)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;clean &quot;</span> + food.getName());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SouseSystem</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">souse</span><span class="params">(Food food)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;souse &quot;</span> + food.getName());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CookSystem</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">cook</span><span class="params">(Food food)</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;cook &quot;</span> + food.getName());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Facade</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> Food food;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Facade</span><span class="params">(Food food)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.food = food;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">make</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">CleanSystem</span>().clean(food);</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">SouseSystem</span>().souse(food);</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">CookSystem</span>().cook(food);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">User</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Facade</span> <span class="variable">facade</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Facade</span>(<span class="keyword">new</span> <span class="title class_">Food</span>(<span class="string">&quot;RoastChicken&quot;</span>));</span><br><span class="line">        facade.make();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>总结：</p>
<ul>
<li>通过给客户端提供一个统一入口，可以对外屏蔽内部子系统的调用细节，客户端所需要交互的对象应当尽可能少；</li>
<li>对于复杂的Web程序，经常会使用一个统一的网关入口来自动转发到不同的Web服务，这种提供统一入口的网关就是Gateway，它本质上也是一个Facade，还可以附加一些用户认证、限流限速的额外服务。</li>
</ul>
<h3 id="2-3-6-享元（Flyweight）"><a href="#2-3-6-享元（Flyweight）" class="headerlink" title="2.3.6 享元（Flyweight）"></a>2.3.6 享元（Flyweight）</h3><p>利用对象池来共享大量细粒度的对象，避免重复创建对象，从而减少内存占用，这也意味着<strong>对象池中的共享对象不可以作为锁对象</strong>。</p>
<p>如下所示，<code>product1</code>和<code>product2</code>是同一个对象，返回结果为<code>true</code>。</p>
 <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Product</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Map&lt;String, Product&gt; cache = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> String id;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Product <span class="title function_">factoryMethod</span><span class="params">(String id)</span> &#123;</span><br><span class="line">        <span class="type">Product</span> <span class="variable">product</span> <span class="operator">=</span> cache.get(id);</span><br><span class="line">        <span class="keyword">if</span> (product == <span class="literal">null</span>) &#123;</span><br><span class="line">            product = <span class="keyword">new</span> <span class="title class_">Product</span>(id);</span><br><span class="line">            cache.put(id, product);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> product;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Product</span><span class="params">(String id)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.id = id;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">User</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Product</span> <span class="variable">product1</span> <span class="operator">=</span> Product.factoryMethod();</span><br><span class="line">        <span class="type">Product</span> <span class="variable">product2</span> <span class="operator">=</span> Product.factoryMethod();</span><br><span class="line">        System.out.println(product1 == product2); <span class="comment">// true</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>总结：</p>
<ul>
<li><p>对于不可变类（实例不能被修改的类）来说，反复创建其相同的实例没有必要，直接向调用方返回一个共享的实例即可；</p>
</li>
<li><p>于不可变的 Java 基本对象的包装类、String、各种池化技术以及工厂方法的内部优化都用到了享元模式，在工厂内部，很可能返回缓存的实例而不是<code>new</code>一个新的实例；</p>
</li>
<li><p>在实际应用中，享元模式主要应用于缓存，即客户端重复请求某些对象时，不必每次查询数据库或者读取文件，而是直接返回缓存中的对象。</p>
</li>
</ul>
<h3 id="2-3-7-代理（Proxy）"><a href="#2-3-7-代理（Proxy）" class="headerlink" title="2.3.7 代理（Proxy）"></a>2.3.7 代理（Proxy）</h3><p>对调用方提供一个代理，该代理能够控制对一个对象的访问。</p>
<p>如下所示， <code>ProductProxy</code>通过实现<code>Product</code>接口，从而在调用<code>Product</code>的<code>fun</code>方法的前后增加一些额外的操作。</p>
<img src="代理.png" alt="装饰" style="zoom:70%;" />

 <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Product</span> &#123;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">fun</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ProductImpl</span> implemets Product &#123;...&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ProductProxy</span> implemets Product &#123;</span><br><span class="line">    <span class="keyword">private</span> Product product;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">ProductProxy</span><span class="params">(Product product )</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.product = product ;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">fun</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// 执行一些额外操作</span></span><br><span class="line">        <span class="built_in">this</span>.product.fun();</span><br><span class="line">        <span class="comment">// 执行一些额外操作</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">User</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Product</span> <span class="variable">product</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ProductProxy</span>(<span class="keyword">new</span> <span class="title class_">ProductImpl</span>());</span><br><span class="line">        product.fun();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>根据代理所增加的额外操作的不同，代理可分为：</p>
<ul>
<li><p>远程代理（Remote Proxy）：本地调用者持有的接口是一个代理，该代理将对接口的方法转换成远程调用并返回结果，该代理<strong>控制了对远程对象的访问</strong>，此时代理附加的额外操作是对请求对象和返回对象进行编码并发送至远程对象；</p>
</li>
<li><p>虚拟代理（Virtual Proxy）：调用者先持有一个代理对象，而真正的对象并没有创建，直到客户端真的需要调用该对象时，才创建真正的对象，该代理<strong>控制了对创建开销很大的对象的访问</strong>，此时代理附加的额外操作是创建真正要访问的对象；</p>
</li>
<li><p>保护代理（Protection Proxy）：该代理<strong>根据调用者的权限控制了对对象的访问</strong>，此时代理附加的额外操作是检查调用者是否具有访问的权限；</p>
</li>
<li><p>智能代理（Smart Reference）：该代理取代了简单的指针，<strong>在存在多个外部调用者时控制了对对象的访问</strong>，此时代理附加的额外操作是对调用者个数进行计数（即记录对象的引用次数），在调用者访问对象时检查是否已经锁定了它，在调用者不进行调用时释放对象。</p>
</li>
</ul>
<h1 id="3、参考资料"><a href="#3、参考资料" class="headerlink" title="3、参考资料"></a>3、参考资料</h1><ul>
<li><p><a href="http://www.cyc2018.xyz/%E5%85%B6%E5%AE%83/%E7%BC%96%E7%A0%81%E5%AE%9E%E8%B7%B5/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E6%80%9D%E6%83%B3.html">http://www.cyc2018.xyz/其他/编码实践/面向对象思想.html</a></p>
</li>
<li><p><a href="https://design-patterns.readthedocs.io/zh_CN/latest/read_uml.html">https://design-patterns.readthedocs.io/zh_CN/latest/read_uml.html</a></p>
</li>
<li><p><a href="http://www.cyc2018.xyz/%E5%85%B6%E5%AE%83/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%20-%20%E7%9B%AE%E5%BD%95.html#%E4%B8%80%E3%80%81%E5%89%8D%E8%A8%80">http://www.cyc2018.xyz/其他/设计模式/设计模式.html</a></p>
</li>
<li><p><a href="https://www.liaoxuefeng.com/wiki/1252599548343744/1264742167474528">https://www.liaoxuefeng.com/wiki/1252599548343744/1264742167474528</a></p>
</li>
</ul>
]]></content>
  </entry>
  <entry>
    <title>Git</title>
    <url>/2022/05/07/git/</url>
    <content><![CDATA[<h1 id="版本控制"><a href="#版本控制" class="headerlink" title="版本控制"></a>版本控制</h1><p>将每一次文件变更的时间，作者，内容都记录下来，并更新版本号。通过记录文件内容的变更，从而<strong>追踪文件的变更</strong>。此外，由于软件开发往往是多人协同作业，那么版本间的同步问题以及开发者间的通信问题都需要通过版本控制来解决，也就是说，版本控制的另一功能是<strong>并行开发</strong>。在开发过程中，首先需要设定开发基线，确定各个配置项的开发初始版本，开发人员再基于开发基线的版本，开发出所需的目标版本，并行开发中的许多错误都可以通过版本控制中分支与合并的方法来解决。</p>
<h1 id="集中式和分布式"><a href="#集中式和分布式" class="headerlink" title="集中式和分布式"></a>集中式和分布式</h1><p>集中式版本控制系统（Centralized Version Control Systems），简称 CVCS。项目的历史记录均被保存在单一位置，<strong>有丢失风险</strong>，且<strong>必须联网</strong>才能工作。</p>
<p>分布式版本控制系统（Distributed Version Control System），简称 DVCS。客户端不仅提取最新版本的文件快照，还把代码仓库完整的克隆备份下来，<strong>不存在丢失风险</strong>，<strong>不需要联网</strong>就能工作。DVCS 通过一个中心服务器来方便的交换修改，Github就是一个中心服务器。没有中心服务器时 DVCS 也能工作，但只是不方便交换修改而已。</p>
<h1 id="SVN-和-Git"><a href="#SVN-和-Git" class="headerlink" title="SVN 和 Git"></a>SVN 和 Git</h1><p>SVN 属于 CVCS，开发者需要从中央仓库中获取代码，并将更改提交到中央仓库，SVN 使用版本序号来标识每个提交，使用一种名为增量式差异的方式存储版本信息，每个版本只存储于上一个版本的差异，SVN 受到服务器性能和带宽的限制，对于非常大的仓库可能会出现性能问题。</p>
<p>Git 属于 DVCS，Git 使用 SHA-1 散列值作为每个提交的唯一标识，Git 与其他版本控制系统的主要区别在于对待数据的方式。大多数版本控制系统都是以文件变更列表的方式存储信息，这类系统将它们保存的信息看作一组基本文件和每个文件随时间逐步累积的差异，而 Git 采用直接记录快照的方式，而非差异比较。每次提交更新或者保存项目状态时，Git 对当时的全部文件制作一个快照并保存这个快照的索引。为了高效，如果文件没有修改，Git 不再重新存储该文件，而是保留一个链接指向之前存储的文件。</p>
<p>Git 可以处理非常大的代码仓库，因为每个开发者都有一份完整的仓库，不需要集中式仓库的所有数据，Git 仓库和 Github 中心服务器之间的传输是通过 SSH 加密的。</p>
<h1 id="工作流"><a href="#工作流" class="headerlink" title="工作流"></a>工作流</h1><p>新建或克隆一个仓库后，当前目录为工作区（Working area），开发人员在工作区修改文件内容。工作区下有一个隐藏目录（<code>.git</code> directory）为 Git 仓库，Git 仓库中存储有所有分支信息，使用一个<code>HEAD</code>指针指向当前分支。暂存区（Staging area）用于暂存修改后的文件快照，暂存区和 Git 仓库组成 Git 版本库。</p>
<img src="工作流图.jpg" alt="工作流图" style="zoom:100%;" />

<h1 id="分支"><a href="#分支" class="headerlink" title="分支"></a>分支</h1><ul>
<li><p>每个提交通过指针连接成一条时间线。</p>
</li>
<li><p>创建仓库时，<code>master</code>指针指向主分支，<code>HEAD</code>指针始终指向当前分支，当前分支可能是主分支也可能是新建的分支。</p>
</li>
<li><p>新建分支就是新建一个指针指向时间线的最后一个节点。</p>
</li>
<li><p>切换分支就是让<code>HEAD</code>指针指向新分支，表示新分支成为当前分支。</p>
</li>
<li><p>每次提交只会让当前分支指针向后移动，而其他分支指针不会移动。</p>
</li>
<li><p>当新建分支开发完毕后，就合并到主分支上，合并分支只需要改变指针即可。</p>
</li>
</ul>
<img src="分支.jpg" alt="分支" style="zoom:100%;" />

<h1 id="revert-和-reset"><a href="#revert-和-reset" class="headerlink" title="revert 和 reset"></a>revert 和 reset</h1><p>revert 和 reset 都能用来回退 git 的 commit，区别在于</p>
<ul>
<li><p>revert 仅仅是指撤销指定的那一次 commit，对于这个 commit 之后的其他 commit 没有影响，执行 revert 会产生记录，并且可以反复使用</p>
</li>
<li><p>reset 的回退比较暴力，是彻底回退到指定的版本，执行 reset 的动作不会产生记录，使用 –hard 的话还会把这个 commit 之后的所有其他 commit 也都一并清除，reset 有三种模式</p>
<ul>
<li><p>–soft 模式会重置指针，但不会修改工作目录或索引，这意味之前的更改仍然存在于工作区中，可以重新提交</p>
</li>
<li><p>–mixed 模式是默认模式，会重置指针并更新索引以匹配指定的 commit，会取消索引中的所有更改，但工作目录中的更改将保留</p>
</li>
<li><p>–hard 模式会重置指针、索引以及工作区，这意味着所有更改都将永久删除，并且没有办法撤销或恢复这些更改</p>
</li>
</ul>
</li>
</ul>
<h1 id="merge-和-rebase"><a href="#merge-和-rebase" class="headerlink" title="merge 和 rebase"></a>merge 和 rebase</h1><p>merge 和 rebase 是两种不同的代码合并策略，用于将一个分支的更改合并到另一个分支</p>
<ul>
<li><p>merge 操作会在分支中创建一个新的 merge commit，这个 commit 将两个分支的更改合并到一个新的 commit 中，不会破坏原分支的历史 commit 记录，一般会在公共分支上进行 merge</p>
</li>
<li><p>rebase 操作不会产生新的 commit 节点，而是为原始分支的每个 commit 创建全新的 commit 来重写历史 commit 记录，形成一个简洁的线性提交记录，一般只会在个人分支上进行 rebase</p>
</li>
</ul>
<h1 id="命令速查表"><a href="#命令速查表" class="headerlink" title="命令速查表"></a>命令速查表</h1><p><a href="http://www.cheat-sheets.org/saved-copy/git-cheat-sheet.pdf">http://www.cheat-sheets.org/saved-copy/git-cheat-sheet.pdf</a></p>
<h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><ul>
<li><p><a href="https://www.liaoxuefeng.com/wiki/896043488029600">https://www.liaoxuefeng.com/wiki/896043488029600</a></p>
</li>
<li><p><a href="http://www.cyc2018.xyz/%E5%85%B6%E5%AE%83/%E7%BC%96%E7%A0%81%E5%AE%9E%E8%B7%B5/Git.html">http://www.cyc2018.xyz/其他/编码实践/Git.html</a></p>
</li>
<li><p><a href="https://snailclimb.gitee.io/javaguide/#/./docs/tools/git/git-intro">https://snailclimb.gitee.io/javaguide/#/./docs/tools/git/git-intro</a></p>
</li>
</ul>
]]></content>
  </entry>
  <entry>
    <title>Gradle</title>
    <url>/2023/07/29/gradle/</url>
    <content><![CDATA[<p>Gradle 和 Maven 都是可以用于 Java 项目管理和构建的工具，Gradle 侧重于灵活快速的自定义构建，Maven 侧重于简单明了的依赖管理，对于构建流程较复杂的大型的多模块项目，可以用 Gradle 来替代 Maven。</p>
<h1 id="依赖管理"><a href="#依赖管理" class="headerlink" title="依赖管理"></a>依赖管理</h1><p>Gradle 使用<code>build.gradle</code>（基于Groovy语言）来作为项目描述文件，与<code>pom.xml</code>的日益臃肿相比，<code>build.gradle</code>中进行依赖管理和插件管理所需的配置都变得更加简短。比如<code>build.gradle</code>的依赖管理只需将<code>groupId</code>，<code>artifactId</code>和<code>version</code>的 value 都用<code>:</code>连接起来，并根据不同的<code>scope</code>来调用不同函数即可</p>
<ul>
<li>compile scope 对应 implementation 或者 api</li>
<li>runtime scope 对应 runtimeOnly</li>
<li>test scope 对应 testImplementation 或者 testRuntimeOnly</li>
<li>provided scope 对应 compileOnly</li>
</ul>
<h1 id="构建流程"><a href="#构建流程" class="headerlink" title="构建流程"></a>构建流程</h1><p>Maven 构建流程中所需执行的每个 phase，都是通过某个插件（plugin）来执行的，Maven只是负责找到 phase 对应的内置标准化 plugin 或者<code>pom.xml</code>文件中声明并配置自定义的 plugin，Maven 把构建流程中几乎所有的工作都放在 plugin 中完成，且每次构建都是全量构建。而 Gradle 则是在<code>build.gradle</code>中定义 task 来执行构建流程，所有的 task 构成一个有向无环图 (Directed Acyclic Graphs , DAGs)，支持更加灵活强大的自定义构建方式，是增量构建。</p>
<h1 id="Wrapper-模式"><a href="#Wrapper-模式" class="headerlink" title="Wrapper 模式"></a>Wrapper 模式</h1><p>由于 Gradle 的版本迭代很快，为了能更方便管理 Gradle 自身的版本，并且让不同项目之间的 Gradle 版本隔离不会互相影响，Gradle 项目最好使用 Wrapper 模式，此时项目根目录有一个<code>gradlew</code>脚本，用来启动 Gradle Wrapper，根据<code>gradle-wrapper.properties</code>的定义，Wrapper 会下载对应的 Gradle 版本并执行构建，免去了开发人员自己去下载和配置 Gradle 环境变量的负担。使用 Wrapper之后，本地也不需要事先安装和配置 Gradle 命令，直接用项目文件中的 gradlew 命令即可。</p>
<h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><ul>
<li><a href="https://gradle.org/maven-vs-gradle/">https://gradle.org/maven-vs-gradle/</a></li>
<li><a href="http://www.flydean.com/gradle-kick-off/">http://www.flydean.com/gradle-kick-off/</a></li>
<li><a href="http://www.flydean.com/gradle-vs-maven/">http://www.flydean.com/gradle-vs-maven/</a></li>
<li><a href="http://www.flydean.com/gradle-build-script/">http://www.flydean.com/gradle-build-script/</a></li>
<li><a href="https://zhuanlan.zhihu.com/p/372585663">https://zhuanlan.zhihu.com/p/372585663</a></li>
</ul>
]]></content>
  </entry>
  <entry>
    <title>Clean Code</title>
    <url>/2022/05/06/clean-code/</url>
    <content><![CDATA[<h1 id="1、整洁代码"><a href="#1、整洁代码" class="headerlink" title="1、整洁代码"></a>1、整洁代码</h1><p>保持高效的唯一做法就是始终保持代码整洁。</p>
<ul>
<li><p>代码逻辑应该直截了当；</p>
</li>
<li><p>尽量减少依赖关系；</p>
</li>
<li><p>不要忽视警告，遵守安全规则；</p>
</li>
<li><p>完善错误处理代码；</p>
</li>
<li><p>性能调制最优；</p>
</li>
<li><p>整洁的代码只做好一件事；</p>
</li>
<li><p>干净利落的抽象；</p>
</li>
<li><p>所有决定都足够准确，不引人猜忌，消除模糊处理；</p>
</li>
<li><p>单元测试和验收测试；</p>
</li>
<li><p>明确、清晰、尽可能少的实体（类、API、方法等）；</p>
</li>
<li><p>没有重复代码（重复代表遗漏了抽象）；</p>
</li>
<li><p>代码应通过其字面表达含义，无需注释亦能容易理解；</p>
</li>
<li><p>代码便于作者之外的人阅读和增补；</p>
</li>
<li><p>几乎没有改进的余地。</p>
</li>
</ul>
<h1 id="2、有意义的命名"><a href="#2、有意义的命名" class="headerlink" title="2、有意义的命名"></a>2、有意义的命名</h1><p>需要同时关注代码的简洁度和模糊度，可通过有意义的命名来降低模糊度。</p>
<ul>
<li><p>名副其实；</p>
</li>
<li><p>无误导倾向；</p>
</li>
<li><p>有意义的区分；</p>
</li>
<li><p>可朗读；</p>
</li>
<li><p>可搜索；</p>
</li>
<li><p>区分名词和动词；</p>
</li>
<li><p>不要起沟通实现的名称，而是起反映类或者函数抽象层级的名称，避免混杂抽象层级；</p>
</li>
<li><p>单字母名称仅用于短方法中的本地变量，名称长度应与其作用域大小相对应，但不要在名称中包含类型或者作用范围信息；</p>
</li>
<li><p>添加有意义的语境（比如创建一个类，类中包含有多个成员变量，则该类名起到了一个变量名前缀的作用，是一个有意义的语境）。</p>
</li>
</ul>
<h1 id="3、函数"><a href="#3、函数" class="headerlink" title="3、函数"></a>3、函数</h1><p>函数应该做且只做好这一件事，即函数中的语句均在同一抽象层级上。</p>
<ul>
<li><p>短小（20行封顶）；</p>
</li>
<li><p><code>if</code>、<code>else</code>、<code>while</code>语句中的代码块应该只占一行；</p>
</li>
<li><p>函数的缩进层级不应该多于两层；</p>
</li>
<li><p>函数输入参数数量越少越好（2个封顶）；</p>
</li>
<li><p>多个参数的传入顺序可以隐含在函数名中；</p>
</li>
<li><p>函数输出参数比较违反直觉，应避免使用输出参数，如果非要修改变量，就修改函数所在的对象；</p>
</li>
<li><p>函数体中不应进行函数名所描述之外的操作，即函数应无副作用；</p>
</li>
<li><p>标识参数指布尔值、枚举等任何用于选择函数行为的参数，使用标识参数宣告了函数做了不止一件事，不应该使用标识参数；</p>
</li>
<li><p>函数中的语句应处于同一抽象层级上，该层级是函数名称所示操作的下一层；</p>
</li>
<li><p>通过多态将<code>switch</code>或者<code>if</code>链语句埋藏在较低的抽象层级（比如抽象工厂）中，而非具体的上层功能函数中；</p>
</li>
<li><p>单个<code>switch</code>原则指对于给定的选择类型，不应有多于一个的<code>switch</code>语句，通过这唯一的<code>switch</code>语句来创建多态对象，取代系统中其他类似的<code>switch</code>语句；</p>
</li>
<li><p>希望具备多态的函数不应该声明为静态函数，的确需要声明为静态的函数，应确保没机会另其有多态行为；</p>
</li>
<li><p>通过模板方法模式或者策略模式修正具体代码不同但算法类似的代码；</p>
</li>
<li><p>用异常处理代替返回错误码时的处理，使得错误处理代码从主路径中分离出来；</p>
</li>
<li><p>结构化编程指无<code>break</code>，<code>continue</code>，<code>goto</code>，只有一个<code>return</code>，而保持函数短小则比结构化编程更有利。</p>
</li>
</ul>
<h1 id="4、注释"><a href="#4、注释" class="headerlink" title="4、注释"></a>4、注释</h1><p>尽量用代码来代替注释进行表达，注释只应该描述有关代码和设计的技术性信息，而不是传达本该更好地在系统中保存的信息。</p>
<p>过时及冗余的注释应及时删除，被注释的代码也应当删除，永不调用的代码（类、函数、变量）也应该被删除。</p>
<p>好注释应：</p>
<ul>
<li><p>提供某个决定背后的意图；</p>
</li>
<li><p>小心确认注释的正确性；</p>
</li>
<li><p>面向读者而非自己；</p>
</li>
<li><p>文本简洁正确无冗余描述；</p>
</li>
<li><p>解释未能自行解释的代码。</p>
</li>
</ul>
<h1 id="5、格式"><a href="#5、格式" class="headerlink" title="5、格式"></a>5、格式</h1><p>即使代码不复存在，代码的风格和律条也会存活下来，代码风格应始终保持前后一致。</p>
<ul>
<li><p>向报纸学习，有主题，有大纲，细节往下依次展开，有许多篇文章而不是一篇大长文；</p>
</li>
<li><p>垂直方向上的空白行隔开了代码概念上的紧密程度；</p>
</li>
<li><p>尽量不要将关系密切的概念放到不同的文件中，这也是避免使用<code>protected</code>变量的理由之一；</p>
</li>
<li><p>解释性的中间变量多一点更好；</p>
</li>
<li><p>代码中出现原始形态数字通常来说是坏现象，应该用命名良好的常量来隐藏它；</p>
</li>
<li><p>局部变量声明和函数定义应靠近被使用的位置而非顶部，实体变量声明应该在类的顶部；</p>
</li>
<li><p>花时间研究代码应该如何排放，不互相依赖的东西不该耦合，比如考虑下成员类是否要移出其外围类，静态函数是否真的应作为该类的静态函数；</p>
</li>
<li><p>当存在时序耦合时，代码应体现出这一点，而不是掩蔽；</p>
</li>
<li><p>可配置的数据应放置于较高层级上；</p>
</li>
<li><p>通过通配符避免过长的导入清单，同时也避免了硬依赖，降低耦合；</p>
</li>
<li><p>不要继承常量，这样会使得常量隐藏在继承结构的顶端，而是应该使用静态导入。</p>
</li>
</ul>
<h1 id="6、对象和数据结构"><a href="#6、对象和数据结构" class="headerlink" title="6、对象和数据结构"></a>6、对象和数据结构</h1><ul>
<li><p>严肃思考对象所包含的数据，不应随意乱加取值器和赋值器；</p>
</li>
<li><p>过程式代码便于在不改动既有数据结构的前提下添加新函数，难以添加新数据结构，面向对象代码便于在不改动既有函数的前提下添加新类，难以添加新函数，需根据情况选择编写两种不同的风格的代码；</p>
</li>
<li><p>方法不应调用由任何函数所返回的对象的方法，因为会暴露所返回对象的内部结构，即违反德墨忒尔律（模块不应了解它所操作对象的内部）；</p>
</li>
<li><p>只有公共变量，没有函数的类（或者所有私有变量均有取值器，且无取值器之外的函数的类）被称为数据传送对象（Data Transfer Objects, DTO），是最精简的数据结构；</p>
</li>
<li><p>避免数据结构和对象的混杂使用。</p>
</li>
</ul>
<h1 id="7、错误处理"><a href="#7、错误处理" class="headerlink" title="7、错误处理"></a>7、错误处理</h1><p>错误处理很重要，但凌乱的错误处理可能会搞乱代码逻辑。</p>
<p>在业务逻辑和错误处理代码之间建立良好的区隔：</p>
<ul>
<li><p>使用异常处理而非返回错误码；</p>
</li>
<li><p>先写<code>try-catch</code>结构，再写业务代码；</p>
</li>
<li><p>使用未检异常（使用已检异常时，抛出异常处和<code>catch</code>语句之间的每个方法签名都需要添加<code>throw</code>子句，这违反了开放/闭合原则）；</p>
</li>
<li><p>思考异常如何被捕获，当各种异常被捕获后的处理一致时，对调用API进行打包，确保返回通用异常类型，从而简化代码；</p>
</li>
<li><p>不返回也不传递<code>null</code>值。</p>
</li>
</ul>
<h1 id="8、边界"><a href="#8、边界" class="headerlink" title="8、边界"></a>8、边界</h1><p>在使用带三方程序包时，需要保持软件边界整洁，将外来代码干净利落地整合进自身代码中。</p>
<ul>
<li><p>避免从公共API中返回边界接口，或者将边界接口作为参数传递给公共API；</p>
</li>
<li><p>在使用第三方程序包之前先通过学习性测试来了解该程序包；</p>
</li>
<li><p>通过定义并使用接口（即定义未知的边界）来使用尚不存在的代码；</p>
</li>
<li><p>追索每种边界条件，边界上的代码需要清晰的分割和定义了期望的测试，应该避免自己的代码去过多了解第三方代码中的特定信息；</p>
</li>
<li><p>处理边界条件的代码应集中到一处，不要散落于代码中。</p>
</li>
</ul>
<h1 id="9、单元测试"><a href="#9、单元测试" class="headerlink" title="9、单元测试"></a>9、单元测试</h1><ul>
<li><p>在编写出无法通过的测试代码之前，不能编写生产代码；</p>
</li>
<li><p>只能编写刚好无法通过的测试代码；</p>
</li>
<li><p>只能编写刚好通过当前失败测试的生产代码；</p>
</li>
<li><p>要像编写生产代码一样编写整洁的测试代码，见前面全部内容；</p>
</li>
<li><p>有些事永远不会在生成环境中做，但在测试环境中做却完全没有问题（双重标准）；</p>
</li>
<li><p>缺陷趋向于扎堆，当在某个函数中发现一个缺陷时，应当全面测试该函数，可能会发现更多的缺陷</p>
</li>
<li><p>单个测试当中的断言个数应当最小化（但也不严苛的追求只能有一个断言），每个测试函数都只测试一个概念；</p>
</li>
<li><p>慢速的测试是不会被运行的测试，测试应当能够快速运行，各个测试之间应当相互独立，可以在任何环境重复通过，应当有布尔值输出，实现自足验证，始终要及时编写测试。</p>
</li>
</ul>
<h1 id="10、类"><a href="#10、类" class="headerlink" title="10、类"></a>10、类</h1><ul>
<li><p>类成员出现顺序：公共静态常量，私有静态变量，私有实体变量，公共函数，由公共函数调用的私有工具函数紧随其后；</p>
</li>
<li><p>类成员通常设为<code>private</code>，测试代码需要调用的函数和变量可设置为<code>protected</code>；</p>
</li>
<li><p>单一权责原则（SRP）认为类或模块应该只有一条加以修改的理由，臃肿的类应当切分为只有单一权责的去耦式单元，只有一条修改的理由；</p>
</li>
<li><p>限制类或者模块中暴露的接口数量，类中的方法越少越好，函数知道的变量越少越好，类拥有的实体变量也越少越好；</p>
</li>
<li><p>类的方法应只对其所属的类中的变量和方法感兴趣，不该垂青其他类中的成员；</p>
</li>
<li><p>类中的每个方法都应该操作一个或多个实体变量，如果类中的每个实体变量都被每个方法所使用，则该类具有最大的内聚性；</p>
</li>
<li><p>创建极大化内聚类一般是不可取也不可能的，但希望类的内聚性保持在较高位置；</p>
</li>
<li><p>根据函数应当短小以及类应当高内聚的原则，将大函数拆分为小函数时，也会将类拆分为小类；</p>
</li>
<li><p>依赖倒置原则（DIP）认为类应当依赖抽象而不是具体实现代码细节；</p>
</li>
<li><p>所有较高层级概念放在基类，所有较低层级概念放在派生类，分离要完整，不要混杂；</p>
</li>
<li><p>基类不应依赖派生类，不应派生类的名字，将基类和派生类部署到不同的jar中，不过有个特例是有限状态机，这种情况下基类和派生类紧密耦合。</p>
</li>
</ul>
<h1 id="11、系统"><a href="#11、系统" class="headerlink" title="11、系统"></a>11、系统</h1><ul>
<li><p>软件系统应将起始过程和起始后的运行过程逻辑分离开（比如延迟性初始化/赋值就违背了这一原则）；</p>
</li>
<li><p>通过抽象工厂模式让应用自行控制何时创建对象，将构造细节隔离在应用程序代码之外；</p>
</li>
<li><p>依赖者模块不应对被依赖者有假设（这就是逻辑依赖），而是通过向被依赖者询问的方式来确定信息（这就是物理依赖）；</p>
</li>
<li><p>依赖注入（Dependency Injection, DI）机制可以分离构造与使用，Spring框架提供了最有名的Java DI容器；</p>
</li>
<li><p>恰当切分关注面，面向切面编程（Aspect Oriented Programming），AOP有时会与实现它的技术相混淆，如方法拦截、通过代理做“封包”，但AOP系统的真正价值在于用简洁和模块化的方式指定系统行为；</p>
</li>
<li><p>最佳系统架构由模块化的关注面领域组成，每个关注面均用纯面向对象语言实现，不同领域之间用最不具有侵害性的方面或类方面工具整合起来；</p>
</li>
<li><p>在理想系统中，通过扩展系统而非修改现有代码来添加新特性。</p>
</li>
</ul>
<h1 id="12、迭进"><a href="#12、迭进" class="headerlink" title="12、迭进"></a>12、迭进</h1><ul>
<li><p>保持系统可测试并测试通过，可测试的系统会导向保持类短小、单一、低耦合、高内聚的设计方案；</p>
</li>
<li><p>消除重复，对于重复代码可以做共性抽取，并遵循SRP原则；</p>
</li>
<li><p>保证代码的表达力，使得读者易于理解作者的意图；</p>
</li>
<li><p>在做到以上前提的基础上尽可能减少类和方法的数量，即这条是优先级最低的一条。</p>
</li>
</ul>
<h1 id="13、并发"><a href="#13、并发" class="headerlink" title="13、并发"></a>13、并发</h1><p>并发将做什么（目的）和何时（时机）做分解开，从而改进应用程序的吞吐量和结构，依靠于容器的并发处理能力还不能够保证并发程序不会出错。</p>
<ul>
<li><p>只有在多个线程或处理器之间能分享大量等待时间的时候能够通过并发来改善性能；</p>
</li>
<li><p>并发系统的算法设计与单线程系统极不相同，并发常常需要对设计策略做根本性修改；</p>
</li>
<li><p>即便使用具有并发处理能力的容器进行并发编程时，依旧要了解容器在做什么，了解如何应对各种并发问题；</p>
</li>
<li><p>分离并发相关代码和其他代码（这也符合单一权责原则），再进行调试；</p>
</li>
<li><p>限制数据作用域，谨记数据封装，严格限制对可能被共享的数据的访问；</p>
</li>
<li><p>使用类库提供的线程安全群集，需要掌握<code>JUC</code>；</p>
</li>
<li><p>使用<code>executor</code>框架执行无关任务，尽量使用非锁定解决方案；</p>
</li>
<li><p>警惕同步方法之间的依赖，一个类中不应该有多个同步方法；</p>
</li>
<li><p>在出现并发问题时，尽可能修改服务端代码，若服务端无法修改，则采用适配器模式修改服务端提供的API，尽量不修改客户端代码；</p>
</li>
<li><p>平静关闭系统很难做到，要预留足够多的时间来编写能够正确关闭的并发代码；</p>
</li>
<li><p>不要将并发系统错误归咎于偶发事件；</p>
</li>
<li><p>不要同时检查非线程代码和线程代码，先确保代码在线程之外可工作，能放进POJO中的代码越多越好，再由线程直接调用POJO；</p>
</li>
<li><p>编写可调整的线程代码，在系统运行时允许线程依据吞吐量和系统使用率来自我调整；</p>
</li>
<li><p>运行多于处理器数量的线程（仅用于测试不要用于生产），这会促进频繁的任务交换，进而越有可能找到错过临界区或导致死锁的代码；</p>
</li>
<li><p>增加对<code>wait()</code>、<code>sleep()</code>、<code>yield()</code>以及<code>priority()</code>方法的调用（仅用于测试不要用于生产），改变代码执行顺序，则更容易测试出出错的执行顺序。</p>
</li>
</ul>
<h1 id="14、逐步改进（案例一）"><a href="#14、逐步改进（案例一）" class="headerlink" title="14、逐步改进（案例一）"></a>14、逐步改进（案例一）</h1><p><strong>问题：</strong>一份能够完成简单需求的代码，会因为后续的简单需求补充而变得混乱，比如原本针对布尔型元素的功能在后续需要对整型、字符串型等各种类型的元素依旧保持有效，这种简单的需求改进很可能导致复杂的代码改进，使得原本整洁的代码变得混乱。</p>
<p><strong>应对：</strong>一开始就尽量了解清楚需求的背景、动机、意义，从用户、产品、开发等各种角色来思考需求后续可能会如何迭代，从而设计出尽可能健壮的代码实现方案。</p>
<p><strong>问题：</strong>初始设计不可能做到绝对周全，后续迭代过程中依旧会遇到需要改动代码结构的情况。</p>
<p><strong>应对：</strong>改动的过程中要采用TDD，每次修改都必须确保系统能像以前一样工作，具体改动方式参照上文内容。</p>
<h1 id="15、Junit内幕（案例二）"><a href="#15、Junit内幕（案例二）" class="headerlink" title="15、Junit内幕（案例二）"></a>15、Junit内幕（案例二）</h1><p>应当更清晰地表达代码的意图：</p>
<ul>
<li><p>多个连在一起的条件判断应当用一个函数封装起来；</p>
</li>
<li><p>正向肯定的判断放在<code>if</code>条件中，而不用if not xxx的逻辑；</p>
</li>
<li><p>变量名称中不加难以理解的前缀；</p>
</li>
<li><p>函数中的局部变量名不与成员变量一致，此时就不需要使用<code>this</code>来区分；</p>
</li>
<li><p>函数调用应良好反映出时序关系；</p>
</li>
<li><p>将功能复杂的大函数拆分成功能单一的小函数。</p>
</li>
</ul>
<h1 id="16、重构SerialDate（案例三）"><a href="#16、重构SerialDate（案例三）" class="headerlink" title="16、重构SerialDate（案例三）"></a>16、重构SerialDate（案例三）</h1><ul>
<li><p>不要继承常量类，而是将常量类改为自己的枚举类型；</p>
</li>
<li><p>实现了<code>Serializable</code>接口的类应当显式声明并手动配置序列版本UID变量；</p>
</li>
<li><p>类的成员变量应确保是与该类有关的变量，否则该变量就不应该称为该类的成员变量，函数同理；</p>
</li>
<li><p>不应由抽象类来提供具体实现信息，这种设计会污染抽象类；</p>
</li>
<li><p>基类不应了解派生类的情况，更不应该在基类的行为中创建出派生类实例，如果代码中出现这种情况可以更改为利用抽象工厂来完成创建实例的任务；</p>
</li>
<li><p>不要通过整数形式来传递信息（描述不清且修改时易遗漏），而是通过符号形式传递；</p>
</li>
<li><p>无需编写默认构造器，因为编译器会自动生成；</p>
</li>
<li><p>成员类应当在概念上依赖于外围类并且足够小巧，否则就将成员类移出外围类；</p>
</li>
<li><p>类的静态函数的入参不应有类实例，该静态函数更不应该对类的实例进行操作。</p>
</li>
</ul>
]]></content>
  </entry>
  <entry>
    <title>History Vocabulary -</title>
    <url>/2023/11/05/history-vocabulary/</url>
    <content><![CDATA[<p>special <strong>occasions</strong> 特殊节日</p>
<p>the <strong>Plaza</strong> 广场</p>
<p>Those <strong>memories come storming back to me</strong> 那些记忆突然涌上我的心头</p>
<p> Something <strong>shifted</strong> 事情转变了</p>
<p><strong>aspiring</strong></p>
<p>it’s <strong>driving me nuts</strong></p>
<p>it’s just a trend that will <strong>phase out</strong> soon.</p>
<p><strong>rants</strong></p>
<p><strong>jogging</strong></p>
<p><strong>irony</strong></p>
<p><strong>haunt</strong></p>
<p><strong>Turning everything into ash</strong>. 把一切变为灰烬</p>
<p><strong>sorta</strong></p>
<p><strong>MA</strong> (Master of Arts)</p>
<p><strong>less to most</strong> 或多或少</p>
<p><strong>leave that out</strong> 那个不要提起来</p>
<p><strong>wannabe</strong></p>
<p><strong>sentimental</strong></p>
<p><strong>contemporary</strong></p>
<p><strong>authors who are alive</strong> 当代作家</p>
<p><strong>senile</strong></p>
<p><strong>misanthrope</strong></p>
<p><strong>relentlessly</strong></p>
<p>university <strong>dean</strong></p>
<p><strong>persuasive</strong></p>
<p><strong>manipulative</strong></p>
<p>there is <strong>no shortage of</strong> xxx 不缺 xxx</p>
<p><strong>step closer to the world of</strong> xxx 离 xxx 更近一点</p>
<p><strong>No doubt their proximity would inspire me</strong>.</p>
<p><strong>expect</strong> somebody at xxx <strong>sharp</strong> 与某人在 xxx 准时见</p>
<p><strong>coveted</strong></p>
<p><strong>got engaged</strong></p>
<p><strong>incredible</strong></p>
<p><strong>ambush</strong></p>
<p><strong>sneak onto his property</strong></p>
<p><strong>commerce</strong></p>
<p><strong>preemptive strike argument</strong> 先发制人的论调</p>
<p><strong>crossing to the xxx side</strong> 进入某个世界</p>
<p><strong>raise class awareness</strong> 提升阶级意识</p>
<p><strong>hangout</strong></p>
<p><strong>have and hold</strong> 互相扶持</p>
<p><strong>masterpiece</strong></p>
<p><strong>crap</strong></p>
<p><strong>compelling</strong></p>
<p><strong>idiotic</strong></p>
<p><strong>hooray</strong></p>
<p><strong>dictaphone</strong></p>
<p><strong>get the hang of it</strong></p>
<p><strong>rewind</strong></p>
<p><strong>correspondence</strong></p>
<p><strong>cordial</strong></p>
<p><strong>dungarees and sneakers</strong></p>
<p><strong>hoods</strong></p>
<p><strong>open-toed shoes</strong></p>
<p><strong>trousers</strong></p>
<p><strong>stockings</strong></p>
<p><strong>above all…</strong> 最重要的是…</p>
<p><strong>proprietor</strong></p>
<p>somebody hereby <strong>grants</strong> to someone</p>
<p><strong>contracts</strong></p>
<p>fun <strong>stuff</strong></p>
<p><strong>inquiry</strong></p>
<p><strong>autobiography</strong></p>
<p><strong>celebrity auction</strong></p>
<p><strong>verbatim</strong></p>
<p><strong>shred</strong>, <strong>shredder</strong></p>
<p><strong>assassin</strong></p>
<p><strong>sidewalk</strong></p>
<p><strong>trial</strong></p>
<p><strong>stupid grin</strong></p>
<p><strong>earnest</strong></p>
<p><strong>A major loser is what he is.</strong></p>
<p><strong>trace</strong> somebody’s steps 追寻某人的脚步</p>
<p><strong>literally</strong></p>
<p><strong>a bunch of obsessive freaks</strong></p>
<p>Good literature is a powerful <strong>aphrodisiac</strong>.</p>
<p>have that xxx (kinds of) <strong>moment</strong>. 有某种感受</p>
<p>difficult <strong>gritty fiction</strong> 深奥写实的小说</p>
<p><strong>insufferably</strong></p>
<p><strong>quirky</strong></p>
<p>I don’t want to be entertained, I want to be <strong>provoked</strong>.</p>
<p>My shoulder hurts <strong>from</strong> carrying all those manuscripts.</p>
<p><strong>slush pile</strong>, <strong>unsolicited</strong> query letters 废稿堆</p>
<p><strong>sobbing and sighing</strong></p>
<p><strong>referral</strong></p>
<p><strong>hilarious</strong></p>
<p><strong>very very occasionally</strong> 极少的情况下</p>
<p><strong>alleviate</strong></p>
<p><strong>on a trial basis</strong> 作为试用</p>
<p><strong>blatant</strong></p>
<p><strong>infringement</strong></p>
<p><strong>scour</strong> the worldwide web</p>
<p><strong>put an end to it</strong> 终结此事</p>
<p><strong>Don’t mean to cause a fuss</strong> 无意打扰</p>
<p><strong>ushered</strong>, fetch them water 端茶送水</p>
<p><strong>belying</strong> the fact</p>
<p>be <strong>mentored</strong> by their boss</p>
<p>show <strong>initiative</strong></p>
<p><strong>secretary</strong></p>
<p><strong>Speaking to/Who is this? It’s is xxx</strong> 请问是哪位，我是 xxx</p>
<p><strong>explosion</strong> during the war</p>
<p><strong>The press</strong> 媒体</p>
<p><strong>standalone</strong></p>
<p><strong>proceed carefully</strong> 小心行事</p>
<p><strong>enough chit chat</strong> 别闲聊了</p>
<p>open up opportunities 开拓机会</p>
<p><strong>shield</strong> somebody from the someplace 将某人与某处隔离</p>
<p><strong>bolster</strong></p>
<p><strong>recluse</strong>, <strong>reclusive</strong></p>
<p><strong>kick out</strong></p>
<p><strong>disinfect</strong></p>
<p><strong>take care of little things</strong> 会干很多零活</p>
<p><strong>sign a lease under her name</strong> 以她的名义签租约</p>
<p><strong>barely</strong></p>
<p><strong>sink</strong>/<strong>sunk</strong></p>
<p><strong>tub</strong></p>
<p><strong>commencement</strong></p>
<p><strong>inn</strong></p>
<p><strong>scrupulously</strong></p>
<p><strong>refuge</strong></p>
<p><strong>nightmare</strong></p>
<p><strong>gut</strong></p>
<p><strong>rip out</strong></p>
<p><strong>veteran</strong></p>
<p><strong>leukemia</strong></p>
<p><strong>copyright</strong></p>
<p><strong>edification</strong></p>
<p><strong>crap sandwich</strong></p>
<p><strong>ritual</strong></p>
<p><strong>tragic</strong></p>
<p><strong>walk by</strong></p>
<p><strong>forlorn</strong></p>
<p><strong>reminisce</strong></p>
<p><strong>tales</strong></p>
<p><strong>take the bait</strong></p>
<p><strong>self-loathing</strong></p>
<p><strong>patriarchy</strong></p>
<p><strong>impose</strong></p>
<p><strong>rigid and terrifying ideas of femininity</strong></p>
<p><strong>paralyze</strong></p>
<p><strong>strip somebody of their dignity</strong></p>
<p><strong>didactic</strong></p>
<p><strong>introspective</strong></p>
<p><strong>commentary</strong></p>
<p><strong>tyrant</strong></p>
<p><strong>closet</strong></p>
<p><strong>memo</strong></p>
<p><strong>proper breakup</strong></p>
<p><strong>contemplate</strong></p>
<p><strong>overwhelming</strong></p>
<p><strong>flunk</strong></p>
<p><strong>repeat my year</strong> 留级</p>
<p><strong>uphold</strong> the spirit of somebody 秉承某人的精神</p>
<p><strong>humble</strong></p>
<p><strong>grew out of xxx</strong> 已经过了 xxx 的年纪了</p>
<p><strong>cab</strong></p>
<p><strong>as far as xxx</strong> 就 xxx 而言</p>
<p><strong>discreet</strong></p>
<p><strong>presume</strong></p>
<p><strong>tip off</strong></p>
<p><strong>predecessor</strong></p>
<p><strong>impeccable</strong></p>
<p><strong>pedestrian</strong></p>
<p><strong>hit a home run</strong> 全垒打</p>
<p><strong>protagonist</strong></p>
<p><strong>Oliver Twist</strong> 雾都孤儿</p>
<p><strong>nostalgia</strong></p>
<p><strong>blow something</strong> 把某事搞砸</p>
<p><strong>renovate</strong></p>
<p><strong>cross the line</strong></p>
<p><strong>rabbit hole</strong> 无底洞</p>
<p><strong>ethically and legally</strong></p>
<p><strong>articulate</strong></p>
<p><strong>enlighten</strong></p>
<p><strong>prescription</strong></p>
<p><strong>drool</strong></p>
<p><strong>exclusively</strong></p>
<p><strong>walk somebody to the something</strong> 给某人介绍某事</p>
<p><strong>jittery</strong></p>
<p><strong>debrief</strong></p>
<p><strong>spine</strong></p>
<p><strong>typo</strong></p>
<p><strong>stickler</strong></p>
<p><strong>peeved</strong></p>
<p><strong>unleash</strong></p>
<p><strong>phony</strong></p>
<p><strong>reveal</strong></p>
<p><strong>hoot</strong></p>
<p><strong>sake</strong></p>
<p><strong>revel</strong></p>
<p><strong>nonchalance</strong></p>
<p><strong>bipolar</strong></p>
<p><strong>muggy</strong></p>
<p><strong>what do you make of him</strong></p>
<p><strong>protect that sanctuary</strong> 保持初心</p>
<p><strong>satirical</strong></p>
<p><strong>flip out</strong></p>
<p><strong>symptom</strong></p>
<p><strong>profound</strong></p>
<p><strong>barley</strong></p>
<p><strong>clauses</strong> 条款</p>
<p><strong>immature</strong></p>
<p><strong>reluctant</strong></p>
<p><strong>alter</strong></p>
<p><strong>pitch</strong></p>
<p><strong>intimately</strong></p>
<p><strong>panicky</strong></p>
<p><strong>My condolence</strong> 节哀顺变</p>
<p><strong>pull my socks up</strong> 我会振作起来</p>
<p><strong>anonymous</strong></p>
<p><strong>brutal</strong></p>
<p><strong>get off</strong></p>
<p><strong>sanctum</strong></p>
<p><strong>fogy</strong></p>
<p><strong>instinct</strong></p>
<p><strong>preliminary</strong></p>
<p><strong>decommission</strong></p>
<p><strong>facility</strong></p>
<p><strong>contraction</strong></p>
<p><strong>possession</strong></p>
<p><strong>nerve-wracking</strong> 非常伤脑筋的</p>
<p><strong>bound for</strong></p>
<p><strong>intercepted</strong></p>
<p><strong>pirate</strong></p>
<p><strong>icky</strong></p>
<p><strong>gooey</strong></p>
<p><strong>gel</strong></p>
<p><strong>maple syrup</strong></p>
<p><strong>snarl</strong></p>
<p><strong>turnpike</strong></p>
<p>a <strong>leaking valve</strong></p>
<p><strong>sealant</strong>, <strong>cement</strong>, <strong>asphalt</strong>, <strong>concrete</strong>, <strong>tar</strong></p>
<p><strong>organ</strong></p>
<p><strong>live up to its name</strong> 不负盛名，名副其实</p>
<p><strong>chord</strong></p>
<p><strong>resident</strong></p>
<p><strong>horrific</strong></p>
<p><strong>terrific</strong></p>
<p><strong>gross</strong></p>
<p><strong>diaper</strong></p>
<p><strong>sanitary</strong> items</p>
<p><strong>landfill</strong></p>
<p><strong>dump</strong></p>
<p><strong>domesticated</strong></p>
<p><strong>scatter</strong></p>
<p><strong>pull over</strong> to the <strong>shoulder</strong> of the road</p>
<p><strong>gravel</strong></p>
<p><strong>paddy</strong></p>
<p><strong>conspiracy</strong> theory</p>
<p><strong>quote</strong>, <strong>quotation</strong> = <strong>line</strong></p>
<p><strong>seminar</strong></p>
<p><strong>come across</strong></p>
<p><strong>brilliant</strong></p>
<p><strong>layaway</strong></p>
<p><strong>sweeping</strong> acts of kindness</p>
<p><strong>restore</strong> somebody’s <strong>faith</strong></p>
<p><strong>Claus</strong></p>
<p><strong>rhyme</strong></p>
<p><strong>sprang</strong></p>
<p><strong>bound</strong></p>
<p><strong>chimney</strong></p>
<p><strong>sleigh</strong></p>
<p><strong>reindeer</strong></p>
<p><strong>whistle</strong></p>
<p><strong>down</strong> 羽毛羽绒</p>
<p><strong>thistle</strong></p>
<p><strong>exclaim</strong></p>
<p><strong>drive out of sight</strong></p>
<p><strong>psychic</strong></p>
<p><strong>palm reader</strong></p>
<p><strong>tarot card reader</strong></p>
<p><strong>crystal ball</strong></p>
<p><strong>pyramid</strong></p>
<p><strong>Egypt</strong></p>
<p><strong>reconcile</strong></p>
<p><strong>counsel</strong></p>
<p><strong>reservation</strong> (for things)</p>
<p><strong>appointment</strong> (for people)</p>
<p><strong>leisure</strong></p>
<p><strong>spinball</strong></p>
<p><strong>punk</strong></p>
<p><strong>sweating and panting</strong></p>
<p><strong>muggy</strong></p>
<p><strong>humid</strong></p>
<p><strong>slippery</strong></p>
<p><strong>collie</strong></p>
<p><strong>blowdry</strong></p>
<p><strong>that goes without saying</strong></p>
<p><strong>demanding</strong> teacher</p>
<p><strong>limo limousine</strong></p>
<p><strong>luxury</strong></p>
<p>physical and <strong>spiritual</strong> needs</p>
<p><strong>creature comforts</strong> 物质享受</p>
<p><strong>estate</strong></p>
<p>stay <strong>mum</strong> about sth</p>
<p>keep sth <strong>confidential</strong></p>
<p><strong>conductor</strong></p>
<p><strong>railway</strong></p>
<p><strong>spanking</strong></p>
<p>sth <strong>take my fancy</strong> = be interesting in sth</p>
<p><strong>jogging</strong></p>
<p><strong>patio</strong></p>
<p><strong>civil</strong> right</p>
<p><strong>midlist</strong></p>
<p><strong>discrimination</strong></p>
<p><strong>spearhead</strong></p>
<p><strong>desegregate</strong></p>
<p><strong>assassinate</strong></p>
<p><strong>beacon</strong></p>
<p><strong>protest</strong></p>
<p><strong>anti-piracy</strong></p>
<p><strong>legislation</strong> = proposed law</p>
<p>in a <strong>tizzy</strong></p>
<p><strong>black out</strong></p>
<p><strong>I’ll have none of it</strong> 我拒绝</p>
<p><strong>vicinity</strong></p>
<p><strong>tattoo</strong></p>
<p><strong>sustain</strong></p>
<p><strong>deceased</strong></p>
<p><strong>dye</strong></p>
<p><strong>conundrum</strong></p>
<p><strong>floss</strong></p>
<p><strong>pile-up</strong> 连环车祸</p>
<p><strong>crumple</strong></p>
<p><strong>crash</strong></p>
<p><strong>plastic</strong></p>
<p><strong>metal</strong></p>
<p><strong>bruise</strong></p>
<p><strong>ego</strong></p>
<p><strong>enthusiast</strong></p>
<p><strong>sleek</strong></p>
<p><strong>Arctic</strong></p>
<p><strong>Antarctic</strong></p>
<p><strong>outcropping</strong></p>
<p><strong>toboggan</strong></p>
<p><strong>authentic</strong></p>
<p> <strong>Beatlemania</strong></p>
<p><strong>prime-time</strong></p>
<p><strong>debut</strong></p>
<p><strong>lean</strong></p>
<p><strong>torture</strong></p>
<p><strong>dilemma</strong></p>
<p><strong>remake</strong></p>
<p><strong>lyric</strong></p>
<p><strong>funeral</strong></p>
<p><strong>controversy</strong></p>
<p><strong>ketchup</strong>/<strong>catchup</strong>/<strong>cat-sup</strong></p>
<p><strong>condiment</strong></p>
<p><strong>pseudonym</strong></p>
<p><strong>specialty</strong></p>
<p><strong>statistically</strong></p>
<p><strong>conquistador</strong></p>
<p><strong>gulf</strong></p>
<p><strong>tragedy</strong></p>
<p><strong>leap year</strong></p>
<p><strong>leapling</strong></p>
<p><strong>plastic surgery</strong></p>
<p><strong>opt out of something</strong></p>
<p><strong>date</strong> 椰枣</p>
<p><strong>Dracula</strong></p>
<p><strong>cross and garlic</strong></p>
<p><strong>mine the mineral</strong></p>
<p><strong>squeeze</strong></p>
<p><strong>dash</strong></p>
<p><strong>bragging</strong> time</p>
<p><strong>muffin</strong></p>
<p><strong>frosting</strong></p>
<p><strong>vending</strong> machine 自动售货机</p>
<p><strong>desert</strong></p>
<p><strong>dessert</strong></p>
<p><strong>limestone</strong></p>
<p><strong>coal</strong></p>
<p><strong>granite</strong></p>
<p><strong>curb</strong></p>
<p><strong>arrogant</strong></p>
<p><strong>nastiness</strong></p>
<p><strong>outrageous</strong></p>
<p><strong>etiquette</strong></p>
<p><strong>emperor</strong></p>
<p><strong>avocado</strong></p>
<p><strong>showy</strong></p>
<p><strong>obelisk</strong></p>
<p><strong>statue</strong></p>
<p><strong>scrap</strong></p>
<p><strong>vocab</strong></p>
<p><strong>crux</strong></p>
<p><strong>dune</strong></p>
<p><strong>permafrost</strong></p>
<p><strong>horizon</strong></p>
<p><strong>stray</strong></p>
<p><strong>parenthesis</strong></p>
<p><strong>skinhead</strong></p>
<p><strong>racist</strong></p>
<p><strong>psycho</strong></p>
<p><strong>glitter</strong></p>
<p><strong>in spades</strong> 表肯定</p>
<p><strong>downside</strong></p>
<p><strong>callus</strong>/<strong>callous</strong></p>
<p><strong>immigrate</strong></p>
<p><strong>exclamatory</strong></p>
<p><strong>blend in</strong></p>
<p><strong>tangible</strong></p>
<p><strong>biscuit</strong></p>
<p><strong>cheetah</strong></p>
<p><strong>jungle</strong></p>
<p><strong>savannah</strong></p>
<p><strong>hippopotamus</strong></p>
<p><strong>renaissance</strong></p>
<p><strong>polymath</strong></p>
<p><strong>sculpture</strong></p>
<p><strong>sculptor</strong></p>
<p><strong>the renaissance man</strong> = <strong>jack of all trades</strong> 万金油</p>
<p><strong>genius</strong></p>
<p><strong>mediocre</strong></p>
<p><strong>pupil</strong></p>
<p><strong>surpass</strong></p>
<p><strong>close-up</strong> 特写</p>
<p><strong>canoe</strong></p>
<p><strong>paddle</strong></p>
<p>a <strong>seasoned veteran</strong></p>
]]></content>
  </entry>
  <entry>
    <title>Java Concurrency</title>
    <url>/2022/05/08/java-concurrency/</url>
    <content><![CDATA[<h1 id="1、基础概念"><a href="#1、基础概念" class="headerlink" title="1、基础概念"></a>1、基础概念</h1><p>由于计算机的运算速度与存储和通信子系统的速度差距太大，大量的时间都花费在磁盘 I/O、网络通信或者数据库访问上，因此不得不加入一层或多层读写速度尽可能接近 CPU 运算速度的高速缓存来作为内存与 CPU 之间的缓冲，此外，还希望通过多任务并发处理来尽可能避免对运算性能的浪费。现代操作系统（Windows、macOS、Linux）执行多任务实际就是让 CPU 对任务数量远远多于 CPU 核数的多个任务<strong>轮流交替并发执行</strong>（如果任务数量小于等于 CPU 核数就是并行执行，不存在轮流交替），而基于高速缓存的存储交互虽然很好地解决了 CPU 与内存速度之间的矛盾，但也引入了缓存一致性问题（每个 CPU 都有自己的高速缓存，但又共享同一主内存），为系统带来了更高的复杂度。</p>
<h2 id="1-1-进程、线程和协程"><a href="#1-1-进程、线程和协程" class="headerlink" title="1.1 进程、线程和协程"></a>1.1 进程、线程和协程</h2><p>在计算机中，一个任务称为一个进程（Process），某些进程内部还需要同时执行多个子任务，这些子任务称为线程（Thread），对于 Java 程序来说，执行多任务是指<strong>多线程并发执行</strong>。Java 线程是映射到操作系统的原生内核线程之上的，如果要阻塞或唤醒一条线程，同样需要操作系统的支持，同样会涉及到用户态到内核态的转换，这种状态转换消耗的时间甚至会比一些简单的用户代码执行的时间还要长，应当避免不必要的频繁的切入内核态。</p>
<p>进程和线程存在以下区别：</p>
<ul>
<li><p>进程和线程是包含关系，一个进程有一个或多个线程，线程有时也被称作是轻量级的进程</p>
</li>
<li><p>进程是资源分配和保护的基本单元，线程是操作系统调度和分派的基本单元</p>
</li>
<li><p>由于进程是运行在它自己的地址空间内的自包容程序，具有一个独立的、完整的、私有的基本运行环境和资源集合，创建进程的开销比创建线程大，同一个进程中的线程会共享进程的资源</p>
</li>
<li><p>进程往往被看作是程序或应用的代名词，但是一个单独的应用程序实际上可能是一组互相协作的进程集合</p>
</li>
<li><p>进程间通信比线程间通信要慢，这是因为线程间通信就是读写同一个变量，不需要进行系统调用，速度很快</p>
</li>
<li><p>进程间不会相互干扰，一个进程崩溃不会影响其他进程，但是任何一个线程的崩溃就会导致整个进程崩溃</p>
</li>
<li><p>多线程编程的复杂度比多进程更高，困难在于协调不同线程驱动的任务之间对共享资源（内存和 I/O）的使用</p>
</li>
</ul>
<p>对于多次 I/O 操作来说，可以使用多线程来完成，但是多线程会引起资源竞争和上下文切换，导致 CPU 算力的浪费以及频繁地切入内核态，为了避免这种情况可以采用异步的方式，但是异步的方式就涉及到回调，会影响代码的可读性，因此就需要使用协程（Coroutine），协程是协作的程序，是用户态的东西，协程任务切换的上下文由用户态来保存和处理，由用户自己决定何时切换协程的上下文，这个过程不会被操作系统感知到，无需操作系统去做抢占式调度，不会产生操作系统级别的线程阻塞和上下文切换。Go 和 Ruby 都实现了协程，Java 在 19 中引入了协程，并在 21 中成为正式功能。</p>
<h2 id="1-2-上下文切换"><a href="#1-2-上下文切换" class="headerlink" title="1.2 上下文切换"></a>1.2 上下文切换</h2><p>CPU 会给每个任务分配时间片，因此，即使是单核 CPU 也支持多任务并发执行代码，从而提升单核 CPU 上的程序的性能（在某个任务阻塞时，其他任务依旧可以继续执行，但如果没有任务会阻塞，那么单核 CPU 上使用并发就没有任何意义）。</p>
<p>上下文切换指的是内核（操作系统的核心）在 CPU 上对进程或者线程进行切换，当前任务执行一个时间片之后会切换到下一个任务，任务切换前后需要保存上一个任务的状态并加载下一个任务的状态，这种任务从保存到再加载的过程就是一次上下文切换。上下文切换的信息被保存在进程控制块（PCB，又称切换桢）中，会被一直保存在 CPU 的内存中，直到被再次使用。Java 中的线程机制是抢占式的，这表示调度机制会周期性地中断线程，将上下文切换到另一个线程，从而为每个线程都提供时间片。 </p>
<p>由于上下文切换存在开销，因此当上下文切换过于频繁时并发执行会比串行执行更慢，尤其是原本设置为并发执行的程序在受限于资源而串行执行时，会比直接串行执行更慢，应当根据实际情况来调整程序的并发程度。为了避免频繁上下文切换而导致的 CPU 资源浪费，可以</p>
<ul>
<li><p>通过合理的线程池管理来减少线程的创建和销毁，线程数并不是越多越好</p>
</li>
<li><p>使用无锁并发编程（比如 CAS），避免线程因等待锁而进入阻塞状态，进而导致的上下文切换</p>
</li>
<li><p>使用用户态线程（又称协程或虚拟线程），用户态线程的切换需要在 JVM 层面做一些成本较低的线程状态的保存和恢复，但不需要操作系统的参与，并不会导致上下文切换</p>
</li>
<li><p>合理使用锁，尽量缩小同步范围，减少线程等待时间，从而避免上下文切换</p>
</li>
</ul>
<h2 id="1-3-并发问题"><a href="#1-3-并发问题" class="headerlink" title="1.3 并发问题"></a>1.3 并发问题</h2><ul>
<li><p>在单线程场景下，CPU 核心的缓存只被一个线程访问，不存在一致性问题；在单核 CPU 多线程场景下，CPU 将某块内存加载到核心缓存后，不同线程访问的都是同样的缓存位置，即便发生线程切换，缓存仍然不会失效；在多核 CPU 多线程场景下，每个 CPU 都会在自己的核心缓存中保留一份共享内存的缓存数据，多线程在多个 CPU 核上并行执行，可能会出现多个线程同时写各自所在的 CPU 缓存的情况，此时各个 CPU 的缓存数据就会出现不一致</p>
</li>
<li><p>为了保证缓存一致性，CPU 会使用总线嗅探机制来检测是否有其他处理器修改了共享内存中的变量，如果有，则更新缓存，但是如果多个线程频繁地读写共享变量，就会导致大量的总线通信，从而引发总线风暴，降低系统性能</p>
</li>
<li><p>当某个线程正在执行的某个操作做了一部分但还没完成时该线程的 CPU 时间片就结束了，这个操作就会被打断直到该线程下一次获得 CPU 时间片才能继续执行，那么这个操作就不是原子操作，即操作的执行不满足原子性，在该操作被打断的过程中所使用的共享数据可能被其他线程修改，进而导致该操作处理的结果与预期不一致</p>
</li>
<li><p>as-if-serial 语义要求不管怎么重排序，单线程程序的执行结果都不能被改变，编译器和处理器如何优化都必须遵守 as-if-serial 语义，因此单线程的执行一定是满足有序性的（Java 中天然的有序性可以总结为：如果在本线程内观察，所有操作都是天然有序的，如果在一个线程内观察另一个线程，所有操作都是无序的），但多线程的执行则无法保证有序性</p>
</li>
</ul>
<h2 id="1-4-并发模型"><a href="#1-4-并发模型" class="headerlink" title="1.4 并发模型"></a>1.4 并发模型</h2><ul>
<li>并发编程需要关注两个关键问题<ul>
<li>线程之间如何通信，指线程之间交换信息的机制</li>
<li>线程之间如何同步，指控制线程操作发生相对顺序的机制</li>
</ul>
</li>
<li>线程间的通信有两种方式<ul>
<li>消息传递，隐式的线程同步</li>
<li>共享内存，显式的线程同步</li>
</ul>
</li>
</ul>
<p>Java 并发采用的是共享内存模型，由 Java 内存模型（JMM）控制线程间的通信（不涉及操作系统内核）</p>
<ul>
<li><p>JMM 是一种屏蔽了各种硬件和操作系统的访问差异的机制及规范，它在各个不同平台之上为 Java 程序呈现了一个一致的内存模型，保证了 Java 程序在各个平台下对内存访问效果一致</p>
</li>
<li><p>JMM 规定了线程间的共享变量（实例域、静态域和数组元素）存储在主内存（堆和方法区）中，每个线程自身有一个私有的工作内存（缓存、写缓冲区、寄存器等），线程的工作内存中保存该线程中使用到的变量的主内存副本拷贝，线程对变量的所有操作都必须在线程工作内存中进行，而不能直接读写主内存</p>
</li>
<li><p>JMM 规定了如何以及何时进行主内存与线程工作内存之间的交互（也就是线程间通信），这个过程中 JMM 使用了<a href="https://www.yuque.com/hollis666/niq4hm/kozqs205honv8nso">内存屏障</a>、限制了处理器优化、提供了一系列同步机制，解决了线程间通信过程中存在的多 CPU 多级缓存导致的一致性问题、CPU 时间片导致的原子性问题、以及编译器对指令重排、处理器对指令乱序执行导致的有序性问题</p>
</li>
<li><p>JMM 所使用的<a href="https://gee.cs.oswego.edu/dl/jmm/cookbook.html">内存屏障</a>是一种 CPU 指令，可以防止 CPU 及编译器对指令序列进行重排序，再加上 JMM 所提供的一系列同步机制则可以一同解决缓存一致性和总线风暴问题</p>
</li>
<li><p>JMM 中的 happens-before 原则要求如果一个操作 A happens-before 另一个操作 B，那么操作 A 的结果对操作 B 是可见的，JMM 通过 happens-before 原则确保了多线程间的可见性和有序性</p>
</li>
</ul>
<h1 id="2、底层原理"><a href="#2、底层原理" class="headerlink" title="2、底层原理"></a>2、底层原理</h1><h2 id="2-1-有序性和可见性"><a href="#2-1-有序性和可见性" class="headerlink" title="2.1 有序性和可见性"></a>2.1 有序性和可见性</h2><p><code>volatile</code>关键字可以用来保证对变量操作的有序性和可见性，是 JVM 提供的最轻量级的同步机制。</p>
<ul>
<li><p><code>volatile</code>只能修饰变量，不能修饰方法和代码块</p>
</li>
<li><p><code>volatile</code>通过内存屏障来禁止指令重排，从而保证了代码执行的有序性</p>
</li>
<li><p><code>volatile</code>保证了多线程共享变量的可见性</p>
<ul>
<li>线程每次修改变量后，立即回写到主内存当中</li>
<li>线程每次访问该变量时总是获取主内存中的最新值</li>
</ul>
</li>
<li><p><code>volatile</code>读操作的开销和普通变量几乎无差别，而写操作由于需要插入内存屏障所以开销更大一点</p>
</li>
<li><p><code>volatile</code>不会引起上下文切换和调度，使用成本比锁低</p>
</li>
<li><p>如果一个域可能会被多个任务同时访问，且这些任务中至少有一个是写入任务，那么就应该将这个域设置为<code>volatile</code>或者将可以访问这个<code>private</code>域的方法都加锁</p>
</li>
</ul>
<p><code>final</code>关键字可以用来保证变量的可见性</p>
<ul>
<li><p>写<code>final</code>域时，只有在对象的<code>final</code>域已经被正确初始化过了之后，对象引用才会为任何线程可见</p>
</li>
<li><p>读<code>final</code>域时，一定会确保先读包含这个<code>final</code>域的对象的引用，再读该对象的<code>final</code>域</p>
</li>
<li><p>在构造函数返回前，被构造对象的引用不能为其他线程所见（即<code>this</code>引用不能溢出），那么不需要使用同步（<code>volatile</code>或者锁）也可以确保任意线程都能看到这个<code>final</code>域在构造函数中被初始化之后的值，这保证了多线程共享<code>final</code>变量的可见性</p>
</li>
</ul>
<h2 id="2-2-原子操作和原子性"><a href="#2-2-原子操作和原子性" class="headerlink" title="2.2 原子操作和原子性"></a>2.2 原子操作和原子性</h2><p>循环 CAS 可以用来保证操作的原子性。</p>
<ul>
<li><p>CAS 指</p>
<ul>
<li><p>当类的当前值是<code>prev</code>时，更新为<code>next</code>，并返回<code>true</code></p>
</li>
<li><p>当类的当前值不是<code>prev</code>时，返回<code>false</code></p>
</li>
</ul>
</li>
<li><p>通过循环 CAS 实现原子操作存在以下问题</p>
<ul>
<li><p>循环时间长的话就会进入忙等待（指 CPU 繁忙却无法前进执行），一旦 CAS 进入忙等待状态一直执行不成功的话，就会造成比较大的 CPU 开销</p>
</li>
<li><p>ABA 问题，解决思路是使用版本号，或者直接改成传统的互斥同步（可能更加高效）</p>
</li>
<li><p>只能保证一个共享变量的原子操作，解决思路是将多个共享变量合并成一个共享变量</p>
</li>
</ul>
</li>
<li><p>CAS 是乐观锁、锁自旋等非阻塞锁的常见实现方式，在 Java 中，JUC 包就是建立在循环 CAS 之上的</p>
</li>
<li><p>JVM 规范规定除了<code>long</code>和<code>double</code>以外的基本数据类型的读写（单条赋值操作）均为原子操作（即为不可中断的操作），满足原子性，<code>volatile</code>额外保证了<code>long</code>和<code>double</code>读写的原子性</p>
</li>
<li><p>自增自减这样的复合操作不是原子操作，不具有原子性</p>
</li>
</ul>
<p>注：</p>
<ul>
<li><p>乐观锁认为数据一般情况下不会有冲突，所以在提交数据更新的时候才会正式对数据的冲突与否进行检测，如果发现冲突了，则返回错误信息，让用户决定如何去做，其典型的实现方式就是 CAS</p>
</li>
<li><p>悲观锁认为数据一般情况下悲并发修改的概率比较大，需要在修改之前先加锁，<code>synchronized</code>就是一种悲观锁，悲观锁会存在加锁解锁导致的性能问题</p>
</li>
</ul>
<h2 id="2-3-synchronized-锁"><a href="#2-3-synchronized-锁" class="headerlink" title="2.3 synchronized 锁"></a>2.3 synchronized 锁</h2><p><code>synchronized</code>关键字可以用来对操作加锁，是 JVM 实现的，不可中断，非公平，可重入，通过单线程独占式执行锁住的操作以及解锁之前会先把变量同步回主存中来同时保证了有序性、原子性、可见性。</p>
<ul>
<li><p><code>synchronized</code>可以对方法和代码块加锁（不能用于修饰变量），有三种加锁方式</p>
<ul>
<li><p>对于普通方法，锁是当前实例对象<code>this</code>，此时必须将对象的域设置为<code>private</code>，确保不能直接访问域，只能由方法来访问</p>
</li>
<li><p>对于静态方法，锁是当前类的 Class 对象</p>
</li>
<li><p>对于同步代码块，锁是<code>synchronized</code>括号里配置的对象</p>
</li>
</ul>
</li>
<li><p>在使用<code>synchronized</code>时，获取到的是哪个锁非常重要，这关系到代码逻辑是否正确以及执行是否高效</p>
</li>
<li><p>无论<code>synchronized</code>代码块中是否抛出异常，都会在<code>synchronized</code>结束处自动正确释放锁</p>
</li>
<li><p><code>synchronized</code>锁的实现依赖于 Java 对象的监视器 Monitor，当尝试获取对象锁时，其实是对该对象的 Monitor 进行操作，Monitor 会保证同一时间点只能有一个线程可以获取锁</p>
</li>
<li><p><code>synchronized</code>获取的锁是可重入的锁（能被同一个线程反复获取的锁），因此每次加锁和解锁时，需要记录这是第几次加锁和解锁，直到记录变为第 0 次时才会真正释放锁（JVM 通过给每个对象设置一个监视器和阻塞队列来实现这一过程）</p>
</li>
<li><p>由于<code>synchronized</code>代码块无法并发执行，且加锁和解锁也需要消耗一定的时间，故<code>synchronized</code>会降低程序的执行效率</p>
</li>
<li><p>如果一个优先级高的线程等待一个优先级低的线程释放锁会导致优先级倒置，引起性能风险</p>
</li>
</ul>
<p>注：</p>
<ul>
<li><p>由于锁语句产生了一种互相排斥的效果（同一时间点只有一个线程可以获取锁），所以这种机制常常被称为互斥量（mutex）</p>
</li>
<li><p>公平锁是指所有希望获得锁的线程都在队列里排队，多个线程按照申请锁的顺序去获得锁，保证队列中的第一个先得到锁，不会饿死，但 CPU 唤醒线程是较大开销，吞吐量会下降很多</p>
</li>
<li><p>非公平锁是指线程先直接尝试去获取锁，此时是有可能获取到锁的，如果获取不到再进入队列排队，因此并不保证多个线程一定是按申请顺序获得锁，但 CPU 不必去唤醒所有线程，整体的吞吐量会高点，可能出现线程饿死</p>
</li>
</ul>
<h2 id="2-4-JVM-锁优化"><a href="#2-4-JVM-锁优化" class="headerlink" title="2.4 JVM 锁优化"></a>2.4 JVM 锁优化</h2><p>在运行期动态编译同步块时，JIT 编译器可以借助一种被称为逃逸分析（详细参见 <a href="../../../../2023/12/09/java-virtual-machine/">Java Virtual Machine</a> 的 3.3.3 小节）的技术来判断同步块所使用的锁对象是否会被多个线程访问，如果分析证实同步块锁对象只能够被一个线程访问，那么 JIT 编译器在编译这个同步块的时候就会取消对这部分的代码块的同步，这就是锁消除，主要是防止由于开发者误加了不必要的<code>synchronized</code>锁而导致的性能下降，比如使用<code>StringBuffer</code>作为局部变量。</p>
<p>大部分情况下减小锁的粒度是符合常理的，但是如果在一段代码中连续地对同一个对象反复加锁解锁，甚至加锁操作出现在循环体中，则相对耗费资源，此时应当放宽加锁的范围，从而减少性能消耗，当 JIT 编译器发现这类情况就会将加锁同步的范围粗化到整个操作序列的外部，这就是锁粗化。</p>
<p>此外，JVM 还引入锁升级来对<code>synchronized</code>进行优化，降低了获得锁和释放锁带来的性能消耗，此时锁一共有四种状态：无锁、偏向锁、轻量级锁和重量级锁，为了提高获得锁和释放锁的效率，锁可以升级但不能降级。</p>
<img src="锁升级.png" alt="锁升级" style="zoom:100%;" />

<ul>
<li><p>在大多数情况下，锁不存在多线程竞争，即总是由同一个线程多次获取，因此引入偏向锁</p>
<ul>
<li>偏向锁表示锁对象当前偏向第一个访问它的线程</li>
<li>加锁和解锁不需要额外的消耗（其实根本没有同步操作），与执行非同步代码相比，性能差距很小</li>
<li>存在锁竞争时，就需要等到安全点再将偏向锁撤销为无锁或升级为轻量级锁，这会带来额外的消耗，在高并发情况下尤为严重</li>
<li>适用于只有一个线程获取锁的场景，如果确认锁通常情况下处理竞争状态，可以关闭偏向锁，偏向锁关闭后程序默认会进入轻量级锁状态</li>
<li>偏向锁在 Java 6 和 Java 7 里是默认启用的，考虑到现代应用程序中只有一个线程获取锁的场景比较少见，且偏向锁的引入比较复杂，给 HotSpot VM 中锁相关部分与其他组件之间的交互也带了复杂性，并且阻碍了一些重大设计更改，JDK 15 中废弃了偏向锁</li>
</ul>
</li>
<li><p>存在多个线程竞争偏向锁时，锁会升级为轻量级锁</p>
<ul>
<li>竞争线程不会阻塞，提高了程序的响应速度</li>
<li>自旋会消耗 CPU，要避免无用的自旋</li>
<li>轻量级锁的自旋默认是开启的</li>
<li>自适应性自旋是指通常监控轻量级锁自旋等待的情况来动态调整自旋等待时间</li>
<li>适用于追求响应速度的场景</li>
</ul>
</li>
<li><p>自旋获取轻量级锁失败时，锁就会膨胀为重量级锁</p>
<ul>
<li>不使用自旋，不消耗 CPU</li>
<li>重量级锁的自旋默认是关闭的</li>
<li>线程阻塞，响应时间缓慢</li>
<li>重锁的重就在于加锁解锁所引起的线程阻塞和唤醒都需要操作系统内核的参与，进而导致线程状态转换的时间消耗比用户代码执行的时间还要长</li>
<li>适用于追求吞吐量的场景</li>
</ul>
</li>
</ul>
<h1 id="3、线程基础"><a href="#3、线程基础" class="headerlink" title="3、线程基础"></a>3、线程基础</h1><h2 id="3-1-启动新线程"><a href="#3-1-启动新线程" class="headerlink" title="3.1 启动新线程"></a>3.1 启动新线程</h2><p>一个 Java 程序实际上是一个 JVM 进程，JVM 进程用一个主线程来执行<code>main</code>方法，除此之外，JVM还有负责垃圾回收的其他线程运行。在方法内部，程序员通过编写代码又可以启动其他新线程，启动新线程有泛化<code>Thread</code>类、实现<code>Runnable</code>接口以及直接使用lambda表达式这三种方式，三种方式的共同点在于都在<code>run</code>方法中定义了线程所需执行的任务，并通过调用<code>start</code>方法来显示地启动线程。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span> <span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">t1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MyThread</span>();</span><br><span class="line">        t1.start();</span><br><span class="line">        </span><br><span class="line">        <span class="type">Thread</span> <span class="variable">t2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(<span class="keyword">new</span> <span class="title class_">MyRunnable</span>());</span><br><span class="line">        t2.start();</span><br><span class="line">        </span><br><span class="line">        <span class="type">Thread</span> <span class="variable">t3</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;...&#125;);</span><br><span class="line">        t3.start ();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyThread</span> <span class="keyword">extends</span> <span class="title class_">Thread</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;...&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyRunnable</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;...&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Java 作为跨平台的编程语言，线程的实现是依赖于具体的操作系统的，针对比较常用的 Windows 和 Linux 来说，都是采用内核线程的方式实现的，即在 Java 程序中创建一个 Thread 时，其实是需要映射到操作系统的线程的具体实现的，其创建、调度都需要切入内核态，成本比较高。</p>
<h2 id="3-2-线程调度"><a href="#3-2-线程调度" class="headerlink" title="3.2 线程调度"></a>3.2 线程调度</h2><ul>
<li><p>给多个并发运行的线程按照特定的机制分配 CPU 的使用权就叫做线程调度，现代操作系统基本采用时分的形式调度运行的线程</p>
</li>
<li><p>JVM 定义了抢占式的线程调度模型，如何调度线程完全由操作系统决定，程序自身无法决定线程间的执行顺序</p>
</li>
<li><p>可以通过<code>Thread.setPriority</code>方法来设定线程的优先级，线程优先级就是决定线程需要多或者少分配一些处理器资源的线程属性</p>
</li>
<li><p>优先级高的线程会被操作系统调度的更加频繁，但不能确保优先级高的线程一定会先执行，也不意味着优先级低的线程得不到执行，即优先级不会导致死锁</p>
</li>
<li><p>针对频繁阻塞（休眠或者I/O操作）的线程需要设置较高优先级，而偏重计算（需要较多CPU时间）的线程则设置较低优先级，确保线程不会被独占</p>
</li>
<li><p>在不同的JVM以及操作系统上，线程规划会存在差异，有的操作系统甚至会忽略对线程优先级的设定，因此，*<em>程序正确性不能依赖线程的优先级高低。</em></p>
</li>
<li><p>如果必须控制任务执行的顺序，那么最好使用同步控制，或者编写自己的协作例程（例程会按照执行的顺序在相互之间传递控制权）而不使用线程</p>
</li>
</ul>
<h2 id="3-3-线程的状态"><a href="#3-3-线程的状态" class="headerlink" title="3.3 线程的状态"></a>3.3 线程的状态</h2><ul>
<li><p>New：新创建的线程，尚未调用<code>start</code>方法</p>
</li>
<li><p>Runnable：运行中的线程，正在执行<code>run</code>方法中的代码</p>
<ul>
<li><p>Ready：属于 Runnable，但未获取到 CPU 时间片</p>
</li>
<li><p>Running：属于 Runnable，但获取到 CPU 时间片</p>
</li>
</ul>
</li>
<li><p>Waiting：因为某些操作而需要等待其他线程的通知才能返回到 Runnable，会让出 CPU</p>
</li>
<li><p>Blocked：因为等待 I/O 操作或等待获取<code>synchronized</code>锁之后才能返回 Runnable，会让出 CPU</p>
<ul>
<li><p>线程等待获取<code>synchronized</code>锁才会进入 Blocked</p>
</li>
<li><p>线程等待获取 JUC 的<code>Lock</code>锁则会进入 Waiting</p>
</li>
</ul>
</li>
<li><p>Timed Waiting：可以在指定的时间内自行返回到 Runnable，会让出 CPU</p>
</li>
<li><p>Terminated：已终止的线程</p>
</li>
</ul>
<p>注：阻塞和挂起是不同的概念，阻塞是指线程为了获得某个结果而不得不暂停执行，挂起是指显式调用某个以暂停为目的的挂起方法令线程暂停执行。</p>
<img src="线程状态转移.png" alt="线程状态转移" style="zoom:100%;" />

<h2 id="3-4-线程的行为"><a href="#3-4-线程的行为" class="headerlink" title="3.4 线程的行为"></a>3.4 线程的行为</h2><ul>
<li><p><code>Thread.start()</code></p>
<ul>
<li><p>调用<code>start</code>方法后，新线程启动</p>
</li>
<li><p>启动一个线程之前最好设置该线程的名称，便于分析排查</p>
</li>
<li><p>一个线程对象只能调用一次<code>start</code>方法</p>
</li>
</ul>
</li>
<li><p><code>Thread.run()</code></p>
<ul>
<li><p>在新线程启动后会立即执行<code>run</code>方法</p>
</li>
<li><p>直接调用<code>run</code>方法并不会执行新线程，而是在主线程中执行<code>run</code>方法</p>
</li>
<li><p><code>run</code>方法正常执行完毕或者因未捕获的异常而终止后该线程都会进入Terminated</p>
</li>
</ul>
</li>
<li><p><code>Thread.yield()</code></p>
<ul>
<li><p>调用<code>yield</code>方法声明了当前线程已经完成了生命周期中最重要的部分，可以切换给其它线程来执行</p>
</li>
<li><p>可以切换给其它线程只是对线程调度器的一个建议，而且也只是建议具有相同优先级的其它线程可以运行</p>
</li>
</ul>
</li>
<li><p><code>Thread.join()</code></p>
<ul>
<li><p>线程调用<code>join</code>方法后，其他线程都进入Waiting，直到当前线程进入Terminated</p>
</li>
<li><p>处于Terminated的的线程调用<code>join</code>方法时会立即返回</p>
</li>
</ul>
</li>
<li><p><code>Thread.interrupt()</code></p>
<ul>
<li><p>对阻塞中的目标线程调用<code>interrupt</code>方法可以向其发出中断请求，此时目标线程会抛出<code>InterruptedException</code>，其中断标志位会被置为<code>true</code></p>
</li>
<li><p>一个可能会进入阻塞操作的线程应当捕获<code>InterruptedException</code>并重置中断标志位或直接声明会抛出<code>InterruptedException</code>（更优）</p>
</li>
<li><p>方法一旦捕获了<code>InterruptedException</code>，当前线程的中断标志位会被自动置为<code>false</code>，如果此时既不打算抛出<code>InterruptedException</code>，又不希望线程就此终止，则应当通过<code>Thread.currentThread.interrupt()</code>来将中断标志位重置为<code>true</code>，否则线程在方法外部将无法得知自身是否被中断</p>
</li>
<li><p>目标线程的<code>run</code>方法可以通过检测<code>isInterrupted</code>方法是否返回<code>true</code>来判断自身是否被中断，处于 Terminated 的的线程调用<code>isInterrupted</code>方法会返回<code>fasle</code></p>
</li>
<li><p>目标线程是否能够立即响应该中断请求，取决于目标线程的<code>run</code>方法中的具体设置，有设置则对中断请求进行相应的处理，没有设置则直接忽略中断请求</p>
</li>
<li><p>试图执行 I/O 操作和试图获取<code>synchronized</code>锁的线程是不可中断的，而当任务以不可中断的方式被阻塞时，那么都会有潜在的死锁的可能</p>
</li>
<li><p>可中断的锁参见 JUC 包（<code>tryLock</code>），可中断的 I/O 操作参见 NIO 包</p>
</li>
</ul>
</li>
<li><p><code>Thread.sleep()</code></p>
<ul>
<li><p><code>sleep</code>方法是<code>Thread</code>的静态方法</p>
</li>
<li><p><code>sleep</code>方法不会释放锁，可以在任何地方（即便非同步区）使用</p>
</li>
<li><p><code>sleep</code>方法会释放 CPU 时间片，在一些底层框架中会使用<code>Thread.sleep(0)</code>来让当前线程主动释放一次 CPU，让其他线程可以进行一次公平的争抢</p>
</li>
</ul>
</li>
<li><p><code>Thread.setPriority()</code></p>
<ul>
<li><p>调用<code>setPriority(int)</code>方法可以设定线程的优先级</p>
</li>
<li><p>优先级的范围是1~10，默认是5</p>
</li>
</ul>
</li>
<li><p><code>Thread.stop()</code></p>
<ul>
<li><p>线程调用<code>stop</code>方法后会进入Terminated</p>
</li>
<li><p>不建议使用<code>stop</code>方法，该方法在调用后不会释放已经占有的资源，容易引发死锁</p>
</li>
<li><p>除了<code>stop</code>方法，还有<code>suspend</code>方法、<code>resume</code>方法都是已经过期的方法</p>
</li>
</ul>
</li>
<li><p><code>Thread.setDaemon()</code></p>
<ul>
<li><p>在调用<code>start</code>方法之前执行<code>setDaemon (true)</code>可以将线程设置为守护线程（也就是后台线程），最典型的应用就是 GC</p>
</li>
<li><p>守护线程指为其他线程服务的线程，对于需要无限循环运行（不终止）的线程应设置为守护线程，由守护线程所创建的任何线程都自动被设置为守护线程</p>
</li>
<li><p>在 JVM 中，所有非守护线程都执行完毕后（而不关心守护线程是否结束），JVM 会自动退出，并杀死进程中所有的守护线程，守护线程并不能被优雅的关闭</p>
</li>
<li><p>守护线程不能持有任何需要关闭的资源（例如打开文件），也不能通过<code>finally</code>块来执行任何逻辑，这是因为守护线程在不执行<code>finally</code>块的情况下就会终止其<code>run</code>方法</p>
</li>
</ul>
</li>
</ul>
<h2 id="3-5-死锁及预防"><a href="#3-5-死锁及预防" class="headerlink" title="3.5 死锁及预防"></a>3.5 死锁及预防</h2><p>死锁是指两个或两个以上的进程或线程在执行过程中，由于资源竞争或者由于彼此通信而造成的一种阻塞现象，若无外力作用，它们都将无法推进下去，此时称系统处于死锁状态或系统产生了死锁。</p>
<ul>
<li><p>死锁发生的四个条件</p>
<ul>
<li>互斥：每一时刻仅有一个线程能访问共享数据或共享资源</li>
<li>上锁及等待：每个线程都对其他线程需要的资源上锁并等待其他线程释放锁</li>
<li>无抢先机制；线程无法抢夺其他线程已经上锁的资源</li>
<li>循环等待：多个线程间循环等待其他线程释放锁</li>
</ul>
</li>
<li><p><strong>死锁一旦发生之后，没有任何机制能解除死锁，只能强制结束 JVM 进程，因此，只能通过破坏死锁发生的条件来预防</strong></p>
</li>
<li><p>预防死锁的四个方式</p>
<ul>
<li>使用允许同时使用的资源，或者增加资源数量，获取资源前检查是否可用等</li>
<li>遇到资源不可用时，就释放已经获取的资源重新来过，但这很可能会导致线程饥饿和活锁问题</li>
<li>满足抢先机制，比如设置优先级，令优先级高的可以抢占资源</li>
<li>所有线程都以同一种资源获取次序来获取资源</li>
</ul>
</li>
<li><p>限定资源：并发环境中有着固定尺寸或数量的资源，例如数据库连接和固定尺寸读/写缓存等</p>
</li>
<li><p>线程饥饿：线程在很长时间内无法抢到时间片去执行就会“挨饿”</p>
</li>
<li><p>活锁：线程因无法获取全部资源而选择释放已经获取的资源，并等待能够获取全部资源从而执行，执行次序一致的线程，每个都想要起步，但发现其他线程已经在“路上”，以致很长时间甚至永远都无法启动</p>
</li>
</ul>
<h1 id="4、线程同步"><a href="#4、线程同步" class="headerlink" title="4、线程同步"></a>4、线程同步</h1><p>多个线程同时读写可变的共享变量时，需要通过线程同步来实现线程间可靠的通信。正确地使用同步可以保证<strong>没有任何线程会看到数据处于不一致的状态中（一致性），一个已经进入同步区的线程在离开同步区之前没有其他线程可以一起进入同步区（有序性和原子性），并且进入同步区的每个线程都能看到由同一个锁保护的之前的所有修改效果（可见性）。</strong></p>
<h2 id="4-1-锁和临界区"><a href="#4-1-锁和临界区" class="headerlink" title="4.1 锁和临界区"></a>4.1 锁和临界区</h2><ul>
<li><p>对于 JVM 规范定义的<strong>单个原子操作</strong>，不需要加锁，再通过<code>volatile</code>关键字来解决有序性和可见性问题后，即可实现同步</p>
</li>
<li><p>对于单行非原子操作和多行原子操作（均无法保证原子性），操作原子性、有序性以及数据可见性是通过加锁和解锁实现的</p>
</li>
<li><p>加锁和解锁之间的代码块称为临界区（Critical Section），任何时候临界区最多只有一个线程（即获得锁的线程）能够执行</p>
</li>
<li><p>线程获取锁时会把线程对应的本地内存中的共享变量置为无效，使得临界区代码必须从主内存中读取共享变量</p>
</li>
<li><p>线程释放锁时会把线程中对应的本地内存中的共享变量刷新到主内存中。</p>
</li>
</ul>
<h2 id="4-2-等待-通知机制"><a href="#4-2-等待-通知机制" class="headerlink" title="4.2 等待/通知机制"></a>4.2 等待/通知机制</h2><p>Java程序使用<code>synchronized</code>解决多线程竞争问题，使用<code>wait</code>、<code>notify</code>、<code>notifyAll</code>、<code>park</code>以及<code>unpark</code>解决多线程协调问题。</p>
<ul>
<li><p><code>wait</code>方法不是一个普通的 Java 方法，而是定义在<code>Object</code>类的一个<code>native</code>方法，也就是由 JVM 的 C 代码实现的</p>
</li>
<li><p><code>wait</code>方法调用时，会<strong>释放</strong>线程获得的锁，<code>wait</code>方法返回后，线程又会重新试图获得锁，因此必须在<code>synchronized</code>块中才能调用<code>wait</code>方法</p>
</li>
<li><p>调用<code>wait</code>方法后，线程进入 Waiting 状态，但<code>wait</code>方法不会返回，直到将来某个时刻，线程从等待状态被其他线程唤醒并唤醒线程释放锁后，<code>wait</code>方法才会返回，然后继续执行下一条语句</p>
</li>
<li><p>当某个线程调用锁对象的<code>wait</code>方法后，需要其他线程调用相同的锁对象的<code>notify</code>方法，该<code>wait</code>方法才能返回，因此必须在<code>synchronized</code>块中才能调用<code>notify</code>方法</p>
</li>
<li><p><code>notify</code>和<code>notifyAll</code>的区别在于：<code>notify</code>只随机唤醒一个等待线程，而<code>notifyAll</code>会唤醒全部由相同锁对象调用<code>wait</code>而等待的线程，故<code>notifyAll</code>更安全</p>
</li>
<li><p>多个线程被唤醒后，只有一个线程能够重新获得锁从而有机会被 CPU 调度进而继续执行，而其他没有竞争到锁的线程将继续等待</p>
</li>
<li><p><code>park</code>和<code>unpark</code>也是一对用于线程等待和唤醒的方法，一般用于实现锁、信号量、线程池等高级并发组件</p>
</li>
<li><p><code>park</code>会使当前线程挂起，进入 Waiting 状态，具体实现会让线程进入等待队列中等待被唤醒，<code>park</code>方法可以不传参也可以传入一个<code>Object</code>类型的参数来标识线程挂起的原因，方便调试和排查问题，<code>Unpark</code>方法需要传入一个<code>Thread</code>类型的参数来标识需要唤醒的线程</p>
</li>
</ul>
<h2 id="4-3-线程安全级别"><a href="#4-3-线程安全级别" class="headerlink" title="4.3 线程安全级别"></a>4.3 线程安全级别</h2><p>“线程安全”（thread-safe）代表是否允许多线程正确同步（即结果和预期的一样），<code>java.lang.StringBuffer</code>、不可变类以及只提供静态方法而无成员变量的工具类都是线程安全的，除此之外没有特殊说明的类默认不是 thread-safe 的。</p>
<p>线程安全并不是要么全有要么全无的属性，而是具有以下多种级别</p>
<ul>
<li><p>不可变的（immutable）：这个类是不可变的，不需要外部同步</p>
</li>
<li><p>无条件的线程安全（unconditionally thread-safe）：这个类是可变的，但是这个类有着足够的内部同步，不需要任何外部同步即可并发使用</p>
</li>
<li><p>有条件的线程安全（conditionally thread-safe）：这个类是可变的，有部分方法需要外部同步，并需要在文档中指明</p>
</li>
<li><p>非线程安全（not thread-safe）：这个类是可变的，需要外部同步来包围这个类的每个方法调用</p>
</li>
<li><p>线程对立的（thread-hostile）：这个类是可变的，并且无法安全地被多线程并发使用，这种类要么需要进行修正，要么标注为弃用</p>
</li>
</ul>
<h2 id="4-4-线程状态传递"><a href="#4-4-线程状态传递" class="headerlink" title="4.4 线程状态传递"></a>4.4 线程状态传递</h2><p>在一个线程中，横跨若干方法调用，需要传递的对象，称之为上下文（Context），Context 是一种状态，可以是用户身份、任务信息等。Java标准库提供了<code>ThreadLocal</code>用于在一个线程中传递同一个 Context。</p>
<ul>
<li><p><code>ThreadLocal</code>表示线程的“局部变量”，存放的是线程间互斥线程内共享的 Context 数据，可以避免同一线程内通过参数传递 Context，更加优雅，典型应用场景有用户身份信息存储、线程安全、日志上下文存储、traceId 存储、数据库 Session 等</p>
</li>
<li><p>通过<code>ThreadLocal</code>的<code>set</code>方法可以将需要的 Context 关联到<code>ThreadLocal</code>实例当中，通过<code>remove</code>方法可以将 Context 从<code>ThreadLocal</code>实例中移除，关联到<code>ThreadLocal</code>中的 Context 在移除之前，所有方法都可以通过<code>ThreadLocal</code>的<code>get</code>方法随时获取到 Context</p>
</li>
<li><p><code>get</code>方法其实是先获取当前线程自身的<code>ThreadLocalMap</code>类型的成员变量，<code>ThreadLocalMap</code>是<code>ThreadLocal</code>的静态内部类，可以通过<code>ThreadLocal</code>对象（<code>this</code>引用）为 key，获取到 Context 数据</p>
</li>
<li><p><code>ThreadLocal</code>相当于给每个线程都开辟了一个独立的存储空间，各个线程的<code>ThreadLocal</code>关联的 Context 互不干扰</p>
</li>
<li><p><code>ThreadLocal</code>一定要在<code>finally</code>块中清除 Context，否则该 Context 所关联的线程在执行下一个任务时，会把上一次的状态带进去，时间久了容易内存泄漏，具体细节需要画图分析，等我以后有空再画（<a href="https://www.yuque.com/hollis666/niq4hm/bueq7weva8ha9f1p">详细参考</a>）</p>
</li>
<li><p><code>ThreadLocal</code>中的 context 即便是在父子线程之间也依旧互斥，即子线程无法获取父线程的 context，如果需要在父子线程之间传递 context，可以使用<code>InheritableThreadLocal</code>，父线程在创建子线程时，子线程会创建父线程的<code>InheritableThreadLocal</code>中的 context 的副本作为自身的<code>InheritableThreadLocal</code>中的 context</p>
</li>
<li><p><code>InheritableThreadLocal</code>只适用于在父线程中手动创建的子线程，而大多数时候线程都是通过线程池创建和复用的，此时可以使用<code>TransmittableThreadLocal</code>（<code>InheritableThreadLocal</code>的子类），适用于分布式跟踪系统、全链路压测、日志收集记录系统上下文、Session 级 Cache 等（<a href="https://www.yuque.com/hollis666/niq4hm/fucuuyqoqv8rdkpr">详细参考</a>）</p>
</li>
</ul>
<p>在使用线程时，出现那些可能看起来极罕见的缺陷，是很寻常并容易发生的事，而且对于到底出了什么错，这些缺陷只能给一个很模糊的概念。在 Java 5中引入了<code>java.util.concurrent</code>包，该包提供了一系列并发锁、线程安全的并发集合、原子操作的封装类以及同步器来实现简单高效健壮的并发。</p>
<h1 id="5、并发锁"><a href="#5、并发锁" class="headerlink" title="5、并发锁"></a>5、并发锁</h1><h2 id="5-1-Lock"><a href="#5-1-Lock" class="headerlink" title="5.1 Lock"></a>5.1 Lock</h2><ul>
<li><p><code>Lock</code>接口提供了与<code>synchronized</code>关键字类似的同步功能</p>
</li>
<li><p>不同于<code>synchronized</code>只需隐式获取释放锁，<code>Lock</code>接口需要显示地获取和释放锁</p>
</li>
<li><p>虽然缺少了一些便捷性，但<code>Lock</code>接口拥有了锁获取和释放的可操作性、可中断的获取锁以及超时获取锁等多种<code>synchronized</code>不具备的同步特性</p>
</li>
<li><p>在<code>try</code>中使用<code>return</code>，确保锁释放不会过早发生</p>
</li>
<li><p>不要在<code>try</code>块中获取锁，否则如果在获取锁时发生了异常，异常抛出时也会导致锁无故释放</p>
</li>
<li><p>在<code>finally</code>块中释放锁，保证在获取到锁之后，最终能够被释放</p>
</li>
<li><p><code>Lock</code>接口的实现基本都是聚合了一个同步器的子类来完成线程访问控制</p>
</li>
</ul>
<h2 id="5-2-ReentrantLock"><a href="#5-2-ReentrantLock" class="headerlink" title="5.2 ReentrantLock"></a>5.2 ReentrantLock</h2><p><code>ReentrantLock</code>在功能上是<code>synchronized</code>的超集，在性能上至少不弱于<code>synchronized</code>，<code>ReentrantLock</code>与<code>synchronized</code>之间的区别在于</p>
<ul>
<li><p><code>synchronized</code>锁在获取时必须一致等待，没有额外的尝试机制，<code>ReentrantLock</code>通过<code>tryLock</code>方法来<strong>尝试</strong>获取锁，如果在一定的时间未获得锁，<code>tryLock</code>方法会返回<code>false</code>，此时程序可以做一些额外的处理，而不是无限等待下去</p>
</li>
<li><p><code>synchronized</code>可以由 JVM 来确保即使发生异常也能自动释放锁，<code>ReentrantLock</code>需要考虑异常，因此在获得锁之后，使用<code>try-finally</code>语句来执行获得锁后的操作（在<code>finally</code>中释放锁）</p>
</li>
<li><p><code>synchronized</code>是 JVM 实现的，不可中断，非公平，加锁和解锁是隐式地，<code>ReentrantLock</code>是 JDK 实现的，可中断，默认是非公平的，也可以是公平的，加锁和解锁是显式地，两者都是可重入的</p>
</li>
<li><p>由于<code>synchronized</code>是不可中断的，而<code>ReentrantLock</code>是可中断的，线程在<code>tryLock</code>失败时不会导致死锁，<code>ReentrantLock</code>比直接使用<code>synchronized</code>更安全</p>
</li>
<li><p><code>synchronized</code>经过 JVM 优化后，其实性能与<code>ReentrantLock</code>基本上持平，且从长远看，JVM 更容易对<code>synchronized</code>来进行优化，这是因为 JVM 可以在线程和对象中记录<code>synchronized</code>中锁的相关信息，而使用<code>ReentrantLock</code>的话，JVM 则很难得知具体哪些对象是由特定线程锁持有的</p>
</li>
</ul>
<h2 id="5-3-ReadWriteLock"><a href="#5-3-ReadWriteLock" class="headerlink" title="5.3 ReadWriteLock"></a>5.3 ReadWriteLock</h2><ul>
<li><p><code>ReentrantLock</code>保证任何时候只有一个线程可以执行临界区代码，与<code>ReentrantLock</code>相比，<code>ReadWriteLock</code>允许多个读线程同时执行临界区代码，但不允许读线程和写线程同时执行</p>
</li>
<li><p>从<code>ReadWriteLock</code>对象可以分别获取读锁和写锁（<code>Lock</code>类型），在使用时，只需根据代码逻辑来区分加写锁或者读锁即可满足以上需求，<code>ReadWriteLock</code>依旧是可重入锁</p>
</li>
<li><p><strong><code>ReadWriteLock</code>同样需要考虑异常，因此在获得锁之后，使用<code>try-finally</code>语句来执行获得锁后的操作（在<code>finally</code>中释放锁）</strong></p>
</li>
<li><p><code>ReadWriteLock</code>类适用于读多写少的场景，可以提高读取效率</p>
</li>
</ul>
<h2 id="5-4-StampedLock"><a href="#5-4-StampedLock" class="headerlink" title="5.4 StampedLock"></a>5.4 StampedLock</h2><ul>
<li><p>与<code>ReadWriteLock</code>相比，<code>StampedLock</code>允许在读线程获取读锁并执行的过程中，写线程获取写锁并执行</p>
</li>
<li><p>从<code>StampedLock</code>对象可以分别获取读锁和写锁（<code>long</code>类型，其实是版本号），在使用时，只需根据代码逻辑来区分加写锁或者读锁即可满足以上需求，<code>StampedLock</code>是不可重入锁</p>
</li>
<li><p><code>ReadWriteLock</code>提供的读锁是悲观锁，<code>StampedLock</code>提供的读锁是乐观锁，乐观锁的并发效率更高，但一旦有小概率的写入导致读取的数据不一致，检测出来后需要再读一遍</p>
</li>
<li><p><code>StampedLock</code>加写锁的操作与<code>ReadWriteLock</code>是一致的，但加读锁时，首先获取读锁（版本号）并直接读取需要的值（读取时不保证原子性），接着通过<code>validate</code>方法验证版本号，验证失败时从<code>StampedLock</code>对象获取悲观读锁，接着重新读取（加锁保证原子性）</p>
</li>
<li><p><strong><code>StampedLock</code>的写锁和悲观读锁需要考虑异常，因此在获得锁之后，使用<code>try-finally</code>语句来执行获得锁后的操作（在<code>finally</code>中释放锁）</strong></p>
</li>
<li><p><code>StampedLock</code>通过将读锁细分为乐观锁和悲观锁，进一步提升并发效率</p>
</li>
</ul>
<h1 id="6、同步器"><a href="#6、同步器" class="headerlink" title="6、同步器"></a>6、同步器</h1><p>锁是面向使用者的，它定义了使用者与锁交互的接口，隐藏了实现细节；同步器是面向锁的实现者的，它简化了锁的实现方式，屏蔽了同步状态管理、线程的排列、等待与唤醒等底层操作。锁和同步器很好地隔离了使用者和实现者所关注的领域，可以实现更加灵活的线程同步。</p>
<h2 id="6-1-AQS"><a href="#6-1-AQS" class="headerlink" title="6.1 AQS"></a>6.1 AQS</h2><ul>
<li><p><code>AbstractQueuedSynchronizer</code>是很多 JDK 实现锁和同步器的基础类，本质是一个抽象同步队列，简称 AQS，出现在 JDK 1.5 中</p>
</li>
<li><p>AQS 使用了一个<code>int</code>型的<code>volatile</code>变量<code>state</code>来维护同步状态（状态的修改通过 CAS 完成），通过内置的 FIFO 双向队列来完成资源获取线程的排队工作，通过<code>park</code>和<code>unpark</code>来实现线程的等待和唤醒</p>
</li>
<li><p>同步器的设计是基于模板方法模式的，可以通过继承 AQS 并重写<code>tryAcquire</code>和<code>tryRelease</code>方法来实现自己的同步器。</p>
</li>
<li><p>自定义的同步器推荐被定义为同步组件的静态内部类，同步器本身没有实现任何同步接口</p>
</li>
<li><p>同步器可分为独占状态的同步器和共享状态的同步器，共享模式下的同步器还需实现<code>tryAcquireShared</code>和<code>tryReleaseShared</code>方法</p>
</li>
<li><p>使用独占模式同步器的主要类库有可重入锁<code>ReentrantLock</code>以及读写锁<code>ReentrantReadWriteLock</code>中的写锁<code>WriteLock</code></p>
</li>
<li><p>使用共享模式同步器的主要类库有信号量<code>Semaphore</code>以及倒数栅栏<code>CountDownLatch</code></p>
</li>
</ul>
<h2 id="6-2-Condition"><a href="#6-2-Condition" class="headerlink" title="6.2 Condition"></a>6.2 Condition</h2><p><code>synchronized</code>可以配合<code>wait</code>和<code>notify</code>来协调线程工作，当用<code>ReentrantLock</code>类代替<code>synchronized</code>时，可以使用<code>Condition</code>类来代替<code>wait</code>和<code>notify</code>。</p>
<ul>
<li><p><code>Condition</code>对象由<code>ReentrantLock</code>对象的<code>newCondition</code>方法返回得到，<code>Condition</code>对象可以唤醒指定线程</p>
</li>
<li><p><code>Condition</code>类提供<code>await</code>、<code>singal</code>、<code>signalAll</code>方法分别代替<code>wait</code>、<code>notify</code>、<code>notifyAll</code>，方法的原理和行为都是一致的</p>
</li>
<li><p><code>await</code>和<code>tryLock</code>类似的是：在等待指定时间后，如果还没有被<code>singal</code>或<code>signalAll</code>唤醒，可以自己醒来</p>
</li>
<li><p>通过<code>ReentrantLock</code>和<code>Condition</code>可以实现更加灵活的线程同步</p>
</li>
</ul>
<h2 id="6-3-CountDownLatch"><a href="#6-3-CountDownLatch" class="headerlink" title="6.3 CountDownLatch"></a>6.3 CountDownLatch</h2><p>用来同步一个或多个任务，强制他们等待由其他任务执行的一组操作完成。</p>
<ul>
<li><p>通过参数<code>count</code>来新建<code>CountDownLatch</code>实例，<code>count</code>为计数器初始值</p>
</li>
<li><p>每当有一个线程达到同步点（屏障）时，调用<code>CountDownLatch</code>的<code>countDown</code>方法使得计数器减1，调用<code>CountDownLatch</code>的<code>await</code>方法使得该线程进入<code>Blocked</code>状态，当计数器等于 0 时，所有被挂起的线程才继续执行</p>
</li>
<li><p><code>CountDownLatch</code>在计数器等于 0 并触发门闩打开后，就不能再次重复使用了，除非新建新的<code>CountDownLatch</code></p>
</li>
</ul>
<h2 id="6-4-CyclicBarrier"><a href="#6-4-CyclicBarrier" class="headerlink" title="6.4 CyclicBarrier"></a>6.4 CyclicBarrier</h2><p>允许多个线程在一个栅栏处等待，直到所有线程都到达栅栏之后，才会继续执行下去。</p>
<ul>
<li><p>通过参数<code>count</code>和<code>Runnable</code>实现类来新建<code>CyclicBarrier</code>实例，计数器初始值为0，<code>Runnable</code>实现类定义了屏障打开之后要执行的内容</p>
</li>
<li><p>每当有一个线程达到同步点（屏障）时计数器自动加1，调用<code>CyclicBarrier</code>的<code>await</code>方法使得该线程进入Blocked状态，当计数器达到<code>count</code>值时，所有线程才继续执行</p>
</li>
<li><p><code>CyclicBarrier</code>在计数器达到足够数量并打开屏障之后依旧能够再次重复使用</p>
</li>
</ul>
<h2 id="6-5-Phaser"><a href="#6-5-Phaser" class="headerlink" title="6.5 Phaser"></a>6.5 Phaser</h2><p>与 CyclicBarrier 类似，但是支持更灵活的栅栏操作，可以动态地注册和注销参与者，以及控制各个参与者的到达和离开。</p>
<h2 id="6-6-Semaphore"><a href="#6-6-Semaphore" class="headerlink" title="6.6 Semaphore"></a>6.6 Semaphore</h2><p>通过<code>Semaphore</code>可以实现多副本资源的并发控制，不同于锁只允许一个任务访问意向资源，<code>Semaphore</code>允许多个任务同时访问某个资源，但是限制访问的线程数量，实现了对象池的概念，避免系统资源被过度占用。</p>
<ul>
<li><p>通过参数<code>permits</code>和<code>fair</code>来新建<code>Semaphore</code>实例，<code>permits</code>代表资源数量，<code>fair</code>代表等待队列是否采用FIFO</p>
</li>
<li><p>每当有一个线程要访问共享资源时，通过<code>Semaphore</code>的<code>acquire</code>方法来获取资源</p>
<ul>
<li>如果信号量的计数器大于1，则意味着有共享资源可以使用，接着令计数器减1，然后该线程获得一份共享资源</li>
<li>如果计数器小于1，则线程进入排队队列</li>
</ul>
</li>
<li><p>每当有线程要释放共享资源时，通过<code>Semaphore</code>的<code>release</code>方法来释放资源，接着令信号量的计数器加1</p>
</li>
</ul>
<h2 id="6-7-Exchanger"><a href="#6-7-Exchanger" class="headerlink" title="6.7 Exchanger"></a>6.7 Exchanger</h2><p>当一个对象的创建代价很高昂时，通过生产者任务来负责创建对象，而需要消费这些对象的任务则是消费者任务，那么<code>Exchanger</code>就是用来在两个任务之间交换对象的栅栏。</p>
<h1 id="7、同步类"><a href="#7、同步类" class="headerlink" title="7、同步类"></a>7、同步类</h1><h2 id="7-1-Concurrent-集合"><a href="#7-1-Concurrent-集合" class="headerlink" title="7.1 Concurrent 集合"></a>7.1 Concurrent 集合</h2><ul>
<li><p><code>java.util.concurrent</code>包提供了<strong>线程安全</strong>的并发集合类，这些并发集合与使用非线程安全的集合类完全相同，但多线程同时读写并发集合是安全的，因此可以大大简化多线程编程</p>
</li>
<li><p>这些线程安全的并发集合类在遍历时不是直接在集合内容上访问的，而是先拷贝原有集合内容，遍历的是开始遍历那一刻拿到的集合拷贝，迭代器只支持不变操作，但不支持<code>remove</code>等可变操作；在进行写操作时，会重新拷贝整个/部分底层数组，并在拷贝的数组（而不是原数组）上实现写操作，这个拷贝的副本在修改过程中是不可见的，只有当修改完成时，被修改的结构才会自动与主数据结构进行交换（原子性操作），这就是 COW</p>
</li>
<li><p>拷贝使得集合上的可变操作的开销很大，而且即便存在拷贝，这些并发集合的<code>add</code>和<code>remove</code>依旧是需要加锁的，这是为了避免拷贝出 N 个副本出来，并发集合类的读操作则并没有加锁，这样的好处是可以同时进行读和写，虽然读到的可能不是最新的，这里的思想是读写分离，是弱一致性/最终一致性，而不是时刻强一致性</p>
</li>
<li><p>并发集合在内部自己管理同步，因此在使用并发集合时，不需要在外部将并发集合锁定，这样只会拖累性能，即始终不要使用<code>synchronized</code>修饰并发集合，而对于<code>synchronized</code>修饰的非并发集合，则需要分情况判断是否使用</p>
</li>
<li><p><code>synchronized</code>修饰的非并发集合无论读操作和写操作的数量如何，都具有大致相同的性能，进行读操作或者少量的写操作时，并发集合会比<code>synchronized</code>修饰的非并发集合快许多，但当进行大量写操作时，需要分别测试使用并发集合或者<code>synchronized</code>修饰的非并发集合，以确定哪种方式更优</p>
</li>
</ul>
<table>
<thead>
<tr>
<th align="center">interface</th>
<th align="center">non-thread-safe</th>
<th align="center">thread-safe</th>
</tr>
</thead>
<tbody><tr>
<td align="center"><code>List</code></td>
<td align="center"><code>ArrayList</code></td>
<td align="center"><code>CopyOnWriteArrayList</code></td>
</tr>
<tr>
<td align="center"><code>Map</code></td>
<td align="center"><code>HashMap</code></td>
<td align="center"><code>ConcurrentHashMap</code></td>
</tr>
<tr>
<td align="center"><code>Set</code></td>
<td align="center"><code>HashSet</code> / <code>TreeSet</code></td>
<td align="center"><code>CopyOnWriteArraySet</code></td>
</tr>
<tr>
<td align="center"><code>Queue</code></td>
<td align="center"><code>ArrayDeque</code> / <code>LinkedList</code></td>
<td align="center"><code>ArrayBlockingQueue</code> / <code>LinkedBlockingQueue</code> / <code>SynchronousQueue</code></td>
</tr>
<tr>
<td align="center"><code>Deque</code></td>
<td align="center"><code>ArrayDeque</code> / <code>LinkedList</code></td>
<td align="center"><code>LinkedBlockingDeque</code></td>
</tr>
</tbody></table>
<h2 id="7-2-Atomic-类"><a href="#7-2-Atomic-类" class="headerlink" title="7.2 Atomic 类"></a>7.2 Atomic 类</h2><ul>
<li><p><code>java.util.concurrent.atomic</code>包提供了一组<strong>原子操作</strong>的封装类（<code>Atomic</code>），适用于计数器、累加器等</p>
</li>
<li><p><code>Atomic</code>类是通过乐观锁的方式实现线程安全的，主要原理是利用了 CAS（Compare and Set），当准备更新<code>Atomic</code>对象时，会将旧值和新值一起提交给<code>compareAndSet</code>方法，如果旧值和当前在<code>Atomic</code>对象中发现的值不一致，则更新失败</p>
</li>
<li><p>需要注意的是，<code>Atomic</code>类对象只有在非常简单的情况下有用，这些情况通常包括只有一个需要被修改的<code>Atomic</code>类对象，并且这个对象独立于其他所有的对象，更加安全的做法是以更加传统的锁入手，只有在性能方面存在问题时，才尝试替换为<code>Atomic</code></p>
</li>
</ul>
<h1 id="8、线程池"><a href="#8、线程池" class="headerlink" title="8、线程池"></a>8、线程池</h1><p>为了避免频繁创建和销毁线程，考虑复用一组线程来执行多个任务，而不是每个任务都对应一个新线程。这种能够接收大量任务并进行分发处理的一组线程就是线程池，线程池内部维护了若干个线程，没有任务时，这些线程都处于 Waiting 状态。</p>
<h2 id="8-1-线程池类"><a href="#8-1-线程池类" class="headerlink" title="8.1 线程池类"></a>8.1 线程池类</h2><p>Java标准库提供了<code>ExecutorService</code>接口表示线程池，<code>ExecutorService</code>知道如何构建恰当的上下文来执行<code>Runnable</code>对象，<code>ExecutorService</code>接口的常用实现类有：</p>
<ul>
<li><p><code>FixedThreadPool</code>：线程数固定的线程池</p>
</li>
<li><p><code>CachedThreadPool</code>：线程数根据任务动态调整的线程池，在程序执行过程中通常会创建与所需数量相同的线程，然后在它回收旧线程时停止创建新线程，是合理的线程池首选，只有当这种方式会引发问题时，才需要切换到<code>FixedThreadPool</code></p>
</li>
<li><p><code>SingleThreadExecutor</code>：仅单线程执行的线程池，就像是数量为1的<code>FixedThreadPool</code>，适用于希望在另一个线程中连续运行的任何长期存活的任务，或是一系列串行执行的短任务</p>
</li>
<li><p><code>ThreadPoolExecutor</code>：可以指定动态线程数范围，线程存活时间以及使用队列的线程池</p>
</li>
<li><p><code>ScheduledThreadPool</code>：用于执行需要定期反复执行的任务</p>
</li>
</ul>
<h2 id="8-2-线程池的创建"><a href="#8-2-线程池的创建" class="headerlink" title="8.2 线程池的创建"></a>8.2 线程池的创建</h2><p><code>Executors</code>类（静态工具类）中封装了很多创建各种线程池类型的静态工厂方法，但是使用这些工厂方法会存在一些弊端，比如创建出的线程池使用无界队列或者允许的最大线程数过大（<code>Integer.MAX_VALUE</code>），就会堆积大量请求或线程，最终导致内存溢出，因此不建议使用<code>Executors</code>，而是应该通过创建<code>ThreadPoolExecutor</code>实例的方式来创建线程池，规避资源耗尽的风险。</p>
<p>线程池的本质是一个<code>HashSet</code>，元素类型是<code>Worker</code>（<code>Runnable</code>的实现类），当给线程池提交任务时，如果当前线程数低于核心线程数，则增加核心线程来执行任务，当当前线程数达到核心线程数时，任务缓存在阻塞队列中排队，当队列已满时，增加非核心线程数来执行任务，当当前线程数达到最大线程数时，触发阻塞队列的饱和/拒绝策略<code>RejectedExecutionHandler</code>来判断如何处理新任务。</p>
<ul>
<li><p>如果线程池没有自定义<code>RejectedExecutionHandler</code>，Java 提供了四种内置的拒绝策略，默认会使用 AbortPolicy，会抛出<code>RejectedExecutionException</code>并丢弃该任务，此外，DiscardPolicy 会默默地丢弃任务而不抛出异常，一般用于日志记录等非关键场景；DiscardOldestPolicy 会尝试将任务队列中最早的任务删除，然后再尝试提交新任务，一般用于实时性要求较高的场景；CallerRunsPolicy 会将任务回退给调用线程（不会抛出异常），调用线程会尝试执行任务，这种处理会降低任务提交速度，适用于任务提交者能够承受任务执行压力但希望有一种缓冲机制的情况</p>
</li>
<li><p>如果线程池使用无界队列<code>LinkedBlockingQueue</code>，其最大长度为<code>Integer.MAX_VALUE</code>，容易在队列中堆积大量请求；如果线程池使用不存储元素的队列<code>SynchronousQueue</code>，则相当于队列永远是满的；一般使用有界队列<code>ArrayBlockingQueue</code>并配合<code>RejectedExecutionHandler</code>一起</p>
</li>
<li><p><strong>线程池中线程的数量并不是越多越好，具体的数量需要评估每个任何的处理时间以及当前计算机的处理器能力和数量</strong>，使用的线程过少，无法发挥处理器的性能；使用的线程过多，将会增加系统的无故开销，起到相反的作用</p>
</li>
<li><p>一般在刚上线时先根据公式（CPU 密集型应用线程数设为 N+1，I/O 密集型应用线程数设为 2N+1，N 为 CPU 核数）设置一个大致初始线程数，然后再通过压测来不断调整至合理数值</p>
</li>
<li><p>不能把大量不同类型的请求提交给同一个线程池，否则当某种类型请求流量过高时，线程池流量过载，进而导致其他类型的请求也都全部崩溃</p>
</li>
<li><p>对 I/O 等阻塞操作的优化优先于对线程池的优化</p>
</li>
</ul>
<h2 id="8-3-线程池的操作"><a href="#8-3-线程池的操作" class="headerlink" title="8.3 线程池的操作"></a>8.3 线程池的操作</h2><p>JUC 尽可能避免对<code>Thread</code>对象的直接操作，而是尽量通过线程池来执行所有操作</p>
<ul>
<li><p>线程池的<code>submit</code>方法用于提交要执行的任务，该方法的入参是一个<code>Runnable</code>接口的实现类，并返回一个<code>Future&lt;?&gt;</code>，通过调用该返回值的<code>cancel</code>方法，它就会拥有在该线程上调用<code>interrupt</code>以停止这个线程的权限</p>
</li>
<li><p>线程池的<code>shutdown</code>、<code>shutdownNow</code>方法都可以用于程序结束时关闭线程池，<code>shutdown</code>会等待线程池中正在执行以及队列中的任务先完成，然后再关闭，<code>shutdownNow</code>会立即停止正在执行的任务（发送一个<code>interrupt</code>调用给它启动的所有线程）</p>
</li>
<li><p>当<code>corePoolSize</code>为零时，池内线程在执行完任务后会在达到<code>keepAliveTime</code>后被 JVM 回收，当<code>corePoolSize</code>大于零时，应该在<code>destory</code>方法中调用线程池的<code>shutdown</code>方法，否则池内线程将不会被回收，并产生内存泄漏问题</p>
</li>
<li><p><code>awaitTermination</code>方法通常放在<code>shutdown</code>方法后面用来判断固定时间后线程池是否关闭</p>
</li>
<li><p>针对<code>ScheduledThreadPool</code>类线程池，通过<code>schedule</code>方法来提交只执行一次的任务，通过<code>scheduleAtFixedRate</code>或<code>scheduleWithFixedDelay</code>方法来提交需要多次反复执行的任务，这三个方法均可设置任务的延迟，<code>scheduleAtFixedRate</code>和<code>scheduleWithFixedDelay</code>均可设置任务执行次数</p>
</li>
<li><p><code>FixedRate</code>和<code>FixedDelay</code>的区别在于：<code>FixedRate</code>是指任务总是以固定时间间隔触发，不管任务执行多长时间；<code>FixedDelay</code>是指上一次任务执行完毕后，等待固定的时间间隔，再执行下一次任务</p>
</li>
<li><p>在<code>FixedRate</code>模式下，假设每秒触发，如果某次任务执行时间超过1秒，后续任务执行可能会延迟开始，但不会并发执行</p>
</li>
<li><p>如果任务抛出了异常，将禁止后续任务的执行</p>
</li>
</ul>
<h2 id="8-4-任务执行结果"><a href="#8-4-任务执行结果" class="headerlink" title="8.4 任务执行结果"></a>8.4 任务执行结果</h2><p>用线程池执行任务时，提交的任务只需实现<code>Runnable</code>接口即可，可如果需要获取任务执行的返回值或异常，则需要<strong>向<code>ExecutorService.submit</code>方法传入一个实现了<code>Callable</code>接口的任务，<code>submit</code>方法会返回一个<code>Future</code>类型的实例</strong>（代表一个<strong>未来</strong>能获取结果的对象）。与<code>Runnable</code>接口不同的是，<code>Callable</code>接口所定义的任务有返回值并且可以返回指定类型的结果，<code>Callable</code>接口所定义的任务可以抛出受检异常，<code>Callable</code>接口不可以应用于<code>Thread</code>类。</p>
<ul>
<li><p>返回的<code>Future</code>类型的泛型与<code>Callable</code>接口的泛型一致，从而达到指定类型的目的</p>
</li>
<li><p><code>Future.get()</code>用于获取指定类型的任务结果实例<code>result</code>或者任务执行的异常，可能会阻塞，需要等待</p>
</li>
<li><p><code>Future.get(long timeout, TimeUnit unit)</code>只等待指定的时间</p>
</li>
<li><p><code>Future.cancel(boolean mayInterruptIfRunning)</code>用于取消当前任务</p>
</li>
<li><p><code>Future.isDone()</code>用于判断任务是否已完成</p>
</li>
</ul>
<p>注：</p>
<ul>
<li><p>Java 主线程和子线程是并发执行的独立单元，因此主线程无法直接捕获子线程的异常，因此只能通过<code>Future</code>来间接获取子线程所执行任务的异常，也可以给子线程设置<code>UncaughtExceptionHandler</code>来处理未捕获的子线程中的异常</p>
</li>
<li><p>每个 Java 都是相对独立的执行单元，拥有独立的执行上下文，一个线程中的异常只会影响该线程本身，其他线程均不受影响，因此 JVM 并不会因为一个线程的异常就退出 JVM 进程</p>
</li>
</ul>
<h2 id="8-5-任务拆解"><a href="#8-5-任务拆解" class="headerlink" title="8.5 任务拆解"></a>8.5 任务拆解</h2><p>Java 7 开始引入了<code>Fork/Join</code>线程池：基于“分治”思想将大任务分解成小任务，利用多核 CPU 并行执行</p>
<ul>
<li><p><code>Fork/Join</code>线程池由<code>ForkJoinPool.commonPool()</code>方法创建得到，线程池的<code>invoke</code>方法用于提交要执行的任务，任务类必须继承自<code>RecursiveTask</code>或<code>RecursiveAction</code>类</p>
</li>
<li><p><code>ForkJoinPool</code>是基于工作窃取算法实现的线程池，池中每个线程都有自己的工作队列，用于存储待执行的任务，当一个线程执行完自己的任务之后，会从其他线程的工作队列中窃取任务执行，以此来实现任务的动态均衡和线程的最大利用率</p>
</li>
<li><p><code>ForkJoinPool</code>中的任务通常是一些可以分割成多个独立子任务的任务（例如快速排序），这些独立子任务由不同的线程来执行，这个过程中<code>ForkJoinPool</code>会自动管理任务的执行、分割和合并，实现任务的最优化执行</p>
</li>
<li><p>与普通线程池中的工作线程不同，<code>ForkJoinPool</code>中的工作线程会自动地创建、销毁以及数量的动态调整，线程池的管理成本很低，而<code>ExecutorService</code>则需要手动定义线程池相关的各种参数控制</p>
</li>
</ul>
<h2 id="8-6-任务编排"><a href="#8-6-任务编排" class="headerlink" title="8.6 任务编排"></a>8.6 任务编排</h2><p>Java 8 开始引入<code>CompletableFuture</code>，<code>CompletableFuture</code>提供了一系列简单明了的链式调用来实现异步任务编排以及事件驱动编程（<a href="https://juejin.cn/post/7140244126679138312">具体使用参考</a>）</p>
<ul>
<li><p><code>CompletableFuture</code>可以<strong>传入</strong>一个实现了<code>Supplier</code>接口的<strong>回调对象</strong>，当异步任务完成或者发生异常时，能够自动调用回调对象的回调方法，当主线程设置好回调之后，不需再关心异步任务的执行，此时不再需要使用会导致主线程被迫等待的<code>Future.get</code>方法或轮询<code>Future.isDone</code>方法</p>
</li>
<li><p><code>CompletableFuture</code>底层实现主要涉及到了<code>Completion</code>链式异步处理、事件驱动、<code>ForkJoinPool</code>线程池、<code>CountDownLatch</code>控制计算状态、<code>CompletionException</code>捕获异常等（<a href="https://www.yuque.com/hollis666/niq4hm/qgrygdsu04a6vfzw">具体原理参考</a>）</p>
</li>
<li><p><code>CompletableFuture</code>底层使用<code>ForkJoinPool</code>而不是<code>ExecutorService</code>是因为它的执行模型和任务分割与<code>ForkJoinPool</code>的理念更加匹配</p>
</li>
</ul>
<h1 id="9、虚拟线程-协程"><a href="#9、虚拟线程-协程" class="headerlink" title="9、虚拟线程/协程"></a>9、虚拟线程/协程</h1><h2 id="9-1-问题与解决"><a href="#9-1-问题与解决" class="headerlink" title="9.1 问题与解决"></a>9.1 问题与解决</h2><p><code>CompletableFuture</code>便于编排存在先后依赖关系的异步任务，一定程序上提高了 CPU 利用率，但是当任务请求数大于服务最大线程数且当前线程都阻塞时，新的任务必须等待直到有新的空闲线程，这个等待过程中 CPU 依旧是空闲的。</p>
<ul>
<li><p>考虑到这种突发流量可能并不是长期持续存在的情况，且创建太多线程会消耗大量资源（线程的上下文切换，占据大量内存等）</p>
</li>
<li><p>常见的方案是升配扩容（垂直扩展，升级机器配置，水平扩展，增加服务节点），缺点是会增加成本，同时有些场景下扩容并不一定能解决问题</p>
</li>
<li><p>异步/响应式编程使用事件驱动即可通过少量线程实现高吞吐的请求处理，但与目前的任务请求和线程一对一的模型差异较大，存在兼容性问题</p>
</li>
<li><p>JDK21 提供了与<code>Thread</code>完全一致的抽象<code>VirtualThread</code>，将平台线程的阻塞变为虚拟线程的阻塞，使得平台线程可以继续处理新的任务请求，减少了线程上下文切换，提高了 CPU 利用率</p>
</li>
</ul>
<h2 id="9-2-虚拟线程"><a href="#9-2-虚拟线程" class="headerlink" title="9.2 虚拟线程"></a>9.2 虚拟线程</h2><ul>
<li><p>平台线程</p>
<ul>
<li><p>对应<code>Thread</code>实例，Java 作为跨平台的编程语言，平台线程的实现是依赖于具体的操作系统的，可以看作是 Java 对操作系统内核线程的包装</p>
</li>
<li><p>操作系统内核线程由操作系统管理，是操作系统调度的基本单元，因此平台线程的创建、调度都需要切入内核态，成本比较高</p>
</li>
<li><p>可以在底层操作系统线程上运行 Java 代码，并在代码所定义的任务的整个生命周期内独占操作系统线程</p>
</li>
<li><p>和操作系统线程是一对一的映射关系，数量受限于操作系统线程的数量</p>
</li>
</ul>
</li>
<li><p>虚拟线程</p>
<ul>
<li><p>虚拟线程就是协程，在 JDK 19 中只是一个预览 API，默认是禁用的，但在 JDK 21 中成为正式功能</p>
</li>
<li><p>虚拟线程对应<code>VirtualThread</code>实例，由 JVM 管理，不与特定的操作系统线程或平台线程相绑定，是作为普通 Java 对象存储在 RAM 中</p>
</li>
<li><p>虚拟线程总是守护线程（意味着 JVM 不会等待虚拟线程执行完成后才退出）且总是具有不可更改的 normal 的优先级，即使调用<code>setDaemon(false)</code>也不能将虚拟线程更改为非守护线程，调用<code>setPriority</code>也不能更改虚拟线程的优先级，也不支持<code>stop()</code>、<code>suspend()</code>、<code>resume()</code>方法，这三个方法在调用时会抛出<code>UnsupportedOperationException</code></p>
</li>
<li><p>Java 代码所定义的任务被提交给虚拟线程，但虚拟线程不能独立执行任务，而是需要将虚拟线程挂载到一个平台线程，在平台线程上运行 Java 代码</p>
</li>
<li><p>真正负责执行虚拟线程中任务的平台线程就称为虚拟线程的载体线程，代码所定义的任务的整个生命周期内不独占载体线程，可以多个虚拟线程共享同一个载体线程</p>
</li>
<li><p>当任务需要阻塞或挂起时，虚拟线程会从平台线程上卸载，释放平台线程资源以供其他任务使用，高并发场景下可以有效利用系统资源，当任务解除阻塞继续执行时，虚拟线程重新装载到平台线程上，并从阻塞点继续执行</p>
</li>
<li><p>挂载和装载的过程在 Java 代码不可见，会产生一个虚拟线程始终在同一个载体线程上运行的假象，但在同一虚拟线程上多次调用的代码实际每次可能使用不同的载体线程，JDK 使用了 FIFO 模式的<code>ForkJoinPool</code>作为虚拟线程的调度器</p>
</li>
<li><p>可以通过轻量级的任务队列来调度多个虚拟线程，避免了平台线程间基于内核的上下文切换开销，且虚拟线程的创建和销毁的开销很低，数量不受限制，可以比平台线程的数量大得多，无需池化</p>
</li>
</ul>
</li>
</ul>
<h1 id="10、分布式锁"><a href="#10、分布式锁" class="headerlink" title="10、分布式锁"></a>10、分布式锁</h1><p>参见 <a href="../../../../2024/02/06/distributed-system/">Distributed System</a> 的 5.1 小节和 <a href="../../../../2024/02/18/redis/">Redis</a> 的 4.3 小节</p>
<h1 id="11、参考资料"><a href="#11、参考资料" class="headerlink" title="11、参考资料"></a>11、参考资料</h1><ul>
<li>《Java并发编程的艺术》</li>
<li>《Effective Java (Third Edition)》</li>
<li>《Thinking in Java (Fourth Edition)》</li>
<li><a href="https://www.liaoxuefeng.com/wiki/1252599548343744/1255943750561472">https://www.liaoxuefeng.com/wiki/1252599548343744/1255943750561472</a></li>
<li><a href="https://juejin.cn/post/6854573217244413966">https://juejin.cn/post/6854573217244413966</a></li>
<li><a href="http://www.cyc2018.xyz/Java/Java%20%E5%B9%B6%E5%8F%91.html">http://www.cyc2018.xyz/Java/Java%20并发.html</a></li>
<li><a href="https://mp.weixin.qq.com/s/vdLXhZdWyxc6K-D3Aj03LA">https://mp.weixin.qq.com/s/vdLXhZdWyxc6K-D3Aj03LA</a></li>
</ul>
]]></content>
  </entry>
  <entry>
    <title>Java Web</title>
    <url>/2023/01/01/java-web/</url>
    <content><![CDATA[<h1 id="Web-系统"><a href="#Web-系统" class="headerlink" title="Web 系统"></a>Web 系统</h1><p>C/S 系统的核心思想是：中央服务器存储有某种数据，服务器可以根据需要将数据分发给某些客户集群，这些数据也可以被客户修改，即服务器指信息存储池、用于分发信息的软件以及信息与软件所驻留的机器或机器集群，客户指与服务器进行通信以获取信息、处理信息的机器或机器集群。</p>
<p>C/S 系统所面临的问题在于，单一的服务器需要同时为多个成百上千个计算机类型和不同操作系统类型的客户服务，任何小的信息分发延迟都会产生重大影响，需要一种通用的信息分发解决方案来统一将所有特定类型的信息分发的延迟最小化。</p>
<p>Web 作为一个巨型 C/S 系统，能够提供一个通用的信息分发解决方案，即客户机对某个服务器产生一个请求，然后服务器返回一个静态文件，客户机上的 Web 浏览器软件根据本地机器的格式来解读服务器返回的文件（一段信息不经任何修改就可以在任意型号的计算机上显示）</p>
<h2 id="客户端编程"><a href="#客户端编程" class="headerlink" title="客户端编程"></a>客户端编程</h2><p>最初的浏览器只是一个观察器，它不能执行任何计算任务，另一方面，它也是安全的，因为它在本地机器上不会执行任何程序，而这些程序有可能包含 bug 和病毒。因此当客户机所发出的请求中存在错误时，依旧需要等待服务器返回响应后才能发现请求中的错误。</p>
<p>这个问题的解决方法就是客户端编程，客户端编程意味着 Web 浏览器逐渐成为一个强有力的引擎，能用来执行任何它可以完成的工作，使得返回给用户的结果更加迅速。与通常意义上的编程不同的是，客户端编程是基于 Web 浏览器（而非操作系统）来产生解决方案的编程。</p>
<ul>
<li>插件<ul>
<li>程序员可以下载一段代码（插件）并插入到浏览器中适当的位置，以此来为浏览器添加各种更快更强大的新功能</li>
<li>插件提供了一个“后门”，允许专家级的程序员不需经过浏览器生产厂商的许可，就可以开发某种客户端编程语言扩展，并将它们添加到服务器中</li>
</ul>
</li>
<li>脚本语言<ul>
<li>插件引发了浏览器脚本语言的开发，通过使用某种脚本语言，可以将客户端程序的源代码直接嵌入到 HTML 页面中，那么脚本语言会在 HTML 页面被显示时自动激活</li>
<li>脚本语言提供了更加容易、快捷的开发方式，可以解决客户端编程中所遇到的80%的问题，因此在解决问题时，应当优先考虑脚本语言，而非 Java 这样的更复杂的解决方案</li>
<li>脚本代码会暴露给任何人去浏览，因此通常不会使用脚本语言来做复杂的事情</li>
</ul>
</li>
<li>Java<ul>
<li>对于脚本语言解决不了的客户端编程的问题，Java 是最流行的解决方案，Java 是通过 applet 以及使用 Java Web Start 来进行客户端编程的</li>
<li>applet 是运行在 Web 浏览器中的小程序，是作为网页的一部分（就像网页中的图片）而自动下载的，当 applet 被激活时，它便开始执行一个程序，程序员只需创建单一的程序，只要浏览器具有内置的 Java 解释器，那么这个程序就可以自动在这台计算机上运行</li>
<li>此时，客户端可以在请求提出之前和之后做尽可能多的事情，例如不必跨网络地发送一张请求表单来检查自己是否填写了错误的日期或其他参数，客户端本身可以快速地标出错误数据</li>
</ul>
</li>
</ul>
<h2 id="服务器端编程"><a href="#服务器端编程" class="headerlink" title="服务器端编程"></a>服务器端编程</h2><p>大部分请求是要求服务器发送一个文件，然后浏览器会以某种适当的形式来解释这个文件，例如将其作为 HTML 页面、图片、Java applet 或脚本程序等来解释。更复杂的对服务器的请求通常涉及数据库事务，甚至涉及到对数据库数据的修改，这类请求必须通过服务器端的某些代码来处理，这就是服务器编程。</p>
<p>基于 Java 的 Web 服务器是用 Java 编写被称为 servlet 的程序来实现服务器端编程，servlet 及其衍生物 JSP 消除了处理具有不同能力的浏览器时所遇到的问题。Web 系统是最常见的 Java 应用系统之一，Web 服务器经常包含多个 servlet，并发是充分利用这些 servlet 的理想方式，当有 Web 请求时，servlet 就会异步执行，原则上，每次 servlet 都是在自己的小世界中执行，与其他 servlet 的执行相分离。</p>
<p>容器是一种为特定组件的运行提供必要支持的一个软件环境（组件运行环境和底层服务），Tomcat 是一个 servlet 容器，底层实现了 TCP 连接，解析 HTTP 协议等非常复杂的服务，它可以为 servlet 的运行提供运行环境。如果没有容器来提供这些服务，就无法编写 servlet 这样代码简单，功能强大的组件。</p>
<p>基于标准 JDK 的开发都是 JavaSE，JavaEE 是在 JavaSE 的基础上，开发的一系列基于各种服务器的组件、API 标准和通用架构。<strong>JavaEE最核心的组件就是基于 servlet 标准的 Web 服务器</strong>，开发者编写的应用程序是基于 servlet API 并运行在 Web 服务器内部的。服务器端编程是 Java 取得巨大成功的因素之一。</p>
<h2 id="性能指标"><a href="#性能指标" class="headerlink" title="性能指标"></a>性能指标</h2><p>QPS (Query Per Second) 是系统每秒能处理的请求数，有时候也称之为吞吐量，可以通过提升 CPU 利用率、增加 CPU 数量、提升内存等方式来提升 QPS</p>
<p>RT (Response Time) 是客户端发出一个请求开始到客户端接收到从服务器端返回的响应结果所经历的响应时间</p>
<p>并发用户数是 QPS 和 RT 的乘积，是某一时刻与服务器进行了交互的在线用户数量</p>
<p>最佳线程数是一个项目最多可以容纳（包含排队的用户）的用户数量，在性能压测时，随着用户数量的增加，起初 QPS 会上升，且 CPU 负载没有明显变化，当用户数量达到一定阈值之后，QPS 不再有明显上升，且 CPU 负载飙高、内存使用急剧增大，RT 大幅增加，那么这个阈值就认为是最佳线程数</p>
<p>当并发用户数超过最佳线程数时，会产生激烈的系统资源竞争，随着资源的枯竭，系统就会崩溃</p>
<h1 id="Tomcat"><a href="#Tomcat" class="headerlink" title="Tomcat"></a>Tomcat</h1><p>Tomcat 是一个基于 Servlet 规范的 Java Web 应用程序服务器，Tomcat 和 Web 服务器（如 Apache、Nginx 等）之间通常是配合使用的，Apache 充当前端服务器，负责接收客户端的请求，处理一部分静态内容请求，并将动态内容请求转发给 Tomcat 进行处理，即 Tomcat 专注于处理动态请求，这种动态请求与静态请求相分离使得整体请求处理效率更高。</p>
<h2 id="请求处理"><a href="#请求处理" class="headerlink" title="请求处理"></a>请求处理</h2><p>Tomcat 启动入口就是<code>Bootstrap</code>类的<code>init</code>、<code>load</code>、<code>start</code>方法，<code>init</code>方法会加载启动相关的类加载器及类；<code>load</code>方法会加载配置文件（<code>server.xml</code>和<code>web.xml</code>），初始化组件；<code>start</code>方法会启动服务，扫描指定的 Web 应用程序目录，部署打包好的 Web 应用；Web 应用启动后，Tomcat 通过连接器监听指定的端口和协议，接收来自客户端的 HTTP 请求。</p>
<ul>
<li>接收到的请求会先经过过滤器 Fliter 的处理（比如安全验证、日志记录等），过滤器是基于 Java Servlet 规范实现的，可以通过配置<code>web.xml</code>来实现</li>
<li>过滤器处理通过之后，Tomcat 会解析请求信息（URL、方法、请求头参数等），根据解析信息从把请求交给对应的 Servlet 容器</li>
<li>Servlet 通过执行其中的 Service 方法来处理请求，处理结束后把请求的响应发送回客户端，Servlet 容器可能在处理请求前后被拦截器 Intercepter 拦截，拦截器会执行额外的逻辑以对请求进行更加精细的控制（比如 AOP、权限控制、事务管理等），拦截器是基于 Spring 实现，可以在 Spring MVC 中配置实现</li>
</ul>
<p>Tomcat 作为一个 Web 容器可能需要部署多个 Web 应用，不同的应用程序可能会依赖同一个第三方类库的不同版本，这些不同版本的类的全路径名可能是一样的，如果采用双亲委派原则则无法加载这些不同版本的路径名相同的类，因此 Tomcat 的类加载机制并没有严格遵守双亲委派原则，而是采用一种层次化的类加载器结构，每个应用都由一个独立的 WebappClassLoader 进行加载，可以提供更好的隔离性和灵活性，以支持多个 Web 应用程序的部署和运行。</p>
<p>Tomcat 的主要应用场景是处理高并发、短连接请求，Tomcat 的默认线程池中使用了很多优化策略以尽可能有效地减少线程创建和销毁的开销，提升线程池的吞吐量和性能，默认最大线程数是 200，默认最小空闲线程数是 10，这种设置可以满足大多数的应用场景，但在实际应用中，也应该根据实际情况进行充分压测之后再确认合理的配置。</p>
<h2 id="I-O-模型"><a href="#I-O-模型" class="headerlink" title="I/O 模型"></a>I/O 模型</h2><p>Tomcat 支持多种 I/O 模型，可以在<code>server.xml</code>中通过配置 Connecter 来选择不同的 I/O 模型，一般使用 NIO 或者 NIO2</p>
<ul>
<li>BIO 是最传统的线程模型，也称为阻塞 I/O，每个客户端连接都由一个独立的线程处理，当并发连接数较大时会导致线程数急剧增加，占用大量系统资源，也有较大的线程切换开销</li>
<li>NIO 是 Java 的新 I/O 库，通过使用 Java NIO 选择器，一个线程可以同时处理多个客户端连接请求，NIO 模型相对于 BIO 来说能够支持更多的并发连接，并且在连接数较大时依旧保持较少的系统资源消耗，但需要在应用层处理 I/O 事件，编程较为复杂</li>
<li>NIO2 是 Java 进一步改进的 NIO 模型，也称 AIO，提供了更多的异步 I/O 操作，包括异步文件 I/O、异步套接字 I/O 等，使得 Tomcat 能够更好地支持异步请求处理，提高处理性能和效率</li>
<li>APR 是 Apache 提供的，为应用程序提供了跨平台的抽象层，提高了高性能的本地 I/O 支持，Tomcat 可以直接利用本地操作系统的底层异步 I/O 特性进行 I/O 操作，在高并发场景下性能非常出色</li>
</ul>
<h1 id="Netty"><a href="#Netty" class="headerlink" title="Netty"></a>Netty</h1><p>Netty 提供异步的、基于事件驱动的网络应用程序框架，可以快速开发高性能、高可靠的网络 I/O 程序，主要用来做网络通信，可以用作 RPC 框架的通信工具，实现即时通信系统。</p>
<p>相比于 Java NIO，Netty 封装了 NIO 库中繁琐的 API，采用非阻塞 I/O 模型和 I/O 多路复用，预制了多种编码能力，支持多种主流协议，采用，也具备很强的定制能力，吞吐量高、低延迟、资源消耗低，开箱即用，使用方便，性能出色，功能强大。</p>
<ul>
<li>零拷贝<ul>
<li>操作系统中的零拷贝是指避免在用户态和内核态之间来回拷贝数据，而 Netty 的零拷贝是指在操作数据时不需要将数据从一个内存区域拷贝到另一个内存区域（比如直接使用堆外内存等），从而提升 CPU 效率</li>
</ul>
</li>
<li>线程模型<ul>
<li>单 Reactor 单线程模型，一个 Reactor 既负责处理连接请求，又负责处理读写请求，只能对应一个 CPU，无法发挥多核 CPU 的优势</li>
<li>单 Reactor 多线程模型，增加了一个 Worker 线程池，Reactor 将业务处理逻辑交由线程池处理，但还是既负责处理连接请求，又负责处理读写请求</li>
<li>主从 Reactor 模型，主 Reactor 主负责连接请求，读写请求全部交给子 Reactor 处理，这样即使在数据准备阶段子 Reactor 被阻塞，主 Reactor 还是可以处理连接事件</li>
</ul>
</li>
<li>无锁串行化设计<ul>
<li>Netty 基于 Reactor 线程模式以及多路复用器实现并发请求处理，避免了线程阻塞和锁竞争</li>
<li>Netty 通过对象池来减少对象的创建和销毁，从而在一定程度上避免锁竞争</li>
<li>Netty 将很多组件都设计为线程安全的，从而避免锁竞争</li>
</ul>
</li>
<li>ByteBuffer 实现<ul>
<li>Java NIO 中原生的 ByteBuffer 不易操作，不能扩容，Netty 重新封装了自己的 ByteBuffer，使用更加简洁，可以根据写入数据的字节数来自动扩容，性能也更好</li>
</ul>
</li>
<li>对象池<ul>
<li>对象池可以避免频繁地创建和销毁对象，尤其是在多线程环境中可以有效地减少线程上下文切换和资源的浪费，提升系统的性能，字符串池就是一种对象池技术</li>
<li>Netty 内置了对象池，从而重复利用一些已经创建的对象</li>
</ul>
</li>
<li>序列化协议<ul>
<li>市面上常见的序列化协议基本上 Netty 都支持，如 Java 原生的序列化（性能较差，不能跨语言）、JSON（轻量级、跨语言，广泛用于分布式）、XML（跨语言）、Protobuf、Thrift 等</li>
</ul>
</li>
</ul>
<h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><ul>
<li>《Thinking in Java, Fourth Edition》</li>
<li>《Thinking in Enterprise Java》<strong>TBR</strong></li>
</ul>
]]></content>
  </entry>
  <entry>
    <title>Apache JMeter</title>
    <url>/2023/02/11/jmeter/</url>
    <content><![CDATA[<div class="hbe hbe-container" id="hexo-blog-encrypt" data-wpm="Oh, this is an invalid password. Check and try again, please." data-whm="OOPS, these decrypted content may changed, but you can still have a look.">
  <script id="hbeData" type="hbeData" data-hmacdigest="575acc451cc918f8ec5b68416b56ad003c3064d84d1c1881af226fe557f02a64">a99f2d1cd7f89812758242c57c62a59ff18e2574f2811713a3ac8a0f59b648bc0ceb90285066d29728c7474ab71f48b025d07546b877b71e9d532e41ea64d963d012557d9fb35009d84bcab05245358fc5a2be5a76d15c9815e8dc021e4927a62b4b131d0b4aa61fb252e386d95fa2e4244fdc3e4487e2876e8342449d9f5ee0628310d339bdd78f24e6d71d73d57f0b00c5c14bcdc890a8115308a0d60b514cad4da194fb86a337422c1584ad45c7fd8af2f03046b3f86a506176dd23f8438a9f18259b6bcdb10320c8d435c3c1c199cb9df132051abdf4df2df313fc1060ec4fa8adb6b915c81f50396d5ba90a602dc93604ea3db74aacbcbc8897cd32f2c7981bdd43ca1ef913b998320c765a8fc2b283402130332d512246ee9256ba49059cfbd09bee32484b83a8ac604cd7ab361ecd6e5c2d4f923f88ca96c31d12ebae376212e500ee93c850835458829486ea735c1a129401cc00b235ae35b5a356c411f2f982505a496563d4a3ee01af843daa2454063a6942aa6bcae3387d199f1de8ab0491ae5bfb1bcc264e35ebd4adcd45bdb78b60f0baac4f788c0f5136a24e1eece3a2c48d9b798397ec7477c1415ab401086ebfb8e3c9fcf5c9e2b2101938f399fbaffcc1736bd8433439ceea087fd59ceca4d54a612c931f2391a04b05c36dff0a5d24b148dfbbf2a47658f3949ba07fa04a2e92745ca4389b2f67d57d2bbc431c8b4012a68034c723c5ef93452bc2acc3d821b3c64cd78502cc8722fba1a7f81278da6a4bee3b185ca83418372d74c623a8aa1e5e2903363f975f5fbf4a80edb1b5ba854dfba4b8a9a8ac777f6427d25415cbe04f3cfcb91ff641653c9b43b15227cfd22bb6ed17614ce166d991e7681ac784a4105175e5fff1799f121e03ae0d88936643797e17c560cb097f892e9420937fd6f3f4ae7f1740e71f4327b5084e58bc48a6a64f699189f86b4cf29bacda4e0c910ef70bc2edfbb0c881f33719efdf62f0892f7801e9d8b3a26f4f5c4e8ece97fc40a5cd4f7ae5b1db306ce75c9fc3f2c28851df416ab928c99f6fa16aa4ddb2879c3abdc5bacc23c62f1fa24bf3fc3709f8656b1c92af33b63c476e534e54f11ada00c0663ed48ed977c306fdc7e0e133a023cbe0ca3000d5a22437883dc1b36c5f317226bd78261773dca98cd8513c7b9a8cdbdf6a3aa29c3866e49b9d5ae067a21b92297f42c43155c96722bf1fa45f4c109d1781e0ab0f77871ed2f848c7990b0522ddc844c88946a49cbff25ddf77ef1dd54b031361c761b72de0a55505f890a4488c5755a62eb54a25b2ccc4220fce8e981be14fe0c4ef436a27f88485e39786ad2f79cad5aa710ec3793e67381fcc7e95e270b7405246a419d96fd38d6dd1baacbe8dd5ee8073364118a4977f6728538775044f1e0ea28a57b864c0e6f348a1556e5ef06a524415460ba3338000b39a3e2c3db9d61faa535bd3d74cc72dc5a99a5d640ad936df6fa47d9bb7721de26d63155acff21c88df39376b73c415087812ffedfbff0b2c3a2156831d884a4c4f8b2511453c5381ecd806778f7e130fe73f76c2dd4ba68e5a92414ed5088cba8e6a0fc974d15a042e7342e6f1a362b06a748bb254df4eec964e650d05f3ed806ef8febffe48c6d3da6ff09cad717bd811cd8bb8e3a217b597f72b061575400892ccc4ff6a44eea99966d52afdca4604858b4bdaacbef3cad697b5f94bb578b611316b433c15eea9107b8c016f5702c6d474fb7590a77cfa615e3138f450068284b0d7bb0e0f6b27eafd0079451b0c19c53407b800ae6160456806d836794a89a418b7e330a869f986709f2577a8912fe8e41204d41950c3b4b9287e4beaf5343adb0d1ded7499c4279258400300fe77a20210eda7fc1babb126bda71feb14cd297e1818aa74ecf6e8db71f195ca6d4254904b199ca811e1521f8f0784c13634cb324525b720d4072e3df2cb52c2ef4ea41edd41c5af4a9ba9065666a03fda1758b5985bbe082911234a4abd42511e8181f842cb752db2a4b9</script>
  <div class="hbe hbe-content">
    <div class="hbe hbe-input hbe-input-default">
      <input class="hbe hbe-input-field hbe-input-field-default" type="password" id="hbePass">
      <label class="hbe hbe-input-label hbe-input-label-default" for="hbePass">
        <span class="hbe hbe-input-label-content hbe-input-label-content-default">Hey, password is required here.</span>
      </label>
    </div>
  </div>
</div>
<script data-pjax src="/lib/hbe.js"></script><link href="/css/hbe.style.css" rel="stylesheet" type="text/css">]]></content>
  </entry>
  <entry>
    <title>Kubernetes</title>
    <url>/2022/10/03/kubernetes/</url>
    <content><![CDATA[<h1 id="英文版"><a href="#英文版" class="headerlink" title="英文版"></a><a href="../../../../2023/09/01/week-53/">英文版</a></h1><h1 id="问题与解决"><a href="#问题与解决" class="headerlink" title="问题与解决"></a>问题与解决</h1><p><strong>Kubernetes</strong>：在分布式系统中，服务集群的部署、调度、伸缩一直是最为重要也最为基础的功能，这意味着需要根据实际流量情况来动态管理容器集群。Kubernetes 是基于 Docker 的开源容器集群管理系统（如今已经是容器编排的事实标准），运行在操作系统之上并与<code>Pod</code>进行交互，目标是通过声明式配置和自动化来管理跨多个主机的容器集群，提供自动部署、回滚、存储编排、资源分配、配置管理、服务发现、负载均衡和自我修复，而用户的工作就在于配置 K8S，定义<code>Node</code>，<code>Pod</code>以及容器。</p>
<p><strong>Elastic Container Service</strong>：ECS 在一个产品中提供两个元素：容器编排平台和托管服务（运行该平台并配置硬件资源），K8S 只提供前者，组织机构越来越多地采用 K8S 托管服务而不是直接使用 K8S，这样可以降低 K8S 的使用复杂性并帮助他们更快地实现生产。</p>
<p><strong>OpenShift</strong>：对于企业级生产环境中的容器来说，仅仅只是安装 K8S 是不够的，Red Hat OpenShift 是企业版的 K8S 集成式开发运维平台，集成了 K8S 以及身份验证、网络、安全、监控、日志管理等其他工具，可通过 CI/CD 来构建和部署自动化。</p>
<h1 id="Pod"><a href="#Pod" class="headerlink" title="Pod"></a>Pod</h1><p>一个<code>Pod</code>由一组容器化应用构成，构成了一个应用所在的逻辑主机。<code>Pod</code>是 K8S 进行创建，编排及管理的最小单位，通常由 K8S 工作负载所创建，而非由用户直接创建。<code>Pod</code>被设计为是一次性可替代的组件，一旦一个<code>Pod</code>被创建后就不可以添加或删除容器，而是应该删除<code>Pod</code>并替换为一个新的<code>Pod</code>。</p>
<p>一个<code>Pod</code>中的一组容器是紧密耦合的，拥有相同的资源上下文（配置，命名空间，卷，网络等），K8S 通过<code>Pod</code>的 DNS/IP 来暴露一个<code>Pod</code>。一个<code>Pod</code>中的一组容器可以通过<code>localhost</code>来互相通信，但是当和<code>Pod</code>外部通信时，<code>Pod</code>内的容器需要协调如何共享网络资源（比如端口号）。</p>
<p><code>services</code>是一组一起工作的<code>Pod</code>的对外逻辑抽象，服务代理自动将服务请求发送到正确的<code>Pod</code>（无论<code>Pod</code>移动到集群中的哪个位置，或者它是否被替换），提供对外访问<code>Pod</code>容器组的策略。<code>services</code>可以通过 API/OpenShift/预定义的指令/终端命令等以一种一致的可预测的方式被编排。</p>
<h1 id="Node"><a href="#Node" class="headerlink" title="Node"></a>Node</h1><p>K8S 会为<code>Pod</code>分配工作机器来在 Linux 环境中执行具体的容器集群调度处理工作，K8S 中的工作机器（虚拟机或者物理机）就称为<code>Node</code>，每个<code>Node</code>都运行了一些<code>Pods</code>，一组<code>Node</code>会构成一个 K8S 集群。</p>
<p><code>Node</code>运行了一些运行<code>Pod</code>所需要的组件，这些组件负责维护运行的<code>Pod</code>并提供 K8S 运行环境。</p>
<ul>
<li><p>kubelet 是负责保证容器都处于健康运行状态的<code>Node</code>组件，会在集群中每个节点上运行，kubelet 并不直接管理容器，而是管理<code>Pod</code></p>
</li>
<li><p>kube-proxy 是负责维护节点上的网络规则的<code>Node</code>组件，是集群中每个节点上运行的网络代理，它所维护的网络规则会允许从集群内部或外部的网络会话与<code>Pod</code>进行网络通信，并且将请求分发到<code>Node</code>中的每个<code>Pod</code></p>
</li>
<li><p>容器运行时是负责运行容器的<code>Node</code>组件，Docker 就是一个容器运行时，一个<code>Node</code>至少要安装一个容器运行时，节点上的 kubelet 会指导容器运行时去创建指定的容器，K8S 最常和 Docker 一起使用，但也可以与其他任何容器运行时一起使用</p>
</li>
</ul>
<h1 id="控制平面"><a href="#控制平面" class="headerlink" title="控制平面"></a>控制平面</h1><p>控制平面指容器编排层，会为集群做出全局决策，以及检测并回应集群中的事件。控制平面可以在集群中的任何节点上运行，一般会有专门的节点来运行控制平面，这种节点不运行任何用户容器。在生产环境中，控制平面通常跨多台计算机运行，一个集群通常运行多个节点，提供容错性和高可用性。</p>
<p>控制面的核心是 API 服务器，API 服务器负责提供 HTTP API，以供用户、集群中的不同部分和集群外部组件互相通信，可用于查询和操纵 K8S API 中对象（例如：Pod、Namespace、ConfigMap 和 Event）的状态。K8S 支持多个 API 版本，每个版本都被称为 API 组，这些 API 组可以被启用或者禁用，在集群升级时需要注意API是否存在不兼容的变更。</p>
<ul>
<li><p>kube-apiserver 是负责处理接收请求的前端控制平面组件，是 API 服务器的主要实现，可以通过运行更多的 kube-apiserver 实例来实现请求的负载均衡</p>
</li>
<li><p>kube-scheduler 是负责监视新创建的 Pod 及资源调度决策的控制平面组件</p>
</li>
<li><p>kube-controller-manager 是负责运行控制器进程的控制平面组件，包括 endpoint-controller（刷新服务和 pod 的关联信息）和 replication-controller（负责指定数量的跨<code>Node</code>的多个<code>Pod</code>在同一时间一起运行）</p>
</li>
<li><p>cloud-controller-manager 是负责运行特定于云平台的控制器进程的控制平面组件。</p>
</li>
</ul>
<h1 id="命名空间"><a href="#命名空间" class="headerlink" title="命名空间"></a>命名空间</h1><p>命名空间（namespace）是一个 Linux 特性，将同一集群中的资源划分为互相隔离的组，同一命名空间内的资源名称要唯一，但跨命名空间时没有这个要求，命名空间的作用域仅针对与命名空间相关联的对象，这种作用域对集群范围的对象不适用。</p>
<p>K8S 的用户命名空间将容器内运行的用户与主机中的用户隔离开来，可以将容器中的用户映射到主机中的不同用户，在容器中以 root 身份运行的进程在其用户命名空间内的操作具有完全的权限，但可以在宿主机中以非 root 用户身份运行，此时在命名空间以外的操作时无特权的。</p>
<p>当创建一个<code>Pod</code>时，默认会有一个网络命名空间来隔离容器网络，一个 PID 命名空间来隔离进程视图，此外也可以通过使用用户命名空间来将容器中的用户与节点中的用户隔离开来，当<code>Pod</code>使用用户命名空间时，不允许该<code>Pod</code>再使用其他 host 命名空间。</p>
<p>K8S 通过命名空间将多个服务归纳到一个具有逻辑的组中，而无需关心服务到底运行在哪个机器。</p>
<h1 id="插件"><a href="#插件" class="headerlink" title="插件"></a>插件</h1><p>插件使用 K8S 资源实现集群功能，并非严格意义上的必需组件。</p>
<ul>
<li><p>DNS 是负责为 K8S 服务提供 DNS 记录的插件</p>
</li>
<li><p>Dashboard 是负责提供通用的、基于 Web 用户界面的插件</p>
</li>
<li><p>容器资源监控是负责将关于容器的常见的时间序列度量值保存并提供浏览界面的插件</p>
</li>
<li><p>集群层面日志是负责将容器的日志数据保存并提供搜索和浏览的插件</p>
</li>
</ul>
<h1 id="Kubernetes-对象"><a href="#Kubernetes-对象" class="headerlink" title="Kubernetes 对象"></a>Kubernetes 对象</h1><p>在 K8S 系统中，K8S 对象是持久化的状态，这些实体描述了哪些容器化应用正在运行，可以被应用使用的资源，以及关于应用运行时表现的策略。K8S 使用这些实体去表示整个集群的状态，并通过控制平面始终管理对象的状态使之达到期望状态。</p>
<p>整个 K8S 对象包含两个嵌套的对象字段：<code>spec</code>和<code>status</code>（分别代表规约和状态）。对于具有<code>spec</code>的对象，必须在创建时设置其内容，描述希望对象所具有的特征，其期望状态，从而告知 K8S 系统想要的集群工作负载状态。</p>
<p>K8S 可以直接创建或者通过 kubectl（命令行接口）来创建对象。kubectl 支持多种不同的方式来创建和管理 K8S 对象，但应只用一种技术来管理对象，混合和匹配技术作用在同一对象上将导致未定义行为。</p>
<p>在 K8S 集群的整个生命周期中创建的每个对象都一个不同的 UID，用于标识对象在这个集群中的唯一性。</p>
<p>名字空间是提供同一集群中的资源划分为互相隔离的组的机制，同一名字空间内的资源名要唯一，但跨名字空间时没有这个要求。不必使用多个名字空间来分隔仅仅轻微不同的资源，例如同一软件的不同版本（可以使用标签）。</p>
<p>标签是附加到 K8S 对象上的键值对，用于指定对用户有意义且相关的对象的标识属性，用于组织和选择对象的子集，能够高效地查询和监听，使用户能够以松散耦合的方式将它们组即的组织结构映射到系统对象，而无需客户端存储这些映射。</p>
<p>与名称和 UID 不同，标签不支持唯一性，反而通常希望许多对象携带相同的标签，此时，可以通过标签选择算法来识别一组对象，一个用例，确定节点集，方便<code>Pod</code>调度。</p>
<h1 id="Elastic-Container-Service"><a href="#Elastic-Container-Service" class="headerlink" title="Elastic Container Service"></a>Elastic Container Service</h1><p>Elastic Containe Service (ECS) 基于虚拟化技术，在云环境中提供了高可用的服务器计算资源，其中包括通用型、计算型、内存型、磁盘型等适用于各种不同应用场景需求的虚拟机实例（运行容器），用户可以根据需要选择，这种资源调整的灵活性和弹性很好的解决了微服务架构所面临的低成本资源伸缩的需求，此外，ECS 还提供了数据备份、安全控制、监控和报警等一系列管理功能，促进了微服务架构的崛起。</p>
<p>Amazon Elastic Containe Service (Amazon ECS) 是一个运行并管理 Docker 容器的容器编排服务，在亚马逊云平台上运行虚拟机集群，同时跨多个可用区（AZ, Availability Zone）管理、扩展和调度这些机器上的容器组。</p>
<h2 id="Amazon-ECS-vs-K8S"><a href="#Amazon-ECS-vs-K8S" class="headerlink" title="Amazon ECS vs K8S"></a>Amazon ECS vs K8S</h2><ul>
<li><p>Amazon ECS 和 K8S 都允许用户在不需要直接操作虚拟机的情况下去操作容器，Amazon ECS 无需用户干预即可部署虚拟机并管理其上的容器，K8S 需要用户配置 K8S 以及定义节点、Pod 以及其中的容器</p>
</li>
<li><p>与 Amazon ECS 不同，K8S 是一个与提供商无关的平台，可以在任何云提供商或本地运行，K8S 工作负载是可移植的，支持混合和多云策略，便于迁移，并且运行效果基本上都是相同的</p>
</li>
<li><p>Amazon ECS 默认情况下是受到保护的，所有容器都在具有隔离、安全网络的虚拟私有云中启动，K8S 通过自己的隔离、安全网络创建自己的专有网络</p>
</li>
<li><p>Amazon ECS 与其他 Amazon 服务顺利集成，这对于容器化工作负载非常有用，K8S 得到了庞大的开源社区的支持，拥有庞大的工具和插件生态系统，K8S 拥有所有容器编排平台中最丰富的生产经验，事实证明，它几乎在任何规模上都是稳健可靠的</p>
</li>
<li><p>Amazon ECS 在一个产品中提供两个元素：容器编排平台和托管服务（运行该平台并配置硬件资源），K8S 只提供前者，将 K8S 与 Amazon ECS 进行比较并不公平</p>
</li>
</ul>
<p>组织机构越来越多地采用 K8S 托管服务而不是直接使用 K8S，这样可以降低 K8S 的使用复杂性并帮助他们更快地实现生产，此类托管服务的示例包括 Amazon Elastic Kubernetes (EKS)，Azure Kubernetes Service (AKS) 以及 Google Kubernetes Engine (GKE)。这些托管服务为 K8S 添加了管理层，使其安全可以与 Amazon ECS 相媲美。</p>
<h2 id="ECS-vs-EKS-vs-Plain-K8S"><a href="#ECS-vs-EKS-vs-Plain-K8S" class="headerlink" title="ECS vs EKS vs Plain K8S"></a>ECS vs EKS vs Plain K8S</h2><p>Amazon Elastic Kubernetes Service (Amazon EKS) 是 Amazon 中用于 K8S 的管理平台，它经过 K8S 项目认证，因此可以保证运行 K8S 生态系统中可能使用的任何现有应用程序、工具或插件</p>
<ul>
<li><p>Amazon ECS 本身是免费的，只需要为其使用的 Amazon EC2 资源付费，而 Amazon EKS 管理则会产生额外的费用成本</p>
</li>
<li><p>基于 Amazon ECS 的部署是很方便的，EKS 则需要通过 Kops 或 CloudFormation 模板来配置和部署集群，比较复杂</p>
</li>
<li><p>EKS 支持多云和混合云部署，而 Amazon ECS 是 Amazon 特定的</p>
</li>
<li><p>小型部署更喜欢 Amazon ECS，因为它的无缝部署和配置</p>
</li>
<li><p>大型或混合型部署更喜欢 EKS，因为它具有更强的定制性以及云和本地系统之间改进的可移植性</p>
</li>
<li><p>过渡到容器化环境的传统工作负载可能会从使用普通 K8S 中获得最大收益，因为它允许在本地构建开发/测试生产环境，然后在需要时将其移动到云中</p>
</li>
</ul>
<p>在部署容器化工作负载时，K8S 和 Amazon ECS 都有一定的限制，这些限制可能会阻碍其在企业级的使用，于是可以考虑 OpenShift。</p>
<h2 id="OpenShift-vs-K8S"><a href="#OpenShift-vs-K8S" class="headerlink" title="OpenShift vs K8S"></a>OpenShift vs K8S</h2><p>K8S 和 OpenShift 都是容器编排平台/CaaS (Container-as-a-Service) 的提供者</p>
<ul>
<li><p>OpenShift 此外还提供利用 K8S 来管理以及高效运行应用的 PaaS (Platform-as-a-Service)，虽然 OpenShift 也有开源版本，但其核心重点是提供具有附加功能的商业容器管理平台，例如，更加严格的安全策略、商业支持、网络、容器镜像管理等</p>
</li>
<li><p>OpenShift 是 RedHat Linux 产品，商业版本只能运行在 RedHat Atomic 或 Enterprise Linux (RHEL) 上，开源版本只能运行在 CentOS 上，而 K8S 则受到 Amazon、Azure 和 Google Cloud Platform 等大多数云服务提供商的支持，可以在任何 Linux 发行版上运行</p>
</li>
<li><p>K8S 的部署和管理是一项复杂且资源密集型的任务，而 OpenShift 提供了一个用户界面，可以更加轻松地可视化和管理应用程序集群和容器</p>
</li>
<li><p>如果有资源去正确管理 K8S 并能充分利用其灵活的部署选择，那么可以选择 K8S，而 OpenShift 则作为一个商业的、包罗万象的解决方案，可以提供持续专门的支持</p>
</li>
</ul>
<h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><ul>
<li><a href="https://kubernetes.io/zh-cn/docs/">https://kubernetes.io/zh-cn/docs/</a></li>
<li><a href="https://yeasy.gitbook.io/docker_practice/kubernetes">https://yeasy.gitbook.io/docker_practice/kubernetes</a></li>
<li><a href="https://www.redhat.com/en/topics/containers/what-is-kubernetes">https://www.redhat.com/en/topics/containers/what-is-kubernetes</a></li>
<li><a href="https://opensource.com/resources/what-is-kubernetes">https://opensource.com/resources/what-is-kubernetes</a></li>
<li><a href="https://aws.amazon.com/cn/blogs/china/microservices-on-amazon-ecs-1/">https://aws.amazon.com/cn/blogs/china/microservices-on-amazon-ecs-1/</a></li>
<li><a href="https://aws.amazon.com/cn/blogs/china/microservices-on-amazon-ecs-2/">https://aws.amazon.com/cn/blogs/china/microservices-on-amazon-ecs-2/</a></li>
<li><a href="https://bluexp.netapp.com/blog/aws-ecs-vs-kubernetes-an-unfair-comparison">https://bluexp.netapp.com/blog/aws-ecs-vs-kubernetes-an-unfair-comparison</a></li>
<li><a href="https://ritza.co/articles/kubernetes-vs-docker-vs-openshift-vs-ecs-vs-jenkins-vs-terraform/">https://ritza.co/articles/kubernetes-vs-docker-vs-openshift-vs-ecs-vs-jenkins-vs-terraform/</a></li>
</ul>
]]></content>
  </entry>
  <entry>
    <title>Master Period -</title>
    <url>/2022/12/29/master-period/</url>
    <content><![CDATA[<div class="hbe hbe-container" id="hexo-blog-encrypt" data-wpm="Oh, this is an invalid password. Check and try again, please." data-whm="OOPS, these decrypted content may changed, but you can still have a look.">
  <script id="hbeData" type="hbeData" data-hmacdigest="34f743a80a69676942cb83961f44713b13d60d21ea65832666a827fd4380771f">a99f2d1cd7f89812758242c57c62a59fe859e32cc19116fcceb1abacce500da0e7393ac7f127219a02f2ac7ee2d5424aa02dff11d5c4061ac5fc5b07eacef350ce9639d07b7c441f77a6c291c8f5dfa5b2775ab96672ec29892d59185f3ae4501b6a6a0763f8e4d66b139fff285aedad8a19e73fa00ba10bab4682050d36d7c3a46d8b87a6e16cb8a3384503bba3354659ffc3a13136227eaca234cee3f3680dc0147fb2aa990c14a9846f9adf9625136c555a6c30c820bf5d281bbcda4bd01915172d1a667c11d6824a8b7044b10d268d91d3dc5769222565f3bf2fb5c02e1b7fbf72cbbcb83f094cb161fdc7165424571f537f11aafbb7c9f43f74794dbde2a0cf388ee758f90176a4849ac2506f12011af66e530f0e4b96974729ffc984455eea7ed22efa4f364e701d017581da8fbe6229be954b26413dedb1a09e263dadb761008da9c7a1f754c44124f19a080fda7cad485fb9b566d89d42e6de9d038e279603f9d30c82adb0598acecd7b681d47e5b455d7686b96fe487c3cda5635bbec67ef4649c909035a51a862c21b505e5defeee0ec8a4709de6cfb764723bc39302f828f876c76ef5790f87fe4b769e0694696734ecb4a7a50917992f2c4ccc0a1a4303ab9b81c7a404a5e37a55fcfa00c4943d227b55ef290f19b444011646828bbbc4f5f5ec688916cae752fd40b8f92f5375935aa857e901cd619294a842b56304466a7945cdd16ff23024ebce05eca1715580bf5cf331d0167f03bab85e2a88c7adac5a617cf534298bfb28c772da4f813a617c5e7c2222a6c6b893216f580a6fbf1b0b17daf02da402482a94d986e6420bf0aeff519856c65fa8005a7a7ef56ca576e051cc66bafb01c15d6926c4d38f4b78a048c8dd0fa54166f5e6440aad56325c5385b17f9d441a709fc7d7f6b52d76422e1e0937e9bc59a316c851aea2608d2079e8e51df8bbe8f52b2c643616d2f5c16d6538589dc056b678e58060e6e70ce499220041be0f9201c809a9e61db1a10500a9c7aedf790860a36a5fad5699f0b592fba0378cfad0a3d1edc1c323d02a6e511b720edef540a312ab72849339f17143f2303507b6724494b7da527e204a897882a2c7761132484d6db1cca70b94e6c41a09959f984403f4fe0ae4cd01edf151f03ef3fe1df34e33124691eac27e9451d8e32040e8e73c00759c9aaa5f99f08707a4a64c8d8f3e744723ab09cec9c0d8d76f54e65627fb349a072742da27c48ce76fed6e275927aad5aaa514ec2b60441321f50f3a381b961bd628d30bbdc3f28f230317d1fc1c0e7457f0d19e78634c1b1680d85ed8ad55bcd9f916997a1cdd6046906c5acef4b8bdd7f13d25a7838b9278844ebee4994251865dda9e2ceadf51a94d7ada69216349930dceb268ce94b0228501003fd97eed1cc5664bee14c7986bf2f92ad683831a38396b00f9b4b48f3f188c8d1c6054bfdd3112f6e11b68f037c777c5f473ea74aee58913bb260ec9f183763730f2e5e0e6e512a464829746fd520d82da4110a39d0b93c905f74784de764522dc73afdfacbf84b0533c5ceb20d47285c93b4e2825bb6eef50a7e3a2c3d552a2c8562b4c2681b4c9d0360c47cfecea0bc7228e6956674f1e2ab70d2fa6bdb76c368e0ae858a631d314d1ec06610432ba800e9914b5ea0118dfa10c8a48214d2a252f90ab1a129377499ea8ab96ab6b2a4f803cdd513bf2b513492209aa100e48c4158972ac790781b05b3a1a04a827c7018f0d5d145323a7bc380f33f987b569d2ffa89e14e43182c978b6afe2a4e2511639a8add95b5c872dfbe78d87c4c7575ccc50de455afd644f9c2fc1060e3d84491372f25bd3130ba02aaac7bcec8a6783dc692f7651b44f88ef7a04f57d8a60726fe94b2cc3d169f12d78f973e3cbb0d52c2fa3c90994bb7c9c468cb68c1f3674f14f6c1204519315a9b28e698635d7cb011c42f6e3fd7b9c2f364f5572dddd304bf9451648c40de7482df08bfe2f3577a1bb07f40a9bbffefdc793ca3fa7f603393a9dd5bf11e9f8cf80c77357792210947e91b495ef4af336b64972df0ec2206a004570e3aec7f20e15d09b69e27f97f71991edb671d083f6899c0c3b927dcab93fafd0b252409928024d671509e433a6495140c0d36a2191143fd65899f6db8440cf0fd3ebf01c0a49c845113c2f99de67f3f73e551e3d86c542e254715024a5e90b37798c697b7f148543cc7bfc73dbfe1eb751d4f70ffa5ddb0748fdbfacd82b1c14fdc1ee0bebc5b668eddcbc14847dede813129f0de6a1cba57ba4de23d4df91eb65b4241d00cd7ba30f9bfa8f2fa7221c0d9d9f86faa84a1cc14d22ea33f4b7a83153f21714a5914cad7ce94a7060e30d7e578b9ec7f8dcae446ac38805fe5c0ced7ce7bbd3ab8ac2329c9cf5ae630994d6327ad6f76fbcdfb47dab194b57bb9b0324b430ea2582f9178ed9d60ff5048773c36087c81ad7c4beb248ccaf2361a680e4237cbc467019f279b7926483f611be036db654547868134d7d70c2ea05255cdab5ec409a9f2c038d62a2b66a0913c056110501603f570049ca39fe33028c883ff9a546a5ea6af5e521cd9f300bc708c91e94609b253653a256d77529ed912e83118fc51e727bf9bd5376a802974621dc1a0a423e577ce527b37f51fe791a772409e612dacc7e437e463d5e570bec8a810fe1f364b853e7204cb00041200b9e0b124ce740007d6e5f5e4210d6ab968dba8bc2b05f77f9a2963e261efb0d89e0f714747700404aa64b220c480a72eef2c54aa0fd58c74784dcdb231433f0c964e4909dbe3eb1483acdc5a92e314bf175a6d9c3b176ff813b0c1ba6c28158789588a5ef6347ca7e916633b920ba9325d7a8e5bd870d82c360b92e9b5d5f0c6da8e68a3092d8c37dbea425e243120026abb6b69ed2c3a5dc67be4a792579c244c3532d54554673069231e1b864e0043a8012aec7ad10049872a2c91f59733d7a547e3541a140951ced97bd9d59ad2bc27577e29f4e3caf3c4bd63c6eec81c2d03c16de9c4b3a1a19bb29a77a707bebea5881a0eff380f16b038415ca59bcf4fcc484e12078358dc86bdc34354a0d0cf42744c1641ea0983b0d76236070f1dba36d244be1cbffa767fc4c67796b0d4f46b060f38e08c16748c9b781734a3ea708853657c5ed7c146f2718e7cde4d4d0318e5a9234a951e811f54d43e231d5e147347e27acfd3cfa4a714a0b3eabf4c72c6ffb15a210eb2bc81d0c8bb9deb5cff4d158f30cc6b5d66df6355ff36c54db4b8618d3b1851f9fc9c97f8c687dc892136ef8b463e42dc29b8c400e00855247574d30e8009b40cc0a154da85937b22cf80a7bf4adc5df4d9298e99502aef53f8c0794096b82c4ff2d34317e51a094926d822016c9902e4092edcbe49bd284fded4a16fccb632594204a7a579a186c8dd731f2c0837197f0e9cf8b2dc4fbf4effc2e2796c085efb926682261c2862d1a4bffdeb1b88863c94c42387a30f14dee264ea366230b402d71ba4cb7856919bd997fe136110f76d1a0b3737248a0b29f9095a61e25f445cdabddb84dd25942e7d3570adee4d844cfa4fdc897ffb5144d0a17ba0d136f214f33e8a662da46f93d03635f5dfb6e43b38cca6f890fe31f9695fd2406ac406ab12a7a31ac14cecbd2eb229a84ff46f0b1124f352787a465b67010cd1cdb1ebd4ad534d68413e4b791d658c8c07b7d586b5a022c0fe866090311c7ffc3b3183eca6058613097661e595c6f4555e137c9e0efe39ec96f1e97b1f39d2194b75d9c99caf7b6918ca43192bc7023948cbcdcda8e631c0c0d7667bfa2a7e7de4f67560b92da5b3101ea898a271854a32291742e42ab35fa0232b51519937f70f31956abd8b0d0dd889c32ff2b0c1b832ed63f3b891a918f46992812b4bc167746cef6d80136337f20dda713c56edb6b52ab7c4537d52d143812b984ef0d69e348ee87e42b2dbad477b171208e1b464019010c1546ec0a85a0d1d5b2561303d093fdff12b1b176bb71cddb2c23996bf6dcd0ee60aa0673ae553820983c5836dd1f0127ebbc7bec6d8c7bfdba747d26bb082152359a359eb4ad722161e4cb707e660824417d924831ef3778d37c1</script>
  <div class="hbe hbe-content">
    <div class="hbe hbe-input hbe-input-default">
      <input class="hbe hbe-input-field hbe-input-field-default" type="password" id="hbePass">
      <label class="hbe hbe-input-label hbe-input-label-default" for="hbePass">
        <span class="hbe hbe-input-label-content hbe-input-label-content-default">Hey, password is required here.</span>
      </label>
    </div>
  </div>
</div>
<script data-pjax src="/lib/hbe.js"></script><link href="/css/hbe.style.css" rel="stylesheet" type="text/css">]]></content>
  </entry>
  <entry>
    <title>Java Virtual Machine</title>
    <url>/2023/12/09/java-virtual-machine/</url>
    <content><![CDATA[<h1 id="1、引言"><a href="#1、引言" class="headerlink" title="1、引言"></a>1、引言</h1><p>Java 技术体系主要由支撑 Java 程序运行的虚拟机、提供各开发领域接口支持的 Java 类库、Java 编程语言及许许多多的第三方 Java 框架（如 Spring、MyBatis）构成。JVM 层面隐藏了机器平台、操作系统、资源管理等底层技术的复杂性和差异性，在千差万别的平台上建立了统一的 Java 运行平台，与此同时也牺牲了一些硬件相关的性能特性，即提升硬件性能时无法等比例提升 Java 程序的运行性能和并放能力，甚至可能没有任何改善，了解 JVM 是为了写出最适合 JVM 运行和自优化的 Java 代码。HotSpot VM 是 Sun/OracleJDK 和 OpenJDK 中的默认 JVM。</p>
<h1 id="2、自动内存管理"><a href="#2、自动内存管理" class="headerlink" title="2、自动内存管理"></a>2、自动内存管理</h1><h2 id="2-1-内存使用"><a href="#2-1-内存使用" class="headerlink" title="2.1 内存使用"></a>2.1 内存使用</h2><p>内存泄漏指程序中分配的内存在不再需要时没有被正确释放回收，内存溢出指程序试图分配超过其可用内存大小的内存空间。Java 程序将控制内存的权利交给了 JVM，在编码的时候享受自动内存管理，但需要通过了解 JVM 使用和回收内存的原理来排查内存泄漏和溢出方面的问题。C++ 则需要在程序中显式地进行内存管理，但有第三方框架可以提供垃圾收集的支持。</p>
<h3 id="2-1-1-内存分区"><a href="#2-1-1-内存分区" class="headerlink" title="2.1.1 内存分区"></a>2.1.1 内存分区</h3><p>JVM 在执行 Java 程序过程中会把它所管理的内存划分为</p>
<ul>
<li><strong>程序计数器</strong><ul>
<li>是一块较小的只读的内存空间，可以看作是当前线程所执行的字节码的行号指示器</li>
<li>每个线程都有自己独立的程序计数器，是线程私有的内存，生命周期与所属的线程相同</li>
<li>如果线程正在执行的是一个 Java 方法，计时器记录的是正在执行的虚拟机字节码指令的地址，如果正在执行的是本地 Native 方法，这个计数器值则为空</li>
<li>此内存区域是唯一一个没有规定任何 OutOfMemoryError 情况的区域</li>
</ul>
</li>
<li><strong>虚拟机栈</strong><ul>
<li>每个线程都有自己独立的虚拟机栈空间，是线程私有的内存，不存在线程安全问题，生命周期与所属的线程相同，栈的大小比堆要小得多，但栈上分配的效率很高，存储速度比堆块，代码执行效率高</li>
<li>每个方法被执行时，JVM 都会同步创建一个栈帧用于存储局部变量表、操作数栈、动态连接、方法出口等信息，Java 方法从被调用到执行完毕就对应栈帧在虚拟机栈中从入栈到出栈的过程</li>
<li>虚拟机栈通常只是指虚拟机栈中局部变量表部分，局部变量表存放了编译期可知的各种基本数据类型、对象引用以及 returnAddress 类型（指向了一条字节码指令的地址）</li>
<li>局部变量表中所存放的这些数据类型在局部变量表中的存储空间以局部变量槽来表示，long 和 double 会占据两个变量槽，其余的数据类型只占用一个变量槽，一个方法需要在栈帧中分配多少个变量槽是在编译期间就确定的，在方法运行期间不会改变局部变量槽的个数</li>
<li>如果线程请求的栈深度大于 JVM 所允许的深度时则抛出 StackOverflowError，如果 JVM 栈容量可以动态扩展，当栈扩展到无法申请到足够的内存时则抛出 OutOfMemoryError 异常</li>
<li>HotSpot VM 通过参数 -Xss 设定初始栈容量，但不支持运行期间的栈容量动态扩展，因此只会在栈容量不足时出现 StackOverflowError，此时会有明确错误堆栈可供分析，可以容易定位到问题代码所在</li>
</ul>
</li>
<li><strong>本地方法栈</strong><ul>
<li>本地方法栈为 JVM 使用到的本地 Native 方法服务，同样是线程私有的内存，不存在线程安全问题，生命周期与所属的线程相同</li>
<li>Native 方法从被调用到执行完毕就对应栈帧在本地方法栈中从入栈到出栈的过程，JVM 可以自由的实现本地方法栈，也可以直接把本地方法栈和虚拟机栈合二为一</li>
<li>本地方法栈也会在栈深度溢出或者栈扩展失败时分别抛出 StackOverflowError 和 OutOfMemoryError</li>
</ul>
</li>
<li><strong>堆</strong><ul>
<li>堆是 JVM 所管理的内存中最大的一块，其大小可以根据需要随时调整（但不是无限的），是被所有线程共享的内存区域，在 JVM 启动时创建，用于存发对象实例，几乎所有的对象实例以及数组元素都在这里分配内存，是 JVM 垃圾收集器管理的内存区域，因此也称作 GC 堆，堆的内存分配和回收都相对复杂</li>
<li>堆可以处于物理上不连续的内存空间中，但在逻辑上应该被视为是连续的，堆既可以是固定大小的，也可以是扩展的（通过参数 -Xmx 和 -Xms 设定），如果堆中没有足够的可用内存来完成实例分配并且堆也无法再扩展时，会抛出 OutOfMemoryError</li>
<li>当出现 OutOfMemoryError 时，首先查看是否存在内存泄漏，确保垃圾收集器回收了所有应当回收的内存，其次检查是否存在不合理的生命周期过长的对象，尽量减少程序运行期间的内存消耗，最后查看是否可以上调堆参数 -Xmx 和 -Xms</li>
<li>当 JVM 的本地线程分配缓冲（TLAB, Thread Local Allocation Buffer）功能关闭时，JVM 会采用乐观锁（CAS+失败重试）的方式来避免线程间的冲突</li>
<li>当 JVM 的 TLAB 功能启动时，每个线程初始化时 JVM 在堆内存的 Eden 中划分出线程自身专属的空间，线程会在这块单独空间上给对象分配内存，保证内存分配的线程安全，“单独”仅仅只是指内存分配这个动作是线程独占的，而在读取、垃圾回收等动作上都是线程共享的</li>
<li>当一个 TLAB 被填满或者废弃时，原有 TLAB 中的对象不会被移动或复制到新的 TLAB 中而是保留在其当前位置，线程会简单地分配一个新的 TLAB，并在新的 TLAB 上继续分配内存，TLAB 内存自身从堆中划分出来也是需要并发控制的，所以不应频繁地划分 TLAB，这就失去了使用 TLAB 的意义</li>
</ul>
</li>
<li><strong>方法区</strong><ul>
<li>方法区也是被所有线程共享的内存区域，存储已被 JVM 加载的类型信息、常量、静态变量、 JIT 编译器编译后的代码缓存等数据，方法区有一个别名叫作非堆，这是为了与堆区分开来，方法区和堆一样不需要连续的内存，可以选择固定大小，也可以扩展，甚至还可以选择不实现垃圾收集</li>
<li><strong>运行时常量池</strong>用于存储常量、符号引用和一些编译期已知的常量数据，字符串字面量不应重复地存储在运行时常量池中，而是应当通过<strong>字符串池</strong>做到可以复用，运行时常量池和字符串池相对于 Class 文件常量池表的一个重要特征是具备动态性</li>
<li>Java 语言并不要求常量一定只有编译期才产生（指的是字面量先在编译期进入 Class 文件常量池表，再在运行期类加载后被存放到运行时常量池或字符串池中这种情况），运行期间也可以将新的常量放入池中（比如 String.intern() 方法会把首次遇到的字符串实例的引用放入字符串池中，并返回该引用），关于 intern 方法详细参见 <a href="../../../../2022/05/08/java-language/">Java Language</a> 中的 5.3 小节</li>
<li>方法区的垃圾收集比较少见，但并非数据进入方法区就永久存在了，方法区的内存回收目标主要是针对常量池的回收和对类型的卸载，一旦方法区无法满足新的内存分配需求时，将抛出 OutOfMemoryError</li>
<li>一个类被垃圾回收的条件是比较严苛的，在经常运行时生成大量动态类的应用场景（比如 CGLIB 这类字节码技术、动态产生大量需要被编译成 Java 类的 JSP 文件等）里就需要特别关注这些类的回收情况</li>
<li>方法区是 JVM 规范中定义出来的一块区域，在具体的不同 JVM 实现不同版本中有很大差别<ul>
<li>在 JDK 6 中，方法区（使用永久代实现）包含运行时常量池、字符串池、代码缓存、静态变量，在 JDK 7 中，方法区保留运行时常量池和代码缓存，但字符串池和静态变量从方法区移动到了堆中，这是因为只有 Full GC 的永久代的 GC 回收效率太低，而很多字符串和静态变量是朝生夕死的，不适合放在永久代</li>
<li>在 JDK 8 中，方法区被重构为元空间，位于直接内存中，这是因为永久代有固定的大小，且不容易调整，在一些场景下容易内存溢出，而元空间可以根据应用程序的需要动态调整大小，元空间的内存使用受限于操作系统对本地直接内存的限制</li>
</ul>
</li>
</ul>
</li>
<li><strong>直接内存/堆外内存</strong><ul>
<li>直接内存并不是 JVM 运行时数据区的一部分，又称堆外内存，通常由操作系统管理，可以提供比堆内存更好的性能，但不受垃圾回收机制的管理，在不需要堆外内存时，务必手动释放内存资源</li>
<li>堆外内存被频繁地用于分配容量较大的缓冲区，比如<code>Unsafe</code>类和 NIO 包中的<code>DirectByteBuffer</code>类都可以分配堆外内存，然后通过一个存储在 Java 堆中的对象作为这块堆外内存的引用进行操作，能够在一些场景中显著提高性能，节省 Java 堆空间，减少垃圾回收的压力</li>
<li>在 I/O 场景下，可以通过零拷贝技术将数据从磁盘或网络读取到堆外内存，然后直接与应用程序进行数据交换，避免在堆内存和堆外内存之间来回复制数据，可以显著提高 I/O 性能，尤其是在处理大量数据时</li>
<li>堆外内存的分配显然不会受到 Java 堆大小的限制，但依旧会受到本机总内存大小以及处理器寻址空间的限制，需要注意的是在配置 JVM 参数时不要忽略直接内存，否则可能会使得 JVM 所管理内存加上堆外内存后超过本机物理内存限制，从而导致动态扩展时出现 OutOfMemoryError</li>
<li>通过参数 -XX:MaxDirectMemorySize 可以指定堆外内存的容量，如果不指定则默认与 Java 堆最大值一致</li>
</ul>
</li>
</ul>
<h3 id="2-1-2-内存分配"><a href="#2-1-2-内存分配" class="headerlink" title="2.1.2 内存分配"></a>2.1.2 内存分配</h3><p>当 JVM 遇到一条<strong>字节码 new 指令</strong>时，首先检查这个指令的参数是否能在常量池中定位到一个类的符号引用，检查这个符号引用代表的类是否已经被加载、解析和初始化，如果没有则先执行相应的<strong>类加载过程</strong>，在类加载完成后即可完全确定对象所需内存的大小，在类加载检查通过后，接着就将一块<strong>大小确定</strong>的内存块从 Java 堆（也有可能经过 JIT 优化后被拆散为标量类型并间接地在栈上分配）中划分出来并<strong>设置对象头</strong>，这些工作都完成后，从 JVM 的视角来看一个新的对象已经产生了，但从 Java 程序的视角来看，对象创建工作刚刚开始，对象中所有的字段还都为默认值，对象需要的其他资源和状态信息也还没有按照预定的意图构造好，接下来需要<strong>执行构造函数</strong>（即 Class 文件中的 &lt;init&gt;() 方法）来按照程序员的意图对对象成员变量进行<strong>初始化</strong>，把<strong>堆内对象的首地址赋给引用变量</strong>，这样一个真正的可用对象才算完全被构造出来，对象在堆内存中的存储布局可以划分为<strong>对象头</strong>、<strong>实例数据</strong>和<strong>对齐填充</strong>。</p>
<p>从 Java 堆中划分内存的方式取决于 Java 堆是否规整，Java 堆是否规整取决于所采用的垃圾收集器是否带有空间压缩整理的能力。当 Java 堆中内存是绝对规整的（所有被使用的内存都被放在一边，空闲的内存被放在另一边，中间放着一个指针作为分界点的指示器）时，那只需进行<strong>指针碰撞</strong>（将指针向空闲方向挪动一段与对象所需大小相等的距离），这种方式在并发情况下并不是线程安全的，所以要么进行<strong>同步锁定</strong>，要么通过 <strong>TLAB</strong>（预先分配一小块内存给每个线程）来把内存分配的动作按照线程划分在不同的空间中进行，只有在 TLAB 空间用完后才需要同步锁定。当 Java 堆中内存不是规整的（使用过的内存和未被使用的内存相互交错在一起）时，JVM 会维护一个<strong>空闲列表</strong>来记录可用的内存块，在分配时就从空闲列表中找到一块足够大的空间划分给对象实例，并更新空闲列表。</p>
<p><strong>对象头中的信息是与对象自身定义的数据无关的额外存储成本</strong>（基本类型数据包装为类对象之后会因为增加了对象头等导致消耗的内存变大），包括两类信息，一类是用于存储对象自身的运行时数据，如对象所对应的哈希码（实际会延后到真正调用 Object::hashCode() 方法时才计算）、GC 分代年龄、锁状态标志、线程持有的锁、偏向线程 ID、偏向时间戳等，这部分数据称为 <strong>Mark Word</strong>，Mark Word 是一个有着动态定义的数据结构，旨在在极小的空间内存储尽量多的数据，根据对象的状态复用自己的存储空间，其长度在 32 位和 64 位的 OS 中分别为 32 个比特和 64 个比特；对象头的另一部分是<strong>类型指针</strong>，即指向方法区内的对象类型数据的地址，JVM 通过这个指针来确定该对象是哪个类的实例及该类的类型信息，但由于查找对象类型数据并不一定要经过对象本身（也可能是通过句柄来访问），因此并不是所有的 JVM 都必须在对象头上保留类型指针；此外，对于数组对象，对象头还必须有<strong>一块用于记录数组长度的数据</strong>。</p>
<p><strong>实例数据部分是对象真正存储的有效信息，即程序代码中定义的各种类型的字段内容</strong>，无论是从父类继承下来的，还是在子类中定义的字段都必须记录起来，这部分的存储顺序会受到 JVM 分配策略参数配置和字段在 Java 源码中定义顺序的影响，HotSpot VM 默认的分配顺序为 long/double、int、short、char、byte/boolean、oop (Ordinary Object Pointer)，即相同宽度的字段总司被分配到一起存放，在这个前提下，父类中定义的变量会出现在子类之前，也允许通过 HotSpot VM 的参数配置令子类之中较窄的变量插入到父类变量的空隙之中。</p>
<p><strong>对齐填充部分并不是必然存在的，也没有特别的含义，仅仅起着占位符的作用</strong>，HotSpot VM 的自动内存管理系统要求对象起始地址必须是 8 字节的整数倍，即任何对象的大小都必须是 8 字节的整数倍，对象头部分已经被设计成正好是 8 字节的整数倍，因此如果对象实例数据部分没有对齐的话就需要通过对齐填充来补全。相同的程序在 64 位虚拟机中消耗的内存一般比 32 位虚拟机要大，这是因为指针膨胀以及对齐填充等因素导致的，可以开启（默认即开启）压缩指针功能来缓解。</p>
<p>Java 程序会<strong>通过栈上的 reference 数据来操作堆中的具体对象</strong>，根据 reference 来访问堆中对象的方式有 JVM 具体实现而定，主流的访问方式主要有使用句柄和直接指针两种。通过<strong>句柄访问</strong>时，Java 堆中可能会划分出一块内存来作为句柄池，reference 中存储的就是对象的句柄地址，而句柄中包含了堆内的对象实例数据与方法区内的对象类型数据各自具体的地址。通过<strong>直接指针访问</strong>时，reference 中存储的直接就是对象实例数据地址，不需要多一次通过访问句柄来间接访问对象的开销，但 Java 堆中对象的内存布局就必须考虑如何在对象数据中放置方法区内的对象类型数据的地址（一般是在对象头中设置类型指针）。</p>
<h2 id="2-2-垃圾收集"><a href="#2-2-垃圾收集" class="headerlink" title="2.2 垃圾收集"></a>2.2 垃圾收集</h2><p>当需要排查各种内存溢出、内存泄漏以及系统并发瓶颈问题时，都可能需要分析系统垃圾回收情况，程序计数器、虚拟机栈、本地方法栈的内存区域与特定线程伴生，其内存分配与回收都具备确定性（在编译期即可大致确定，且当方法结束或者线程结束时内存自然就随着回收了），无需过多考虑回收问题，而 <strong>Java 堆和方法区</strong>这两个区域则有显著的不确定性，只有运行期才能确定程序到底会创建哪些对象，其内存的分配和回收是动态取决于对象的引用关联情况的，需要重点关注。</p>
<h3 id="2-2-1-回收条件"><a href="#2-2-1-回收条件" class="headerlink" title="2.2.1 回收条件"></a>2.2.1 回收条件</h3><p>回收方法区时，需要判断方法区内的常量、类型信息等是否存在引用关联关系，其中，判断一个类型是否属于不再被使用的类需要满足三个条件：该类及其所有派生子类的所有实例都已经被回收，加载该类的类加载器已经被回收，该类对应的 Class 对象没有在任何地方被引用，此时该类的类型信息允许被回收，但也不一定（HotSpot VM 提供了 -Xnoclassgc 参数进行控制），在大量使用反射、动态代理、CGLIB 等字节码框架、动态生成 JSP 以及 OSGi 这类频繁自定义类加载器的场景中，通常都需要 JVM 具备类型信息卸载的能力，以确保不会对方法区造成过大的内存压力。</p>
<p>回收 Java 堆时，需要判断堆内对象是否存在引用关联关系，如果 reference 类型的数据中存储的数值是另外一块内存的起始地址，就称该 reference 数据是代表某块内存、每个对象的强引用，垃圾收集器永远不会回收被<strong>强引用</strong>的对象；<strong>软引用</strong>是用来描述一些还有用，但非必须的对象，在系统将要发生内存溢出前，会把软引用对象列进回收范围之中，即被软引用的对象只能生存到内存即将溢出为止，若回收后还没有足够的内存，才会抛出内存溢出异常；<strong>弱引用</strong>也是用来描述那些非必须对象，区别在于被弱引用的对象只能生存到下一次垃圾收集发生为止，当垃圾收集器开始工作，无论当前内存是否足够，都会回收只被弱引用关联的对象；<strong>虚引用</strong>也称为幽灵引用或者幻影引用，一个对象是否被虚引用完全不会对其生存时间构成影响，也无法通过虚引用来取得一个对象实例，虚引用关联的唯一目的只是为了在被引用对象被回收时收到一个系统通知。</p>
<p>当判断一个对象不存在引用关联关系时，该对象将会被第一次标记，随后判断该对象是否需要执行 finalize 方法（对象没有覆盖 finalize 方法或 finalize 方法已经被 JVM 执行过都视作不需要执行），对于不需要执行 finalize 方法的对象则真正回收该对象，对象死亡，对于需要执行 finalize 方法的对象将会被放置在一个名为 F-Queue 的队列之中，并在稍后由一条由 JVM 自动建立的、低调度优先级的 Finalizer 线程去触发这些对象的 finalize 方法开始运行（并不承诺一定会等待方法运行结束），随后垃圾收集器将对 F-Queue 中的对象进行第二次小规模标记，此时再一次检查 F-Queue 队列中的对象是否依旧不存在引用关联关系，若存在则将其移出 F-Queue，若不存在则真正回收该对象，对象死亡。整个过程中任何一个对象的 finalize 方法都只会被系统自动调用一次，但<strong>并不推荐在对象的 finalize 方法中令对象重新被引用，JVM 并不鼓励定义和使用 finalize，所有 finalize 能做的工作，都可以使用 try-finally 或者其他方式做的更好更及时</strong>。</p>
<p>引用计数算法和根可达算法都可以判断一个对象是否存在引用关联关系。<strong>引用计数算法</strong>会在对象中添加一个引用计数器，每当有一个地方引用该对象计数器值就加一，每当引用失效计数器值就减一，计数器值为零的对象就是不可能再被使用的，但引用计数<strong>无法分辨循环引用</strong>的情况，JVM 并不使用引用技术算法来判断对象是否存活。<strong>根可达性算法</strong>通过一系列称为 <strong>GC Roots</strong> 的根对象作为起始节点集，根据引用关系向下搜索，搜索过程所走过的路径称为引用链，如果某个对象到 GC Roots 间没有任何引用链相连，则证明此对象是不可能再被使用的，JVM 采用根可达算法来判断对象是否存活，固定可作为 GC Roots 的对象包括虚拟机栈（栈帧中的本地变量）中引用的对象、方法区中类静态属性引用的对象、方法区中常量引用的对象、本地方法栈中 JNI（即 Native 方法）引用的对象、JVM 内部的引用（比如基本数据类型对应的 Class 对象，常驻的异常对象，系统类加载器等）、活着的线程、所有被 synchronized 锁持有的对象、反映 JVM 内部情况的 JMXBean、JVMTI 中注册的回调、本地代码缓存等。</p>
<p>所有垃圾收集器<strong>在 GC Roots 枚举这一步骤时必须暂停用户程序</strong>，HotSpot 在类加载动作完成时，就会把对象内什么偏移量上是什么类型的数据计算出来，在即时编译的过程中也会在特定的位置（被称为<strong>安全点</strong>）记录下栈里和寄存器里哪些位置是引用，并使用一组称为 <strong>OopMap</strong> 的数据结构来存放所有所有执行上下文和全局性的引用，在 OopMap 的协助下，HotSpot 可以快速准确地完成 GC Roots 枚举（停顿时间不随堆容量而增长了），<strong>安全点的选定既不能太少以至于让收集器等待时间过长，也不能太过频繁以至于过分增大运行时的内存负荷，基本上是以具有让程序长时间执行且不会改变共享数据状态（即指令序列的复用）为标准进行选定的</strong>，比如方法调用、循环跳转、异常跳转等都属于指令序列复用（不过 HotSpot 默认不会在索引值为 int 或范围更小的数据类型的循环中插入安全点，但如果存在一个这样的循环且循环时间仍然很长的程序，可以将索引类型改为 long 来使得 HotSpot 插入安全点）。</p>
<p>为了在发生垃圾收集时应当尽可能让所有线程（不包括执行 JNI 调用的线程）都跑到最近的安全点然后停顿下来，可使用抢先式中断和主动式中断。<strong>抢先式中断方案</strong>在垃圾收集发生时，系统首先把所有用户线程全部中断，然后恢复中断地方不在安全点上的线程的执行，直到该线程跑到安全点上再重新中断，现在几乎没有 JVM 采用抢先式中断来暂停线程响应 GC 事件。<strong>主动式中断方案</strong>仅仅简单设置一个中断标志位，各个线程执行过程中会在安全点和需要分配内存的地方去主动去轮询这个中断标志位，一旦发现中断标志为真时就自己在当前/最近的安全点上主动中断挂起。<strong>在等待所有用户线程都到达安全点之前，垃圾收集线程无法开始工作，只能空转（自旋），因此安全点设置的不合理就会导致长时间的等待</strong>。</p>
<p>对于获取到 CPU 时间片的执行中的线程来说，安全点机制保证了线程执行时在不太长的时间内就会遇到可进入垃圾收集过程的安全点，但对于未获取到 CPU 时间片的线程（比如处于 sleep 或 blocked 状态）来说，线程无法响应 JVM 的中断请求，不能走到安全点去中断挂起自己，这种线程会标识自己已经进入了安全区域，<strong>安全区域</strong>是指能够确保在某一段代码片段之中，引用关系不会发生变化，这个区域中任何地方开始垃圾收集都是安全的，可以看作是被扩展拉伸了的安全点。<strong>JVM 发起垃圾收集时无需管这些已声明自己在安全区域内的线程，当线程要离开安全区域时，它要检查 JVM 是否已经完成了根节点枚举或其他需要暂停用户线程的阶段，如果完成了则线程可以继续执行，否则线程就必须一直等待，直到收到可以离开安全区域的信号为止</strong>。</p>
<h3 id="2-2-2-收集算法"><a href="#2-2-2-收集算法" class="headerlink" title="2.2.2 收集算法"></a>2.2.2 收集算法</h3><p>绝大多数对象都是朝生夕灭的，而熬过越多次垃圾收集过程的对象就越难以消亡，且不同年龄类型的对象之间的引用相对于同年龄类型的引用来说仅占极少数，因此收集器考虑将对象依据其年龄（对象熬过垃圾收集过程的次数）分配到 Java 堆的不同的区域中存储，每次回收时重点关注那些朝生夕灭的区域（<strong>新生代</strong>）更能以较低代价回收到大量空间，而那些难以消亡的对象所在区域（<strong>老年代</strong>）则被 JVM 以较低的频率去回收，这就兼顾了垃圾收集的时间开销和内存空间的有效利用。</p>
<p>根据垃圾收集器每次回收 Java 堆被划分出的其中某一个还是某些区域，产生了<strong>新生代收集</strong>（Minor/Yong GC）、<strong>老年代收集</strong>（Major/Old GC，只有 CMS 收集器有这种行为）、<strong>混合收集</strong>（Mixed GC，收集整个新生代和部分老年代，只有 G1 收集器有这种行为）、<strong>整堆收集</strong>（Full GC，收集整个 Java 堆、方法区以及直接内存）这样的回收行为类型的划分。根据 Java 堆不同区域存储对象的存亡特征的不同，产生了<strong>标记-清除算法</strong>、<strong>标记-复制算法</strong>、<strong>标记-整理算法</strong>这些与对象存亡特征相匹配的针对性垃圾收集算法，这些算法都首先依据根可达算法标记出所有需要回收的对象（因此算法称为追踪式垃圾收集/间接垃圾收集），基于根可达算法的标记阶段会随着 Java 堆变大而等比例增加停顿时间，在标记完成后，统一回收掉所有被标记的对象。</p>
<p>所有涉及到部分区域收集行为的垃圾收集都会面临<strong>跨代引用</strong>的问题，即<strong>需要判断某一块非收集区域是否存在有指向了收集区域的指针，但又不希望扫描整个非收集区域</strong>，因此需要一种称为<strong>记忆集</strong>的抽象数据结构来记录从非收集区域指向收集区域的指针集合。非收集区域中的所有含跨代引用的对象所组成的对象数组是一种最简单的记忆集实现方式，但空间占用和维护成本都相当高昂，HotSpot 使用<strong>卡表</strong>来实现记忆集，卡表是一个由收集区域所有内存块所组成的字节数组，其中每一个元素都对应着一块特定大小（一般都是以 2 的 N 次幂的字节数）的内存块（被称为卡页，通常包含不止一个对象），只要有其他区域中对象引用了本区域的对象，该对象所在卡页所对应的卡表元素就变脏了，其元素值需要被标识为 1（这个维护卡表的动作需要放到每一个赋值操作之中），那么垃圾收集时只需筛选出卡表中变脏的元素，就能得知收集区域中哪些内存块中包含跨代指针，把它们加入 GC Roots 中一并扫描。</p>
<p>在快速完成 GC Roots 枚举后，从 GC Roots 再继续往下遍历对象图就是根可达分析，在这个过程中，会将尚未被访问过的对象标记为白色的（刚开始阶段都是白色的），将已经被访问过的对象但还存在对象引用未被访问过的标记为灰色，将已经被访问过的对象且对象的所有引用也都已经被访问过的标记为黑色，整个根可达分析过程就是对象逐渐由白变灰再变黑的过程，最终白色就是不可达的应该消亡的对象，黑色就是应该存活的对象。根可达分析过程的停顿时间与 Java 堆容量以及对象图结构复杂度直接成正比例关系，因此考虑<strong>并发的根可达分析</strong>，而当有用户线程在并发工作时，会导致对象图结构被修改，进而可能会导致应该消亡的对象被标记为存活以及应该存活的对象被标记为消亡，前者会产生还算可以接受的浮动垃圾，后者则会导致应用程序错误，为了避免这种情况，产生了增量更新和原始快照这种解决方案。<strong>增量更新</strong>方案会记录黑色对象被新插入的指向白色对象的引用记录，当并发结束后，再将这些记录过引用关系的黑色对象为根重新扫描，可以简化理解为黑色对象一旦新插入了指向白色对象的引用之后，就变回灰色对象。<strong>原始快照</strong>方案会记录灰色对象被新删除的指向白色对象的引用记录，当并发结束后，再将这些记录过引用关系的灰色对象为根重新扫描，可以简化理解为无论引用关系删除与否，都会按照刚刚开始扫描那一刻的对象图快照进行扫描。</p>
<p><strong>Mark-Sweep</strong> 算法最基础（另外两个都是以这个为基础）最快速，但执行效率不稳定（效率随对象数量增长而降低），还会产生大量不连续的内存碎片；<strong>Mark-Copy</strong> 将可用内存划分为一块较大的 Eden 区和两块较小的 Survivor 区，每次分配内存时只使用 Eden 区和其中一块 Survivor 区，当可用内存用完需要垃圾搜集时，将 Eden 区和这一块 Survivor 区中还存活的对象根据其对象头中的存活年龄信息判断是将其复制到另一块空白 Survivor 区中还是移动到老年代（如果在 Survivor 中低于等于某年龄的所有对象大小的总和大于 Survivor 空间的一半，那么就把大于等于这个年龄的对象都移动到老年代），然后直接清理掉 Eden 区和已用过的那块 Survivor 区，这种算法要求必须有一块区域是空白的，不会产生空间碎片，但可用内存空间被缩小为原本的 90%（Eden 和 Survivor 的大小比例是 8:1），且当内存中多数对象都长时间存活时，会产生大量内存空间复制的开销，不过当多数对象都可回收时，仅需要复制占少数的存活对象，因此<strong>多用于回收新生代</strong>；<strong>Mark-Compact</strong> 将所有存活的对象都向内存空间一端移动并更新所有引用这些对象的地方（这种操作必须全程暂停用户应用程序才能进行），然后直接清理掉边界以外的内存，<strong>多用于回收老年代</strong>，当存在大量存活对象时这会是一种极为负重的操作，但若不进行这种移动操作，频繁的基于碎片化空间的内存分配和访问则会严重影响应用程序吞吐量，考虑到内存分配和访问相比垃圾收集频率要高得多，从整个程序的吞吐量来看，移动对象会更划算。</p>
<p>新创建的对象一般是在 Java 堆的新生代的 Eden 区中划分内存，当 Eden 区没有足够空间进行内存分配时，JVM 将发起一次 Minor GC。Minor GC 发生之前必须先确保老年代中最大可用的连续空间是大于新生代所有对象总空间（确保 Minor GC 是安全的）或者大于历次晋升到老年代对象的平均大小（是有风险的 Minor GC），若条件不满足则进行 Full GC，若条件满足则尝试进行 Minor GC，若 Minor GC 失败（即担保失败）则需要进行 Full GC，Full GC 之后如果空间还是不够，则触发 OutOfMemoryError。如果在 Eden 区给大对象（典型的大对象是那种很长的字符串、元素数量很庞大的数组）分配内存，就很容易提前触发 GC，且在后续的 GC 中，大对象在 Eden 区以及两个 Survivor 之间的来回复制也是很高的开销，因此大对象可以直接分配在老年代。<strong>大对象对 JVM 的内存分配来说是坏消息，考虑到老年代的相对稳定是控制 Full GC 频率的关键，一个存活时间很短的大对象则是一个更坏的消息，开发人员应当尽量避免这种情况。</strong>此外，1）如果存在永久代且永久代空间不足；2）代码中执行<code>System.gc()</code>这两种情况也都会触发 Full GC，不过第二种情况并不保证是立即触发。正常情况下，Full GC 应该是相对较少发生的，频繁的 Full GC 会导致应用程序的性能下降和响应时间延长，应当将 Full GC 频率降低到至少不会在用户使用过程中发生，可以每天深夜时通过定时任务触发 Full GC 或服务器重启来保持可用内存在一个稳定的水平。</p>
<h3 id="2-2-3-经典收集器"><a href="#2-2-3-经典收集器" class="headerlink" title="2.2.3 经典收集器"></a>2.2.3 经典收集器</h3><p>不同的厂商、版本的 JVM 所包含的垃圾收集器都可能会有很大差别，JVM 一般也都会提供各种参数供用户根据自己的应用特点和要求组合出各个内存分代所使用的收集器，经典的垃圾收集器算不上是最先进的技术，但足够成熟，可在生产环境放心使用，具体如下</p>
<ul>
<li>Serial<ul>
<li>属于新生代收集器，可与 CMS、Serial Old 搭配使用</li>
<li>在垃圾收集时必须暂停其他所有用户线程直到垃圾收集结束，只能<strong>单线程工作</strong>，采用 Mark-Copy</li>
<li>使用简单，是所有收集器里<strong>额外内存消耗最小</strong>的，也没有线程交互的开销，可以获得最高的单线程收集效率（与其他收集器的单线程相比）</li>
<li>对于内存较小的分区来说，其停顿时间完全可以控制在十几、几十毫秒以内，对于用户来说完全是可以接受的</li>
</ul>
</li>
<li>ParNew<ul>
<li>属于新生代收集器，可与 CMS、Serial Old 搭配使用</li>
<li>实质上是 <strong>Serial 的多线程并行版本</strong>，但在单核 CPU 中，由于存在线程交互的开销，ParNew 并不会有比 Serial 更好的效果</li>
<li>ParNew 其余的行为和 Serial 完全相同，同样在垃圾收集时必须暂停其他所有用户线程直到垃圾收集结束，同样采用 Mark-Copy</li>
</ul>
</li>
<li>Parallel Scavenge<ul>
<li>属于新生代收集器，可与 Serial Old、Parallel Old 搭配使用</li>
<li>能够多个垃圾收集线程<strong>并行</strong>，在垃圾收集时必须暂停其他所有用户线程直到垃圾收集结束，采用 Mark-Copy</li>
<li><strong>Parallel Scavenge 关注的目标是达到一个可控制的吞吐量（即 CPU 用于运行用户代码的时间与总消耗时间的比值）</strong>，而不是尽可能缩短垃圾收集时的用户线程停顿时间，Parallel Scavenge也称为吞吐量优先收集器，可以最高效率的利用 CPU 时间，尽快完成程序的运算任务</li>
<li>Parallel Scavenge 允许用户通过设定参数来控制最大的垃圾收集停顿时间（<strong>更短的停顿时间是以牺牲吞吐量和新生代空间位代价换取的</strong>）或者直接设定吞吐量大小，还允许用户通过激活开关参数来允许 JVM 根据当前系统的运行情况收集性能监控信息，动态调整各种细节参数（比如新生代大小、Eden 与 Survivor 的比例等）以提供最合适的停顿时间或者最大的吞吐量，这种调节方式称为垃圾收集的<strong>自适应的调节策略</strong></li>
</ul>
</li>
<li>Serial Old<ul>
<li>属于老年代收集器，可与 CMS、Serial、ParNew、Parallel Scavenge 搭配使用</li>
<li>是 <strong>Serial 的老年代版本</strong>，同样在垃圾收集时必须暂停其他所有用户线程直到垃圾收集结束，同样只能单线程工作，采用 Mark-Compact</li>
<li>可以在 CMS 发生 Concurrent Mode Failure 时作为后备预案</li>
</ul>
</li>
<li>Parallel Old<ul>
<li>属于老年代收集器，可与 Parallel Scavenge 搭配使用</li>
<li>是 <strong>Parallel Scavenge 的老年代版本</strong>，同样能够多个垃圾收集线程并行，同样在垃圾收集时必须暂停其他所有用户线程直到垃圾收集结束，采用 Mark-Compact</li>
<li>在<strong>注重吞吐量或者 CPU 资源较为稀缺的场合</strong>都可以优先考虑 Parallel Scavenge 加 Parallel Old 这个组合，是 JDK 8 中默认使用的组合</li>
</ul>
</li>
<li>CMS (Concurrent Mark Sweep)<ul>
<li>属于老年代收集器，可与 Serial、ParNew、Serial Old 搭配使用</li>
<li>HotSpot 中第一款真正意义上支持并发的垃圾收集器，<strong>首次实现了让垃圾收集线程和用户线程并发工作，以获取最短回收停顿时间为目标</strong>，又称为并发低停顿收集器</li>
<li>CMS 将垃圾收集过程分为四个步骤<ul>
<li><strong>初始标记</strong>，标记 GC Roots 能直接关联到的对象，需要暂停其他所有用户线程，耗时很短</li>
<li><strong>并发标记</strong>，从 GC Roots 的直接关联对象开始遍历整个对象图（三色标记），耗时长，与用户线程一起并发工作，基于<strong>增量更新</strong>实现并发标记</li>
<li><strong>重新标记</strong>，修正并发标记期间因用户程序运作而导致标记产生变动的标记记录，多个垃圾收集线程并行工作，需要暂停其他所有用户线程，耗时比初始标记阶段稍长一些，但远比并发标记阶段短</li>
<li><strong>并发清除</strong>，清理标记阶段判断已经死亡的对象，耗时长，与用户线程一起并发工作</li>
</ul>
</li>
<li>CMS 对 <strong>CPU 资源非常敏感</strong>，在并发阶段，虽然无需用户线程停顿，但会因为垃圾收集线程占据了一部分 CPU 资源而导致<strong>应用程序变慢</strong>，总吞吐量降低</li>
<li>由于<strong>需要预留一些内存</strong>以供并发收集时的用户线程使用，CMS 在老年代内存使用达到一定域值（用户可设定）后就会被触发</li>
<li>CMS 还会产生浮动垃圾，也可能出现 Concurrent Mode Failure 进而导致另一次完全暂停所有用户线程的 Full GC 的产生</li>
<li>在平时多数时间都采用 Mark-Sweep，暂时容忍内存碎片的存在，直到内存空间的碎片化程度已经大到影响对象分配时，再采用一次 Mark-Compact 以获得规整的内存空间，这时需要暂停所有用户线程进行 Full GC</li>
<li>CMS 的记忆集相当简单，考虑到新生代对象极不稳定，引用变化频繁，维护新生代到老年代的跨代引用开销是很大的，所以只需唯一一份用于记录老年代到新生代的跨代引用的卡表即可，代价就是老年代的垃圾收集需要把这个新生代作为 GC Roots 进行扫描</li>
</ul>
</li>
<li>G1 (Garbage First)<ul>
<li>是一个<strong>面向全堆（包括新生代和老年代）和方法区</strong>的垃圾收集器，不再需要其他的收集器配合工作，可以由用户指定期望的停顿时间，目标是<strong>在延迟可控的情况下获得尽可能高的吞吐量</strong>，适用于大型内存环境，可以有效管理大型堆</li>
<li>G1 可以面向任何内存部分组成的回收集进行回收，衡量标准不再是这块内存属于哪个分代而是哪块内存中存放的垃圾数量最多，回收受益最大，这就是 <strong>Mixed GC</strong> 模式，但一旦内存回收的速度赶不上内存分配的速度，就要暂停所有用户线程进行 Full GC</li>
<li>G1 将连续的 Java 堆划分为多个大小相等的独立区域 Region，每个 Region 都可以根据需要当做新生代的 Eden、Survivor 或者老年代使用（大小超过了整个 Region 容量的对象判定为超大对象，会被存放在 N 个连续的 Humongous Region 之中）</li>
<li>新生代的 Eden、Survivor 以及老年代不再是固定的了，而是<strong>一系列不一定连续的 Region 的动态集合</strong>，G1 能够对不同角色的 Region 采用不同的策略去进行垃圾收集</li>
<li>G1 会跟踪各个 Region 中的<strong>垃圾堆积的价值</strong>（所获得的空间大小以及回收所需时间的经验值），在后台维护一个<strong>优先级列表</strong>，每次根据用户设定允许的收集停顿时间优先处理回收价值收益最大的那些 Region，即收回停顿时间可预测</li>
<li>Region 被视作单次回收的最小单元，每次回收收集到的内存空间都是 Region 的整数倍，可以有计划地避免在整个 Java 堆中进行 Full GC，基于优先级的 Region 区域回收也保证了 G1 在有限的时间内获取尽可能高的收集效率</li>
<li>对于跨 Region 的对象引用可以通过记忆集避免非收集区域的扫描，<strong>G1 的每个 Region 都维护有自己的记忆集</strong>，G1 的记忆集在存储结构的本质上是一种哈希表，Key 是别的 Region 的起始地址，Value 是一个存储卡表索引号的集合，这种不仅包含我指向谁还包含谁指向我的双向的卡表结构更加复杂，也占用更多内存（大约堆容量的 10% ~ 20%）</li>
<li>G1 将垃圾收集过程分为四个步骤<ul>
<li><strong>初始标记</strong>，标记 GC Roots 能直接关联到的对象，需要暂停其他所有用户线程，耗时很短，而且是借用进行 Minor GC 的时候同步完成的，所以这个阶段实际并没有额外的停顿</li>
<li><strong>并发标记</strong>，从 GC Roots 的直接关联对象开始遍历整个对象图（三色标记），耗时长，与用户线程一起并发工作，基于<strong>原始快照</strong>实现并发标记</li>
<li><strong>最终标记</strong>，处理并发阶段结束后仍遗留下来的少量需要重新标记的记录，多个垃圾收集线程并行工作，需要暂停其他所有用户线程</li>
<li><strong>筛选回收</strong>，更新 Region 的统计数据，对各个 Region 的回收价值和成本进行排序，根据用户所期望的停顿时间来制定回收计划，选择多个 Region 构成回收集，将回收集中存活的对象复制到空的 Region 中，再清理掉回收集中所有的旧 Region，多个垃圾收集线程并行工作，需要暂停其他所有用户线程</li>
</ul>
</li>
<li>G1 整体上看是 Mark-Compact，但从局部（两个 Region 之间）上看是 Mark-Sweep，这意味着 G1 运作期间既不会像 Mark-Sweep 那样产生内存空间碎片，又不至于像 Mark-Compact 那样让垃圾收集成为极为负重的操作</li>
<li>G1 在 JDK 7 中推出，在 JDK 9 中设置为默认的垃圾收集器，从 G1 开始，垃圾收集器的设计导向都变为追求内存收集速度能赶上应用的内存分配速率即可，并不追求一次把整个 Java 堆全部清理干净</li>
</ul>
</li>
</ul>
<p>在执行垃圾收集时，暂停所有 Java 用户线程称为 STW（Stop-The-World），此时所有 Java 代码都停止，native 代码可以执行，但不能与 JVM 交互，不管选择哪种垃圾收集器，STW 都是不可避免的，只能尽量降低 STW 的时长。</p>
<h3 id="2-2-4-高性能收集器"><a href="#2-2-4-高性能收集器" class="headerlink" title="2.2.4 高性能收集器"></a>2.2.4 高性能收集器</h3><p>衡量垃圾收集器的重要指标是内存占用、吞吐量和延迟，要在这三个方面的性能指标同时表现完美的收集器是极其困难甚至是不可能的，在执行效果上有革命性改进的实验状态的高性能垃圾收集器最多可以同时达成其中的两项。随着硬件性能日益增长，内存空间逐渐增大，收集器运行时对应用程序的影响会逐渐降低，即应用程序的吞吐量会更高，但是延迟时间反而会增大，因此延迟逐渐成为垃圾收集器最重视的性能指标，高性能垃圾收集器至少应做到低延迟，举例如下</p>
<ul>
<li>Shenandoah<ul>
<li>几乎整个工作过程全部都是并发的，只有初始标记和最终标记阶段有短暂的暂停用户线程（停顿时间基本固定，与堆容量没有正比例关系），目标是实现一种能在任何堆内存大小都可以把停顿时间限制在十毫秒以内的垃圾收集器<strong>，以用户程序吞吐量下降为代价实现了用户程序低延迟时间</strong></li>
<li>Shenandoah 将垃圾收集过程分为九个步骤<ul>
<li><strong>初始标记</strong>、<strong>并发标记</strong>以及<strong>最终标记</strong>都与 G1 一样</li>
<li><strong>并发清理</strong>用于清理那些对象全部无法存活的 Region，与用户线程一起并发工作</li>
<li><strong>并发回收</strong>，把回收集中的存活对象先复制一份到其他未被使用的 Region 之中，<strong>与用户线程一起并发工作（通过 CAS 来保证并发正确性）</strong>，运行时间取决于回收集的大小，是 Shenandoah 的核心概念</li>
<li><strong>初始引用更新</strong>，将堆中所有指向对象被复制前的旧地址引用修正到复制后的新地址，时间很短，会产生一个非常短暂的用户线程停顿</li>
<li><strong>并发引用更新</strong>，按照内存物理地址的顺序线性地搜索出堆中的引用类型，把旧值改为新值，与用户线程一起并发工作，运行时间取决于内存中涉及的引用数量的多少</li>
<li><strong>最终引用更新</strong>，修正存在于 GC Roots 中的引用，时间很短，会产生一个非常短暂的用户线程停顿，停顿时间只与 GC Roots 的数量有关</li>
<li><strong>并发清理</strong>，此时整个回收集中所有的 Region 已再无存活的对象，最后再重新执行一次并发清理来回收整个回收集</li>
</ul>
</li>
<li>Shenandoah 很多思路都与 G1 高度一致，区别在于 Shenandoah <strong>支持与用户线程并发进行的回收</strong>，Region 不再有不同分代角色，摒弃了耗费大量内存和资源去维护的哈希表记忆集，而是改用连接矩阵这一全局数据结构来记录跨 Region 的引用关系，并对并发失败后的 Full GC 提供了多线程支持</li>
</ul>
</li>
<li>ZGC<ul>
<li>几乎整个工作过程全部都是并发的，只有初始标记和最终标记阶段有短暂的暂停用户线程（暂停时间基本固定，与对容量没有正比例关系），目标是实现一种能在任何堆内存大小都可以把停顿时间限制在十毫秒以内的垃圾收集器<strong>，以并发的垃圾收集时间延长为代价实现了用户程序低延迟时间</strong></li>
<li>ZGC 也采用基于 Region 的堆内存布局，区别在于 ZGC 的 Region 具有动态创建和销毁的特性，分为大中小三类具备不同容量的 Region，分别用于放置不同大小等级的对象，其中小型和中型 Region 的容量是固定的，而大型 Region 的容量是可以动态变化的</li>
<li>ZGC 使用<strong>染色指针</strong>（标记信息存储在引用对象的指针上而不是存储在对象上）技术（需要操作系统的支持），JVM 可以直接从指针中看到其引用对象的三色标记状态、是否进入了重分配集（即被并发的用户线程移动过）、是否只能通过 finalize 方法才能被访问到等信息，染色指针使得一旦某个 Region 的存活对象被移走之后，这个 Region 立即就能够被释放和重用</li>
<li>ZGC 将垃圾收集过程分为六个步骤<ul>
<li><strong>初始标记</strong>、<strong>并发标记</strong>以及<strong>最终标记</strong>都与 G1 和 Shenandoah 一样，区别在于 ZGC 的标记是在指针上而不是在对象上进行的</li>
<li><strong>并发预备重分配</strong>，会扫描所有的 Region，根据特定的条件统计得出哪些 Region 需要清理，这些 Region 组成重分配集（不同于之前的回收集）</li>
<li><strong>并发重分配</strong>，将重分配集中的存活对象重新复制到其他新的 Region 中，并未重分配集中的每个 Region 维护一个记录了从旧地址到新地址的转向关系的转发表，重分配集中的 Region 会被释放，并发运行的用户线程只需从引用上就能明确得知一个对象是否处于重分配集中，在访问处于重分配集中的对象时则根据转发表访问到新地址（称为<strong>指针自愈</strong>），只有第一次访问会慢一些，后面就正常，因此对于用户线程的影响要比 Shenandoah 更低</li>
<li><strong>并发重映射</strong>，修正整个堆中指向重分配集中的对象旧地址的所有引用，这一步的目的是为了不变慢以及结束后可以释放转发表，但由于旧地址引用是可以在被用户线程访问时自愈的，所以并不是一个必须要迫切完成的任务，可以将这一步合并到下一次垃圾收集的并发标记阶段里去完成</li>
</ul>
</li>
<li>ZGC 在 JDK 11 推出，ZGC 的整个垃圾收集过程都是与用户线程并发的，这会产生大量的浮动垃圾，进而导致并发收集周期会很长，如果回收速度赶不上分配速度就会导致内存溢出</li>
</ul>
</li>
<li>Epsilon<ul>
<li>Epsilon 不仅仅是一个垃圾收集器，而是自动内存管理子系统，除了垃圾收集以外，还负责堆的管理与布局，对象的分配，与解释器、编译器、监控子系统协作等职责</li>
<li>Epsilon 的目标是服务于那种只运行数分钟甚至数秒的应用，只要 JVM 能够正确分配内存，在堆耗尽之前就早已退出，运行负载极小、没有任何回收行为的 Epsilon 就是很恰当的选择</li>
</ul>
</li>
</ul>
<h1 id="3、程序执行系统"><a href="#3、程序执行系统" class="headerlink" title="3、程序执行系统"></a>3、程序执行系统</h1><p>代码编译的结果从本地机器码转变为平台中立的<strong>由 Class 文件来存储的字节码</strong>（不依赖于特定硬件及操作系统，紧凑、稳定、可扩展，是更优的程序编译后存储格式），JVM 只是与 <strong>Class 文件这种特定的二进制文件格式</strong>所关联并使用公有的<strong>字节码指令集</strong>，因此运行在不同硬件平台和操作系统上的各种 JVM 都可以载入和执行同一种平台无关的存储有字节码的 Class 文件，从而实现程序（不仅仅是 Java 程序，可以是任意能够被编译成存储字节码的 Class 文件的程序）的一次编写，到处运行（<strong>平台无关性</strong>和<strong>语言无关性</strong>）。程序源语言中的各种语法、关键字、常量变量和运算符号的语义最终都会由多条字节码指令组合来表达，这意味着字节码指令所能提供的语言描述能力必须比被编译的源码本身更加强大才行，一些源码语言本身无法有效支持的语言特性并不代表在字节码中也无法有效表达。</p>
<h2 id="3-1-类文件结构"><a href="#3-1-类文件结构" class="headerlink" title="3.1 类文件结构"></a>3.1 类文件结构</h2><h3 id="3-1-1-主体结构"><a href="#3-1-1-主体结构" class="headerlink" title="3.1.1 主体结构"></a>3.1.1 主体结构</h3><p>Class 文件中包含了 JVM 指令集、符号集以及若干其他辅助信息，Class 文件必须应用许多<strong>强制性的语法和结构化约束</strong>，但图灵完备的字节码格式，保证了任意一门功能性语言都可以表示为一个能被 JVM 所接受的有效的 Class 文件。Class 文件是一组以 8 个字节为基础单位的二进制流，各个数据项严格按照顺序紧凑地排列在文件之中，中间没有任何分隔符（对于需要占用 8 个字节以上空间的数据项则会按照高位在前的方式分割成若干个 8 个字节进行存储），这使得 Class 文件中存储的内容几乎全部是程序运行的必要数据，没有空隙存在。Class 文件中只有无符号数和表这两种数据结构，<strong>无符号数</strong>属于基本的数据类型，可以用来描述数字、索引引用、数量值或者按照 UTF-8 编码构成字符串值，<strong>表</strong>（命名都习惯性地以 “_info” 结尾）是由多个无符号数或者其他表作为数据构成的复合数据类型，用于描述有层次关系的复合结构的数据，整个 Class 文件本质上也可以视作是一张表。无论是无符号数还是表，当需要描述同一类型但数量不定的多个数据时，经常会使用一个前置的容量计数器加若干个连续的数据项的形式，这一系列连续的某一类型的数据称为某一类型的集合。对 Java 语言来说，任意一个有效的类或接口所应当满足的格式可以称为 Class 文件，但它实际上并不一定需要以磁盘文件的形式存在，Class 文件应当是指一串二进制字节流，包括但不限于磁盘文件、网络、数据库、内存或者动态生成，然后直接送入类加载器中。</p>
<p>每个 Class 文件的头 4 个字节称为<strong>魔数</strong>，魔数唯一作用是确定这个文件是否为一个能被 JVM 接受的 Class 文件（使用魔数而不是文件扩展名来识别是因为文件扩展名可以随意改动，不够安全）；紧跟着魔数的 4 个字节存储的是 Class 文件的<strong>版本号</strong>，高版本的 JDK 能向下兼容低版本的 Class 文件，但不能运行向上更高版本的 Class 文件，即 JVM 拒绝执行超过其版本号的 Class 文件；版本号之后是<strong>常量池</strong>，常量池是 Class 文件结构中与其他数据项关联最多最繁琐的数据项，是 Class 文件中第一个出现的表类型数据项，通常也是占用 Class 文件空间最大的数据项之一，常量池入口会放置一项无符号数代表<strong>常量池容量计数值</strong>；常量池之后紧接着的 2 个字节代表<strong>访问标志</strong>，用于识别一些类或接口层次的访问信息，包括这个 Class 是类还是接口，是否 public，是否 abstract，是否 final 等等；访问标志之后是按顺序排列的<strong>类索引</strong>、<strong>父类索引</strong>和<strong>接口索引集合</strong>，类索引用于确定这个类的全限定名，父类索引用于确定类的父类的全限定名，接口索引集合用来描述这个类实现了哪些接口；<strong>字段表集合</strong>用于描述接口或类中声明的类级变量以及实例级变量（不包括在方法内部声明的局部变量），依次包含访问标志、名称索引、描述符索引、属性表集合；<strong>方法表集合</strong>用于描述方法定义（与字段表集合对字段的描述几乎是完全一致的方式），而方法中的 Java 代码经过编译后存放在方法表集合中一个名为 Code 的属性中；<strong>属性表集合</strong>用于描述某些场景专有的信息（Class 文件、字段表、方法表都可以携带自己的属性表集合），集合中各个属性表不具有严格顺序限制（更详细的我目前不想学）。</p>
<h3 id="3-1-2-字节码指令"><a href="#3-1-2-字节码指令" class="headerlink" title="3.1.2 字节码指令"></a>3.1.2 字节码指令</h3><p>JVM 指令由一个字节长度的、代表着某种特定操作含义的数字（称为<strong>操作码</strong>，长度限定为 1 字节，种类不超过 256 条）以及跟随其后的零至多个代表此操作所需的参数（称为<strong>操作数</strong>）构成，由于 JVM 采用面向操作数栈而不是面向寄存器的架构（操作数都存放在操作数栈中），所以大多数指令都不包含操作数，只有一个操作码。大多数指令都包含其操作所对应的数据类型信息，但并非每一种数据类型和每一种操作都有对应的指令，比如大多数对于 boolean、byte、short 和 char 类型数据的操作实际上都是使用相应的对 int 类型作为运算类型来进行的，此外，有一些单独的指令可以在必要的时候用来将一些不支持的类型转换为可被支持的类型。<strong>加载和存储指令</strong>用于将数据在栈帧中的局部变量表和操作数栈之间来回传输，存储数据的操作数栈和局部变量表主要由加载和存储指令进行操作，此外还有少量指令，如<strong>访问对象的字段或数组元素的指令</strong>也会向操作数栈传输数据。<strong>算术指令</strong>用于对操作数栈上的两个值进行某种特定运算，并把结果重新存入到操作栈顶，不存在直接支持 boolean、byte、short 和 char 类型的算术指令（应使用操作 int 类型的指令代替），只有除法指令以及求余指令会在除数为零时抛出异常，其他任何数据运算都不会抛出运行时异常（包括溢出情况也不会抛出异常）。<strong>类型转换指令</strong>可以将两种不同的数值类型相互转换，一般用于实现用户代码中的窄化的显式类型转换操作，或者用于处理数据类型相关指令无法与数据类型一一对应的问题（JVM 直接支持小范围类型到大范围类型的安全转换，这种情况无需显式使用类型转换指令），窄化转化中可能发生的上限溢出、下限溢出以及精度丢失等情况均不会抛出异常。<strong>对象创建和访问指令</strong>针对类实例和数组分为不同的字节码指令。<strong>操作数栈管理指令</strong>用于直接操作操作数栈（就如同一个普通数据结构中的堆栈那样直接操作）。<strong>控制转移指令</strong>可以将 JVM 有条件或无条件地从指定位置指令的下一条指令继续执行程序，即有条件或无条件地修改 PC 寄存器的值。<strong>方法调用指令</strong>与数据类型无关。<strong>方法返回指令</strong>是根据返回值的类型区分的。<strong>异常处理指令</strong>全部由 athrow 指令来实现，异常处理（catch 语句）则不是由字节码指令来实现的，而是采用异常表来完成。<strong>同步指令</strong>通过管程（Monitor，或直接称为锁）来同步方法内部一段指令序列的同步（整个方法级别的同步是隐式的，实现在方法调用和返回操作之中，无须通过同步指令来控制），同步指令 monitorenter 和 monitorexit 必须配对使用。</p>
<h2 id="3-2-类加载机制"><a href="#3-2-类加载机制" class="headerlink" title="3.2 类加载机制"></a>3.2 类加载机制</h2><p>JVM 将描述类的数据从 Class 文件加载到内存，并对数据进行校验、转换解析和初始化，最终形成可以被 JVM 直接使用的 Java 类型，这个过程称为 JVM 的类加载机制，Class 文件中描述的各类信息都需要通过 JVM 的类加载机制被加载到 JVM 之中才能被运行使用。Java 语言中，类型的加载、连接和初始化过程都是在程序运行期间完成的，这种策略让提前编译面临额外的困难，也会让类加载时的性能开销更大，但为 Java 应用提供了极高的扩展性和灵活性，Java 天生可以动态扩展的语言特性就是依赖<strong>运行期间动态加载和动态连接</strong>这个特点实现的。</p>
<h3 id="3-2-1-主体过程"><a href="#3-2-1-主体过程" class="headerlink" title="3.2.1 主体过程"></a>3.2.1 主体过程</h3><p>一个类型从被加载到 JVM 内存中开始，到卸载出内存为止，它的整个生命周期将会经历加载（Loading）、验证（Verification）、准备（Preparation）、解析（Resolution）、初始化（Initialization）、使用（Using）和卸载（Unloading）七个阶段。验证、准备、解析这三个部分统称为连接（Linking），加载、连接、初始化统称为类加载，整个类加载过程都是线程安全的。除了 Resolution 阶段在某些情况下可以在 Initialization 阶段之后再开始（这是为了支持 Java 的动态绑定）以外，所有阶段都是按照以上顺序按部就班的开始，会在一个阶段执行的过程中调用/激活另一个阶段，因此这些阶段在开始之后通常是互相交叉地混合进行的，并不是按部就班的进行或结束。</p>
<ul>
<li><strong>加载</strong><ul>
<li>类加载过程的第一个阶段 Loading 在<strong>何时开始并没有强制约束</strong>，这可以交给 JVM 的具体实现来自由把握，比如创建类的实例、使用类的静态变量或静态方法、使用反射机制访问类，此外，JVM 启动时，会自动加载一些基础类，比如<code>Object</code>、<code>Class</code>类</li>
<li>在 Loading 阶段，JVM <strong>通过一个类的全限定名来获取定义此类的二进制字节流，将这个字节流所代表的静态存储结构转化为方法区的运行时数据结构，在 Java 堆中生成一个代表这个类的 java.lang.Class 对象</strong>，作为访问方法区中关于这个类的各种类型数据的入口</li>
<li>定义此类的二进制字节流可以有很多来源，比如 ZIP/JAR/EAR/WAR 包、网络（典型应用就是 Web Applet）、运行时计算生成（动态代理技术）、由其他文件生成（典型场景是 JSP 文件）、从数据库中读取、从加密文件中获取（防止 Class 文件被反编译的保护措施，确保程序运行逻辑不被窥探）</li>
<li>非数组类的 Loading 阶段既可以使用 JVM 中内置的引导类加载器来完成，也可以由用户自定义的类加载器去完成，开发人员可以<strong>通过定义自己的类加载器去控制字节流的获取方法，从而赋予应用程序更多的运行动态性</strong></li>
<li>数组类不通过类加载器创建，而是由 JVM 直接在内存中动态构造出来的，但对于元素类型为引用类型的数组类来说，需要递归采用上述非数组类的 Loading 阶段来加载这个数组元素类型</li>
</ul>
</li>
<li><strong>验证</strong><ul>
<li>Verification 阶段是 Linking 的第一步，其工作量在整个类加载过程中占了相当大的比重，目的是<strong>确保 Class 文件的字节流中包含的信息符合约束要求，保证这些信息被当做代码运行后不会危害 JVM 自身的安全</strong></li>
<li>Verification 阶段的大致包括文件格式验证、元数据验证、字节码验证和符号引用验证这四个检验动作</li>
<li>Verification 阶段并<strong>不是必须要执行的</strong>，如果程序运行的所有代码都已经被反复使用和验证过，在生产环境的实施阶段就可以关闭 Verification 阶段，以缩短 JVM 类加载的时间</li>
</ul>
</li>
<li><strong>准备</strong><ul>
<li>Preparation 阶段会正式<strong>为类中定义的 static 变量（不包括实例变量）分配内存并设置变量系统初始值/默认零值</strong>（而不是程序中定义的初始值），但是对于 static final 变量则会被设置为程序中定义的初始值</li>
</ul>
</li>
<li><strong>解析</strong><ul>
<li>符号引用是以一组符号来描述所引用的目标，比如类名、字段名、方法名等，符号可以是任何形式的字面量，只要使用时能够无歧义地定位到目标即可，与 JVM 内存布局和内存地址无关，引用的目标也不一定是已经加载到 JVM 内存中的内容，符号引用是在编译期间产生的，在编译后的 Class 文件中存储</li>
<li>直接引用是可以直接指向目标的指针、相对偏移量或者是一个能间接定位到目标的句柄，是与 JVM 内存布局相关的，是实际指向目标的内存地址，引用的目标一定是已经加载到 JVM 内存中的内容，同一个符号引用在不同 JVM 实例上翻译出来的直接引用一般不会相同</li>
<li>Class 文件中并没有保存各个方法、字段最终在内存中的布局信息，Resolution 阶段会<strong>将 Class 文件常量池表内的符号引用替换为直接引用（这称为静态解析）</strong>以及将字面量存放到方法区的<strong>运行时常量池或字符串池</strong>中，主要指类/接口、字段、类方法、接口方法、方法类型、方法句柄和调用点限定符这七类符号引用（分别对应 Class 文件常量池中不同的常量类型）</li>
<li>JVM 可以根据需要来<strong>自行判断何时进行 Resolution 阶段</strong>（到底是在类的 Loading 阶段进行时开始解析还是等到一个符号引用将要被使用前开始解析），JVM 会对第一次解析的结果进行缓存，避免重复进行 Resolution 阶段</li>
</ul>
</li>
<li><strong>初始化</strong><ul>
<li>当对一个类型（类/接口）进行<strong>主动引用</strong>时，必须立即对该类型进行初始化，而加载、验证、准备自然需要在此之前开始，除此之外所有的<strong>被动引用</strong>都不会触发初始化</li>
<li>主动引用举例：使用 new 关键字实例化对象、读写一个类型的 static 字段（被 final 修饰、已在编译器初始化的除外）、调用一个类型的 static 方法、对类型进行反射调用、初始化类的子类、JVM 启动时被指定的包含 main 方法的主类、初始化包含有 default 方法的接口的实现类、接口的实现类引用接口中定义的常量</li>
<li>被动引用举例：通过子类来引用父类中定义的 static 字段、使用 new 关键字实例化一个类型的数组、引用一个类在编译期间就已经初始化的 static 字段（其实被转化为对常量池的引用了）、初始化接口的子接口</li>
<li>Initialization 阶段 JVM 才真正开始执行类中编写的程序代码，主导权被交给应用程序，实际就是<strong>执行类中所有 static 变量的赋值动作和 static 语句块</strong>的过程，所有 static 变量会被设置为程序中定义的初始值（除了 Initialization 阶段可以执行程序中定义的赋值逻辑以及 Loading 阶段可以通过程序自定义类加载器以外，其他阶段都完全由 JVM 来主导控制）</li>
<li>JVM 必须保证 Initialization 阶段在多线程环境中被正确地加锁同步，只会有一个线程去执行这个类的初始化，其他线程都需要阻塞等待直到活动线程执行完毕，因此<strong>一旦 Initialization 阶段所执行的代码中有耗时很长的操作，就可能造成多个线程阻塞</strong></li>
</ul>
</li>
<li><strong>使用</strong><ul>
<li>在类加载完毕之后，会有代码来主动引用该类</li>
</ul>
</li>
<li><strong>卸载</strong><ul>
<li>如果该类所有的实例、该类的 ClassLoader 都已经被 GC 回收，且该类的<code>Class</code>对象没有在任何地方被引用，那么该类会在 Full GC 期间从方法区被回收掉</li>
<li>JVM 自带的类加载器因为会一直加载基础对象，因此 JDK 自带的基础类是一定不会被回收的，那么自定义类加载的类才会被回收，比如 tomcat、SPI、JSP 等临时类</li>
<li>由于类卸载是一个比较耗时的操作，会影响程序的性能，JVM 并不会在程序运行过程中频繁地卸载类，通常是在内存空间不足（也就是 Full GC）时才会进行类卸载</li>
<li>JDK 9 中引入了模块化，在模块化环境下，如果一个模块中的类不再被引用，那么这个模块就可以被卸载，通过模块化可以对 Java 类进行更加精细的控制，使 Java 应用程序更加安全、可靠、可维护</li>
</ul>
</li>
</ul>
<h3 id="3-2-2-类加载器"><a href="#3-2-2-类加载器" class="headerlink" title="3.2.2 类加载器"></a>3.2.2 类加载器</h3><p>应用程序可以自己决定如何通过一个类的全限定名来获取定义此类的二进制字节流，实现这个动作的代码被称为类加载器。每一个类加载器都拥有一个独立的类名称空间，对于任意一个类，都必须由它的类加载器和这个类本身一起共同确立其在 JVM 中的唯一性（对于来源于同一个 Class 文件的被同一个 JVM 加载的两个类，<strong>只要加载它们的类加载器不同，那两个类在 JVM 中就是两个不同的类</strong>）。</p>
<p><strong>双亲委派模型</strong>是 Java 推荐给开发者的一种类加载器实现的最佳实践（并不是一个强制性约束的模型），模型要求除了顶层的启动类加载器以外，其余的类加载器都应有自己的父类加载器，类加载器之间的父子关系一般不是以继承关系而是使用组合关系来复用父加载器的代码，当一个类加载器收到了类加载的请求，它首先不会自己去尝试加载这个类，而是把这个请求委派给父类加载器去完成，因此<strong>所有的加载请求最终都应该传送到最顶层的启动类加载器中，只有当父加载器反馈自己无法完成这个加载请求（它的搜索范围中没有找到所需的类）时，子加载器才会去尝试自己去完成加载，同一个类一定是由同一个类加载器加载的</strong>。双亲委派模型主要是<code>ClassLoader.loadClass</code>实现的，只要在自定义类加载器中重写该方法，即可<a href="https://www.yuque.com/hollis666/niq4hm/gt8zp4">破坏双亲委派模型</a>。</p>
<p><strong>Java 模块化系统</strong>实现了可配置的封装隔离机制，模块定义除了代码以外，还包含依赖其他模块的列表、导出的包列表（即其他模块可以使用的列表）、开放的包列表（即其他模块可反射访问模块的列表）、使用的服务列表、提供服务的实现列表。当类路径中缺失了运行时依赖的类型，模块可以声明对其他模块的显式依赖，JVM 能够在启动时验证应用程序开发阶段设定好的依赖关系在运行期是否完备，如有缺失则直接启动失败，避免了一部分由于类型依赖而引发的运行时异常。</p>
<p>所有类加载器之间从父到子的顺序依次是启动类加载器，平台类加载器、应用程序类加载器以及自定义类加载器，这些类加载器都继承于 jdk.internal.loader.BuiltinClassLoader，BuiltinClassLoader 实现了模块化架构下类如何从模块中加载的逻辑以及模块中资源可访问性的处理，启动类加载器，平台类加载器以及应用程序类加载器都有各自负责加载的模块。<strong>当平台及应用程序类加载器收到类加载请求时，要先判断该类是否能够归属到某一个系统模块中，如果存在这样的归属关系，就要优先委派给负责那个模块的加载器（而不是父加载器）完成加载，从而使得模块化系统得以顺利运作</strong>，这算是对双亲委派模型的一种破坏。</p>
<ul>
<li><strong>启动类加载器（Bootstrap Class Loader）</strong><ul>
<li>是在 JVM 内部和 Java 类库共同协作实现的，是 JVM 的一部分</li>
<li>负责加载存放在<JAVA_HOME>\lib 目录，或者被 -Xbootclasspath 参数所指定路径中存放的 JVM 能够识别的类库加载到 JVM 内存中</li>
<li>不应被 Java 程序直接引用，用户在编写自定义加载器时，如果需要将加载请求委派给启动类加载器时，直接使用 null 作为加载器替代即可</li>
</ul>
</li>
<li><strong>平台类加载器（Platform Class Loader）</strong><ul>
<li>平台类加载器是由 Java 代码实现的，独立于 JVM，继承自<code>java.lang.ClassLoader</code>类</li>
<li>负责加载那些属于 Java 平台模块系统的非核心模块，这些模块位于 JDK 的 lib 目录下（但不包括核心的 java.* 类库），在 module-info.java 文件中被明确声明</li>
<li>开发者可以直接在程序中使用平台类加载器来加载 Class 文件</li>
</ul>
</li>
<li><strong>应用程序类加载器（Application Class Loader）</strong><ul>
<li>应用程序类加载器是<code>java.lang.ClassLoader.getSystemClassLoader()</code>方法的返回值，也称为系统类加载器，独立于 JVM</li>
<li>负责加载用户路径上所有的类库</li>
<li>开发者同样可以直接在程序中使用应用程序类加载器来加载 Class 文件</li>
</ul>
</li>
<li><strong>自定义类加载器（User Class Loader）</strong><ul>
<li>如果用户认为有必要则还可以加入自定义的类加载器（同样独立于 JVM）来进行拓展，典型的如增加除了磁盘位置之外的 Class 文件来源，或者通过类加载器实现类的隔离、重载等功能</li>
</ul>
</li>
</ul>
<h2 id="3-3-程序执行"><a href="#3-3-程序执行" class="headerlink" title="3.3 程序执行"></a>3.3 程序执行</h2><h3 id="3-3-1-执行引擎"><a href="#3-3-1-执行引擎" class="headerlink" title="3.3.1 执行引擎"></a>3.3.1 执行引擎</h3><p><strong>字节码执行引擎</strong>是 JVM 的核心组成部分之一，不同于物理机的执行引擎是直接建立在处理器、缓存器、指令集和操作系统层面上的，JVM 的执行引擎则是由软件自行实现的，可以不受物理条件制约地定制指令集与执行引擎的结构体系，能够执行那些不被硬件直接支持的指令集格式。在不同的 JVM 实现中，执行引擎在执行字节码时通常会有<strong>解释执行引擎</strong>和<strong>编译执行引擎</strong>两种选择，也可能两者兼备，还可能会同时包含几个不同级别的<strong>即时编译执行引擎</strong>一起工作，但所有 JVM 的执行引擎的输入都是字节码二进制流，输出都是执行结果。</p>
<p>JVM 以方法作为最基本的执行单元，<strong>栈帧则是用于支持 JVM 进行方法调用和方法执行的数据结构</strong>，栈帧中存储了方法的局部变量表、操作数栈、动态连接和方法返回地址等信息，每一个方法从调用开始到执行结束都对应着一个栈帧在虚拟机栈里从入栈到出栈的过程。在编译 Java 程序源码时就分析计算出了栈帧中需要多大的局部变量表以及需要多深的操作数栈，一个栈帧所需要的内存并不会受到程序运行期间变量数据的影响，而仅仅取决于程序源码和具体 JVM 实现的栈内存布局形式。</p>
<p>方法调用并不等同于方法中的代码被执行，方法调用阶段唯一的任务就是确定被调用方法的版本，暂时还未涉及方法内部的具体运行过程，Class 文件常量池中存储的都只是符号引用，而不是方法在实际运行时内存布局中的入口地址/直接引用。在 Class 文件的类加载过程的解析阶段会将 Class 文件常量池内的一部分符号引用替换为直接引用（这称为<strong>静态解析</strong>），这些方法（static 方法和 private 方法）在程序真正运行之前就有一个可确定的且运行期不可改变的调用版本；而另一部分则会到运行期间才能确定目标方法的直接引用（这称为<strong>动态连接/运行时转换</strong>）。</p>
<h3 id="3-3-2-解释与编译"><a href="#3-3-2-解释与编译" class="headerlink" title="3.3.2 解释与编译"></a>3.3.2 解释与编译</h3><p>将便于人编写、阅读、维护的高级计算机语言所写的源代码翻译成计算机能解读、运行的低阶机器语言的过程就是编译，负责这一过程的处理工具就是编译器，反编译的过程与编译相反，就是将以编译好的语言还原到未编译的源代码状态，为了保护源代码，就需要将编译后结果保护起来，防止反编译。</p>
<p>具体在 Java 语言中，编译分为前端编译和后端编译，<strong>前端编译器</strong>（与源语言有关但与目标机器无关，比如 javac）把 *.java 文件转变成 *.class 文件，并通过编译器语法糖（与具体的 JDK 相关）来降低编码复杂度和提高编码效率，而不是依赖字节码或 JVM 底层支持。Java 常见的语法糖包括了泛型、枚举、断言、内部类、变长参数、自动装箱拆箱、常量条件编译、<code>+</code>拼接字符串、foreach、try-with-resource、lambda 等，这些语法糖只能存在于 Java 源码中，语法糖在编译阶段被还原为原始的基础语法结构（这个过程称为解语法糖），JVM 运行时并不直接支持这些语法糖。JVM <strong>解释器</strong>会在程序启动以及运行期解释执行字节码（这个过程不需要编译成本地机器码），JVM <strong>即时编译器（也称 JIT 编译器/后端编译器）</strong>会在运行期以热点代码（运行特别频繁的某个方法或某个代码块）为目标，将其编译成物理硬件可以直接执行的本地机器码（会被缓存起来以备下次使用）然后执行（这个过程就是字节码的编译执行），JVM 选择把对性能的优化全部集中到运行期的 JIT 编译器中，从而让那些不是由 Java 产生的 Class 文件也同样能享受到编译器优化措施。<strong>提前编译器（也称 AOT 编译器）</strong>在程序运行前直接把程序编译成与目标机器指令集相关的本地机器代码，这种编译方式不仅要和目标机器相关，甚至还必须和 JVM 运行时参数绑定，省去了字节码这一中间产物，也就丧失了程序的平台无关性和语言无关性，但可以避免在运行时的编译性能消耗和内存消耗，有可能获得更高的运行性能。C++ 就是直接由源码被编译成机器代码，执行速度快、效率高，但依赖与平台机器关联的编译器。</p>
<p>JVM 通过基于采样的热点探测和基于计数器的热点探测这两种方式来确定热点代码，采用<strong>基于采样的热点探测</strong>时，JVM 会周期性地检查各个线程的调用栈顶，如果发现某个方法经常出现在栈顶则判断该方法是热点方法，这种方式简单高效，还容易获取方法调用关系，但容易受到线程阻塞等因素影响而扰乱探测结果，也很难精确确认一个方法的热度；采用<strong>基于计数器的热点探测</strong>时，JVM 会为每个方法建立计数器，统计方法的执行次数，如果发现方法的执行次数超过一定阈值就判断该方法是热点方法，这种方式的统计结果更加精确严谨但比较麻烦，且无法获取到方法的调用关系。HotSpot 采用基于计数器的热点探测，并为每个方法准备了方法调用计数器和回边计数器（用于统计方法中的循环体执行次数）。热点探测是在方法执行过程中进行的，一旦发现新的热点代码就会产生编译请求（由后台编译线程执行），但执行引擎默认不会同步等待编译请求完成，而是继续进入解释器按照解释方式执行字节码，一旦提交的请求被 JIT 编译器编译完成，该方法的调用入口地址就会被系统自动改写成新值，下一次调用该方法时就会使用已编译的版本。</p>
<p>目前主流的商用 JVM 内部都同时包含解释器和 JIT 编译器，当程序需要迅速启动和执行时，解释器可以首先发挥作用，把越来越多的代码编译成本地机器代码，减少解释器的中间损耗，获得更高的执行效率；当程序运行环境中内存资源限制较大，可以使用解释执行节约内存，反之可以使用编译执行来提升效率，此外，当 JIT 编译器根据概率选择一些不能保证正确的优化手段并出现问题时，可以通过逆优化退回到解释状态继续执行，即解释器可以作为 JIT 编译器激进优化时的后备。HotSpot VM 中内置了两个 JIT 编译器，分别是<strong>客户端编译器（又称 C1 编译器，编译速度更高）、服务端（又称 C2 编译器，编译质量更好）</strong>，在分层编译的工作模式之前，HotSpot VM 通常工作于混合模式（Mixed Mode），但用户也可以通过参数强制 HotSpot VM 运行于解释模式（Interpreted Mode）或编译模式（Compiled Mode）。<strong>Mixed Mode</strong> 时解释器与其中一个编译器直接搭配，<strong>Interpreted Mode</strong> 时编译器完全不工作，全部代码都使用解释执行，<strong>Compiled Mode</strong> 时优先使用编译方式执行程序，解释器仅在编译无法进行的情况介入。</p>
<p>考虑到 JIT 编译器需要占用程序运行时间，且为了编译出优化程度越高的代码，所花费的时间便会越长，甚至解释器可能还要替编译器收集性能监控信息，这对解释执行阶段的速度也有所影响，为了在程序启动响应速度与运行效率之间达到最佳平衡，HotSpot VM 使用分层编译。<strong>分层编译</strong>根据编译器编译、优化的规模与耗时，划分出不同编译层次：第 0 层，程序纯解释执行，并且解释器不开启性能监控功能；第 1 层，使用 C1 编译器将字节码编译为本地代码来运行，进行简单可靠的稳定优化，不开启性能监控功能；第 2 层，仍使用 C1 编译器执行，仅开启方法及回边次数统计等有限的性能监控功能；第 3 层，仍使用 C1 编译器执行，开启全部性能监控；第 4 层，使用 C2 编译器将字节码编译为本地代码，相比于 C1 编译器，C2 编译器会启用更多编译耗时更长的优化，还会根据性能监控信息进行不可靠的激进优化。实施分层编译后，解释器、C1 编译器以及 C2 编译器就会同时工作，热点代码都可能会被多次编译，在解释执行时解释器无需额外承担收集性能监控信息的任务，在 C2 编译器采用高复杂度的优化算法时 C1 编译器可先采用简单优化来为 C2 编译器争取更多的编译时间。</p>
<h3 id="3-3-3-JIT-优化"><a href="#3-3-3-JIT-优化" class="headerlink" title="3.3.3 JIT 优化"></a>3.3.3 JIT 优化</h3><p>JIT 编译器的主要优化有：锁消除、锁膨胀、标量替换、栈上分配、方法内联、空值检查消除、类型检测消除、公共子表达式消除。JIT 根据对象的逃逸状态采用不同的优化策略，这些优化可以显著提高性能，减少垃圾收集的压力，以提高 Java 程序的性能和效率。对象的逃逸状态如下</p>
<ul>
<li><p>全局逃逸</p>
<ul>
<li>指对象超出了方法或线程的范围，比如存储在静态字段或作为方法的返回值</li>
<li>由于对象可能被多个线程访问，一般不适合进行锁消除、栈上分配或其他内存优化，但可以进行方法内联或循环优化这样的优化</li>
</ul>
</li>
<li><p>参数逃逸</p>
<ul>
<li>指对象被作为参数传递或被参数引用（但在方法调用期间不会全局逃逸），不适用进行栈上分配这样的优化</li>
<li>由于对象不会被方法外部的代码使用，可以进行锁消除这样的优化，也可以进行方法内联或循环优化这样的优化</li>
</ul>
</li>
<li><p>无逃逸</p>
<ul>
<li>指对象可以被标量替换，意味着它的内存分配可以从生成的代码中移除</li>
<li>这是最适合优化的情况，可以进行方法内联、循环优化、栈上内存分配、锁消除、甚至完全消除对象分配（标量替换）</li>
</ul>
</li>
</ul>
<p>注：</p>
<ul>
<li><p>自 JDK 7 开始，默认是开启逃逸分析的，但逃逸分析自身也是需要进行一系列复杂的分析的，其性能消耗并不保证一定能被优化效果所弥补，因此这项技术其实并不是十分成熟</p>
</li>
<li><p>标量是指一个无法再分解成更小的数据的数据，Java 的基本数据类型就是标量，而那些还可以分解的数据叫做聚合量，Java 对象就是聚合量，可以分解为其他聚合量和标量</p>
</li>
<li><p>当发现一个局部对象没有逃逸到线程和方法外，不会被外界访问时，这个对象就可能不会在堆上分配内存，而是把这个原本需要在堆中分配内存的对象拆解成若干个栈上分配的标量，减少堆内存的占用，这就是标量替换和栈上分配</p>
</li>
<li><p>方法内联意味着将一个方法的代码直接插入到调用的地方，避免方法调用的开销，这种优化对于小型且频繁调用的方法特别有用。·</p>
</li>
<li><p>预热是指在应用刚刚启动时，通过调用负载均衡，先放一小部分流量来触发 JIT 优化，等基本优化好了之后再服务大流量</p>
</li>
</ul>
<h1 id="4、参考资料"><a href="#4、参考资料" class="headerlink" title="4、参考资料"></a>4、参考资料</h1><ul>
<li>《Understanding the JVM, Advanced Features and Best Practices, Third Edition》</li>
<li><a href="https://www.yuque.com/hollis666/niq4hm/ouwbti">常用的 JVM 工具</a></li>
<li><a href="https://www.yuque.com/hollis666/niq4hm/nw8et6">常用的 JVM 启动参数</a></li>
</ul>
]]></content>
  </entry>
  <entry>
    <title>Message Queue</title>
    <url>/2024/02/21/mq/</url>
    <content><![CDATA[<h1 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h1><p>消息队列的目标在于</p>
<ul>
<li>解耦，上游系统模块可以独立地将消息发布到消息队列中，无需关心消息的订阅方，下游系统模块可以自行从消息队列中订阅所需的消息，无需关心消息的发布方，通过消息队列可以解耦原本需要直接依赖的系统模块</li>
<li>异步，对于一些比较耗时的操作来说，如果使用同步的方式处理，会阻塞主工作流并使其性能下降，可以将操作封装成消息放到消息队列中，由子系统异步地对消息队列中的消息进行处理，可以避免原本同步时对主流程的影响</li>
<li>控流，针对那些非常态的突发性流量，并不适合直接增加系统资源，可以将消息队列作为缓冲区，令系统以一个比较平稳的流量负载运行，减少瞬时压力，提升系统的稳定性</li>
</ul>
<p>为了实现以上目标，消息队列应当做到</p>
<ul>
<li>可靠性高，消息队列应当实现消息的备份、持久化存储以及故障恢复等功能，确保消息不会丢失</li>
<li>扩展性好，消息队列应当能够通过增加服务实例来轻松实现消息队列的水平扩展</li>
<li>灵活性强，消息队列应当能够支持多种消息传递模型，例如点对点，发布-订阅等，适应各种业务场景</li>
</ul>
<p>Kafka、ActiveMQ、RabbitMQ 和 RocketMQ 都是常见的消息中间件，都提供了高性能、高可用、可扩展且灵活的消息队列，区别如下</p>
<ul>
<li>Kafka 主要支持发布-订阅模型，ActiveMQ、RabbitMQ 和 RocketMQ 同时支持点对点和发布-订阅模型</li>
<li>Kafka 在数据处理和数据分发方面具备高吞吐量，可以处理每秒数百万条消息，ActiveMQ、RabbitMQ 和 RocketMQ 吞吐量相对 Kafka 较低</li>
<li>Kafka 将消息划分为多个分区，并分布在多个服务器上，实现了负载均衡和高可用性，ActiveMQ、RabbitMQ 和 RocketMQ 也支持消息分区和负载均衡，但实现方式不同</li>
<li>Kafka 易于使用和部署，但是一些高级功能需要比较复杂的配置，ActiveMQ、RabbitMQ 和 RocketMQ 提供了很多灵活的多功能，但是会增加开发和部署的复杂度</li>
<li>Kafka 不支持优先级队列、延迟队列、死信队列以及重试队列，ActiveMQ、RabbitMQ 和 RocketMQ 都支持</li>
<li>Kafka 主要是拉模式，ActiveMQ、RabbitMQ 和 RocketMQ 同时支持推拉两种模式</li>
<li>Kafka 提供更加快速的消息持久化，并且支持高效的消息查询，RabbitMQ 和 RocketMQ 提供更加传统的消息持久化方式</li>
<li>Kafka、ActiveMQ 和 RocketMQ 都是基于 Java 语言的，RabbitMQ 是基于 Erlang 的</li>
<li>Kafka 和 RocketMQ 的社区活跃度和发展势头是最高的</li>
</ul>
<h1 id="Kafka"><a href="#Kafka" class="headerlink" title="Kafka"></a>Kafka</h1><ul>
<li>架构<ul>
<li>Kafka 是分布式架构，由 Producer（生产者）、Broker（Kafka 集群）、Consumer（消费者）组成</li>
<li>Producer 负责将消息发布到 Broker 中的一个或多个 Topic，每个 Topic 包含一个或多个分区（Topic 是承载消息的逻辑容器，用于区分具体业务，分区是存储消息的物理容器，每个分区都是一个有序且持久化存储地日志文件）</li>
<li>Consumer 负责从 Broker 中拉取一个或多个 Topic 的消息，并修改消息的 Offset，以确保消息的顺序性、一致性、不丢失、也不重复（Offset 是每条消息的位置信息，单调递增）</li>
<li>多个 Broker 组成 Kafka 集群，每个分区都有一个主 Broker 和多个从 Broker，只有主 Broker 才可以处理 Producer 和 Consumer 的请求，每个 Broker 节点都可以存储一个或多个 Topic 的分区副本，以提供高可用性和容错能力</li>
<li>Kafka 使用 Zookeeper 作为分布式协调服务，用于维护 Kafka 集群的状态和元数据信息，比如 Topic 和分区的分配信息、分区的主 Broker、消费者组以及消费者 Offset 等</li>
</ul>
</li>
<li>消息发送<ul>
<li>Kafka 将多个消息打包成一个批次，减少了网络传输和磁盘写入的次数，提高了消息的吞吐量和传输效率</li>
<li>Kafka 通过一个确认机制来告知生产者消息是否发送成功，生产者可以异步发送消息，不必等待每个消息的确认</li>
<li>Kafka 将数据分布在不同的分区中，生产者可以并行发送多个消息（每个消息发送到某个特定分区），提高了消息的吞吐量</li>
<li>Kafka 通过对消息进行压缩，减少了需要网络传输的数据量，提高了消息的传输效率</li>
</ul>
</li>
<li>消息存储<ul>
<li>Kafka 使用零拷贝来避免数据的拷贝操作，降低了内存和 CPU 的使用率，提高了系统性能</li>
<li>Kafka 以顺序写入的方式来将数据写入磁盘，降低了磁头寻道时间，提高了写入效率</li>
<li>Kafka 在从磁盘中读取数据时，会在操作系统的页缓存中保留数据页副本，后续的数据访问会更加快速</li>
<li>Kafka 通过分段的日志文件来存储消息，每个分段都有自己的索引文件，这些索引文件是每隔一定数量的消息建立索引点的稀疏索引，索引占用空间小，内存可以加载更多的索引，从而提高查找特定消息的效率</li>
<li>Kafka 将消息划分为多个分区，并分布在多个服务器上，每个分区都有多个消息副本，实现了负载均衡和高可用性</li>
</ul>
</li>
<li>消息消费<ul>
<li>Kafka 通过消费者群组实现消息的负载均衡和容错处理，同一个消费者组内的消费者可以共享消费负载，如果一个消息被消费者组中的任何一个消费者消费了，则组内其他消费者就不会再收到这个消息</li>
<li>Kafka 的重平衡机制会在消费者组中新增或删除消费者（或者订阅 Topic 数量发生变化，或者订阅 Topic 的分区数量发生变化）时，重新分配 Topic 分区给各个组内的各个消费者，以保证每个消费者消费的分区数量尽可能均衡</li>
<li>Kafka 支持不同消费者独立并行的消费不同分区的消息</li>
<li>Kafka 支持一次性拉取多个消息进行消费</li>
</ul>
</li>
<li>消息传递语义<ul>
<li>At-least-once，消息不会丢失但可能会重复（默认）</li>
<li>At-most-once，消息可能会丢失但不会重复</li>
<li>Exactly-once，消息不会丢失也不会重复</li>
</ul>
</li>
</ul>
<h1 id="RocketMQ"><a href="#RocketMQ" class="headerlink" title="RocketMQ"></a>RocketMQ</h1><ul>
<li>架构<ul>
<li>RocketMQ 同样由 Producer、Broker（MQ 集群）、Consumer 组成</li>
<li>Producer 负责将消息发送到 Broker，Consumer 负责从 Broker 消费消息，Consumer Group 和记录该 Consumer Group 与服务端交互方式、Topic、Tag 的配置项的映射关系是一比一</li>
<li>Broker 是存储和转发消息的中转服务器，Broker 集群中的每个 Broker 都拥有独立的存储空间和消息队列，集群有单 Master、多 Master、多 Master 多 Slave 这三种方式，</li>
<li>RocketMQ 使用 NameServer 作为命名服务，NameServer 负责维护 Broker 的元数据信息（Broker 地址、Topic、Queue 等），同时也是路由和寻址中心，Producer 和 Consumer 在启动时需要连接到 NameServer 来获取 Broker 的信息以及路由信息等</li>
</ul>
</li>
<li>事务消息发送<ul>
<li>RocketMQ 的事务消息是通过 TransactionListener 接口来实现的</li>
<li>Producer 在发送消息时，首先向 Broker 发送一条 half 消息，half 消息会被存储在 Broker 的事务消息日志中（此时的 half 消息还不能被消费），Producer 在 half 消息发送成功后再执行本地事务并告知 Broker 事务执行结果</li>
<li>若 Producer 事务执行成功，就会通知 Broker 提交改事务消息（此时消息可以被消费了），若执行失败，就会通知 Broker 回滚该事务消息（此时消息会被删除）</li>
<li>若 Broker 在规定时间内没有收到事务执行结果，会不断向 Producer 发送回查消息来询问结果，若 Producer 未能在过期时间内返回响应，则 Broker 自动回滚该事务消息</li>
</ul>
</li>
<li>顺序消息消费<ul>
<li>和 Kafka 支持同一个分区内的消息顺序消费（不同分区的消息消费是无序的）一样，RocketMQ 也提供同一个队列的消息顺序消费（不同队列的消息消费是无序的），因此顺序消费的前提是 Producer 选择同一个 Broker 以同步的方式发送顺序消息</li>
<li>接着需要向该 Broker 为特定消费者申请分布式锁，加锁成功后该 Broker 的后续消息会只发送给特定的 Consumer，该 Consumer 会一次性拉取多条消息到本地 MessageQueue，因此需要申请 MessageQueue 锁来确保同一时间一个队列中只有一个线程能处理队列中的消息，即可顺序消费消息</li>
<li>由于顺序消息消费需要加锁，因此会降低吞吐量，甚至造成消息阻塞</li>
</ul>
</li>
<li>非顺序消息消费<ul>
<li>RocketMQ 支持广播消费和集群消费</li>
<li>广播消费时，RocketMQ 会将每条消息推送给集群内的所有消费者，保证消息至少被每个消费者消费一次，但是并不会重投消费失败的消息，客户端每一次重启都会从最新消息消费，客户端被关闭期间发送至服务端的消息将会被自动跳过</li>
<li>集群消费时，RocketMQ 会将每一条消息都只分发到一个消费者客户端处理，不保证每一次失败重投的消息都被路由到同一个消费者上</li>
</ul>
</li>
<li>延时消息消费<ul>
<li>RocketMQ 支持需要等待指定时长才能能被消费的延时消息，实现方式是先将消息存储在内存中，然后使用定时器/时间轮进行消息延迟，到达指定时间后再将消息存储到磁盘中，此时才能由消费者消费</li>
</ul>
</li>
<li>消息堆积<ul>
<li>但客户端消息消费耗时过长或并发度较小时，就可能会出现消息堆积，此时可以增加消费者数量、提升消费者速度、降低生产者速度、清理过期消息、增加更多的 Broker 队列</li>
</ul>
</li>
</ul>
<h1 id="RabbitMQ"><a href="#RabbitMQ" class="headerlink" title="RabbitMQ"></a>RabbitMQ</h1><p>RabbitMQ 实现了高级消息队列协议（AMQP），也支持其他消息传递协议，例如简单文本定向消息协议（STOMP）和物联网协议（MQTT）</p>
<ul>
<li>架构<ul>
<li>RabbitMQ 由 Producer、VHost、Exchange、Queue、Binding、Consumer 组成</li>
<li>Producer 将消息发布到 Exchange，Exchange 是消息的接收和路由中心，将接收到的来自生产者的消息路由到一个或多个与之绑定的 Queue 中，Queue 是消息的存储和消费地，保存者未被消费的消息并等待 Consumer 消费，Binding 是 Exchange 和 Queue 之间的关联关系，定义了 Exchange 将消息路由到哪些 Queue 中</li>
<li>VHost 是 RabbitMQ 的虚拟主机，类似于操作系统中的命名空间，用于将 RabbitMQ 的资源进行隔离和分组，每个 VHost 都拥有自己的 Exchange、Queue、Binding 和权限设置，不同 VHost 之间的资源相互独立，可以用于将不同的应用服务进行隔离，防止彼此之间的消息冲突和资源竞争</li>
</ul>
</li>
<li>消息分发<ul>
<li>RabbitMQ 通过确认机制或者事务机制来保证消息一定能成功发送，RabbitMQ 有六种消息分发模式，分别是简单模式、工作队列模型、发布订阅模式、路由模型、主题模型以及 RPC 模式</li>
<li>简单模式是最基本最简单的消息传递模式，一个 Producer 将消息发送到一个 Queue 中，一个 Consumer 从 Queue 中获取并处理消息，消息的处理是同步的，适用于单个 Producer 和单个 Consumer 的场景</li>
<li>工作队列模式用于实现一个任务在多个 Consumer 之间的并发处理的场景，每个消息只能被一个 Consumer 处理，可以提高系统的吞吐量</li>
<li>发布订阅模式用于实现一个消息被多个消费者同时处理的场景（日志订阅等），Exchange 会将消息广播到所有绑定的 Queue，每个队列对应一个 Consumer</li>
<li>路由模式用于实现需要根据消息的路由键将消息路由到不同队列的场景，Exchange 会根据路由键将消息路由到与之匹配的队列中，实现消息的筛选和分发</li>
<li>主题模式是一个更灵活更复杂的消息路由模式，使用通配符匹配路由键，可以将消息路由到多个队列中</li>
</ul>
</li>
<li>延迟消息消费<ul>
<li>RabbitMQ 中的正常消息如果超过存活时间（TTL 过期），或者队列长度超限，或者被消费者拒绝，或者无法路由等没有被消费，那么就会成为死信，并被重新发送到死信队列中</li>
<li>可以通过给消息设置 TTL，等待消息过期成为死信之后再消费，就实现了延迟消息消费，RabbitMQ 的 TTL 是可以设置任意时长的，不同于 RocketMQ 只能设置一些固定的时长</li>
<li>注意如果排在队头的消息的 TTL 设置的很大，那么排在队头之后的消息即使过期也无法进入死信队列，而是会一直被队头阻塞</li>
</ul>
</li>
<li>消息重复<ul>
<li>RabbitMQ 通过解决幂等问题来避免消息重复消费，即每个消息都带有一个唯一的标识，Consumer 通过这个唯一标识来判断消息是否被重复消费了</li>
</ul>
</li>
</ul>
]]></content>
  </entry>
  <entry>
    <title>Maven</title>
    <url>/2022/05/07/maven/</url>
    <content><![CDATA[<p>Maven是一个用于 Java 项目管理和构建的工具，提供了一套标准化的项目结构，标准化自动化的构建流程（编译、测试、打包、发布），以及项目依赖管理机制（jar 包导入、冲突解决）。</p>
<h1 id="项目结构"><a href="#项目结构" class="headerlink" title="项目结构"></a>项目结构</h1><p>一个使用Maven管理的Java项目目录结构如下：</p>
<ul>
<li><p><code>pom.xml</code>：项目描述文件 (Project Object Model)；</p>
</li>
<li><p><code>src/main/java</code>：Java源码；</p>
</li>
<li><p><code>src/main/resources</code>：资源文件；</p>
</li>
<li><p><code>src/test/java</code>：测试源码；</p>
</li>
<li><p><code>src/test/resources</code>：测试资源文件；</p>
</li>
<li><p><code>target</code>：所有编译、打包生成的文件。</p>
</li>
</ul>
<p>注：</p>
<ul>
<li><p>在<code>pom.xml</code>文件中，<code>groupId</code>定义隶属的实际项目；<code>artifactId</code>定义项目中的一个模块；</p>
</li>
<li><p>一个Maven工程是由<code>groupId</code>，<code>artifactId</code>和<code>version</code>作为唯一标识，在引用其他第三方库的时候，也是通过这3个变量来唯一定位要依赖的jar包。</p>
</li>
</ul>
<h1 id="依赖管理"><a href="#依赖管理" class="headerlink" title="依赖管理"></a>依赖管理</h1><p>Maven会自动解析并判断真正需要的依赖，避免了繁琐的人工管理。Maven定义了几种依赖关系（scope）如下：</p>
<ul>
<li><p>compile：编译、运行和测试时需要用到的jar包（最常用的，直接放入classpath），打包时也要包含进去；</p>
</li>
<li><p>test：编译UT时需要用到的jar包，不会随项目发布，比如junit；</p>
</li>
<li><p>runtime：编译时不需要，但运行和测试时需要用到的jar包，比如mysql；</p>
</li>
<li><p>provided：编译时需要用到，但运行时不需要（运行时由JDK或某个服务器提供），打包时不需要包含进去，比如servlet-api。</p>
</li>
</ul>
<p>Maven 默认的依赖传递原则如下：</p>
<ul>
<li><p>最短路径优先原则：A -&gt; B -&gt; C(2.0) 路径和 A -&gt; C(1.0) 路径相比，最终生效的是路径更短的 1.0 版本的 C 包</p>
</li>
<li><p>最先声明优先原则：如果路径长度一致，A -&gt; C(1.0) 和 B -&gt; C(2.0) 相比，最终生效的更早声明的 1.0 版本的 C 包</p>
</li>
</ul>
<p>如果在应用运行期间发生了<code>NoSuchMethodError</code>、<code>ClassNotFoundException</code>等异常或错误时，需要考虑依赖冲突问题，Maven 的 jar 包依赖传递原则最终选择的 jar 包可能并不是真正需要的，通过<code>mvn dependency:tree</code>命令可以打印整个项目的 jar 包依赖的依赖树，从而查看冲突 jar 包的多种不同版本的依赖路径，此时就需要如下人工干预手段来选择所需要的 jar 包：</p>
<ul>
<li><p>在<code>&lt;dependency&gt;&lt;/dependency&gt;</code>标签内使用<code>&lt;exclusions&gt;&lt;exclusion&gt;&lt;/exclusion&gt;&lt;/exclusions&gt;</code>标签来排除不需要的 jar 包</p>
</li>
<li><p>在父 POM 中直接指定需要的版本，无需一个一个地进行 exclusion</p>
</li>
</ul>
<h1 id="常见打包格式"><a href="#常见打包格式" class="headerlink" title="常见打包格式"></a>常见打包格式</h1><p>jar 和 war 是 Java 中常见的两种打包文件格式</p>
<ul>
<li><p>jar 包是一种用于打包 Java 类（.class 文件）和相关资源（文本文件，图片等）的归档文件格式，方便进行分发和部署，通常用于在 Java 应用中引入其他的库文件，也可以作为 Java 应用程序的可执行文件运行</p>
</li>
<li><p>fat jar 是一种包含所有依赖项的 jar 文件（将多个 jar 文件打包到一个 jar 中），这些依赖项通常需要在运行时加载，可以方便地一次性部署和维护多个 jar 组成的应用程序，但 fat jar 容易过大不利于网络传输和存储，需要在 fat jar 和普通 jar 之间权衡</p>
</li>
<li><p>war 包是一种用于打包 Web 应用程序的归档文件格式，通过包含 Web 应用程序的所有文件和资源，如 JSP 文件、HTML 文件、JS 文件、CSS 文件、.class 文件、web.xml 文件、配置文件、资源文件等，是将 Web 应用程序打包和部署的标准方式，可以方便地将 Web 应用程序部署到 Web 容器（Tomcat、Jetty 等）中</p>
</li>
<li><p>ear 包是一种打包 Java EE 的归档文件格式，包含多个模块，如 ejb 模块、war 模块、jar 模块等，是一种高级的打包格式，打包后再 Java EE 服务器上部署</p>
</li>
<li><p>sar 包通常用于将 Java EE 应用程序部署在 JBoss 应用服务器上，JBoss 可以方便地将 Java EE 应用程序部署为服务，并对服务进行管理、监控和控制</p>
</li>
<li><p>apk 包是一种用于打包 Android 应用程序的归档文件格式，包含 Android 应用程序的所有资源文件、代码文件、配置文件、库文件等</p>
</li>
</ul>
<h1 id="jar-包的发布与下载"><a href="#jar-包的发布与下载" class="headerlink" title="jar 包的发布与下载"></a>jar 包的发布与下载</h1><ul>
<li><p>一个 jar 包一经发布就无法修改，修改已发布 jar 包的唯一方法是发布一个新版本；</p>
</li>
<li><p>Maven 维护了一个中央仓库，所有第三方库将自身的 jar 以及相关信息上传至中央仓库，Maven 就可以从中央仓库把所需依赖下载到本地；</p>
</li>
<li><p>一个 jar 包一旦被下载过，就会被 Maven 自动缓存在本地目录（用户主目录的<code>.m2</code>目录），避免重复下载；</p>
</li>
<li><p><code>version</code>以<code>-SNAPSHOT</code>结尾的jar包会被Maven视为开发版本，开发版本每次都会重复下载，这种开发版本只能用于内部私有的Maven repo，公开发布的版本不允许出现 SNAPSHOT；</p>
</li>
<li><p>当中央仓库速度较慢时，可以选择一个速度较快的 Maven 的镜像仓库（镜像仓库定期从中央仓库同步），使用Maven镜像仓库需要在用户主目录的<code>.m2</code>目录创建一个<code>settings.xml</code>配置文件，进行配置；</p>
</li>
<li><p>进入到<code>pom.xml</code>所在的目录，输入命令<code>mvn clean package</code>，即可在<code>target</code>目录下获得编译后自动打包的jar包。</p>
</li>
</ul>
<h1 id="构建流程"><a href="#构建流程" class="headerlink" title="构建流程"></a>构建流程</h1><ul>
<li><p>Maven有两个生命周期（lifecycle）： <code>default</code>和<code>clean</code>，每个lifecycle都由一系列阶段（phase）构成；</p>
</li>
<li><p>mvn命令后面的参数是指phase；</p>
</li>
<li><p>当命令中只有一个phase时，就运行<code>default</code>这个lifecycle，并运行到指定的phase；</p>
</li>
<li><p>当命令中有两个phase时，就依次先后运行<code>clean</code>和<code>default</code>这两个lifecycle到分别指定的phase；</p>
</li>
<li><p>常用的phase按运行顺序分别是clean（清理所有生成的class和jar）、compile（编译）、test（运行测试）、package（打包）；</p>
</li>
<li><p>每执行一个phase，又会触发一个或多个goal，goal是最小任务单元，goal的名称是<code>a:b</code>这种形式；</p>
</li>
<li><p>大多数情况下只要指定phase，就默认执行这些phase默认绑定的goal，只有少数情况可以直接指定运行一个goal，例如，启动Tomcat服务器的命令是<code>mvn tomcat:run</code>；</p>
</li>
<li><p>执行每个phase，都是通过某个插件（plugin）来执行的，maven只是负责找到phase对应的plugin；</p>
</li>
<li><p>maven内置了一些常用的标准插件，当标准插件无法满足要求时，还可以通过在<code>pom.xml</code>文件中声明并配置自定义的插件。</p>
<ul>
<li><p>maven-source-plugin插件用于创建源码</p>
</li>
<li><p>maven-javadoc-plugin插件用于创建javadoc</p>
</li>
<li><p>spring-boot-maven-plugin插件用于将应用打包成一个可执行的jar包或war包（可直接使用<code>java -jar</code>命令执行）</p>
</li>
</ul>
</li>
</ul>
<h1 id="模块管理"><a href="#模块管理" class="headerlink" title="模块管理"></a>模块管理</h1><ul>
<li><p>将一个项目拆分为多个模块可以降低软件复杂度，拆分后的项目中的每个模块都有自己的<code>pom.xml</code>和<code>src</code>，可以把每个模块当做独立的Maven项目，每个模块也可以在<code>pom.xml</code>引入其他模块；</p>
</li>
<li><p>当模块之间存在大量重复时，可以提取出公共的部分作为parent，parent的<code>&lt;packaging&gt;</code>是<code>pom</code>，module的<code>&lt;packaging&gt;</code>是<code>jar</code>，parent本身不含任何Java代码；</p>
</li>
<li><p>在根目录输入命令<code>mvn clean package</code>，即可将包括parent在内的所有module一次性全部编译打包。</p>
</li>
</ul>
<img src="模块结构.jpg" alt="模块结构" style="zoom:100%;" />

<h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><ul>
<li><a href="https://www.liaoxuefeng.com/wiki/1252599548343744/1255945359327200">https://www.liaoxuefeng.com/wiki/1252599548343744/1255945359327200</a></li>
</ul>
]]></content>
  </entry>
  <entry>
    <title>MySQL</title>
    <url>/2022/08/06/mysql/</url>
    <content><![CDATA[<h1 id="1、概述"><a href="#1、概述" class="headerlink" title="1、概述"></a>1、概述</h1><h2 id="1-1-基础概念"><a href="#1-1-基础概念" class="headerlink" title="1.1 基础概念"></a>1.1 基础概念</h2><h3 id="1-1-1-关系型数据库"><a href="#1-1-1-关系型数据库" class="headerlink" title="1.1.1 关系型数据库"></a>1.1.1 关系型数据库</h3><p>关系型数据库是指采用了关系模型来组织数据的数据库，可以简单理解为二维表格模型，常见的 MySQL、Oracle 都是关系型数据库</p>
<ul>
<li>以行和列的形式存储数据，以便用户管理</li>
<li>采用结构化查询语言（SQL）来对数据库进行查询，支持各种范围查询、公式计算等</li>
<li>数据通常存储在硬盘中（这导致了一定的性能问题），MySQL 可以基于内存存储</li>
<li>十分强调数据一致性、事务以及读写性能</li>
</ul>
<p>NoSQL 表示非关系型数据库，比如 Redis、MongoDB 等</p>
<ul>
<li>主要指那些非关系型的、分布式的，一般不保证事务的数据存储系统，一般无法回滚（MongoDB 在集群模式下可以回滚）</li>
<li>无需提前设计表结构，数据可以根据需要自由地存储和组织，高效灵活，非常适合那些复杂、高变化、高并发量的场景</li>
<li>基于键值来存储数据，通过 key 来查询数据，不一定支持范围查询、公式计算等，对于 value 的类型有不同的支持，没有固定的要求和限制</li>
<li>数据通常存储在内存中（MongoDB 基于磁盘存储）</li>
</ul>
<h3 id="1-1-2-事务"><a href="#1-1-2-事务" class="headerlink" title="1.1.2 事务"></a>1.1.2 事务</h3><p>事务是一组数据库操作序列，是一个独立的工作单元，事务应当具备四个特性：</p>
<ul>
<li>原子性（atomicity）：一个事务必须被视为一个不可分割的最小工作单元，整个事务中的所有操作要么全部执行成功，要么全部执行失败。</li>
<li>一致性（consistency）：确保数据库总是从一个一致性的状态转换到另一个一致性的状态，在一致性状态下，所有事务对同一数据的读取结果都是相同的。</li>
<li>隔离性（isolation）：一个事务所做的修改在最终提交之前，对其他事务是不可见的，即一个事务的执行不会对其他事务执行产生影响。</li>
<li>持久性（durability）：一旦事务提交，则其所做的修改就会永远保存到数据库中，持久性是有很多不同级别的。</li>
</ul>
<p>满足 ACID 特性的事务处理系统才是一个运行良好的系统，这种事务处理过程中额外的安全性也会需要数据库系统做更多额外的工作，需要更强的 CPU 处理能力，更大的内存和更多的磁盘空间。</p>
<h3 id="1-1-3-并发一致性问题"><a href="#1-1-3-并发一致性问题" class="headerlink" title="1.1.3 并发一致性问题"></a>1.1.3 并发一致性问题</h3><p>当事务的一致性没有满足时，就会出现一些并发一致性问题：</p>
<ul>
<li>脏读：一个事务读到其他事务还未提交的修改数据，假如其他事务撤销了该修改，那么当前事务读到的就是脏数据/无效数据。</li>
<li>不可重复读：一个事务多次读取同一数据集合，假如此时有其他事务对这一数据集合进行了修改，那么当前事务多次读取到的结果是不同的。</li>
<li>幻读：一个事务多次读取同一数据集合，假如此时有其他事务对这一数据集合进行了插入或者删除，那么当前事务就会读取到幻行（行数不一致），是不可重复读的一种特殊场景。</li>
</ul>
<h3 id="1-1-4-隔离级别"><a href="#1-1-4-隔离级别" class="headerlink" title="1.1.4 隔离级别"></a>1.1.4 隔离级别</h3><p>在 SQL 标准中定义了四种隔离级别：</p>
<ul>
<li>未提交读（READ UNCOMMITED）<ul>
<li>事务中的修改即使没有提交，对其他事务也都是可见的；</li>
<li>此时会出现脏读、不可重复读以及幻读。</li>
</ul>
</li>
<li>提交读（READ COMMITED）<ul>
<li>一个事务从开始到提交之前，所做的修改对其他事务都是不可见的；</li>
<li>是 Oracle 等大多数数据库系统的默认事务隔离级别；</li>
<li>此时可能会出现不可重复读和幻读。</li>
</ul>
</li>
<li>可重复读（REPEATABLE READ）<ul>
<li>在同一事务中多次读取同一数据的结果是一样的；</li>
<li>是 MySQL 的默认事务隔离级别；</li>
<li>可能会出现幻读。</li>
</ul>
</li>
<li>可串行化（SERIALIZABLE）<ul>
<li>强制事务串行执行；</li>
<li>这一隔离级别需要加锁来实现；</li>
<li>不会出现并发一致性问题。</li>
</ul>
</li>
</ul>
<p>较低级别的隔离通常可以执行更高的并发，系统的开销也更低，但需要开发人员自行解决该隔离级别无法保证解决的问题。</p>
<p>注：</p>
<ul>
<li>Oracle 只支持 READ COMMITED、SERIALIZABLE、READ-ONLY 这三种隔离级别，显然 SERIALIZABLE 和 READ-ONLY 不适合作为默认级别，那就只剩下 READ COMMITED 这一个默认选择了</li>
<li>MySQL 的定位是一个稳定的关系型数据库，那么为了解决单点故障就引入了主从复制机制，为了保证主从服务器之间的数据一致性就需要通过 BinLog 进行数据同步，早期的 BinLog 只有 statement 这种记录格式（即记录 SQL 语句原文），如果此时使用 READ COMMITED 这一隔离级别，那么一旦后执行的 SQL 先被提交，也就先被记录到 BinLog 中，BinLog 中记录的 SQL 的执行顺序的错误会导致从表的数据与主表不一致，而在 REPEATABLE READ 这一隔离级别下，间隙锁会保证一定是先执行的 SQL 先被提交，从而避免后续的一系列问题，因此 MySQL 使用 REPEATABLE READ 作为默认的隔离级别</li>
<li>后来 MySQL 的 BinLog 出现了 statement 以外的其他记录格式（row 和 mixed），其中 row 格式可以在 READ COMMITED 下正常工作，此时就可以将 MySQL 的隔离级别改为 READ COMMITED，从而执行更高的并发</li>
</ul>
<h2 id="1-2-MySQL"><a href="#1-2-MySQL" class="headerlink" title="1.2 MySQL"></a>1.2 MySQL</h2><h3 id="1-2-1-架构"><a href="#1-2-1-架构" class="headerlink" title="1.2.1 架构"></a>1.2.1 架构</h3><p>MySQL 是一个灵活的数据库系统，主要体现在：可适应不同的硬件，可支持多种数据类型，可支持多种应用类型，尤其是其存储引擎架构将数据的处理和存储相分离，极大地提高了使用时的灵活性。</p>
<p>MySQL 的逻辑架构可分为三层：</p>
<ul>
<li>最上层是服务器层（与客户端对接）<ul>
<li>实现连接处理、授权认证等功能；</li>
<li>每个客户端连接都会在服务器进程中拥有一个线程，该连接的操作都会由这个线程执行，服务器对线程进行统一管理。</li>
</ul>
</li>
<li>第二层是查询执行引擎（实现所有的跨存储引擎的功能）<ul>
<li>比如查询解析、分析、优化、缓存等；</li>
<li>优化器并不关心具体使用的是什么存储引擎，但存储引擎对于优化是有影响的。</li>
</ul>
</li>
<li>第三层是存储引擎层<ul>
<li>MySQL 支持多个存储引擎的架构，那么针对一些复杂问题（比如事务处理、锁管理等）就不需要单一的通用解决方案，每个存储引擎都可以提供自己的解决方案；</li>
<li>服务器通过API与存储引擎通信，这些 API 对服务器屏蔽了不同存储引擎之间的差异；</li>
<li>不同的存储引擎之间不会通信，只是相应上层服务器的请求。</li>
</ul>
</li>
</ul>
<h3 id="1-2-2-存储引擎"><a href="#1-2-2-存储引擎" class="headerlink" title="1.2.2 存储引擎"></a>1.2.2 存储引擎</h3><p>数据库存储引擎是用于存储、处理和保护数据的核心服务，可控制访问权限并快速处理事务，MySQL 的存储引擎是基于表的，即可以指定某张表使用何种存储引擎</p>
<ul>
<li>InnoDB<ul>
<li>MySQL 默认的事务性存储引擎是 InnoDB，只有在需要它不支持的特性时，才考虑使用其他存储引擎；</li>
<li>InnoDB 可以将表的数据和索引存放在单独的文件中，存储格式是平台独立的；</li>
<li>InnoDB 在 5.6 之后支持全文索引（5.6 之前不支持）；</li>
<li>InnoDB 表是基于聚簇索引建立的，索引和数据存储在一起，这与其他存储引擎有很大不同；</li>
<li>InnoDB 支持事务、行级锁、表锁，还是 MySQL 中唯一支持外键的内置存储引擎；</li>
<li>InnoDB 不保存表的行数，必须建立针对自增长字段的单个字段的索引；</li>
<li>InnoDB 在清空整个表时是一行一行的删除，效率非常慢；</li>
<li>InnoDB 支持真正的热备份，MySQL 其他的存储引擎不支持热备份，要获取一致性视图需要停止对所有表的写入；</li>
<li>InnoDB 适合频繁修改的场景、涉及到安全性较高的场景。</li>
</ul>
</li>
<li>MyISAM<ul>
<li>在 MySQL5.5 之前，MyISAM 是默认的存储引擎；</li>
<li>MyISAM 提供高效的全文索引、压缩等特性；</li>
<li>MyISAM 支持表锁，不支持事务、外键、行级锁，崩溃后无法安全恢复；</li>
<li>MyISAM 采用非聚簇索引，采用索引和数据分离的存储方式；</li>
<li>MyISAM 保存表的行数，自增长字段可以和其他字段一起建立联合索引，不要求针对自增长字段的单个字段的索引；</li>
<li>MyISAM 在清空整个表时会重建表；</li>
<li>MyISAM 适合的场景有：频繁查询的读场景、插入为主的场景、表比较小可以忍受修复操作的场景、表在创建并导入数据后不会再进行修改的场景（采用 MyISAM 压缩表）。</li>
</ul>
</li>
</ul>
<h3 id="1-2-3-特性"><a href="#1-2-3-特性" class="headerlink" title="1.2.3 特性"></a>1.2.3 特性</h3><ul>
<li><p>存储</p>
<ul>
<li>MySQL 的数据是存储在磁盘上面的（Memory 引擎除外），但是为了提升读写性能，InnoDB 就引入 Buffer Pool 这一中间层，Buffer Pool 是在内存上的一块连续空间，主要用途是缓存数据页（页预读以及写脏页）</li>
<li>MySQL 的内存表技术允许将数据和索引存储在内存中，从而提高检索速度和修改数据的效率，可以实现快速响应的查询，节约硬盘存储空间，创建内存表与创建普通表一样，但需要将存储引擎设置为：ENGINE = MEMORY；</li>
<li>数据库的行格式决定了一行数据是如何进行物理存储的，进而影响查询和 DML 操作的性能，在 InnoDB 中，常见的行格式有 4 种；<ul>
<li>COMPACT，除了保存字段值外，还会利用空值列表保存 null 值，还会记录变长字段长度列表和记录头信息，适合处理大量包含可变长度列的数据</li>
<li>REDUNDANT，会把该条记录中所有列（包括隐藏列）的长度信息都存储到字段长度偏移列表中，这种格式用的比较少</li>
<li>DYNAMIC，是 COMPACT 的改进版，保持了 COMPACT 的优点，同时在存储大的可变长度列时更加灵活，能够动态地选择存储额页内或页外，适用于大部分的应用场景，并在存储空间和性能上做了一定的平衡，结构与 COMPACT 大致相同</li>
<li>COMPRESSED，是在 DYNAMIC 的基础上添加了页外压缩功能，可以在存储页外数据时对数据进行压缩，从而减少磁盘占用空间，在查询时会自动解压缩并返回结果，增加了 CPU 的使用，可能会降低一些查询性能</li>
<li>BARRACUDA，相对于前面的格式，支持更多高级特性，如动态行格式、行级压缩、空间管理等</li>
</ul>
</li>
</ul>
</li>
<li><p>死锁</p>
<ul>
<li>死锁指两个或两个以上并发事务在同一资源上互相占用，并请求锁定对方占用的资源，从而导致恶性循环的现象；</li>
<li>死锁的产生可能是由于真正的数据冲突，也可能是由于存储引擎的实现方式；</li>
<li>可以通过减少锁的数量、减少锁的时长、固定访问顺序以及减少操作的数据量等方式来预防死锁发生；</li>
<li>死锁发生后只有部分或者完全回滚其他一种事务，才能打破死锁；</li>
<li>InnoDB 目前处理死锁的方法是：将持有最少行级排它锁的事务进行回滚；</li>
<li>补充：即使只操作同一条记录，也会发生死锁，这是因为数据库锁的是索引，并不是记录，事务中更新一条记录时可能会使用到多个索引值，那就意味着那么存在多个线程按照不同的顺序去获取这一条记录对应的多个锁时，依旧存在发生死锁的可能</li>
</ul>
</li>
<li><p>日志</p>
<ul>
<li>事务日志可以帮助提高事务的效率，存储引擎在修改表的数据时只需修改其内存拷贝，再将修改行为记录到持久在硬盘上的事务日志中，而不需要每次都将修改的数据持久到硬盘，日志持久以后，内存中被修改的数据可以在后台慢慢地刷回到磁盘，这称之为预写式日志，修改数据需要写两次磁盘；</li>
<li>BinLog、RedoLog、UndoLog 都是 MySQL 的日志类型文件</li>
<li>BinLog 主要用来对数据库进行数据备份、崩溃恢复和数据复制（适用于所有的存储引擎），记录的是数据库中所有 DDL 和 DML 语句，是包含了一切的最全面最原始的东西，BinLog 支持 statement、row 和 mixed 这<a href="https://www.yuque.com/hollis666/niq4hm/pl5wcg4cmn8dgufn">三种记录格式</a>；</li>
<li>RedoLog 和 UndoLog 主要用于事务管理（只能用于 InnoDB 存储引擎），记录的是事务中的数据修改操作和回滚操作；</li>
<li>RedoLog 用于崩溃恢复，保持事务的持久性，记录了事务的所有数据更改（不仅是数据更改的最终结果，还有实现这些更改的具体操作）；</li>
<li>UndoLog 用于回滚，保持事务的原子性和一致性，记录的是事务执行前的内容。</li>
</ul>
</li>
<li><p>自动提交</p>
<ul>
<li>事务由存储引擎实现，MySQL 服务器层不管理事务；</li>
<li>不要在一个事务中混合使用事务型和非事务型的表，因为在回滚时，非事务型的表上的变更无法撤销，这会导致数据库处于不一致的状态；</li>
<li>InnoDB 默认采用自动提交模式，可通过设置来禁用或者启用；</li>
<li>InnoDB 的所有操作都是在事务中执行的，即便是没有修改的查询也会自动开启一个隐式事务，这种隐式事务不会持有任何锁，并且处于自动提交模式；</li>
<li>可以设置隔离级别，新的隔离级别会在下一个事务开始时生效 。</li>
</ul>
</li>
<li><p>Online DDL</p>
<ul>
<li>在出现 Online DDL 之前，InnoDB 索引构建期间会对表加排它锁，Online DDL 则允许尽最大可能在不阻塞其他会话的情况下（需要等待所有进行中的事务都提交）创建或删除索引</li>
<li>一般在非高峰期进行此类操作，避免影响用户正常使用，Online DDL 一旦操作失败，其回滚的成本较高，因此在进行 DDL 之前要进行充分的测试和规划，确保有备份和回滚计划</li>
</ul>
</li>
</ul>
<h3 id="1-2-4-锁"><a href="#1-2-4-锁" class="headerlink" title="1.2.4 锁"></a>1.2.4 锁</h3><p>InnoDB 采用两段锁定协议，事务执行时会自动根据隔离级别执行隐式锁定，所有的锁都在事务提交或者回滚时被一起释放</p>
<p>MySQL 服务器层也提供显式锁定语句，但除了禁用自动提交以外，任何时候都不要使用显式锁定，否则可能会产生无法预料的结果</p>
<p>MySQL 提供的锁可以按照不同的方式进行划分</p>
<ul>
<li>按照操作划分为 DML 锁、DDL 锁</li>
<li>按照加锁方式划分为自动锁、显式锁</li>
<li>按照粒度划分为<ul>
<li>行级锁是 MySQL 中粒度最小的锁，只针对当前操作的行进行加锁，锁冲突概率最低，并发度高，但加锁的开销是最大的，加锁是最慢的，会出现死锁</li>
<li>表级锁是 MySQL 中粒度最大的锁，对当前操作的整张表加锁，实现简单，资源消耗较少，加锁快，锁冲突概率最高，并发度低，不会出现死锁</li>
<li>页级锁是行级锁和表级锁之间的折中，一次锁定相邻的一组记录，各方面性能都介于行级锁和表级锁之间，会出现死锁</li>
<li>InnoDB 是通过给索引上的索引项加锁来实现行级锁的（Oracle 则是在数据块中对相应数据行加锁），这意味着<ul>
<li>只有通过索引条件检索数据时才会使用行级锁，否则将使用表级锁</li>
<li>只要使用索引（无论是什么类型的索引）就会使用行级锁</li>
<li>只要使用相同的索引键（即便访问不同行）就会出现锁冲突</li>
<li>即便在 SQL 条件中使用了索引字段，但真正是否使用索引是由 MySQL 优化器通过判断不同执行计划来内部决定的</li>
</ul>
</li>
</ul>
</li>
<li>按照级别划分为共享锁、排它锁<ul>
<li>共享锁，是读取操作创建的锁（又称读锁），其他事务可以并发读取数据，但任何事务都不能对数据进行修改，即不能获取数据的排它锁，直到共享锁释放</li>
<li>排它锁，是写入操作创建的锁（又称写锁），其他任何事务都不能并发读取或者修改数据，获取排它锁的线程既可以读又可以写</li>
</ul>
</li>
<li>按照使用方式划分为乐观锁、悲观锁<ul>
<li>乐观锁，主要通过 CAS + 版本号机制实现，假设数据一般情况下不会造成冲突，并不会使用数据库提供的锁机制，开销低，效率高，适用于读操作频繁，写操作较少的场景，一旦粒度控制的不好，业务失败的概率就会比较高</li>
<li>悲观锁，需要先关闭事务自动提交属性，然后通过<code>SELECT ... FOR UPDATE</code>来进行加锁，会在修改数据之前先加排它锁，若加锁失败则等待或者抛出异常（响应方式由用户根据实际需要决定），加排他锁成功后就可以对记录进行修改，事务完成后自动释放排它锁，开销大，效率低，会产生死锁，适用于写操作频繁，并发程度高的场景</li>
<li>虽然乐观锁相比于悲观锁只是没有提前加锁，并通过 CAS 做并发校验，但是在真正更新数据的那一刻依旧是需要加一个短暂的锁的，悲观锁的提前加锁则使得锁定的时长要长的多</li>
</ul>
</li>
<li>按照锁的对象划分为<ul>
<li>记录锁（Record Lock），锁的是索引记录（即使没有定义索引，InnoDB 也会自动创建一个隐藏的聚集索引，并使用这个索引来锁定记录），锁粒度较小</li>
<li>间隙锁（Gap Lock），锁的是索引记录之间的间隙（间隙指的是索引数据结构中可以插入新值的位置），或第一个索引记录之前的间隙，或最后一个索引记录之后的间隙</li>
<li>记录锁和间隙锁的组合（Next-Key Lock），同时锁索引记录和间隙，是左开右闭的，锁粒度加大，死锁的可能性更大</li>
<li>使用 Gap Lock 和 Next-Key Lock 的前提是可重复读这一隔离级别，在这一级别下，加锁的基本单位是 Next-Key Lock，然后再视情况退化为 Record Lock 或 Gap Lock</li>
</ul>
</li>
<li>意向锁<ul>
<li>当一个事务请求获取行级锁或表级锁时，MySQL 会自动获取相应的表的意向锁，那么其他事务尝试获取锁时，就可以先基于这个意向锁来判断是否有事务已经加过锁，并根据锁的级别是共享锁还是排它锁来判断自己是否可以获取锁，这样就可以在不阻塞其他事务的情况下为当前事务锁定资源</li>
<li>意向锁并不是直接锁定资源，而是为了通知其他事务，以防各个事务在资源上设置不兼容的锁</li>
<li>意向锁并不是由用户请求的，而是有 MySQL 管理的，是一个表级锁，会在触发意向锁的事务提交或者回滚后释放</li>
<li>意向锁按照级别划分为<ul>
<li>意向共享锁，表示事务打算在资源上设置共享锁，并且不希望其他事务设置排它锁</li>
<li>意向排它锁，表示事务打算在资源上设置排它锁，并且不希望其他事务设置共享锁或排它锁</li>
</ul>
</li>
</ul>
</li>
<li>字典锁（MetaData Lock）<ul>
<li>MDL 锁是一种用于管理元数据并发访问的锁机制，而不是数据本身的锁</li>
<li>数据库会在执行 DDL 操作时加上 MDL，保护数据库中的元数据对象（表、列、索引、视图等），确保在 DDL 操作期间不会出现数据一致性问题和竞争条件</li>
<li>MDL 也可以分为共享 MDL 和排他 MDL，当事务开始时，通常会以共享 MDL 的方式访问元数据对象，如果事务需要对元数据对象进行修改操作，就需要将共享 MDL 升级为排他 MDL，这种升级通常是系统自动执行的</li>
</ul>
</li>
</ul>
<h3 id="1-2-5-MVCC"><a href="#1-2-5-MVCC" class="headerlink" title="1.2.5 MVCC"></a>1.2.5 MVCC</h3><ul>
<li><p>基于提升并发性能的考虑，事务型存储引擎实现的都不是简单的行级锁，一般都同时实现了多版本并发控制（MVCC），可以看作是行级锁的一个变种；</p>
</li>
<li><p>MVCC 实现的基础是快照读，快照读是通过在 UndoLog 中保存数据在某个时间点的快照来实现的，不加锁的查询语句就会进行快照读，（加锁的查询语句以及增删改语句都会进行当前读，当前读就是读取最新数据，是悲观锁实现的基础）；</p>
</li>
<li><p>InnoDB 的 MVCC 是在每行记录后面保存两个隐藏的列来实现的，分别是行的创建时间和行的过期时间，这个时间并非实际的时间值，而是版本号；</p>
</li>
<li><p>每个事务的开始时间的系统版本号会作为事务的版本号（是自增长、唯一的），事务版本号被用来标记该事务所做的修改，事务版本号会和事务查询到的每行记录的版本号进行比较，只有创建时间小于等于当前事务版本号，且删除时间未定义或大于当前事务版本号的记录，才能作为查询结果，避免了脏读问题；</p>
</li>
<li><p>由于未提交读总是要读取最新数据行（无论是否提交），而串行化会对所有读取的数据行加锁，所以 MVCC 只能在提交读和可重复读这两个隔离级别下工作；</p>
</li>
<li><p>在提交读隔离级别下，每次读取都会重新生成一个快照，总是读取最新的已提交数据行，这一隔离级别下只会使用 Record Lock；</p>
</li>
<li><p>在可重复读隔离级别下，MVCC 只会在第一次读取的时候生成快照，后续的所有读都是基于这同一个快照，只有本事务对数据进行更改才会更新快照，避免了不可重复读问题。</p>
</li>
<li><p>在可重复读隔离级别下的幻读问题</p>
<ul>
<li>本事务不对数据记录进行更改时，所有的读取都基于第一次读取时生成的快照，避免了幻读问题</li>
<li>本事务对数据记录更改时，通过 Gap Lock 和 Next-Key Lock 将记录之间的间隙锁住，可以防止其他事务插入新行，避免了幻读问题</li>
<li>当本事务第一次读取之后，存在其他事务插入新行并提交，接着本事务再对数据进行更改时（加锁已经迟了），那么本事务更新快照之后就会读到其他事务插入的行，发生幻读问题，这种情况必须在本事务一开始就立即加锁，才能避免幻读问题，但这也是导致死锁的一个重要根源，需要慎重使用，没有死锁的话感觉已经变成串行执行事务了……</li>
<li>综上，在可重复读隔离级别下，MVCC + 数据修改时加的间隙锁可以避免大部分的幻读问题，MVCC + 事务一开启就立即加锁可以避免幻读问题，但容易死锁，InnoDB 只有使用可串行化这一隔离级别才可以彻底解决幻读问题</li>
</ul>
</li>
</ul>
<h1 id="2、设计"><a href="#2、设计" class="headerlink" title="2、设计"></a>2、设计</h1><h2 id="2-1-数据类型"><a href="#2-1-数据类型" class="headerlink" title="2.1 数据类型"></a>2.1 数据类型</h2><p>不管储存哪种类型的数据，有以下几个原则：</p>
<ul>
<li>尽可能使用可以正确存储数据的最小数据类型</li>
<li>尽可能选择简单的操作代价低的数据类型，比如整型比字符型更简单</li>
<li>尽量避免NULL，NULL值会使得索引变得复杂</li>
<li>对于相关联的列，应选择与关联表中的对应列一样的数据类型</li>
<li>数据如何存储取决于存储引擎，对于相同的类型，并非所有的存储引擎都会按照相同的方式处理</li>
</ul>
<h3 id="2-1-1-整数类型"><a href="#2-1-1-整数类型" class="headerlink" title="2.1.1 整数类型"></a>2.1.1 整数类型</h3><p>可以存储的范围从-2^(N-1)到2^(N-1)-1，N是存储空间的位数，但无符号类型UNSIGNED表示不允许负值，这使得存储范围提高一倍。</p>
<table>
<thead>
<tr>
<th align="center"></th>
<th align="center"></th>
<th align="center"></th>
<th align="center"></th>
<th align="center"></th>
<th align="center"></th>
</tr>
</thead>
<tbody><tr>
<td align="center">类型</td>
<td align="center">TINYINT</td>
<td align="center">SMALLINT</td>
<td align="center">MEDIUMINT</td>
<td align="center">INT</td>
<td align="center">BIGINT</td>
</tr>
<tr>
<td align="center">位数</td>
<td align="center">8</td>
<td align="center">16</td>
<td align="center">24</td>
<td align="center">32</td>
<td align="center">64</td>
</tr>
</tbody></table>
<p>实数类型：可以用于存储带有小数部分的数字以及比BIGINT更大的整数，</p>
<table>
<thead>
<tr>
<th align="center"></th>
<th align="center"></th>
<th align="center"></th>
<th align="center"></th>
</tr>
</thead>
<tbody><tr>
<td align="center">类型</td>
<td align="center">FLOAT</td>
<td align="center">DOUBLE</td>
<td align="center">DECIMAL</td>
</tr>
<tr>
<td align="center">位数</td>
<td align="center">4</td>
<td align="center">8</td>
<td align="center">尽量只在需要对小数进行精确计算时使用</td>
</tr>
</tbody></table>
<h3 id="2-1-2-字符串类型"><a href="#2-1-2-字符串类型" class="headerlink" title="2.1.2 字符串类型"></a>2.1.2 字符串类型</h3><p>CHAR 类型是定长的（0 ~ 255），会根据定义的字符串长度分配足够的空间，会在存储时自动在结尾添加空格来将字符串填满至指定长度（这也就导致了原字符串内容末尾的空格信息丢失），适合存储很短的字符串，或者所有值都接近同一个长度，或者经常变更的数据（这是因为长度固定，不会产生碎片以及页分裂）</p>
<p>VARCHAR 用于存储可变长字符串（0 ~ 65535），兼容性更好，只会存储实际的字符串内容，不会填充空格，但会额外用到 1 ~ 2 个字节存储长度信息，当字符串列的最大长度比平均长度大很多，列的更新很少时，VARCHAR 比定长类型更节省空间，而列更新时很可能会导致页分裂</p>
<p>BLOB 和 TEXT 都是为存储很大的数据而设计的字符串数据类型，分别采用二进制和字符方式存储。与其他类型不同，MySQL 把每个 BLOB 和 TEXT 当做一个独立的对象处理</p>
<p>可变长度列（VARCHAR、VARBINARY、BLOB、TEXT）的前 768 字节的数据存储在 B 树节点的索引记录中，超出部分则存储在溢出页中</p>
<p>固定长度列若是大于或等于 768 字节，则会被编码为可变长度列，可以存储在页外</p>
<p>MySQL 对 Unicode 的支持<a href="https://www.yuque.com/hollis666/niq4hm/hwe1ut">参考</a></p>
<h3 id="2-1-3-日期和时间类型"><a href="#2-1-3-日期和时间类型" class="headerlink" title="2.1.3 日期和时间类型"></a>2.1.3 日期和时间类型</h3><p>DATETIME类型能保存大范围的值，使用8个字节的存储空间，与时区无关</p>
<p>TIMESTAMP类型只是用4个字节的存储空间，显示的值依赖于时区，默认为NOT NULL，应该尽量使用TIMESTAMP</p>
<h2 id="2-2-范式"><a href="#2-2-范式" class="headerlink" title="2.2 范式"></a>2.2 范式</h2><h3 id="2-2-1-定义"><a href="#2-2-1-定义" class="headerlink" title="2.2.1 定义"></a>2.2.1 定义</h3><p>范式（Normal Form）是用于设计关系型数据库的规范要求，这些规范可以让数据库的设计更加简洁清晰，也会更好地保证一致性。</p>
<ul>
<li>1NF 要求数据库的每一列都是不可分割的基本数据项，而不能是集合、数组等非原子数据项（满足 1NF 的数据库才是关系数据库）</li>
<li>2NF 是在 1NF 的基础上，要求每一个非主属性完全函数依赖于主属性（消除部分依赖）</li>
<li>3NF 是在 2NF 的基础上，要求每一个非主属性都不依赖于其他非主属性（消除间接依赖）</li>
</ul>
<p>完全遵守数据库三范式确实可以避免一些写时异常，提升一些写入性能，但同时也会丢失一些读取性能，这是因为表中没有任何冗余字段，那么查询时就会经常有多表关联查询，为了解决这一问题，就产生了反范式。</p>
<h3 id="2-2-2-范式和反范式"><a href="#2-2-2-范式和反范式" class="headerlink" title="2.2.2 范式和反范式"></a>2.2.2 范式和反范式</h3><p>范式化的表通常更小，范式化的更新操作通常比反范式化要快，范式化的表通常需要关联，代价昂贵，而反范式化的表则可以很好地避免关联。</p>
<p>反范式是一种针对遵从设计范式的数据库的性能优化策略，一定是发生在满足范式设计的基础上，相当于先遵守规则，但进行局部调整，并不等于非范式化，通常混用范式和反范式。</p>
<p>最常见的反范式化数据的方法是复制、缓存、增加冗余字段，其实就是用空间换时间，方便进行数据查询，而不再需要经常做多表联合查询，此时带来的问题是如何保证这些冗余之间的一致性。</p>
<p>在一些数据量大、并发高、查询频率远高于写入频率的场景下，适当做一些反范式，可以提升性能，降低响应时延，提升并发效率。</p>
<h3 id="2-2-3-缓存表和汇总表"><a href="#2-2-3-缓存表和汇总表" class="headerlink" title="2.2.3 缓存表和汇总表"></a>2.2.3 缓存表和汇总表</h3><p>有时提升性能最好的方法是在同一张表中保存衍生的冗余数据，甚至创建一张完全独立的缓存表或汇总表。</p>
<p>缓存表表示存储那些可以比较简单地从其他表获取数据的表，对优化搜索和检索查询语句很有效。</p>
<p>汇总表表示使用 GROUP BY 语句聚合数据的表。</p>
<p>在使用缓存表和汇总表时，必须决定是实时维护数据还是定期重建。</p>
<h2 id="2-3-索引"><a href="#2-3-索引" class="headerlink" title="2.3 索引"></a>2.3 索引</h2><p>索引是存储引擎用于快速找到记录的一种数据结构，可以理解为看书时的内容页码。在MySQL中，索引是在存储引擎层而不是服务器层实现的，不同存储引擎的索引的底层实现和工作方式不一样。</p>
<h3 id="2-3-1-B-Tree-索引"><a href="#2-3-1-B-Tree-索引" class="headerlink" title="2.3.1 B+Tree 索引"></a>2.3.1 B+Tree 索引</h3><p>B Tree 和 B+Tree 都是自平衡搜索数据结构，非叶子节点的根节点至少有 2 个子节点，非根非叶子节点至少有 m/2（向上取整）个子节点，至多有 m 个子节点（m 是 B 树的阶数），更多的子节点决定了更低的树高，进而减少了磁盘访问次数，具有 k 个子节点的非叶子节点包含 k - 1 个升序排列的键，每一个叶子节点到根节点的距离相同，在插入和删除节点时会通过节点的分裂和合并来保持树的平衡</p>
<ul>
<li>B Tree 的节点（叶子节点和非叶子节点）既存储索引值，也存储相关数据记录，B+Tree 的非叶子节点仅存储索引值，所有的数据记录都按顺序存储在叶子节点中</li>
<li>B Tree 的叶子节点之间没有直接连接，B+Tree 的每一个叶子节点都包含指向上一个叶子节点和下一个叶子节点的指针（双向链表），方便进行范围查询</li>
<li>B Tree 的范围查询需要在整棵树上进行遍历，命中的可能是非叶子节点也可能是叶子节点，B+Tree 的范围查找直接遍历叶子节点即可，无需回溯到非叶子节点</li>
<li>B Tree 的查询需要遍历整棵树，磁盘 I/O 次数较多，适用于随机读写（可能可以在非叶子节点中提前找到所需的数据记录）、内存受限的环境（整棵树占用更小的内存空间）</li>
<li>B+Tree 基于叶子节点的高效的范围查询则使得 I/O 次数相对较少，且非叶子节点只存储索引值则可以用来存储更多的索引数据，适用于大规模数据集的范围查询（不需要遍历整棵树）</li>
</ul>
<p>B+Tree 索引是目前关系型数据库系统中最常见、最有效的索引，如果没有特别指明类型，那默认指 B+Tree 索引，使用 B+Tree 索引时</p>
<ul>
<li>不再需要进行全表扫描，能够加快访问数据的速度</li>
<li>必须按照索引的最左列开始查找，不能跳过索引中的列，适合全键值、键值范围或键值最左前缀的范围查找</li>
<li>如果查询中有某个列的范围查询则其右边所有列都无法使用索引优化查找</li>
<li>B+Tree 索引列是顺序组织存储的，如果 B+Tree 索引可以按某种方式查找到值，那么也可以按照这种方式用于排序，适合 ORDER BY、GROUP BY 顺序查找</li>
<li>叶子节点的大小是固定的，一般都会设置为一页的大小，因此可以很好地利用磁盘预读特性来一次性读取多个节点到内存中，减少 I/O 操作次数</li>
<li>在插入和删除数据时需要调整索引结构，可能会涉及到页分裂和页合并，索引的维护成本高</li>
</ul>
<h3 id="2-3-2-唯一索引"><a href="#2-3-2-唯一索引" class="headerlink" title="2.3.2 唯一索引"></a>2.3.2 唯一索引</h3><p>MySQL 基于 B+Tree 索引实现唯一索引，B+Tree 的每个节点上都会添加一个指向唯一性索引值的指针，当在索引列上插入新值/更新索引列时，会触发唯一性检查器，使用 B+Tree 检查索引列中是否该要插入的值/更新后的新值，如果已经存在就会抛出唯一性约束冲突的异常。</p>
<ul>
<li>唯一索引查询通常会比非唯一索引查询更快，这是因此唯一索引能够快速定位到唯一值，而非唯一索引则需要扫描整个索引并匹配符合条件的记录</li>
<li>唯一性检查器在一定程度上降低了插入性能，而唯一性索引列的值的更新则需要先删除旧记录，再插入新纪录，也会一定程度上降低更新性能</li>
</ul>
<p>主键索引是一种特殊的唯一索引</p>
<ul>
<li>主键索引不能为 NULL，但唯一索引是可以为 NULL 的</li>
<li>主键索引在一张表中只能有一个，但唯一索引在一张表中可以创建多个</li>
<li>在 InnoDB 中，主键索引就是聚簇索引，因此基于主键索引的查询一定不需要回表，而唯一索引通常是非聚簇索引，通常需要回表，但也可能成为聚簇索引，比如没有创建主键索引时，MySQL 会默认选择一个唯一的非空索引作为聚簇索引</li>
<li>主键可以被其他表引用为外键，而唯一索引是不可以的</li>
</ul>
<h3 id="2-3-3-索引跳跃"><a href="#2-3-3-索引跳跃" class="headerlink" title="2.3.3 索引跳跃"></a>2.3.3 索引跳跃</h3><p>B+Tree 索引先按联合索引左边的 key 进行排序，再按依次按照右边的 key 进行排序，左前缀匹配中的”左“是指联合索引的顺序左，和 SQL 中的查询条件的顺序没有关系，如果不涉及联合索引，根据单个字段的索引进行查询时（比如模糊匹配）也需要遵守最左前缀。</p>
<p>但对于索引跳跃扫描来说，可以支持不符合索引最左前缀原则条件下的 SQL，依旧能够使用联合索引来减少不必要的扫描，这种索引跳跃扫描其实是隐式地构造了联合索引中的左侧索引列的扫描条件，这种查询优化比较适用于索引左侧列取值范围比较小，区分度不高的情况，一旦索引左侧列的区分度特别高，索引跳跃扫描反而会更慢。</p>
<p>索引跳跃扫描有一些限制条件如下</p>
<ul>
<li>表至少有一个联合索引，联合索引最前和最后的列可以是空的，但中间的列必须是非空的</li>
<li>查询必须只能依赖一张表，不能多表联合</li>
<li>查询中不能使用 GROUP BY 或 DISTINCT 语句</li>
<li>查询的字段必须是索引中的列</li>
</ul>
<h3 id="2-3-4-哈希索引"><a href="#2-3-4-哈希索引" class="headerlink" title="2.3.4 哈希索引"></a>2.3.4 哈希索引</h3><p>哈希索引基于哈希表实现，对于每一行数据，存储引擎都会对所有的索引列计算一个哈希码，哈希索引将所有的哈希码存储在索引中，同时在哈希表中保存指向每个数据行的指针，使用哈希索引时</p>
<ul>
<li>哈希索引自身只需存储哈希值和行指针，索引的结构非常紧凑，因此哈希索引查找的速度非常快，除非有很多哈希冲突</li>
<li>哈希索引数据不是按照索引值顺序存储的，因此无法用于排序</li>
<li>哈希索引始终使用索引列的全部内容来计算哈希值，因此不支持部分索引列匹配查找，只有精确匹配索引所有列的查询才有效</li>
<li>哈希索引不支持任何范围查询，只支持等值比较查询，包括<code>=</code>、<code>IN()</code></li>
<li>在插入和删除数据时只需要计算新行的哈希码或者删除哈希码，索引的维护成本低</li>
</ul>
<p>InnoDB 引擎在注意到某些索引值被使用得非常频繁时，它会在内存中基于 B+Tree 索引之上再创建一个哈希索引，这样就让 B+Tree 索引也具有哈希索引的一些优点，这个功能叫做自适应哈希索引。</p>
<h3 id="2-3-5-全文索引"><a href="#2-3-5-全文索引" class="headerlink" title="2.3.5 全文索引"></a>2.3.5 全文索引</h3><p>通过数值比较、范围过滤等就可以完成绝大多数需要的查询了，但是如果希望通过关键字的匹配来进行基于相似度的查询过滤，而不是精确的数值比较，就可以使用全文索引（在 MySQL 5.6 提供的）。互联网搜索引擎就是一种全文索引。 </p>
<p>使用全文索引时</p>
<ul>
<li>全文索引查找的是文本中的关键词，而不是直接比较索引中的值</li>
<li>在相同的列上同时创建全文索引和基于值的 B+Tree 索引不会有冲突</li>
<li>全文索引适用于 MATCH AGAINST 操作，而不是普通的WHERE条件操作，且MATCH函数中指定的列必须和全文索引中指定的列完全相同，WHERE条件比较必须在完成全文搜索返回记录后才能进行</li>
<li>使用全文索引的查询自动按照相似度进行排序，此时MySQL无法再使用索引排序，如果需要相关性以外的排序操作，那么只能在查询中使用ORDER BY做文件排序</li>
<li>全文索引不会记录查询关键字来自哪一行，因此无法使用全文索引来查询某个关键字是否在某一列中存在，也无法用作索引覆盖扫描</li>
</ul>
<h3 id="2-3-6-聚簇索引"><a href="#2-3-6-聚簇索引" class="headerlink" title="2.3.6 聚簇索引"></a>2.3.6 聚簇索引</h3><p>聚簇索引并不是一种单独的索引类型，而是一种数据存储方式。聚簇索引就是将数据与索引连续地存储在一起，这种连续并不是物理上的连续，而是逻辑上的连续，这种索引方式保证数据行的物理存储顺序和索引的逻辑顺序相同，因此查找聚簇索引的速度非常快。因为无法同时把数据行存放在两个不同的地方，所以一个表只能有一个聚簇索引。</p>
<p>聚簇索引以外的索引都是非聚簇索引，也叫二级索引或辅助索引，辅助索引就是将数据和索引分开存储，不影响表中数据行的物理存储顺序，而是单独创建一张索引表，用于存储索引列和对应数据行的指针。</p>
<p>InnoDB 一般选择主键索引来构建聚簇索引，在 B+ Tree 这一数据结构中保存了索引值和数据行，将数据行按照主键顺序存储在叶子节点中。在InnoDB 中，聚簇索引“就是”表。</p>
<p>InnoDB 选择非主键字段构建辅助索引，辅助索引的叶子节点存储的不再是数据行，而是数据行的索引字段值和指向数据页数据行的逻辑指针（主键值）。当通过辅助索引来查找数据时，InnoDB 会通过辅助索引叶子节点获得对应的主键值，然后再通过主键索引来找到一个完整的数据行，这个过程就叫做回表。</p>
<p>使用聚簇索引时</p>
<ul>
<li>聚簇索引将相关数据保存在一起，因此可以减少磁盘 I/O</li>
<li>聚簇索引的索引和数据保存在同一个 B+ Tree 中，因此数据访问会更快</li>
<li>聚簇索引列的更新代价很高，因为会强制将每个被更新的行移动到新的位置，甚至在插入新行时可能导致页分裂，占用更多的磁盘空间</li>
<li>辅助索引访问需要两次索引查找（多了一次回表），而不是一次</li>
<li>尽量避免使用数据随机（不连续且值的分布范围非常大）的列来做聚簇索引，自增列就比较好</li>
</ul>
<h3 id="2-3-7-覆盖索引"><a href="#2-3-7-覆盖索引" class="headerlink" title="2.3.7 覆盖索引"></a>2.3.7 覆盖索引</h3><p>覆盖索引指索引包含所有需要查询的字段的值，此时只访问索引即可，而无须再回表查询。</p>
<p>由于覆盖索引必须要存储索引列的值，而哈希索引和全文索引都不存储索引列的值，所以 MySQL 只能用 B+Tree 索引来做覆盖索引。</p>
<p> 使用覆盖索引时</p>
<ul>
<li>索引条目通常远小于数据行大小，更容易全部放入内存中，因此可以极大地减少数据访问量</li>
<li>索引是按照列值顺序存储的，因此可以将随机 I/O 变为顺序 I/O，且范围查询会比随机从磁盘读取每一行数据的 I/O 次数更少</li>
<li>按照覆盖索引顺序扫描得到的有序结果会比对先得到结果再进行排序操作的效率更高</li>
<li>如果不符合最左前缀匹配的话，即便是索引覆盖也无法用到索引</li>
</ul>
<p>MyISAM 中的索引都是非聚簇索引，索引和数据时分开存储互相独立的，在 MyISAM 的索引树中，叶子节点上存储地并不是数据，而是数据所在的地址，在根据索引查询的过程中，必须先查到数据所在的地址，然后再查询真正的数据，至少有两次查询过程，而在 InnoDB 中，基于聚簇索引或者覆盖索引的查询则不需要回表。</p>
<h3 id="2-3-8-索引下推"><a href="#2-3-8-索引下推" class="headerlink" title="2.3.8 索引下推"></a>2.3.8 索引下推</h3><p>索引下推是指先通过 WHERE 条件中的索引字段返回符合条件的索引，然后根据剩余的 WHERE 条件来判断索引是否符合条件。</p>
<p>如果不应用索引下推，那么就会先通过 WHERE 条件中的索引字段返回符合条件的数据行，然后根据剩余的 WHERE 条件来判断数据是否符合条件。</p>
<p>索引下推技术减少了回表次数。</p>
<h2 id="2-4-高性能索引"><a href="#2-4-高性能索引" class="headerlink" title="2.4 高性能索引"></a>2.4 高性能索引</h2><h3 id="2-4-1-建立索引"><a href="#2-4-1-建立索引" class="headerlink" title="2.4.1 建立索引"></a>2.4.1 建立索引</h3><p>索引大大减少了服务器需要扫描的数据量，可以帮助服务器避免排序和临时表，可以将随机 I/O 变为顺序 I/O，可以减少需要锁定的行。但正确创建和使用索引才能真正发挥出索引的优势，应当遵循以下原则</p>
<ul>
<li>对于非常小的表，大部分情况下简单的全表扫描更高效；对于中大型的表中频繁查询的列，索引就非常有效；对于特大型的表，建立和使用索引的代价非常大，需要通过分区技术来区分出查询需要的一组数据，而不是一条记录一条记录的匹配</li>
<li>不同类型的索引适用于不同类型的查询，应根据实际情况选择适合的索引类型，B+ Tree 索引、哈希索引、全文索引、前缀索引等</li>
<li>索引列不能是表达式的一部分，也不能是函数的参数，应尽量简化 WHERE 条件，始终将索引列单独放在比较符号的一侧</li>
<li>对于 BLOB、TEXT 或者很长的 VARCHAR 类型的列，索引这些列的完整长度会让索引变得大且慢，此时应使用前缀索引并仔细考虑前缀长度，需要注意 MySQL 无法使用前缀索引做 ORDER BY、GROUP BY 以及覆盖扫描</li>
<li>在多个列上建立独立的单列索引大部分情况下并不能提高 MySQL 的查询性能，尤其是多个列一起被频繁查询时，需要考虑建立合适的多列联合索引并通过索引覆盖来避免回表查询，且优先将选择性高的列放到联合索引最前列</li>
<li>对于区分度不高的列建立索引也不一定没用，性能差并不是区分度不高导致的，而是要具体分析索引扫描的行数成本，如果存在某个值对应的行数很少，那么对该列建立索引依旧有可能大大降低需要扫描的行数，提升性能</li>
<li>索引并不是越多越好，不要创建重复索引（指在相同的列上按照相同的顺序创建的相同类型的索引），尽量避免创建冗余索引，过多的索引会占用大量的磁盘空间，影响写入和删除性能</li>
<li>尽可能设计既满足排序，又用于查找行的索引</li>
<li>确保关联查询时的 ON 或者 USING 子句中的列上有索引，只需要在关联顺序中的第二个表的相应列上创建索引</li>
<li>确保 GROUP BY 和 ORDER BY 中的表达式只涉及到一个表中的列，且列上有索引，这样 MySQL 才有可能使用索引来优化这个过程</li>
<li>对于创建出的索引，要经常使用执行计划分析来查看索引是否有在正确使用</li>
</ul>
<h3 id="2-4-2-索引失效"><a href="#2-4-2-索引失效" class="headerlink" title="2.4.2 索引失效"></a>2.4.2 索引失效</h3><p>索引失效可能是因为</p>
<ul>
<li>索引列参与计算</li>
<li>对索引列进行函数操作</li>
<li>使用 OR 且 OR 的两边存在大于或小于的比较（如果 OR 两边都是等于号判断则不依旧可以走索引）</li>
<li>LIKE 操作且匹配值的前面有匹配符（如果只是值后面有匹配符是可以走索引的），可以通过反转列值来将前面的匹配符移到后面</li>
<li>隐式类型转换</li>
<li>!= 比较</li>
<li>IS NOT NULL</li>
<li>ORDER BY</li>
<li>IN</li>
</ul>
<h3 id="2-4-3-索引选择"><a href="#2-4-3-索引选择" class="headerlink" title="2.4.3 索引选择"></a>2.4.3 索引选择</h3><p>到底使用哪个索引是优化器根据成本预估来决定的，优化器会倾向于选择一个成本最低的方式进行查询，成本与以下因素有关</p>
<ul>
<li>基数性，就是通常说的区分度，基数性越高，区分度越好，成本越低，优化器越倾向于使用该索引</li>
<li>选择性，指过滤数据的能力，决定着扫描行数，扫描行数越少，成本越低</li>
<li>索引覆盖，优化器倾向于使用覆盖索引来减少回表</li>
<li>ORDER BY，为了减少 file sort，优化器倾向于直接使用天然有序的索引</li>
<li>索引类型，优化器会根据查询类型来选择最合适的索引类型</li>
<li>访问类型，范围查询、点查找、扫描等不同的访问类型也会影响索引的选择，比如某些索引更适合范围查询</li>
<li>索引的大小和深度，较小、较浅的索引占用更少的磁盘空间，通常更快</li>
<li>内存使用，对于大型表，优化器还会考虑执行计划的内存使用情况，尽量避免造成过多的内存占用</li>
<li>系统资源限制，优化器还会考虑内存、磁盘 I/O 等系统资源限制</li>
</ul>
<p>如果优化器选错了索引，可能是因为不准确的统计信息、复杂的查询逻辑以及系统配置等，因此可以通过定期更新统计信息、使用强制索引（FORCE INDEX，谨慎使用）、优化查询（详细见 3.1 小节）、调整索引、调整 MySQL 系统配置等方式来解决。</p>
<h3 id="2-4-4-低性能"><a href="#2-4-4-低性能" class="headerlink" title="2.4.4 低性能"></a>2.4.4 低性能</h3><p>使用索引查询仍然很慢可能是因为</p>
<ul>
<li>优化器选错索引</li>
<li>数据分布不均匀导致某些索引节点的数据量很大，而某些节点的数据量很少</li>
<li>SQL 语句本身存在问题，优化方式详见下节</li>
<li>数据库表以及索引设计不合理</li>
<li>系统硬件或网络环境问题</li>
</ul>
<h1 id="3、优化"><a href="#3、优化" class="headerlink" title="3、优化"></a>3、优化</h1><p>优化主要就是在快速、精确和简单这三者之间尽量满足其二。</p>
<h2 id="3-1-查询"><a href="#3-1-查询" class="headerlink" title="3.1 查询"></a>3.1 查询</h2><h3 id="3-1-1-执行流程"><a href="#3-1-1-执行流程" class="headerlink" title="3.1.1 执行流程"></a>3.1.1 执行流程</h3><p>优化查询的目标在于降低查询的响应时间，查询性能低下最基本的原因是访问的数据太多，消耗大多时间，所以需要确认存储引擎是否在检索以及服务器是否在分析大量超过需要的数据。</p>
<p>要写一个好的查询，那么就要理解查询是如何被执行的，理解时间都被消耗在哪些地方，从而对查询进行优化，查询的执行流程如下</p>
<ul>
<li>客户端使用 C/S 通信协议与 MySQL 建立连接，发送一条查询到服务器</li>
<li>服务器检查查询缓存，若命中缓存则立即返回缓存中的结果</li>
<li>若没有命中缓存，则进行 SQL 解析（语法分析和语义分析）、预处理、并由优化器生成执行计划</li>
<li>根据执行计划调用存储引擎的 API 来执行查询（索引的作用就在于可以减少存储引擎需要访问的数据行）</li>
<li>存储引擎将检索到的数据返回给服务器，服务器进行调用后的数据处理，并将结果给客户端（如果查询可以被缓存，这时也会将结果存放到查询缓存中）</li>
</ul>
<p>查询缓存允许 MySQL 将查询结果缓存起来，以便在以后相同的查询被再次执行时可以直接返回缓存中的结果不必再次重新解析和执行该查询语句，查询缓存在 session 之间共享，因此由一个客户端生成的结果集可以用来响应另一个客户端发出的相同查询，可以提高查询性能。</p>
<p>查询缓存要求查询必须以字节级别完全匹配，大小写敏感，包含非确定函数或使用临时表的查询结果不会被缓存，查询缓存不能很好地应对不均匀的查询分布，会占据大量内存开销，还可能因为数据库中的数据更改而导致一致性问题，此外，对底层表的任何修改都会导致这些表的所有缓存失效。</p>
<p>在 MySQL 5.6 之前查询缓存默认是开启的，从 MySQL 5.6 开始查询缓存默认是禁用的，在 MySQL 8 中取消了查询缓存，以提高整体性能和可维护性。</p>
<p>一个查询的执行顺序依次是FROM、JOIN、WHERE、GROUP BY、HAVING、SELECT、DISTINCT、ORDER BY、LIMIT</p>
<h3 id="3-1-2-关联查询"><a href="#3-1-2-关联查询" class="headerlink" title="3.1.2 关联查询"></a>3.1.2 关联查询</h3><p>在 MySQL 中可以使用 JOIN 在两个或多个表中进行关联查询</p>
<ul>
<li>INNER JOIN（内连接或等值连接），获取两张表中字段匹配的记录，取交集</li>
<li>LEFT JOIN（左连接），获取左表所有记录和右表中匹配的记录，取交集和左表</li>
<li>RIGHT JOIN（右连接），获取右表所有记录和左表中匹配的记录，取交集和右表</li>
</ul>
<p>MySQL 是使用嵌套循环的方式来实现关联查询的，第一张表做外循环/驱动表，第二张表做内循环/被驱动表，外循环/驱动表的每一条记录跟内循环/被驱动表中的记录作比较，符合条件的输出，具体到算法实现上有三种，假设驱动表的行数是 N，被驱动表的行数是 M</p>
<ul>
<li>simple nested loop，全量扫描两张表进行两两对比，复杂度是 O(N*M)</li>
<li>index nested loop，当被驱动表用到的字段有索引时，可以用到索引进行查询，因为索引是 B+Tree，复杂度近似是 O(N*logM)</li>
<li>block nested loop，会提前把驱动表的一部分结果放到 JOIN BUFFER 中，然后被驱动表的每一行都和整个缓存中的数据对比，复杂度还是 O(N*M)，但是由于缓存是基于内存的，所以效率更高</li>
</ul>
<p>以上算法效率都不高，假设每张表的行数都是 N，M 张表的关联查询的复杂度是 O(N^M)，所以不建议使用多表 JOIN，可以改成在代码中基于内存进行关联查询，或者增加数据库中的数据冗余，从而避免关联查询 SQL。</p>
<p>对于 LEFT JOIN 来说，一般选择左表作为驱动表，对于 RIGHT JOIN 来说，一般选择右表作为驱动表，但具体使用哪张表作为驱动表是由优化器以更高的访问性能和筛选性能为原则来决定的，优化器倾向于选择较小的/能够使用过滤条件进行筛选的表作为驱动表，以减少后续的匹配操作。</p>
<p>HASH JOIN 可以用于优化嵌套循环的关联查询，底层用到了 HASH 表，基本思想是将驱动表数据加载到内存/磁盘，由此建立 HASH 表，接着只需要遍历一遍被驱动表，然后再去通过哈希查找在哈希表中寻找匹配的行，就可以完成 JOIN 操作了。</p>
<h3 id="3-1-3-重构方式"><a href="#3-1-3-重构方式" class="headerlink" title="3.1.3 重构方式"></a>3.1.3 重构方式</h3><p>对 MySQL 连接来说，连接和断开连接都非常轻量级，在返回一个小的查询结果方面很高效，因此<strong>可以考虑将大查询切分为多个小查询</strong>。</p>
<p>对 MySQL 的查询缓存来说，如果关联中的某个表发生了变化，那么就无法使用查询缓存，因此<strong>可以将关联查询分解，对每个表进行单表查询并在应用程序中进行关联</strong>，与此同时，执行单个查询还可以减少锁竞争。</p>
<p>MySQL 客户端和服务器之间的通信协议是半双工的，这意味着一旦客户端发送了请求，那么接下来就只能等待并完整地接收整个响应结果，而不能让服务器中途停止发送数据，因此<strong>必要时一定要在查询中加上 LIMIT 限制</strong>，从而让查询能够早点结束，早点释放相应的资源。</p>
<p>MySQL 总是通过创建并填充临时表的方式来执行 UNION，MySQL 默认会给临时表加上 DISTINCT 选项，这会导致对整个临时表的数据做唯一性检查，代价非常高，因此<strong>除非确实需要服务器消除重复的行，则一定要使用 UNION ALL 关键字</strong>，此外，如果希望 UNION 的各个子句能够根据 LIMIT 只取部分结果集，或者希望先排序再合并结果集的话，就需要在 UNION 的各个子句中分别使用 LIMIT 和 ORDER BY，然后再加上全局的 LIMIT 和 ORDER BY。</p>
<p>COUNT() 函数可以统计某个列值的数量，也可以统计行数，如果在括号中指定了列或者列的表达式，则统计的就是这个表达式的非空结果数，如果括号中是<code>*</code>时，会忽略所有的列而直接统计所有的行数，此时效率更高，因此<strong>在需要统计列值的数量又确定该列均不为空时，最好使用COUNT(*)。</strong></p>
<h3 id="3-1-4-特定类型重构"><a href="#3-1-4-特定类型重构" class="headerlink" title="3.1.4 特定类型重构"></a>3.1.4 特定类型重构</h3><p>MySQL 优化器在大多数情况下能够很好的工作，但依旧存在一定的局限性，会对某些类型的查询生成低效的执行计划，因此需要对这类查询进行改写重构，比如</p>
<ul>
<li><p>WHERE 条件中使用 IN() 或者 EXISTS() 包含的子查询需要重构为关联查询</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> film</span><br><span class="line"><span class="keyword">WHERE</span> film_id <span class="keyword">IN</span> (<span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> film_actor <span class="keyword">WHERE</span> actor_id <span class="operator">=</span> <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> film</span><br><span class="line"><span class="keyword">WHERE</span> <span class="keyword">NOT</span> <span class="keyword">EXISTS</span> (<span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> film_actor <span class="keyword">WHERE</span> film_actor.film_id <span class="operator">=</span> film_id);</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 改为</span></span><br><span class="line"><span class="keyword">SELECT</span> film.<span class="operator">*</span> <span class="keyword">FROM</span> film</span><br><span class="line"><span class="keyword">INNER</span> <span class="keyword">JOIN</span> film_actor <span class="keyword">USING</span>(film_id)</span><br><span class="line"><span class="keyword">WHERE</span> actor_id <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">SELECT</span> film.<span class="operator">*</span> <span class="keyword">FROM</span> film</span><br><span class="line"><span class="keyword">LEFT</span> <span class="keyword">JOIN</span> film_actor <span class="keyword">USING</span>(film_id)</span><br><span class="line"><span class="keyword">WHERE</span> film_actor.film_id <span class="keyword">IS</span> <span class="keyword">NULL</span>;</span><br></pre></td></tr></table></figure></li>
<li><p>使用 DISTINCT 和 GROUP BY 的关联查询会产生临时表，需要重构为子查询</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="keyword">DISTINCT</span> film.<span class="operator">*</span> <span class="keyword">FROM</span> film</span><br><span class="line"><span class="keyword">INNER</span> <span class="keyword">JOIN</span> film_actor <span class="keyword">USING</span>(film_id);</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 改为</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> film</span><br><span class="line"><span class="keyword">WHERE</span> <span class="keyword">EXISTS</span> (<span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> film_actor <span class="keyword">WHERE</span> film_actor.film_id <span class="operator">=</span> film_id);</span><br></pre></td></tr></table></figure></li>
<li><p>关联查询做分组时，采用查找表的标识列来做分组的效率会比其他列更高，尤其是使用第二个表的标识列效率更高</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> actor.<span class="operator">*</span> <span class="keyword">FROM</span> film_actor</span><br><span class="line"><span class="keyword">INNER</span> <span class="keyword">JOIN</span> actor <span class="keyword">USING</span> (actor_id)</span><br><span class="line"><span class="keyword">GROUP</span> <span class="keyword">BY</span> actor.first_name, actor.last_name;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 改为</span></span><br><span class="line"><span class="keyword">SELECT</span> actor.<span class="operator">*</span> <span class="keyword">FROM</span> film_actor</span><br><span class="line"><span class="keyword">INNER</span> <span class="keyword">JOIN</span> actor <span class="keyword">USING</span> (actor_id)</span><br><span class="line"><span class="keyword">GROUP</span> <span class="keyword">BY</span> actor.actor_id;</span><br></pre></td></tr></table></figure></li>
<li><p>关联查询的 SELECT 中尽量不要使用非分组列，因为查询得到的非分组列的结果通常是不定的，如果使用非分组列则应确保该非分组列一定是直接依赖分组列，并且在每个分组中的值是唯一的，或者业务上根本不在乎这个值具体是什么</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> actor.<span class="operator">*</span> <span class="keyword">FROM</span> film_actor</span><br><span class="line"><span class="keyword">INNER</span> <span class="keyword">JOIN</span> actor <span class="keyword">USING</span> (actor_id)</span><br><span class="line"><span class="keyword">GROUP</span> <span class="keyword">BY</span> actor.actor_id;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 改为</span></span><br><span class="line"><span class="keyword">SELECT</span> actor.actor_id <span class="keyword">FROM</span> film_actor</span><br><span class="line"><span class="keyword">INNER</span> <span class="keyword">JOIN</span> actor <span class="keyword">USING</span> (actor_id)</span><br><span class="line"><span class="keyword">GROUP</span> <span class="keyword">BY</span> actor.actor_id;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 或者</span></span><br><span class="line"><span class="keyword">SELECT</span> actor.first_name, actor.last_name <span class="keyword">FROM</span> film_actor</span><br><span class="line"><span class="keyword">INNER</span> <span class="keyword">JOIN</span> actor <span class="keyword">USING</span> (actor_id)</span><br><span class="line"><span class="keyword">GROUP</span> <span class="keyword">BY</span> actor.actor_id;</span><br></pre></td></tr></table></figure></li>
<li><p>分组查询时，如果没有通过 ORDER BY 子句显示的指定排序列，结果集会自动按照分组列进行排序，如果不关心结果集的顺序，而这种默认又导致了需要文件排序，则应显示指定不需要排序，如果希望按照分组列进行排序，也应显示指定排序方向</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> actor.actor_id <span class="keyword">FROM</span> film_actor</span><br><span class="line"><span class="keyword">INNER</span> <span class="keyword">JOIN</span> actor <span class="keyword">USING</span> (actor_id)</span><br><span class="line"><span class="keyword">GROUP</span> <span class="keyword">BY</span> actor.actor_id;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 改为</span></span><br><span class="line"><span class="keyword">SELECT</span> actor.actor_id <span class="keyword">FROM</span> film_actor</span><br><span class="line"><span class="keyword">INNER</span> <span class="keyword">JOIN</span> actor <span class="keyword">USING</span> (actor_id)</span><br><span class="line"><span class="keyword">GROUP</span> <span class="keyword">BY</span> actor.actor_id</span><br><span class="line"><span class="keyword">ORDER</span> <span class="keyword">BY</span> <span class="keyword">NULL</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 或者</span></span><br><span class="line"><span class="keyword">SELECT</span> actor.actor_id <span class="keyword">FROM</span> film_actor</span><br><span class="line"><span class="keyword">INNER</span> <span class="keyword">JOIN</span> actor <span class="keyword">USING</span> (actor_id)</span><br><span class="line"><span class="keyword">GROUP</span> <span class="keyword">BY</span> actor.actor_id <span class="keyword">DESC</span>;</span><br></pre></td></tr></table></figure></li>
<li><p>当使用 LIMIT 且偏移量又非常大的时候，可以考虑使用覆盖索引来扫描大量偏移找到真正所需的行，然后根据需要做一次关联操作从而返回所需的列</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> film_id, description <span class="keyword">FROM</span> film</span><br><span class="line"><span class="keyword">ORDER</span> <span class="keyword">BY</span> title LIMIT <span class="number">1000</span>, <span class="number">5</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 改为</span></span><br><span class="line"><span class="keyword">SELECT</span> film_id, description <span class="keyword">FROM</span> film</span><br><span class="line"><span class="keyword">INNER</span> <span class="keyword">JOIN</span> (<span class="keyword">SELECT</span> film_id <span class="keyword">FROM</span> film <span class="keyword">ORDER</span> <span class="keyword">BY</span> title LIMIT <span class="number">1000</span>, <span class="number">5</span>) <span class="keyword">USING</span> (film_id);</span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="3-2-更新"><a href="#3-2-更新" class="headerlink" title="3.2 更新"></a>3.2 更新</h2><h3 id="3-2-1-执行流程"><a href="#3-2-1-执行流程" class="headerlink" title="3.2.1 执行流程"></a>3.2.1 执行流程</h3><p>一次完整的 Update 操作过程基本如下</p>
<ul>
<li>InnoDB 首先在 Buffer Pool 中查找要更新的记录是否在内存中，如果不在，则从磁盘读取该页到 Buffer Pool 中</li>
<li>InnoDB 在 UndoLog 中记录修改前的数据（用来保证事务原子性和一致性，事务回滚时将修改操作回滚到修改前的状态），UndoLog 的写入是先写入到内存中，再由一个后台线程定时刷新到磁盘中（异步执行）</li>
<li>InnoDB 在 Buffer Pool 中更新该页，将该页的状态设置为脏页（表示该页已经被修改但尚未写入磁盘），更新的同时也将修改操作写入到 RedoLog 中</li>
<li>InnoDB 在执行完所有修改操作后会将 RedoLog 写入磁盘（以保证事务持久性），事务信息（事务开始的时间、数据库名、表名、事务 ID、SQL 语句）会被记录到 BinLog 中（主从复制，用于将主库上的事务同步到从库上），等待从库接收到 BinLog（半同步主从复制），事务被提交（两阶段提交）返回给客户端</li>
<li>InnoDB 在提交事务之后，通过一个后台线程在 MySQL 服务器空闲或者负载较低时（或者 MySQL 关闭或重启时）将 Buffer Pool 中的脏页写入磁盘（异步执行），因此可能会延迟写入</li>
</ul>
<h3 id="3-2-2-两阶段提交"><a href="#3-2-2-两阶段提交" class="headerlink" title="3.2.2 两阶段提交"></a>3.2.2 两阶段提交</h3><p>如果先写入 RedoLog 成功，但还没来得及写入 BinLog 时系统崩溃，在 MySQL 重启后可以根据 RedoLog 重写，但是主从同步时，从库无法从 BinLog 中得知这条 SQL，进而会导致主从数据不一致。</p>
<p>如果先写入 BinLog 成功，但还没来得及写入 RedoLog 时系统崩溃，MySQL 重启后不会进行重写，主库中的操作丢失，但是主从同步时，从库会从 BinLog 中得知这条 SQL，依旧会导致主从数据不一致。</p>
<p>两阶段提交是在更新过程中保持 BinLog 和 RedoLog 一致性的一种手段，RedoLog 和 BinLog 中都会记录一个全局唯一标识的事务 ID，如果 RedoLog 和 BinLog 中所记录的事务 ID 是一致的，MySQL 就认为 RedoLog 和 BinLog 逻辑上是一致的。</p>
<ul>
<li>Prepare 阶段，这个阶段 SQL 已经成功执行并生成 RedoLog，假如此时系统崩溃，直接回滚事务即可，RedoLog 和 BinLog 都没有相应的记录</li>
<li>BinLog 持久化，通过<code>write</code>将 BinLog 写入文件缓冲区，通过<code>fsync</code>将 BinLog 从文件缓冲区永久写入磁盘，假如此时系统崩溃，重启后检查 BinLog 中的事务是否存在且完整，如果完整则提交事务，不存在或不完整则回滚事务</li>
<li>Commit，在执行引擎内部执行事务操作，更新 RedoLog，假如此时系统崩溃，重启后的处理同上一步一致</li>
</ul>
<p>组提交通过将多个事务的提交操作合并成一个批处理操作来减少磁盘 I/O 和锁定开销，从而加速事务的处理，此时需要累计多个事务都到达 Prepare 阶段后再将一组日志一次性持久化到磁盘。</p>
<h3 id="3-2-3-插入或更新"><a href="#3-2-3-插入或更新" class="headerlink" title="3.2.3 插入或更新"></a>3.2.3 插入或更新</h3><p>INSERT INTO … ON DUPLICATE KEY UPDATE 语句可以实现插入或更新的功能，这要求表必须有主键或唯一索引，插入的数据必须包含主键或唯一索引，主键或唯一索引列的值不能为 Null</p>
<p>此外，REPLACE INTO 会在存在唯一索引冲突时先删除旧记录，INSERT IGNORE INTO 会在唯一索引冲突时忽略该条插入操作且不报错</p>
<h3 id="3-2-4-热点数据更新"><a href="#3-2-4-热点数据更新" class="headerlink" title="3.2.4 热点数据更新"></a>3.2.4 热点数据更新</h3><p>热点数据的高效更新对于高并发秒杀场景至关重要</p>
<ul>
<li>库存拆分<ul>
<li>将一个大的库存拆分成多个小库存，拆分后更新操作就可以分散道不同的库表中进行，降低锁粒度提升并发</li>
<li>实现较简单，但存在碎片问题、库存调控并不方便</li>
</ul>
</li>
<li>请求合并<ul>
<li>将多个库存扣减请求合并成一个，进行批量更新</li>
<li>实现较简单，更适用于异步场景，或者经过分析后认为可以将更新合并的场景</li>
</ul>
</li>
<li>将 UPDATE 转换成 INSERT<ul>
<li>直接插入一次占用记录，然后异步统计剩余库存</li>
<li>没有 UPDATE 操作，无锁冲突，但不好统计剩余库存</li>
</ul>
</li>
<li>热点检测<ul>
<li>针对频繁更新或秒杀类业务场景，大幅度优化对于热点行数据的 UPDATE 操作，当开启热点更新自动探测时，系统会自动探测是否有单行的热点更新，让大量的并发 UPDATE 排队执行，以减少大量行锁造成的并发性能下降</li>
<li>开发不需要做额外的事情，但改造 MySQL 有成本，有很多云上数据库都支持这种热点检测</li>
</ul>
</li>
</ul>
<h2 id="3-3-分区"><a href="#3-3-分区" class="headerlink" title="3.3 分区"></a>3.3 分区</h2><h3 id="3-3-1-分区表"><a href="#3-3-1-分区表" class="headerlink" title="3.3.1 分区表"></a>3.3.1 分区表</h3><p>对用户来说，分区表是一个独立的逻辑表，但是底层由多个物理子表组成。分区的主要目的是将数据按照一个较粗的粒度分在不同的表中，将相关的数据存放在一起。适用于大数据量的过滤场景。</p>
<p>MySQL通过对底层物理子表封装来实现分区表，所有的字表都是被隐藏的，只能通过分区表去访问字表。</p>
<p>MySQL存储引擎管理分区的各个底层表和管理普通表一样，从存储引擎的角度来看，分区底层表和普通表没有不同，无须区分。与此同时，索引也是按照分区的子表定义的，分区表的索引只是在各个底层表上各自加上一个完全相同的索引。</p>
<p>MySQL支持多种分区表。使用较多的是根据范围进行分区，每个分区存储落在某个范围的记录。除此之外，MySQL还支持键值、哈希和列表分区以及子分区。</p>
<p>分区表达式可以是列，也可以是包含列的表达式，但表达式返回的值必须是一个确定的整数，而且不能是一个常数。</p>
<h3 id="3-3-2-优势与限制"><a href="#3-3-2-优势与限制" class="headerlink" title="3.3.2 优势与限制"></a>3.3.2 优势与限制</h3><p>分区表的优点如下</p>
<ul>
<li>查询、批量删除、优化、检查、备份和修复时都很方便</li>
<li>将需要放入内存的数据范围缩小至小范围的热点数据</li>
<li>可令不同的分区分布在不同的物理设备上，高效利用多个硬件设备</li>
<li>减少InnoDB的单个索引的互斥访问、锁竞争等</li>
</ul>
<p>分区表的限制如下</p>
<ul>
<li>一个表最多只能有1024个分区</li>
<li>如果分区字段中有主键或者唯一索引的列，那么所有主键列和唯一索引列都必须包含进来</li>
<li>分区表中无法使用外键约束</li>
<li>所有的分区底层表都必须使用相同的存储引擎（有些存储引擎不支持分区）</li>
<li>索引作用范围在各个分区内，没有全局索引</li>
</ul>
<h3 id="3-3-3-使用分区"><a href="#3-3-3-使用分区" class="headerlink" title="3.3.3 使用分区"></a>3.3.3 使用分区</h3><p>数据库在根据索引的扫描结果回表查询所有符合条件的记录时，会产生大量的随机I/O，响应时间会大的不可接收的程度，此外，索引维护的代价也非常高。因此，在数据量超大的时候，B+Tree索引就无法起作用了（除非是覆盖索引），</p>
<p>此时，需要通过分区技术以代价非常小的方式区分出查询需要的较小范围的数据。因为分区不需要精确定位每条数据的位置，无需额外的数据结构记录每个分区有哪些数据，所以代价非常低，只需要一个简答的表达式就可以表达每个分区存放是什么数据。</p>
<p>使用分区表时需要注意的事项如下</p>
<ul>
<li><p>分区表达式的值不能为NULL</p>
<p>当表达式的值为NULL或者非法时，该记录会被存放到第一个分区，那么后续对数据进行操作时，不仅仅会全量扫描WHERE条件筛选出的分区，还会扫描存放NULL值和非法值的第一个分区，如果第一个分区非常大，数据操作的代价也就非常大</p>
</li>
<li><p>分区列与索引列匹配</p>
<p>如果定义的索引列和分区列不匹配，会导致查询无法进行分区过滤，应当避免建立与分区列不匹配的索引</p>
</li>
<li><p>范围分区的分区数尽量限制在100以下</p>
<p>在进行范围分区时，随着分区数的增长，搜索分区的成本越来越高，可以通过限制分区的数量来缓解（其他分区类型，比如键分区和哈希分区，则没有这样的问题）</p>
</li>
<li><p>使用批量操作而非单行单个操作</p>
<p>当查询访问分区表时，在分区过滤之前是需要打开并锁住所有底层表的，这对单行单个操作来说会带来明显的额外开销，因此可以用批量操作的方式来降低单个操作的此类开销</p>
</li>
<li><p>访问分区表时要在WHERE条件中带入分区列</p>
<p>即便在创建分区时可以使用表达式，但在在查询时只能根据列来过滤分区，不能根据表达式的值去过滤分区</p>
</li>
</ul>
<h2 id="3-4-缓存"><a href="#3-4-缓存" class="headerlink" title="3.4 缓存"></a>3.4 缓存</h2><h3 id="3-4-1-缓存与命中"><a href="#3-4-1-缓存与命中" class="headerlink" title="3.4.1 缓存与命中"></a>3.4.1 缓存与命中</h3><p>MySQL将缓存存放在一个引用表中，通过一个哈希值引用，从而缓存完整的SELECT查询结果。当判断缓存是否命中时，MySQL会直接使用SQL语句和客户端发送过来的其他原始信息进行比较，任何字符上的不同（包括空格、注释）都会导致缓存不命中。当查询命中该缓存，MySQL会立即返回结果（即使要查询的表被锁住时），跳过了解析、优化和执行阶段。</p>
<p>此外，当查询语句中具有不确定的数据或者任何用户自定义函数、用户变量、临时表以及包含列级权限的表时，则不会缓存结果；如果查询中涉及到任何一个表发生了变化，那么和这个表相关的所有的缓存数据以及关联表的缓存数据都将失效。</p>
<p>在一个InnoDB事务在提交之前，与该事务所修改的表相关的查询时无法被缓存的，因此长时间运行的事务会大大降低缓存的命中率。</p>
<h3 id="3-4-2-缓存与内存"><a href="#3-4-2-缓存与内存" class="headerlink" title="3.4.2 缓存与内存"></a>3.4.2 缓存与内存</h3><p>查询缓存是完全存储在内存中的，缓存数据包含维护相关的数据（大约40KB）和查询结果，用于查询结果的内存则被分为一个个变长的数据块。</p>
<p>当有查询结果需要缓存时，MySQL会申请一个数据块用于存储结果，由于需要在查询开始返回时结果时就分配空间，而此时是无法预知查询结果到底多大的，无法为每一个查询结果精确分配大小恰好匹配的缓存空间，因此可能会在缓存数据块之间留下很多内存碎片。</p>
<p>此外，如果缓存使用了很大的内存并存放了大量的查询结果，而在进行缓存失效操作时是需要通过一个全局锁来保护的，此时，所有需要做该操作的查询（无论是否命中缓存、还是缓存失效检测）都要等待这个锁，这就很可能导致整个系统都僵死一段时间，因此缓存过大时会带来过大的系统消耗。</p>
<p>查询缓存并不一定能起到正向作用，但对于复杂的SELECT语句且涉及到的UPDATE、DELETE和INSERT操作相比SELECT来说非常少的情况，可以使用查询缓存。</p>
<h3 id="3-4-3-缓存和-InnoDB"><a href="#3-4-3-缓存和-InnoDB" class="headerlink" title="3.4.3 缓存和 InnoDB"></a>3.4.3 缓存和 InnoDB</h3><p>因为InnoDB有自己的MVCC机制，所以相比其他存储引擎，InnoDB和查询缓存的交互要更加复杂。InnoDB会控制在一个事务中是否可以使用查询缓存，每一个InnoDB表的内存数据字典都保存了一个事务的ID号，而事务是否可以访问查询缓存取决于当前事务ID以及对应的数据表上是否有锁。</p>
<p>原则上，在InnoDB的MVCC架构下，当某些修改不影响其他事务读取一致的数据时，是可以使用查询缓存的，但是这样实现起来会非常复杂，InnoDB做了一个简化，让所有有加锁操作的事务都不使用任何查询缓存。</p>
<h3 id="3-4-4-使用缓存"><a href="#3-4-4-使用缓存" class="headerlink" title="3.4.4 使用缓存"></a>3.4.4 使用缓存</h3><p>库表结构的设计、查询语句、应用程序设计都可能会影响到查询缓存的效率，一些使用注意事项如下</p>
<ul>
<li>用多个小表代替一个大表对查询缓存有好处，这会使得失效策略能够在一个更合适的粒度上进行</li>
<li>批量写入相比单条写入效率更好，这会使得缓存失效操作只需进行一次，但不要同时做延迟写和批量写，这会导致服务器僵死较长时间</li>
<li>控制缓存空间，空间太大时进行过期操作会导致服务器僵死较长时间</li>
<li>对于写密集型的应用来说，直接禁用查询缓存可能会提高系统的性能</li>
<li>对于读密集型的应用来说，由于互斥信号量的竞争，有时也可以通过禁用缓存来提高性能</li>
<li>在高并发压力环境中查询缓存往往会导致系统性能的下降，此时不建议使用查询缓存</li>
</ul>
<h2 id="3-5-其他"><a href="#3-5-其他" class="headerlink" title="3.5 其他"></a>3.5 其他</h2><h3 id="3-5-1-视图"><a href="#3-5-1-视图" class="headerlink" title="3.5.1 视图"></a>3.5.1 视图</h3><p>视图本身是一个虚拟表，不存放任何数据，不能建立索引，而在使用SQL语言访问视图时，视图返回的数据是从MySQL从其他表中生成的。因此，视图就像是一个窗口，用户通过各种视图来从不同的角度查看自己感兴趣的数据。</p>
<p>在基于视图执行查询时，MySQL可以使用合并算法和临时表算法来实现视图。如果可能，会尽可能使用合并算法，但如果视图中包含GROUP BY、DISTINCT、任何聚合函数，UNION、子查询等只要无法在原表记录和视图记录中简历一一映射场景时，都会使用临时表算法来实现视图。当视图使用临时表时，无法将WHERE条件下推到各个具体的表，也不能使用任何索引。</p>
<p>使用临时表算法实现的视图在某些时候性能会很糟糕，而即使是基于合并算法实现的视图也会有额外的开销，而且视图的性能难以预测，所以视图在性能优化上还不是那么成熟。</p>
<h3 id="3-5-2-主键"><a href="#3-5-2-主键" class="headerlink" title="3.5.2 主键"></a>3.5.2 主键</h3><p>主键可以是任意一种数据类型，一般是以一个自增字段作为主键，这可以避免主键重复，减少新行插入时的重排序，减少数据页的分裂以及分裂导致的内存碎片和 I/O 操作，查询速度更快，但由于 ID 是顺序自增可预测的，这就给系统带来了一定的安全风险，ID 也可能会用尽（用尽后下一次插入会报主键冲突），另外在分库分表场景下无法依赖一张表的自增来做主键 ID（会有冲突）。</p>
<p>如果没有定义主键 InnoDB 则选择一个唯一的非空索引代替，如果没有这样的索引则隐式定义一个隐藏的主键（比如 row_id，用户无法看到或修改这个列，但可以使用该列来进行排序或连接操作）来作为聚簇索引，从而聚集数据。隐式主键 row_id 用完后下一次插入会覆盖历史数据（无感知）。</p>
<p>UUID 虽然几乎不可能用完，但是会增加存储需求，会导致较频繁的页分裂，写入开销大，也不适合范围查询，取值无实际含义，不方便页面展示，查询效率低。</p>
<p>一旦自增主键真的用完，可以考虑使用分布式 ID。</p>
<h3 id="3-5-3-外键"><a href="#3-5-3-外键" class="headerlink" title="3.5.3 外键"></a>3.5.3 外键</h3><p>InnoDB 是 MySQL 中唯一支持外键的内置存储引擎，外键用于确保两个相关表中始终有一致的数据列，有助于维护数据的一致性和完整性，但这也导致查询需要额外访问一些别的表，意味着需要额外的锁，甚至会导致一些死锁，且难以排查。</p>
<p>对于相关数据的同时更新使用外键更合适，但是如果外键只是用作数值约束，那么使用触发器或者显示的通过枚举来限制取值的性能会更好些。</p>
<p>级联更新时强阻塞，存在数据库更新风暴的风险，外键与级联更新适用于单机低并发，不适合分布式、高并发集群，如果设计的是一个高性能的系统，那么在更在意系统性能的情况下不会使用外键，而是通过应用程序来维护。</p>
<p>外键通过难以跨越不同数据库来建立关系，无法适应分库分表场景。</p>
<h3 id="3-5-4-触发器"><a href="#3-5-4-触发器" class="headerlink" title="3.5.4 触发器"></a>3.5.4 触发器</h3><p>触发器可以在执行增删改操作的前后执行一些特定的操作，可以读取或者改变触发SQL语句所影响的数据，因此，可以使用触发器实现一些强制限制，否则，就需要在应用程序中实现这些逻辑。</p>
<p>触发器可以用于自动更新反范式化数据以及记录变更日志等，可以保证数据总是一致的，可以减少客户端和服务器之间的通信，可以简化应用逻辑，还可以提高性能。</p>
<p>但对于每一个表的每一个事件，最多只能定义一个触发器，且MySQL只支持基于行的触发，即触发器始终是针对一条记录的，如果变更的数据集非常大的话，效率会很低。</p>
<p>在InnoDB表上的触发器是在同一个事务中完成的，原操作和触发器操作会同时失败或者成功，因此，在排查问题时原操作和触发器都需要进行排查。</p>
<h3 id="3-5-5-存储过程"><a href="#3-5-5-存储过程" class="headerlink" title="3.5.5 存储过程"></a>3.5.5 存储过程</h3><p>存储过程是一种在数据库中存储地预编译的代码块，可以执行一系列的数据库操作，存储过程被设计用来完成特定的功能或业务逻辑，通常是一组 SQL 语句的集合。</p>
<p>存储过程的执行效率低于应用程序，但优于某些操作，比如存储过程调用可以替代很多小查询时（节省了查询解析和网络开销）。</p>
<p>存储过程难以维护和调试，MySQL也没有控制存储程序的资源消耗的方案，所以存储过程中的一个小错误可能直接把服务器拖死。</p>
<p>存储过程会给数据服务器增加额外的压力，而数据库服务器的扩展性相比应用程序要差很多，存储过程通常不是跨数据库平台兼容的。</p>
<p>过度依赖存储过程可能会导致数据库权限和访问控制变得复杂，也很难将它们纳入常规的源代码管理、代码审查和版本控制流程。</p>
<p>最好不要复制对存储过程的调用，直接复制由存储过程程序改变的数据则会更好。</p>
<p>一般推荐的做法是直接在应用程序中实现业务逻辑，这可以通过任何服务器端编程语言完成，可以提高代码的可移植性和可维护性，应用程序代码也更加容易管理和部署。</p>
<h3 id="3-5-6-排序"><a href="#3-5-6-排序" class="headerlink" title="3.5.6 排序"></a>3.5.6 排序</h3><p>排序的方式主要取决于优化器的选择，如果优化器认为使用索引更快则采用索引排序，否则就会采用文件排序（filesort）。</p>
<p>索引天然就是有序的，因此采用索引排序的效率是最高的，在查询字段和排序组成联合索引并且查询条件符合最左前缀匹配，查询可以用到索引覆盖时采用索引排序的概率很大，此外通过 LIMIT 等方式来将查询行数限制在一个较小的大小时大概率也会采用索引排序。</p>
<p>在采用 filesort 时，MySQL 会给每个线程分配一块内存用于排序，称为 sort_buffer，如果需要排序的内容小于 sort_buffer，排序就会在 sort_buffer 内存中进行，否则就需要使用磁盘临时文件，临时文件采用归并排序，首先会把需要排序的数据拆分到多个临时文件里同步进行排序操作，然后把多个排好序的文件合并成一个结果集返回给客户端。</p>
<p>如果需要排序的字段长度并不长，那么就会使用全字段排序（将查询的所有字段都放到 sort_buffer 或临时文件中）直接返回结果集，如果字段长度很长，则采用 row_id 排序，并在根据排序字段完成对主键的排序后二次回表再返回结果集。</p>
<p>ORDER BY 的列中，如果多行具有相同的值，服务器会自由地以任何顺序返回这些行，因此在排序的基础上进行分页时一定要通过具备唯一性的字段来令排序方式固定。</p>
<h3 id="3-5-7-计数"><a href="#3-5-7-计数" class="headerlink" title="3.5.7 计数"></a>3.5.7 计数</h3><p>COUNT(1) 和 COUNT(*) 表示是直接查询符合条件的行数（包含值为 Null 的行），两者性能接近，COUNT(col) 表示是查询符合条件的列的不为 Null 的行数，由于 COUNT(col) 需要判断是否为 Null，因此性能比前两个要慢一些。</p>
<p>由于 MyISAM 的锁是表级锁，不会有并发的行数修改，所以 MyISAM 把表的总行数单独记录下来，在没有 WHERE 条件的行数查询时就可以直接返回记录下来的表的行数；而 InnoDB 支持行级锁，表的行数可能会被并发修改，那么缓存记录下来的总行数就是不准确的了，那么在统计行数时，InnoDB 会优先选择最小的非聚簇索引（比聚簇索引小得多）来扫表。</p>
<h3 id="3-5-8-分页"><a href="#3-5-8-分页" class="headerlink" title="3.5.8 分页"></a>3.5.8 分页</h3><p>LIMIT 0 可以快速返回一个空的结果集，这是用来检测一个查询是否有效的一种很有用的方式。</p>
<p>MySQL 通常更愿意执行全表扫描，但如果通过 LIMIT 限制只查询很少的行数的话，某些情况下就可能会使用索引。</p>
<p>LIMIT 很适合用来提前终止扫描，即避免不必要的扫描，如果明确知道需要的行数的话，那么建议使用 LIMIT。</p>
<p>对于同样大小的页，查询偏移量更大的页显然性能更差，这种深度分页会先读取包括偏移量和所需页的记录，再丢弃偏移量数据，返回所需页。</p>
<p>可以通过主键查询来优化深度分页，首先通过子查询来获取所需页的主键（仅需要丢弃偏移主键数据），然后再使用这些主键在主查询中获取完整的数据行，基于主键的查询则非常高效。</p>
<h3 id="3-5-9-数据页"><a href="#3-5-9-数据页" class="headerlink" title="3.5.9 数据页"></a>3.5.9 数据页</h3><p>InnoDB 数据页是 InnoDB 存储引擎中用于存储数据的基本单位，是磁盘上的一个连续区域，大小通常为 16 KB，InnoDB 的每次读写都是以一个数据页大小为单位的，B+Tree 的每个节点都对应着一个数据页，B+Tree 通过节点之间的指针连接了不同层级的数据页，从而构建了一个高效有序的索引结构。</p>
<p>页分裂是指将该页中的一部分索引记录移动到一个新的页面中，从而为新记录腾出空间，保持 B+Tree 的平衡和性能，分裂这个动作可能会引起连锁反应，从叶子节点沿着树结构一路分裂到根节点。页合并是指将两个相邻的索引页面合并成一个更大的页面，减少 B+Tree 的层级，从而提升查询性能。</p>
<p>页分裂和页合并时涉及大量数据移动和重组的操作，频繁进行这种操作会导致 B+Tree 索引结构频繁调整，增加数据库的 I/O 负担和 CPU 消耗，影响数据库的插入和删除等操作的整体性能，也导致磁盘上数据库占用更多的磁盘空间以及较多的空间碎片。</p>
<p>插入大量数据时尽量使用批量插入的方式，而不是逐条插入，从而减少页分裂的次数。为了避免频繁删除导致页面过于稀疏而触发页合并，一般建议使用逻辑删除而不是物理删除。</p>
<h3 id="3-5-10-长事务"><a href="#3-5-10-长事务" class="headerlink" title="3.5.10 长事务"></a>3.5.10 长事务</h3><p>长事务是指事务中要执行的 SQL 很多，事务的事件比较长，这会导致长时间占用数据库连接，难以回滚，更多更大概率的锁竞争，大量日志等问题，因此应当确保事务中只包含必须的处理，将不需要再事务中进行的操作（如读操作、内存计算、I/O 操作、远程调用等）放到事务外处理。</p>
<h3 id="3-5-11-删除"><a href="#3-5-11-删除" class="headerlink" title="3.5.11 删除"></a>3.5.11 删除</h3><p>DELETE 用于删除表中的一行或多行记录，可以配合 WHERE 一起使用，操作过程中会记录 BinLog，比较慢，可以回滚，不会重置自增的计数器，是 DML。</p>
<p>TRUNCATE 用于快速删除表中的所有记录，并重置自增的计数器，不可以配合 WHERE 一起使用，速度很快，是 DDL。</p>
<p>DROP 用于删除整个表结果及其数据，不可以配合 WHERE 一起使用，操作不可回滚，速度很快，是 DDL，如果需要恢复可以尝试数据库备份但不保证可以百分百恢复。</p>
<h2 id="3-5-执行计划"><a href="#3-5-执行计划" class="headerlink" title="3.5 执行计划"></a>3.5 执行计划</h2><p>执行计划中排在第一行的表是驱动表，排在第二行的表是被驱动表</p>
<p><a href="https://www.yuque.com/hollis666/niq4hm/fho0bamf4qpcril5">https://www.yuque.com/hollis666/niq4hm/fho0bamf4qpcril5</a></p>
<p><a href="https://www.yuque.com/hollis666/niq4hm/gux80i">https://www.yuque.com/hollis666/niq4hm/gux80i</a></p>
<p><a href="https://www.yuque.com/hollis666/niq4hm/upcggbxiyk11gudc">https://www.yuque.com/hollis666/niq4hm/upcggbxiyk11gudc</a></p>
<p><a href="https://www.yuque.com/hollis666/niq4hm/dxmpt2">https://www.yuque.com/hollis666/niq4hm/dxmpt2</a></p>
<p>累了，学不动，等以后有空再研究</p>
<h1 id="4、复制"><a href="#4、复制" class="headerlink" title="4、复制"></a>4、复制</h1><p>复制解决的基本问题是让一台服务器的数据和其他服务器保持同步，实现一种“水平扩展”的架构，这种功能不仅有利于构建高性能的应用，同时也是死高可用性、可扩展性、灾难恢复、备份以及数据仓库等工作的基础。</p>
<p>通过复制所实现的“水平扩展”可以将读操作指向备库来获得更好的读扩展，但由于不能像分发读操作那样将写操作等同地分发到更多服务器上，随着查询数量的增加，需要的服务器数量的增加并非线性扩展，即当为单台主库增加备库时，将很快达到投入远高于回报的地步。因此，对于写操作，并不适合通过复制来扩展写操作，写操作通常是复制的瓶颈（对数据进行分区是唯一可以扩展写操作的方法）。</p>
<h2 id="4-1-复制方式"><a href="#4-1-复制方式" class="headerlink" title="4.1 复制方式"></a>4.1 复制方式</h2><h3 id="4-1-1-执行流程"><a href="#4-1-1-执行流程" class="headerlink" title="4.1.1 执行流程"></a>4.1.1 执行流程</h3><p>MySQL支持两种复制方式，基于行的复制和基于语句的复制，这两种方式都有以下三个步骤</p>
<ul>
<li>在主库每次提交事务完成数据更新前，把数据更改记录到 BinLog（这些记录被称为 BinLog 事件），记录后主库会告知存储引擎可以提交事务了（MySQL 会按事务提交的顺序而非每条语句的执行顺序来记录 BinLog）</li>
<li>备库启动一个 I/O 线程，该线程跟主库建立一个普通的客户端连接，然后在主库上启动一个二进制转储线程，该线程会自动读取主库上 BinLog 中的事件，备库 I/O 线程会将接收到的事件记录到自己的 RelayLog 中，完成从 BinLog 到 RelayLog 的复制</li>
<li>备库启动一个 SQL 线程来读取 RelayLog 中的事件，将其重放到备库数据之上，实现异步的数据复制</li>
</ul>
<p>以上这种复制架构实现了获取事件和重放事件的解耦，允许这两个过程异步进行，但是<strong>由于备库只有一个 SQL 线程来重放 RelayLog 中的事件，因此主库上并发运行的查询在备库只能串行化执行</strong>。此外，<strong>需要给每个服务器分配一个全局唯一的服务器 ID</strong>，当复制 SQL 线程读中继日志时，会丢弃事件中记录的服务器 ID 和该服务器本身 ID 相同的事件，从而打破复制过程中的无限循环。</p>
<p>主从延迟是指在主从复制过程中，从服务器上的数据与主服务器上的数据之间存在的时间差或延迟，一般来说可能是网络延迟、从节点 CPU、内存、线程数量等性能问题导致的。</p>
<h3 id="4-1-2-复制方式"><a href="#4-1-2-复制方式" class="headerlink" title="4.1.2 复制方式"></a>4.1.2 复制方式</h3><p>基于语句的复制也称为逻辑复制，此时，主库会记录那些造成数据更改的查询，当备库读取并重放这些事件时，实际上只是把主库上执行过的SQL再执行一遍。</p>
<ul>
<li>逻辑复制实现起来非常简单，并且能让二进制日志里的事件更加紧凑</li>
<li>即便主备的模式不同（比如表的定义不同但数据类型相兼容，列的顺序不同等），逻辑复制依旧能够工作</li>
<li>逻辑复制基本上就是执行 SQL，那么所有在服务器上发生的变更都以一种容易理解的方式运行，出现问题时可以很好地定位</li>
<li>考虑到同一条 SQL 在不同时刻下执行可能并不相同，因此在传输的二进制日志中，除了查询语句，还包括了一些元数据信息（比如当前的时间戳），即便如此，依旧存在无法一些被正确复制的 SQL（比如使用了触发器或者存储过程）</li>
<li>由于更新必须是串行的，这意味着需要更多的锁，可能代价会很高</li>
<li>不是所有的存储引擎都支持这种复制模式</li>
<li>单线程的逻辑复制常常导致备库容量小于主库</li>
</ul>
<p>基于行的复制会将实际数据记录在二进制日志中。</p>
<ul>
<li>基于行的复制的最大的好处是可以正确的复制每一行数据，无需重放更新主库数据的查询，能更加高效的复制数据</li>
<li>因为基于行的复制并不要求这种强串行化是可重复的，因此可以减少锁的使用，也占用更少的 CPU</li>
<li>基于行的复制模式下，如果在备库更新一个不存在的记录时会报错并停止复制，因此能够帮助找到并解决数据不一致的情况</li>
<li>但如果被更新的数据量非常大，比如全表更新，此时每一行的数据都会被记录到二进制日志中，这使得二进制日志事件非常庞大，复制开销会很大</li>
<li>基于行的复制并不知道主库中到底执行了哪些 SQL，因此出现问题时很难找到问题所在</li>
</ul>
<p>MySQL 默认情况下使用的是基于语句的复制方式，如果发现语句无法被正确地复制，就切换到基于行的复制模式。</p>
<h3 id="4-1-3-异步和同步"><a href="#4-1-3-异步和同步" class="headerlink" title="4.1.3 异步和同步"></a>4.1.3 异步和同步</h3><p>MySQL 目前支持全同步复制、异步复制和半同步复制。</p>
<p>异步复制是 MySQL 默认的复制方式，主库在执行完事务操作以后，会立刻返回给客户端，无需关心从库是否完成该事务的执行，当主库执行完事务但还没来得及将数据同步给从库时，从库就会丢失这次事务的变更内容。</p>
<p>全同步复制是指主库执行完一个事务后等待所有从库完成数据复制之后才会给客户端反馈，这种方式可以保障安全性，但当从库比较多时性能很差。</p>
<p>半同步复制是介入全同步复制和异步复制之间的一种方案，主库在执行完一个事务之后，也不会立刻给客户端反馈，而是等其中一个从库完成数据同步之后再反馈给客户端，但也不必等待所有从库都完成事务。</p>
<h2 id="4-2-复制拓扑"><a href="#4-2-复制拓扑" class="headerlink" title="4.2 复制拓扑"></a>4.2 复制拓扑</h2><h3 id="4-2-1-主库和备库"><a href="#4-2-1-主库和备库" class="headerlink" title="4.2.1 主库和备库"></a>4.2.1 主库和备库</h3><p>可以在任意多个主库和备库之间建立复制，但要注意每个备库只能有一个主库，一个主库可以有多个备库，一个备库可以有多个兄弟备库，每个备库必须有唯一的服务器 ID 并保持 ID 不变，备库可以把其主库上的数据变化传播到其他备库。</p>
<ul>
<li>在有少量写和大量读时，可以使用一主多备的结构（备库之间没有交互），将读分摊到多个备库上，直到主备之间的带宽成为瓶颈为止，这种结构简单、灵活，避免了很多其他拓扑结构的复杂性</li>
<li>当两个处于不同地理位置的办公室，并且都需要一份可写的数据拷贝时，可以使用主-主复制的结构，两台服务器中的每一个都被配置成对方的主库和备库，这种结构最大的问题是解决冲突，需要仔细的配置划分数据和权限</li>
<li>主主复制结构的一个变体是令其中一台服务器是只读的被动服务器，这能很好的避免冲突，且由于配置是对称的，反复切换制动和被动服务器也非常方便，是构建容错性和高可用性的非常强大的方式</li>
<li>环形复制结构可以由三个或更多的主库，每个服务器都是它之前的服务器的备库，是它之后的服务器的主库，主主复制结构就是环形复制结构的一个特例，但两个服务器以上的环形结构不具备对称配置和简单的故障转移，并且完全依赖于环上的每一个可用节点，这大大增大了整个系统失效的几率，应该尽量避免这种脆弱的环形结构</li>
</ul>
<h3 id="4-2-2-分发主库"><a href="#4-2-2-分发主库" class="headerlink" title="4.2.2 分发主库"></a>4.2.2 分发主库</h3><p>复制操作在主库的开销主要是启用 BinLog 带来的开销，备库对主库增加的网络 I/O 开销，唤醒复制线程发送时间的开销等。</p>
<p>每个备库会在主库上创建一个二进制转储线程来读取 BinLog 文件中的数据并将其发送给备库，每个备库都重复这样的工作而不会共享资源。那么当备库足够多并且有很大的事件时，主库上的负载会显著上升，甚至可能由于备库同时请求同样的事件而耗尽内存并崩溃或者是大量的磁盘检索。</p>
<p>如果需要多个备库，可以从主库移除负载并使用分发主库。分发主库事实上也是一个备库，它的唯一目的就是提取主库的 BinLog。此时，多个备库连接到分发主库而非原来的主库。这种主库、分发主库以及备库组成的复制拓扑结构使原来的主库摆脱大量备库带来的负担。</p>
<p>此外，分发主库还可以用于对 BinLog 事件执行过滤和重写规则，这比在每个备库上重复进行日志记录、重写和过滤要高效很多。但由于分发主库的存在，各个备库与原始主库的 BinLog 坐标已经不相同的，所以无法使用一个备库来代替主库。</p>
<h3 id="4-2-3-定制化方案"><a href="#4-2-3-定制化方案" class="headerlink" title="4.2.3 定制化方案"></a>4.2.3 定制化方案</h3><p>MySQL可以根据需要定制解决方案，典型的定制方案包括组合过滤、分发和向不同的存储引擎复制，这其中最大的限制是合理地监控、管理以及所拥有的资源的约束（比如网络带宽、CPU能力等）。</p>
<ul>
<li>选择性复制：在主库上将数据划分到不同的数据库里，将数据库复制到不同的备库上</li>
<li>分离功能：在线事务处理（OLTP）查询比较短并且是事务型的，在线数据分析（OLAP）查询通常很大，也很慢，并且不要求绝对最新的数据，这两种查询给服务器带来的负担不同，需要不同的配置，可使用不同的备库上来执行</li>
<li>数据归档：在备库上保留主库上删除过的数据，实现数据归档</li>
<li>日志服务器：通过创建没有数据的日志服务器，用于可靠的地存储主库的二进制日志，更加容易重放和过滤二进制日志事件，对崩溃后重启复制也很有帮助</li>
</ul>
<h1 id="5、备份"><a href="#5、备份" class="headerlink" title="5、备份"></a>5、备份</h1><p>对于备份来说，复制是一项很有意义的技术补充，但复制既不是备份也不能够取代备份。</p>
<p>在上一章介绍了数据库之间的增量数据更新的复制方式，然而在一种更加典型的案例（同时也是大多数情况）下，有一个已经运行了一段时间的主库，然后用一台新安装的备库与之同步，此时需要考虑存量数据的复制，可以通过以下方式中任意一种来实现复制</p>
<ul>
<li>冷备份：关闭主库，然后将数据复制到备库，重启主库后，使用一个新的二进制日志文件</li>
<li>热备份：如果仅使用了MyISAM表，可以在主库运行时通过热备份来复制数据</li>
<li>使用快照或备份：如果知道对应的二进制日志坐标，就可以使用主库的快照或者备份来初始化备库（如果使用备份，需要确保存在从备份的时间点开始到现在的主库二进制日志）</li>
</ul>
<h1 id="6、补充"><a href="#6、补充" class="headerlink" title="6、补充"></a>6、补充</h1><p><strong>（这些补充内容以后有空单开一篇详细学下）</strong></p>
<h2 id="基准测试"><a href="#基准测试" class="headerlink" title="基准测试"></a>基准测试</h2><p>基准测试是针对系统设计的一种压力测试，可以观察系统在不同压力下的行为。在新系统正式上线到生产环境之前都应该进行基准测试，而且，基准测试应该运行足够长的时间，应该确认测试结果可重复。</p>
<p>可以考虑的测试指标有</p>
<ul>
<li>吞吐量：指单位时间内的事务处理数，常用的测试单位是每秒事务数（TPS）或每分钟事务数（TPM）</li>
<li>响应时间或延迟：指测试任务所需的整体时间</li>
<li>并发性：指任意时间内有多少同时发生的并发请求，并发性测试通常不是为了测试应用能达到的并发度，而是为了测试应用在不同并发下的性能</li>
<li>可扩展性：指系统资源增加时系统性能的提升情况（理想情况下是呈线性提升），可扩展性指标便于发现系统应用的瓶颈</li>
</ul>
<p>归根结底，应当尽可能收集一些需求，测试那些对用户来说最重要的指标。</p>
<h2 id="性能剖析"><a href="#性能剖析" class="headerlink" title="性能剖析"></a>性能剖析</h2><p>性能剖析（profiling）用于测量服务器的时间花费在哪里并生成剖析报告，项目中应尽量包含性能剖析的代码。</p>
<p>注：</p>
<ul>
<li>“查询”泛指所有发送给服务器的命令</li>
<li>性能用查询的响应时间来度量</li>
<li>性能优化是指在一定的工作负载下尽可能地降低响应时间</li>
</ul>
<h2 id="加密解密"><a href="#加密解密" class="headerlink" title="加密解密"></a>加密解密</h2><p>服务端加解密指的是数据在入库之前就加密好，需要时从数据库读出来之后再解密，可以保证数据绝对安全</p>
<p>MD5 严格来说不是加密算法，只是一种哈希算法，MD5 不支持解密，只能用于哪种存储后只做匹配而不作查询展示的场景，如用户密码</p>
<p>MySQL 提供了一些内置的<a href="https://www.yuque.com/hollis666/niq4hm/xg32pfnstsrh9pdp">加密函数</a>，可以直接用来对数据进行加密，</p>
<p>加密虽然可以保证数据安全，但也会增加性能开销，引入更高的复杂性，使得查询和检索更加困难，密钥的正确管理也会成为关键问题</p>
<p>如果需要对加密数据进行模糊查询，可以明文进行分词，然后分别加密存储到数据库中，那么就可以对分词文本进行模糊匹配，但可以进行模糊匹配的文本就限定在分词文本的范围中，还是不够灵活，另一种改进的方式是将所有需要用于模糊查询的信息都拼接成一个字符串放到同一个字段中，这样就只需要通过这个字段做模糊查询即可。</p>
<h1 id="7、参考资料"><a href="#7、参考资料" class="headerlink" title="7、参考资料"></a>7、参考资料</h1><ul>
<li>《High Performance MySQL, Third Edition》</li>
<li><a href="https://dev.mysql.com/blog-archive/whats-new-in-mysql-8-0-generally-available/">https://dev.mysql.com/blog-archive/whats-new-in-mysql-8-0-generally-available/</a></li>
<li><a href="https://www.yuque.com/hollis666/niq4hm/qimt8ayyqk8y5qc7">https://www.yuque.com/hollis666/niq4hm/qimt8ayyqk8y5qc7</a></li>
<li><a href="https://www.yuque.com/hollis666/niq4hm/mgpczmz7la99dkft">https://www.yuque.com/hollis666/niq4hm/mgpczmz7la99dkft</a></li>
<li><a href="https://www.yuque.com/hollis666/niq4hm/zhfa5g">https://www.yuque.com/hollis666/niq4hm/zhfa5g</a></li>
</ul>
]]></content>
  </entry>
  <entry>
    <title>Overview -</title>
    <url>/2023/07/31/overview/</url>
    <content><![CDATA[<div class="hbe hbe-container" id="hexo-blog-encrypt" data-wpm="Oh, this is an invalid password. Check and try again, please." data-whm="OOPS, these decrypted content may changed, but you can still have a look.">
  <script id="hbeData" type="hbeData" data-hmacdigest="d9bdf49478ec5be24336732cb69ba5aab7b45b912f62411469d0a4cc3269dbb7">a99f2d1cd7f89812758242c57c62a59f951a667adeb13518bea2b283c304e7eeaaaa59a33293fe17ead018ca777db13246daa86a1651b300274637bf9a429479cb493d5ff9127daf5fb6e2612ce564278707d5ae2860d267c12a193d5f0eb5c23059765ded32779a647e13b7ed7f08e459e528752b474759097e7910ad94d6cccbeeec1eb930353b9f4ce96de5c3dbacc91df1fe081b52b8998fecc2de1c686590c05117e899660c71eb9b1cd76e14df7f238d7e237ba1de6172fa3c1903e73242e5c55c6d84c39b47c0df918d70d004abf89b74502b9e9a5bc8adfd84cb78777e4fa734829f9731dbdebf3043698880c8ecb662752b3cebe102af09c322b927080c75004536313c4d07f750e69b65aaca59dd52a3580aa4d6c8ed6d0503b5096e1992c1ca50ba08144321e2c462bad09a2af7ce085cd1242c659735c3bb9d333cadf894e014ed3eb8a710f2dfec2af5f9564353fa982c4a828c9caa662bab61c03c53dd33dd193ecd3c18676d25cc0ce6d92cefc9048be852c9080d9d3892959b2ddd78590663f2dc7bca5496aaf91cb90267b4a02c8d727420c877fe3d76005331326b3e269ca849e8ce976c67d7c62066ab5f944ab6282d593e25961b693c0c3d3ea6b64d93dd0900ac3efd46a0a546769bf2f0d0b8f50d04be6c896b0d277be98c21aac4392f89029fcc0e1dc4dbd3e39b4b3d754d58e1c1ed401738d54035e7f1a611a4b57a755403fe71427039f5c5fcf8955711a1642a2df30811ff43b4279c2ec20c23a2c16df723ce8a5b4116b244ff19e0cb6eee5d7f20659db8231d5873f8ea127aae7fbfece089fea007f79f3c5e20c0f483215826c6a45a515b1c7015550190f05ea15d73ecb14b53876262b46d1b5e865ec5dca220412c4327f1db9fc720e88b2a834b678b57a2a94ee84d7d0ce602ccf3aa70d2ea827c8b4f56177c1bc9d68b983de26fd2c71c647697a792157844a633eede21cb27e552a2e7dda957244b7e3a7ff2b65342b24a57995a8e4dbbe7f312bf7ee4ce08db131ad539954eba33c006326b0e5e3c5a2863d5a4d864e16ee109201532886c1c13c3c249d0240bf5dc8f1b54766f6da28b482abb8603a2c105118078491d52d65eec912917a4f8bf88344763cf1966461a97bf29db7d9c2be5dd20d118768892b10fff93d1526f984ab8c48fb044963e0263d62fc50a0de87eb696f200b7c27f664ce397c76f3eb27109a3420f92b6a71bfc585c04ffdfc8b84031b16766b23f1c16cb25e5ecc7a77efb201adf1f7759cd283ded833da21150c885fc19663a9b0e2b933af17d50d186ded0ea27894c8e421bc65d1ac92dadf184d035b31f9b0d55e88f67c4684b5d3612c95393c2ee5acb96da4c8d1217a78260c9bc0086e443ecebe1080c88ae11a2f948717bfb7fa551509fe3e0de7e9600895cdaa52a8563418444a56f688c42a9fbabbad1c5c4ecb088c77deb8fbbe1af124524ac7b36ac6eba076dc6b88c74a6778ae17537aad7caeaf1b744a9440338597832a6f9ca3a0e0a8a46acbd26d391191836fd15a0eb7746078712c72f52b8cdca2580012bf913f4663f03743f28bef4c10d9b4b9410ff25f1e8e5cba010cc7d80dd81a556d11caacea7eb328887726edd3cd737a2bc16f25b25a15dba2afd346199770424d31d07f7c82a8e27de46f08c158e310d20eac4c14fddab2484c3e9e39ec6ae31878bdf8915b1609f5a344d8d97ce8479f0c1d2446c54a335069d1ef51d99b271911d14e55677331f81725d22f64b25fc114c49495f0247a49448a98076980ee9497279ce67c710a2507af8ac07952bbabdb49d72efacdb7000775b604a6b8991cbb0a4fc1aaf493bb1dca850fcd5c71ab00020cd45a53f29350b5d21d1f348871e1d46ac5506e8e780b90217eb1d1e9555f2fbfb74397f3e24adb10b057e7259bb9c05d777ebaa8b16e121894414e4a2b26d4c84d74ec753a07842478f01dde382a432fab49a5f2ba9990f9a5dd82a98c59aec4d41bbdb4ed470271ea69789ae357f94eb17b068d117dd96ffd1324645eebb727f65493ce4199bc34279a20bbd8bb7aa0c4cd3fba1d75cc6246033ef59ff62133f5e46ef9d8bca0a1eea4037e2456e9517ff671cbbee93f603bc37c3929623dc37319bf381412f7ef48d29337d9d753d5b93c7309f450c6633dcd44ba48216158e3722af01f7fa9bcafaca9f2604f68e265ce7c9c7b4d6504eebf04186ffc96870f4ceed152b631301777ed91c869b24d4282d5302230fbc9cd3829506e81f3b0599ed756b815b64c1c1e31250c28303efe5e5688c09e097d5bf374bd83a1ec11b745e4e5c6b5d2a5e968865aa9e199422523a35fa11c661998efb1aed8ee29c8da0246eb1225662946389c9ae7a44759e8c642c3db4a705931791398c3c71b427fd61f6c92ec2779643a802b4bd90492c5512b1d7c3039402277ff05a223a005300893601e82fc2f277418393d1096f112e433aaa6a250bf57930dd0ee36b0697272f607dd681985d8f97b42d62a0b096c076eb07c6954b585fdd0c6eed6f2910f3cb5c6bd0c28bb1bcfa52e0021d45b1a8eb1e18bcab58baee065fd3c78c677810ff7aba9472b8acb5fa49b04bf85b887e6c6923474639551961000b29a3f1c1fcfd1d044cf106bade334e88678956ffc062e8eb88ce085bb2ea7f33fd5845f8c24e971fcafe8d13efa6710939ed06000945c2b8567b545c54a02e5562e56aa59bee65eb81a98dcc7cdcb809ed2e6834255df3f03eedf1c9582122cfc3aae98e3d24ce3cd4d53b8ab2eb7eb4dc003475c6177f5ba270da359d30202ea7b474a9458885b60a5734556365cce22c27f1f58bdfe1c4ec52895ab0d19d6da12d0c10fc567c41435a675bc8eb49703e36b2c11510b900dd38cd2163211cc0f3579b4c1d719784eed78df80bc932a4a3048eeb47e2df0343189e118af0fed5a2b8b53c3783bcccde936a0b33ac4171eba7a19a05dee9d7daa167e1ea8d213331cde56b2893c6bd094b04ec88632e35b71311591199b1363c7e37cf51bfb7f62a6d079e0e786ab2d2f39a01cf463313c9c9b4a0c90218562cb1a51a01723ba9fca9e9d89140baacbf119d71bb493aded1075893b85812712cb1fa6c3ed152415a0c97678c1001b3ad7321a65123fb8f2d930d0066bb53a01828a000672cbc57efee284e972d805dd22b411d7c408eca7fafbe87281a38de2048f82f2b8b9c5a213622773c31e07978c973a7ebc6a39cfdbfaa148c40edb0a2527c1e9cb46519808125e413d61d9e0c1ab6be1fb8003166a7249fdf1ef6683b1c7fdf05ccfdf8e57e16533d0bd736e1b0d49078699435a579f0e25e02bc3ace879906f93f676965acda5ab10603b134fe06c3d98f596494b99dc36b88fb7a2fbd08ce00e5741f2668b617f91f60d88137f770ed55d538a3e4aa0ff15e15c4f2160a938dc97df1abce11dbb65924211a85f558bf35e735cfc125bec22183384807a67475c1429cd9db13e64128e0784f0b5af943f74f1a42e23eb7574f9b2b39b9987110fab4078c92f76b702badca2ba442546d258f27c8ccc3b557ae55cfc437703874bef1d814d8ef155683a4c121f901847894c64bdb0c12bce1e09ab626c0643f80ad72599f4fe64ef204d041d2de107a5e2bc69685553dbe73d464700ca4ec62f760a8902481e64372f1ac346db421f5d9ee45693293024408afda47a65cf7df44b89f73a35900730b56bf1e0dbf5adf6cb5db0ace72c58232ce2eb3635b474b0ff235ed46b049a368a019c96173ccc4891c95a120cbd6f6e3ef34fd52e35fe8a22d817a20c7b1e67b83c20dea456af51492bacaaf225fd76b37afe66e459d3f3a399162047c775d5ceeb00fb88dea243dcdcbb2309a1ce22e36a7b73614e36fe9666d4dfe84b85eec385b8b0ab771bfec6ce6274f7c1c8da43695ca32604988ff0a3e5cdbf9bc47e9110dec6aef1580433a8488ac6f1d18cb336512c671235d99d674914a0487729f2b3391c9b0feead37de807100128b5d432b902639def32d40f35b3e128c16f8e9304f90a09f4212733fed169a1b1a74315226e91cdfe24d5220cf57fcd330755a0c6ed728f29939f7b5fc08dd7c10c7b830a5faa23e01776eeb4ac064efa8d4b98d3fd6826454fe5861c48350d23bda4b63d54a1b2005602834585fb654964306fbb025a51bc994ac89b02eb7609d22ad0a86803bd4bd5a2ea9692cf073ef1e392d6c0b2944c74d9905a52b1d7075891dc13ea098b4d42294cf480f2cda6483ce47d37bd7938fd1463cb636612ff66baf173a21db0fbfe9b139c340fe151b8063b27e216dd16d9da7a8940865946e85abcf63a2313987645deada9033ad12f8ed77a91dd8ea264ff598f237e9cc5678117e203bb9d7f35bffe2b9d514e821f5515130dd877b89b561e44826347ea5e08614efaeba1af709cceacd40a8eecd468ad1e8ab5f97116c26f17e9c8131cbaa77cb266c3382ba35e6cbce69f3174a98af9e357f893201f6a5f2362e18c9b5b6d0a0895a14016fb1485e61fe66b911aad609af2784db0d5f7684e0a31a31a491093ae608331bce762800dc6cbce985805f7ccac8bee4a850242d3161d3ffce25241376b59153e7d76d6897c08bbf95957383de04296b0782351e03cbbb971f456a1497799be6bb5c946addc0e344e53782a97616e3844972deda4bd7b542d26749fa5f554e2123f7d2093c36c0095a8dbf2098d96e019ce34d0afbdd47c7ddb75e7f9e17ced02bca9969470efa94b8d9bc957c89160e20db7403fad19b29b80228b8155da226b98b243eaa0933489f357860921b778aef7b025bcd88fb42c00d71604c35cb85466ed39649d4d19985b04763976570b0218d613553c9adc8baab3cf6b1f33ce9b85acde63e5882d36a6de3047f145c5e90be1decdf718877d317fcca814139d70d09bbb267f8a3dcb7fa012849e66734e9533854050043d4f3ab00778f583123d8e1e6f677e7608eb9b4e57cea4b3f32647a81651906fc77357827008fb3835aff0a395241bf926532347a5397e5b60f07f98826ebb31677ec570e74490aa35df8c2d4e2f07d429af83cc9f59da47ce5ffd7692fdd6bb52cdb663c9dcee60d24425880851b6ce66b5816b2ab7de760df6131c28cf8f090cd9d15681159b41d20a76e63ba6a8c90b8c0559cfc5414af05179fdfb85e98434ef6ed64bb835e2ada8ea6c710ba15a99a711d71797090815744a16f4388a88341a6ee698386eb36f0ff459c5b0a621e0fbdde88d744de60ba11d1b929d0a06fcf98558bc176ea1e2413c8b310aac6c3c6a54c3891dc6dd45be6db7ed074870f072d590f530cc1b3cd051d4752508d1854f3840bc054858e36562abbdd14355bb282f38c93bc146f0e46f1f71e9df949cd51d42b0da3e9b1260ca4046c2374c8412d2fc6a1c328ade9242ec050fcd19f3ca3e78d2d4e0e6e5860b648468b48259a6b93e43147647333bec637118c6eb8d40638a0880522267f1271666b965a83a4186ffa1342de902bd66c184223827c14624d6515ce5eeba277d1957780705ceee780f64ac3ae98e711394ab04c911e23f203fb84c6cce0c835c1d2c3760e0994604bb461a8cfc91d2e6f01beb534405935ca464093a87e49a6e172c2c90117a053262a21dbacd2a07030ab13763b7ace892840b2af8025f754f19f713a3a22bb13cbf24fae764f1e43d0f432e418e18d2382acbbb09b591a8fe481891aa2e5530429ebe5695493c1bf127040dc3e3466e0f3dbbc2cf280ea2ff94589dffc2e729c4e4825f4f93f2bc345b373086c2924c89e07825286212bb432ef5390616beaaf06297060e4a347e54fda32de9a33cf6aedc6a292f24699535b72bde7394ef405ecc78aec0390730e47b9341d17bcf9445a1016e47ac8bdd86c6be2785694aaf7ae894b4b046eaea015b1ed829eb8278d9c32253c84c1717a0f31308cb7eb6844939f3840548b56bd43f964da1d959c517091dd7dd20c73464eed10ed9510dd9483969eb6d2ce87db9d6c925fec6b678a7774328b5d7fe0598c6c3a6c103269a449983f6b66e7901f453d40d227103951c74f1154c86ae2f627ee33cada93e5b3e0d788004faf53c7b33714bd1fc3e4ceae47e9703ab8bb77635690aeaf9c323ce4ed0276672c0e170462d3ca988d17e76a06bbe60dad2c1e9b954e30aa3fa31e7af2c41ba56b5b21a9adace219cc5e93dae84407f143d1bf4e935a1735b2f9364b165f0f259291337f43829edaf7456fe1c224e2e3a3a2fe22f8f68416404f4014d41fec9312b03e420469ff944c87b121025f56ede42292a9907f588ae03c3bba3b9f6f7284db4db7d1202b1df3a0082fc2edc2f186c85c48e477b2cffc1ad78dfa51203b46e3b40fa73b59350f6134a7106a363b8601888874c1dcad3711a980b586d61c2ec85cb6002570e829a356cc916e6ec627a12bd330ee0a80b2c338bc5f268a61d4fceadc8256924bc9fc606a6114dc51944a81eaa7fcbe1507d12c4e47fd8b1433241dbc2deac548ac05c755eea88245081b4f6c0fa01d44a0881a68b1e15b98b25dfecc31c1b810b7d9c48bb7db06688f9874534ca606175013ab2ffa874bea088a313c45b92be9c709d5cf1a0efd90559eccba98dda6c85a2971f05e5ea0320fd64482047b8ac8eee9f11ef347fd9b75aada740c37396c2862550f4fc9ae8cc7bd54761f3df0d373edef52d1c94fa5c0a64579632d834d10affac3190fa6ffe1ce7b482fdec036cfed661e6dd7a5716c5bad5d9fe3c1fde2350b6b2f616f2eadcf9907e8877d9c9b1a469b67e7115da155d95ee5fa7dbef3d4c14146b0ad28884cc55c02f97c39a2578dcc03c9706bc53ff79dd7bf41ab4bc71ba439c032aee441aaaf1747c3bb1bbcb341018f06da798921a6faf0e0c07818930dd2fa4c084753677a7ff1cb100ba56a5c362bf0e3b91e8c453c30ad4d228016e92a985068f5c0bc656580eeb43302601c161acfa2a6526b4f572f014f6dfbc361902d6306e8b8a2ba0ce11286d68999e1438b75febf357afe7823cfdfa49aed41217306af70d3779b451facc179e812b276e6313c9c7a4ac0677ca271ff5d9e0702d1acdc6f6ebe14778188c273e1114e611d5e16ead0abbb8cd6b92cd3f6b03bd978e8a60893b6caca30195368756759a3852357116f08cc0fa47626e4cf100157e7a197995b6a6c7381e328612d1486c1485ab4b5385a57c486b533dfb619cdea4e2fe42eacbe21b3f87082a54f3b7a089259c7bd92aec66181ce3921017c102814c22945e9d4f55a7b375977fa1729d887460b138f255505af8527c27cad0fe724e3ce0ade74ceca2843f0155b62124594aba92b6a47f42fef2e58fc6929f567921123ed0ab5f9151cae5ee3bbd199634dd86bc4bd071cee471e282c06b3a2cab7bb00f0cd16987b9bee779d12092822123715e7bd425cefb6c009a688e7885028d91370063cec0b49a20c4c336b1275c6f33b90dc93acde8b44401f676f8ddb001413d8b7d95b5bb98114bc6bd8708c0c8655ee79b35dbb83412758aa1104db4ce4664f6f5d7fcbceff6a92ac654c44378ab489490cc269ffeee6f7fa99c3e5b4c0804a05ae7eff1591e8c56d1</script>
  <div class="hbe hbe-content">
    <div class="hbe hbe-input hbe-input-default">
      <input class="hbe hbe-input-field hbe-input-field-default" type="password" id="hbePass">
      <label class="hbe hbe-input-label hbe-input-label-default" for="hbePass">
        <span class="hbe hbe-input-label-content hbe-input-label-content-default">Hey, password is required here.</span>
      </label>
    </div>
  </div>
</div>
<script data-pjax src="/lib/hbe.js"></script><link href="/css/hbe.style.css" rel="stylesheet" type="text/css">]]></content>
  </entry>
  <entry>
    <title>Oracle</title>
    <url>/2022/12/15/oracle/</url>
    <content><![CDATA[<h1 id="存储单元"><a href="#存储单元" class="headerlink" title="存储单元"></a>存储单元</h1><ul>
<li><strong>表空间（Table Space）</strong>是存储例如表、索引、序列等对象的逻辑存储器。每个 Table Space 至少具备一个物理的 Data File 来在操作系统层面真实地存储 Table Space 中的内容，Table Space 和 Data File 是一对多的关系。</li>
<li><strong>段（Segment）</strong>用于存储 Table Space 中的对象，是一种消耗物理存储空间的任何逻辑单元。一个 Table Space 可以有多个 Segment，但一个 Segment 只属于一个 Table Space，Table Space 和 Segment 是一对多的关系。Segment 和 Data File 没有直接关系，一个 Segment 可能存在于多个 Data File 中。</li>
<li><strong>扩展（Extent）</strong>是连续的磁盘存储块的逻辑集合。Segment 和 Extent 是一对多的关系，Data File 和 Extent 也是一对多的关系。</li>
<li><strong>数据块（Block）</strong>是 Oracle 服务器管理数据的最小逻辑单元。Extent 和 Oracle Block 是一对多的关系，Oracle Block 和 OS Block 是一对多的关系，Data File 和 OS Block 是一对多的关系。</li>
</ul>
<img src="存储单元.jpg" alt="存储单元" style="zoom:100%;" />

<h1 id="SQL-执行"><a href="#SQL-执行" class="headerlink" title="SQL 执行"></a>SQL 执行</h1><ul>
<li><strong>Syntax Check</strong>：确保 SQL 符合基本语法规则</li>
<li><strong>Semantic Check</strong>：确保 SQL 具备意义，比如涉及到的对象、表、列是存在的</li>
<li><strong>Shared Pool Check</strong>：判断 SQL 执行 Hard Parse 还是 Soft Parse（Soft Parse 会跳过 Optimization 和 Row Source Generation，直接 Execution），DDL 语句始终都会进行 Hard Parse</li>
<li><strong>Optimization</strong>：对于每个具备唯一哈希值的 DML都至少进行一次 Optimization，但 Oracle 从来不会优化 DDL（除非该 DDL 中存在需要优化的 DML 部分），目前 Oracle 采用的是基于代价的优化器（CBO），这种判断方式非常依赖于数据对象的统计分析信息</li>
<li><strong>Row Source Generation</strong>：从优化器接收最优执行计划，并生成可供数据库其余部分使用的迭代执行计划</li>
<li><strong>Execution</strong>：SQL 引擎执行 Row Source Generation 生成的树中的每个 Row Source（这个步骤是DML处理中唯一的强制步骤）</li>
</ul>
<table>
<thead>
<tr>
<th align="center"></th>
<th align="center"></th>
</tr>
</thead>
<tbody><tr>
<td align="center"><strong>Grammar Order</strong></td>
<td align="center"><strong>Execution Order</strong></td>
</tr>
<tr>
<td align="center">1) SELECT DISTINCT &lt;..&gt;</td>
<td align="center">1) FROM&lt;..&gt; ON&lt;..&gt; JOIN &lt;..&gt;</td>
</tr>
<tr>
<td align="center">2) FROM &lt;..&gt; JOIN &lt;..&gt; ON &lt;..&gt;</td>
<td align="center">2) WHERE &lt;..&gt;</td>
</tr>
<tr>
<td align="center">3) WHERE &lt;..&gt;</td>
<td align="center">3) GROUP BY &lt;..&gt;</td>
</tr>
<tr>
<td align="center">4) GROUP BY &lt;..&gt;</td>
<td align="center">4) HAVING &lt;..&gt;</td>
</tr>
<tr>
<td align="center">5) HAVING &lt;..&gt;</td>
<td align="center">5) SELECT DISTINCT &lt;..&gt;</td>
</tr>
<tr>
<td align="center">6) ORDER BY &lt;..&gt;</td>
<td align="center">6) ORDER BY &lt;..&gt;</td>
</tr>
</tbody></table>
<h1 id="执行计划"><a href="#执行计划" class="headerlink" title="执行计划"></a>执行计划</h1><p>优化器给出的执行计划是一种推荐的用于执行 SQL 的方法，从执行计划中可以得到数据库在执行 SQL 时所采用的访问和连接表的方式。</p>
<p>执行计划所列出的方式不一定是最高效的，通过观察执行计划中的内容可以判断当前 SQL 的是否能够高效地执行。</p>
<p>比如可以观察优化器所估计的每一步操作将处理多少行，以及估计的行数（即基数）与实际数量的比较情况</p>
<ul>
<li>如果基数估计是错误的，这意味着可以通过改写 SQL 来帮助优化器找到更优的执行计划</li>
<li>如果基数估计是准确的，但查询仍然太慢，则需要查看是否可以创建一些数据结构来更快地访问数据</li>
<li>如果表访问方式和表连接方式与期望的方式不同，则基数估计基本就是错误的</li>
<li>需要注意的是成本（Cost）是优化器用来比较同一 SQL 的不同执行计划的内部度量，不同 SQL 之间的 Cost 的比较是没有意义的，不应通过这种比较来对比 SQL 改写前后的性能优劣</li>
</ul>
<p>在遵循执行计划来执行 SQL 时，是根据中序遍历来执行计划中的所有操作的，即从执行计划的顶部开始，沿着树向下执行第一个叶子操作，然后沿着树返回到第一个带有未访问子节点的节点，重复这个过程直到执行了执行计划中的所有操作（UNION 操作是后序遍历，存在子查询时情况有变，详细见参考资料）。</p>
<h1 id="表访问方式"><a href="#表访问方式" class="headerlink" title="表访问方式"></a>表访问方式</h1><ul>
<li>TABLE ACCESS FULL（全表扫描）<ul>
<li>读取表中所有的行，并检查每一行是否满足 SQL 语句中的 WHERE 限制条件</li>
<li>除非真正需要返回的数据较多，不建议使用全表扫描来读取数据量太大的表</li>
</ul>
</li>
<li>TABLE ACCESS BY ROWID（通过 ROWID 的表存取）<ul>
<li>ROWID 是由 Oracle 自动加在表中每行最后的一列伪列，表中并不会物理存储 ROWID 的值，因为不能对该列的值进行增删改操作，但是可以进行查询</li>
<li>行的 ROWID 指出了该行所在的数据文件、数据块以及行在该块中的位置，因此通过 ROWID 来定位目标行是非常高效的，是 Oracle 中存取单行数据最快的方法</li>
<li>Oracle 要么从WHERE 条件要么从索引扫描来获取需要访问的行的 ROWID </li>
</ul>
</li>
<li>TABLE ACCESS BY INDEX SCAN（索引扫描）<ul>
<li>索引既存储每个索引的键值，也存储具有该键值的行的ROWID </li>
<li>索引扫描分两步，先扫描索引得到对应的 ROWID（内存读取，速度较快），再通过 ROWID 定位到具体的行读取数据</li>
<li>当只需要返回部分行的数据时，对于无范围操作符的唯一索引则使用索引唯一扫描，对于非唯一索引或者有范围操作符的唯一索引则使用索引范围扫描</li>
<li>当需要返回所有行的数据时，对于排序操作则使用索引全扫描，对于无排序操作则使用索引快速扫描</li>
</ul>
</li>
</ul>
<h1 id="表连接方式"><a href="#表连接方式" class="headerlink" title="表连接方式"></a>表连接方式</h1><p>在使用 JOIN 关键字来对两张表作连接，表（row source）之间的连接顺序对于查询效率有很大的影响。</p>
<p>根据连接顺序的不同，将作连接的两张表分别定义为驱动表和匹配表</p>
<ul>
<li>驱动表（Driving Table）<ul>
<li>驱动表指连接时首先存取的表，又称外层表</li>
<li>驱动表的全表数据集会作为循环基础数据，其中每一条数据都会作为过滤条件到被驱动表中查询数据，最后合并</li>
<li>如果驱动表返回比较多的数据行，则对所有的后续操作有负面影响</li>
<li>驱动表需要全表扫描，不走索引，所以建不建索引都无法优化性能</li>
<li>一般选择小表（应用 WHERE 限制条件后返回较少行数的表）作为驱动表</li>
</ul>
</li>
<li>匹配表（Probed Table）<ul>
<li>又称内层表</li>
<li>从驱动表获取一行具体数据后，会到内层表中寻找符合连接条件的行</li>
<li>可以通过将匹配表中的与驱动表连接的字段建立索引，从而优化性能</li>
<li>一般选择大表（应用 WHERE 限制条件后返回较多行数的表）作为匹配表</li>
</ul>
</li>
</ul>
<p>内连接时小表为驱动表，左外连接时左表为驱动表，右外连接时右表为驱动表。</p>
<p>表连接方式有以下几种</p>
<ul>
<li>SORT MERGE JOIN（排序 - 合并连接）<ul>
<li>一般用于两个表之间的连接条件为不等于条件的情况，例如&lt;、&lt;=、&gt;或&gt;=</li>
<li>在联合大数据集时，性能比 NESTED LOOPS 更好</li>
</ul>
</li>
<li>NESTED LOOPS（嵌套循环）<ul>
<li>一般用于联合小数据集且能高效访问匹配表的情况</li>
<li>可以看作是两个嵌套的 FOR 循环</li>
</ul>
</li>
<li>HASH JOIN（哈希连接）<ul>
<li>一般用于联合大数据集的情况</li>
<li>优化器选择两个表中较小的表来在内存中建立哈希表，接着扫描更大的表，并在 JOIN 的列上执行相同的哈希算法</li>
</ul>
</li>
<li>CARTESIAN PRODUCT（笛卡尔积）<ul>
<li>通常只只用于涉及的表很小，或者语句中一个或多个表没有到任何其他表的连接条件的情况</li>
<li>优化器将来自一个数据源的每一行与来自另一个数据源的每一行连接起来，创建两个集合的笛卡尔积</li>
<li>笛卡尔连接并不常见，因此如果它是由于任何其他原因而选择的，那么它可能是基数估计有问题的标志（严格地说，笛卡尔积不是一个连接）</li>
</ul>
</li>
</ul>
<h1 id="优化技巧"><a href="#优化技巧" class="headerlink" title="优化技巧"></a>优化技巧</h1><ul>
<li><p>建立数据结构</p>
<ul>
<li>当 SQL 很慢且无法通过改写 SQL 来提升性能时，就可以创建一些数据结构来更快地访问数据</li>
<li>比如创建索引、临时表、实体视图、约束、分区、甚至优化表的设计</li>
</ul>
</li>
<li><p>去掉冗余</p>
<ul>
<li>不要 SELECT 不需要的字段</li>
<li>不要 JOIN 不需要的表</li>
</ul>
</li>
<li><p>尽可能减少需要重复的操作/查询</p>
</li>
<li><p>EXISTS 和 IN</p>
<ul>
<li><p>两者之间并不一定是前者性能更好，和连接查询类似，这里也存在驱动表和匹配表的关系</p>
</li>
<li><p>应当根据表的大小来选择驱动表和匹配表，从而确定使用 EXISTS 还是 IN</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> A <span class="keyword">WHERE</span> id <span class="keyword">IN</span> (<span class="keyword">SELECT</span> id <span class="keyword">FROM</span> B); <span class="comment">-- B 是驱动表</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> A <span class="keyword">WHERE</span> <span class="keyword">EXISTS</span> (<span class="keyword">SELECT</span> <span class="number">1</span> <span class="keyword">FROM</span> B <span class="keyword">WHERE</span> B.id <span class="operator">=</span> A.id); <span class="comment">-- A 是驱动表</span></span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p>使用连接而不是子查询，因为它为优化器提供了更多的空间</p>
</li>
<li><p>添加逻辑上多余的过滤条件，这些条件可能仍然有助于搜索最佳执行计划，特别是对于外部连接。</p>
</li>
<li><p>避免数据类型的隐式转换，特别是在 WHERE 子句中</p>
</li>
<li><p>尽可能避免对条件中的索引列使用&lt;&gt;、NOT IN、NOT EXISTS 和 LIKE 等不带前导 ‘%’ 的比较操作符</p>
</li>
<li><p>不要对 WHERE 子句中的索引列应用函数</p>
</li>
<li><p>不要在聚合之前滥用 HAVING 过滤行</p>
</li>
<li><p>避免不必要的排序，包括当使用 UNION ALL 而不是 UNION 时</p>
</li>
<li><p>除非必须使用，否则避免使用DISTINCT</p>
</li>
</ul>
<p>TBC</p>
<h1 id="语法小抄"><a href="#语法小抄" class="headerlink" title="语法小抄"></a>语法小抄</h1><ul>
<li><p>不区分 <code>&quot;&quot;</code> 和 null</p>
</li>
<li><p>分页 <code>... OFFSET 0 ROWS FETCH NEXT 50 ROWS ONLY</code>（不是使用 <code>LIMIT</code>）</p>
</li>
<li><p>针对某一列进行去重（<code>DISTINCT</code>是对返回的所有列进行去重，此时返回的某一列仍旧存在重复列）</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> (</span><br><span class="line">    <span class="keyword">SELECT</span> </span><br><span class="line">        <span class="keyword">DISTINCT</span> column1,column2,</span><br><span class="line">        <span class="built_in">row_number</span>() <span class="keyword">OVER</span>(<span class="keyword">PARTITION</span> <span class="keyword">BY</span> column1 <span class="keyword">ORDER</span> <span class="keyword">BY</span> column2) <span class="keyword">AS</span> row_cnt </span><br><span class="line">    <span class="keyword">FROM</span> tableA</span><br><span class="line">    ...</span><br><span class="line">) <span class="keyword">WHERE</span> row_cnt <span class="operator">=</span> <span class="number">1</span></span><br></pre></td></tr></table></figure></li>
<li><p>排序时忽视大小写 <code>ORDER BY NLSSORT(column1, &#39;NLS_SORT=BINARY_CI&#39;)</code></p>
</li>
<li><p>定义一个 SQL 片断 <code>WITH AS</code></p>
</li>
<li><p>多行拼接为一行 <code>listagg(column, &#39;;&#39; on overflow truncate)</code></p>
</li>
<li><p>查看执行计划 <code>EXPLAIN PLAN FOR SQL; SELECT * FROM table(dbms_xplan.display);</code></p>
</li>
<li><p>查看当前 session 锁住的对象</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> c.owner, c.object_name, c.object_type, b.sid, b.serial#, b.status, b.osuser, b.machine </span><br><span class="line"><span class="keyword">FROM</span> v$locked_object a, v$session b, dba_objects c </span><br><span class="line"><span class="keyword">WHERE</span> b.sid <span class="operator">=</span> a.session_id <span class="keyword">AND</span> a.object_id <span class="operator">=</span> c.object_id <span class="keyword">ORDER</span> <span class="keyword">BY</span> object_name;</span><br></pre></td></tr></table></figure></li>
<li><p>kill 当前 session </p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">ALTER</span> <span class="keyword">SYSTEM</span> KILL SESSION <span class="string">&#x27;:sid, :serial#, @1&#x27;</span>;</span><br></pre></td></tr></table></figure></li>
</ul>
<h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><ul>
<li><a href="https://www.oracletutorial.com/oracle-administration/oracle-database-architecture">https://www.oracletutorial.com/oracle-administration/oracle-database-architecture</a></li>
<li><a href="https://docs.oracle.com/database/121/TGSQL/tgsql_sqlproc.htm#TGSQL175">https://docs.oracle.com/database/121/TGSQL/tgsql_sqlproc.htm#TGSQL175</a></li>
<li><a href="https://docs.oracle.com/database/121/TGSQL/tgsql_optcncpt.htm#TGSQL196">https://docs.oracle.com/database/121/TGSQL/tgsql_optcncpt.htm#TGSQL196</a></li>
<li><a href="https://docs.oracle.com/database/121/TGSQL/tgsql_interp.htm#TGSQL277">https://docs.oracle.com/database/121/TGSQL/tgsql_interp.htm#TGSQL277</a></li>
<li><a href="https://blogs.oracle.com/connect/post/how-to-read-an-execution-plan">https://blogs.oracle.com/connect/post/how-to-read-an-execution-plan</a></li>
<li><a href="https://blog.csdn.net/weixin_42156231/article/details/124920365">https://blog.csdn.net/weixin_42156231/article/details/124920365</a></li>
<li><a href="https://blog.csdn.net/weixin_42156231/article/details/124749986">https://blog.csdn.net/weixin_42156231/article/details/124749986</a></li>
<li><a href="https://www.oracle.com/docs/tech/database/technical-brief-explain-the-explain-plan-052011.pdf">https://www.oracle.com/docs/tech/database/technical-brief-explain-the-explain-plan-052011.pdf</a></li>
<li><a href="https://blog.csdn.net/weixin_44390164/article/details/119970753">https://blog.csdn.net/weixin_44390164/article/details/119970753</a></li>
<li><a href="https://oracle.readthedocs.io/en/latest/sql/hints/optimization.html">https://oracle.readthedocs.io/en/latest/sql/hints/optimization.html</a></li>
</ul>
]]></content>
  </entry>
  <entry>
    <title>Java Language</title>
    <url>/2022/05/08/java-language/</url>
    <content><![CDATA[<h1 id="1、面向对象"><a href="#1、面向对象" class="headerlink" title="1、面向对象"></a>1、面向对象</h1><p>Java 是一种面向对象的编程语言（C++ 既可以面向对象，也可以面向过程）。面向对象方式通过对象来提供对某个问题的描述，通过对象的属性和行为来提供对某个问题的解决，对象的属性可以包含其他对象，对象的行为可以包含对其他对象的调用。面向对象有五大基本原则：单一职责原则（一个类只做一件事）、开放封闭原则（对扩展开放、对修改封闭）、里氏替换原则（子类能够替换其父类）、依赖倒置原则（程序要依赖于抽象接口而不是具体的实现）、接口隔离原则（使用多个互相隔离的小接口而不是一个总的大接口）。</p>
<h2 id="1-1-对象的基本特征"><a href="#1-1-对象的基本特征" class="headerlink" title="1.1 对象的基本特征"></a>1.1 对象的基本特征</h2><p>对象具有的一些特征是状态、行为、标识和类型</p>
<ul>
<li>状态和行为分别意味着对象都可以拥有内部数据域（field）和方法（method），方法签名（signature）由方法名称和所有参数类型组成，不包括方法的返回类型</li>
<li>标识意味着每一个对象都可以唯一地与其他所有对象区分开来</li>
<li>类型则决定了这个对象可以具备什么样的状态和行为，对象的类型有类（包括枚举）、接口、数组这三种，通常被称为引用数据类型（与之相对的是基本数据类型）</li>
</ul>
<p>面向对象具有的三大特征是封装、继承和多态</p>
<ul>
<li><p><strong>封装</strong>：当开发一个东西供别人使用时，这个东西可以是一个方法、一个类、接口、甚至一个系统等，可以将这个东西封装起来，通过文档约定告知别人如何使用，那么别人在使用我开发的东西，或者我使用别人开发的东西时，可以不用去深究具体的实现细节，从而能够更加专注于自身开发工作，实现相对独立的开发、测试、优化、使用、理解和修改，降低代码的耦合性</p>
<table>
<thead>
<tr>
<th align="center"></th>
<th align="center"></th>
<th align="center"></th>
<th align="center"></th>
<th align="center"></th>
</tr>
</thead>
<tbody><tr>
<td align="center">访问权限控制符</td>
<td align="center">本类</td>
<td align="center">包内</td>
<td align="center">包外子类</td>
<td align="center">任何地方</td>
</tr>
<tr>
<td align="center">public</td>
<td align="center">√</td>
<td align="center">√</td>
<td align="center">√</td>
<td align="center">√</td>
</tr>
<tr>
<td align="center">protected</td>
<td align="center">√</td>
<td align="center">√</td>
<td align="center">√</td>
<td align="center">×</td>
</tr>
<tr>
<td align="center">default</td>
<td align="center">√</td>
<td align="center">√</td>
<td align="center">×</td>
<td align="center">×</td>
</tr>
<tr>
<td align="center">private</td>
<td align="center">√</td>
<td align="center">×</td>
<td align="center">×</td>
<td align="center">×</td>
</tr>
</tbody></table>
</li>
<li><p><strong>继承</strong>：当我们在继承某个类，获得了这个类的属性和方法时，可以在现有类的基础上，去继续拓展新的属性和方法，去进一步的开发更加细致更加个性化的功能，这可以增加代码的可重用性（类之间只能单继承，接口之间可以多继承），除了继承（is-a），组合（has-a）同样也能够增加代码的可重用性</p>
<p>继承：</p>
<ul>
<li>继承是一种白盒式的复用，父类的内部细节对于子类时可见的，如果父类的实现发生了改变，那么子类也将随之改变，这就导致了子类行为的不可预知性，且子类不能改变父类的接口，依赖于父类的实现，缺乏独立性</li>
<li>Java 的单继承结构保证所有对象都具备某些功能，可以执行某些基本操作，所有的对象都可以很容易地在堆上创建，参数传递得到了极大的简化，垃圾回收器的实现也变得容易得多</li>
<li>可重用性并不是并不是继承技术最重要的方面，其最重要的方面是用来表现新类和基类之间的关系，这种关系可以用“新类是现有类的一种类型”这句话来加以概括，从而实现向上转型，也就是说，继承应当仅仅用在必须使用的场合（需要进行向上转型的场合），这样会使得设计更加清晰</li>
</ul>
<p>组合</p>
<ul>
<li>组合是一种黑盒式的复用，组合对象之间各自的内部细节是不可见的，不破坏封装，具有较好的可扩展性，一般用于想在新类中使用现有类的功能而非它的接口的情形，更加简单灵活，在建立新类时，应该首先考虑组合</li>
<li>动态组合使得整体对象可以在运行期间动态不同类型的局部对象，整体类还可以对局部类进行包装，封装局部类的接口，提供新的接口，但是整体类不能直接自动获得局部类的接口功能，在创建整体类的对象时需要创建所有局部对象</li>
</ul>
</li>
<li><p><strong>多态</strong>：多态指同一个行为在不同情况下可以有不同的实现细节，但可以通过共通的方式进行调用，可以分为重载实现的多态和重写实现的多态，这可以增加代码的灵活性</p>
<p>重载：</p>
<ul>
<li>是在一个类中的多态性的体现；</li>
<li>在一个类中定义多个相同方法名但参数列表不同的方法就称为方法的重载，参数列表不同包括参数类型、个数或者顺序不同；</li>
<li>重载方法之间可以有不同的返回类型，不同的访问修饰符，抛出不同的异常，这些都没有硬性要求；</li>
<li>在编译期就能根据确定调用函数的参数来确定是调用哪一个重载方法，体现了编译多态性；</li>
</ul>
<p>重写：</p>
<ul>
<li>是在父类和子类之间的多态性的体现；</li>
<li>在子类中定义与父类方法签名一致的方法就称为方法的重写（<strong>方法签名就由方法名+参数列表构成</strong>）；</li>
<li>子类的重写的方法除了方法签名之外，方法的返回类型也必须和父类一致，方法访问修饰符的限制一定要大于父类方法的访问修饰（public&gt;protected&gt;default&gt;private），还不能抛出新的检查异常或者比被父类方法申明更加宽泛的检查型异常；</li>
<li>在运行期才能确定是调用父类的方法还是子类重写的方法，体现了运行多态性；</li>
<li>不要在构造器中调用可能被子类重写的方法，可能会使用还未被初始化的变量；</li>
</ul>
</li>
</ul>
<p>当试图开发或理解一个程序设计时，最好的方法之一就是将对象想象为“服务提供者”，程序本身向用户提供服务，它将通过调用其他对象的服务来实现这一目的，开发人员的目标就是去创建（或者是在现有代码库中寻找）能够提供理想服务来解决问题的一系列对象。</p>
<h2 id="1-2-创建、存储、销毁对象"><a href="#1-2-创建、存储、销毁对象" class="headerlink" title="1.2 创建、存储、销毁对象"></a>1.2 创建、存储、销毁对象</h2><p>创建类就是在描述这个类的对象的外观与行为，创建对象则通常用<code>new</code>操作符来创建（此时数据存储空间才被分配），而对于一些比较小的、简单的变量，不用<code>new</code>来创建，而是创建一个并非是引用的基本类型变量，这个变量直接存储“值”，Java 对所有的基本类型都有平台无关的标准的范围限制和字节长度（C++ 对所有的数字类型有标准的范围限制，但其字节长度是跟具体实现相关的，同一个类型在不同操作系统可能长度不一样），Java 基本类型如下</p>
<table>
<thead>
<tr>
<th align="center"></th>
<th align="center"></th>
<th align="center"></th>
<th align="center"></th>
<th align="center"></th>
<th align="center"></th>
<th align="center"></th>
<th align="center"></th>
<th align="center"></th>
</tr>
</thead>
<tbody><tr>
<td align="center">基本类型</td>
<td align="center">boolean</td>
<td align="center">char</td>
<td align="center">byte</td>
<td align="center">short</td>
<td align="center">int</td>
<td align="center">long</td>
<td align="center">float</td>
<td align="center">double</td>
</tr>
<tr>
<td align="center">大小</td>
<td align="center">-</td>
<td align="center">16 bits</td>
<td align="center">8 bits</td>
<td align="center">16 bits</td>
<td align="center">32 bits</td>
<td align="center">64 bits</td>
<td align="center">32 bits</td>
<td align="center">64 bits</td>
</tr>
<tr>
<td align="center">取值范围</td>
<td align="center"></td>
<td align="center">0~2^16-1</td>
<td align="center">-2^7~2^7 - 1</td>
<td align="center">-2^15~2^15 - 1</td>
<td align="center">-2^31~2^31 - 1</td>
<td align="center">-2^63~2^63 - 1</td>
<td align="center">-2^128~2^128</td>
<td align="center">-2^1024~2^1024</td>
</tr>
</tbody></table>
<p>注：</p>
<ul>
<li><p>单个<code>boolean</code>型长度为 32 bit，<code>boolean</code>数组中的每个<code>boolean</code>值的长度为 8 bit</p>
</li>
<li><p><code>boolean</code>型无法转换为其他基本类型，也无法进行加减等任何算术运算以及位运算，除<code>boolean</code>以外的任何一种基本类型都可以通过类型转换变为其他基本类型，但有可能丢失信息</p>
</li>
<li><p>浮点数由符号位、指数位以及尾数位组成，指数位决定范围，尾数位决定精度，<code>float</code>的符号位、指数位以及尾数位分别是 1 bit、8 bits、23 bits，<code>double</code>的符号位、指数位以及尾数位分别是 1 bit、11 bits、52 bits，浮点数并不能把表示范围中的所有的数都表示出来</p>
</li>
<li><p>有的小数无法用二进制精确表示（比如 0.1 的二进制形式是无限循环的），因此<code>float</code>和<code>double</code>都可能只是近似值而非精确值，存在精度丢失，所以在需要进行高精度运算时使用<code>BigDecimal</code>（比如金额运算）</p>
</li>
<li><p>由于<code>float</code>和<code>double</code>都是不精确的，所以不应使用<code>float</code>和<code>double</code>作为入参来<code>new</code>一个<code>BigDecimal</code>（只会得到更加不精确的数字），而是应该使用<code>String</code>作为入参</p>
</li>
<li><p><code>BigDecimal</code>内部使用一个无标度值和一个标度来表示一个数，<code>BigDecimal</code>的等值比较应使用忽略标度的<code>compareTo</code>而不是同时比较值和标度的<code>equals</code>（1.0 与 1.00 使用<code>equals</code>的返回结果为 <code>false</code>）</p>
</li>
</ul>
<p>从概念上讲，“初始化”和“创建”是彼此独立的，在 Java 中，“初始化”和“创建”捆绑在一起，由构造器来完成。编写构造器时有一条准则：用尽可能简单的方法使对象进入正常状态，构造器内唯一能够安全调用的那些方法是基类中的<code>final</code>方法（因为这些方法不能被子类重写），此外，构造器应当避免调用其他方法，尤其是可能被子类重写的方法，可能会使用还未被初始化的变量。</p>
<p>Java 中创建对象可以使用<code>new</code>关键字来调用构造器、使用反射机制来调用构造器、使用<code>clone</code>方法（并不调用构造器）、使用反序列化（基于反射和<code>Unsafe</code>类，并不调用构造器）、使用构造函数的方法句柄来间接调用构造器，从而创建对象，Java 鼓励使用构造函数和工厂方法来创建对象，以确保对象的正确初始化，并维护对象的不变性。</p>
<p>Java 通过编译错误来保证局部变量在使用前都能得到恰当的初始化，对于Java 类的成员变量（或数组的元素），不会通过编译错误来保证在使用前得到初始化，如果该成员变量（或元素）是基本类型，那么在未初始化时会被赋一个初值，如果是对象引用，那么在未初始化时会获得一个特殊值<code>null</code>。</p>
<p>静态初始化只有在必要时刻才会进行，只有在第一次访问静态数据的时候（或者首次创建静态数据所在的类的一个对象时）才会被初始化，且初始化动作只进行一次。</p>
<p>程序运行时，有五个不同的地方可以存储数据</p>
<ul>
<li>寄存器<ul>
<li>位于处理器的内部，数量及其有限，是最快的存储区</li>
<li>寄存器根据需求进行分配，无法在 Java 程序中直接控制（C 和 C++ 允许程序员向编译器建议寄存器的分配方式）</li>
</ul>
</li>
<li>堆栈<ul>
<li>位于 RAM 区，通过堆栈指针可以从处理器那里获得直接支持，堆栈指针向下移动则分配新的内存，向上移动则释放那些内存</li>
<li>是一种快速有效额分配存储方法，仅次于寄存器，Java 基本类型和对象引用就存储在堆栈中，但是 Java 对象并不存储于其中</li>
<li>Java 编译器系统必须知道存储在堆栈内所有项的确切的生命周期，以便上下移动指针，这一约束限制了程序的灵活性</li>
</ul>
</li>
<li>堆<ul>
<li>位于 RAM 区，是一种通用的内存池，用于存放所有的 Java 对象</li>
<li>编译器并不需要知道堆内存储的数据的生命周期，因此堆内的分配存储具有很大的灵活性，与此同时，用堆进行存储分配和清理可能比用堆栈需要更多的时间</li>
</ul>
</li>
<li>常量存储<ul>
<li>常量值通常直接存放于程序代码内部</li>
<li>在嵌入式系统中，常量本身会和其他部分分隔离开，此时可以存在在 ROM 中</li>
</ul>
</li>
<li>非 RAM 存储<ul>
<li>完全存活于程序之外的数据（例如流对象、持久化对象）通常存放与磁盘上，或者被发送给另一台机器</li>
<li>这类数据即使在程序终止时，仍然可以保持自己的状态，因此将这类数据转化成可以存放在其他媒介上的事物，在需要时，可恢复成常规的、基于 RAM 的对象</li>
<li>Java 提供了对轻量级持久化的支持，而诸如 JDBC 和 Hibernate 这样的机制提供了更加复杂的对在数据库中存储和读取对象信息的支持</li>
</ul>
</li>
</ul>
<p>Java 基本类型和对象引用的作用域由花括号的位置决定，但<code>new</code>创建出的 Java 对象可以存活于作用域之外，Java 对象不具备和 Java 基本类型一样的生命周期，需要通过垃圾回收器来监视用<code>new</code>创建的所有 Java 对象，辨别那些不会再被引用的对象，并释放这些对象的内存空间。</p>
<p>垃圾回收器只知道释放那些经由<code>new</code>分配的内存，而不知道如何释放对象并非使用<code>new</code>而获得的特殊内存区域，那么为了应对这种情况，Java 允许在类中定义一个<code>finalize</code>方法，<code>finalize</code>会在该对象被垃圾回收时被调用，从而在该对象被垃圾回收时附加一些释放内存的回收工作（回收该对象所含有的其他并非使用<code>new</code>创建的对象），JVM 并不鼓励定义和使用<code>finalize</code>，所有<code>finalize</code>能做的工作，都可以使用<code>try-finally</code>或者其他方式做的更好更及时。</p>
<p>一旦涉及到垃圾回收，能够信赖的事就不会很多了，不是所有的 Java 对象都一定会被垃圾回收，Java 对象可能不被垃圾回收，即使被回收，也可能以任何回收器想要的顺序来回收对象，且垃圾回收只与释放内存有关，不能依赖垃圾回收去做任何除了释放内存之外的事情，垃圾回收并不等于“析构”。</p>
<p><code>finalize</code>并不是析构函数，并且绝对不能在程序中显式调用<code>finalize</code>，如果需要进行除释放存储空间之外的清理工作（比如已经打开的文件或网络连接需要关闭），就得在程序中明确调用某个自定义的恰当的 Java 类的清理方法，这个清理方法就等同于析构函数（Java 本身并未提供析构函数），该方法必须确保得到执行，派生类必须重写基类的该方法，并在重写方法的最后调用基类的该方法。</p>
<h2 id="1-3-接口、抽象类、内部类"><a href="#1-3-接口、抽象类、内部类" class="headerlink" title="1.3 接口、抽象类、内部类"></a>1.3 接口、抽象类、内部类</h2><p>接口，抽象类和内部类提供了一种将接口与实现分离的更加结构化的方法。</p>
<ul>
<li><p>接口</p>
<ul>
<li><p>接口被用来建立类与类之间的协议，只要一个方法操作的是接口，那么就可以使用任何实现了该接口的类，提升代码复用性</p>
</li>
<li><p>接口中的域隐式地是<code>public</code>，<code>static</code>和<code>final</code>的，接口中的方法隐式地是<code>public</code>，接口的实现类所实现的接口方法必须被显式定义为<code>public</code></p>
</li>
<li><p>接口是一种重要的工具，但是容易被滥用（比如类的构造器几乎在任何时候，都可以替代为一个接口和一个工厂）</p>
</li>
<li><p>任何抽象性都应该是应真正的需求而产生的，恰当的原则应当是优先选择类而不是接口，当接口的必需性变得非常明确时再去重构为接口，而不是一开始就到处添加额外级别的间接性，带来额外的复杂性</p>
</li>
</ul>
</li>
<li><p>抽象类</p>
<ul>
<li><p>抽象类是普通类与接口之间的中庸，是为复用而设计的类，创建抽象类是希望通过抽象类中的通用接口操纵一系列类</p>
</li>
<li><p>如果接口的多个实现类中有相同的可复用的代码，则在接口和实现类中间加一层抽象类（接口的骨架类），将可复用的代码抽出到抽象类中，骨架类的扩展类则实现接口方法的定制化实现（这就是模板方法模式）</p>
</li>
</ul>
</li>
<li><p>内部类</p>
<ul>
<li><p>将一个类的定义放在另一个类的定义内部就是内部类（但内部类和组合是完全不同的概念）</p>
</li>
<li><p>内部类不仅是一种代码隐藏机制，内部类还拥有其外围类的所有元素的访问权，也就是说内部类提供了某种进入外围类的窗口</p>
</li>
<li><p>创建内部类对象的时刻并不依赖于外围类对象的创建，但对于普通（非静态）的内部类来说，要通过外部类对象来创建内部类对象，即必须使用外部类的对象来创建内部类对象，在拥有外部类对象之前不可能创建内部类对象</p>
</li>
<li><p>如果不需要内部类对象与其外围类对象之间的联系，那么就可以将内部类声明为<code>static</code>，这通常称为嵌套类</p>
</li>
<li><p>创建嵌套类对象不需要对外部类对象的引用，嵌套类也不像普通的内部类对象那样保存外围类对象的引用，因此嵌套类无法访问非静态的外围类对象，但嵌套类可以直接在类方法中创建并操作外围类对象</p>
</li>
<li><p>在接口中定义嵌套类可以使得该嵌套类代码被接口的所有不同实现所共用，在类中定义嵌套类，并在嵌套类中定义用于测试的<code>main()</code>方法可以很方便的测试这个外部类</p>
</li>
<li><p>无论外围类是否已经继承了某个实现，内部类可以独立地继承自一个实现，因此，可以通过定义多个内部类来继承多个非接口类型，并向外围类提供实现，这某种程度上帮助外围类实现了多继承结构</p>
</li>
<li><p>内部类不仅包含外围类对象的信息，还自动拥有一个指向此外围类对象的引用，在此作用域内，内部类有权操作外围类所有的成员，包括<code>private</code>成员，因此内部类是面向对象的闭包</p>
</li>
<li><p>继承外围类时，并不意味着派生类的同名内部类隐式继承了外围类的内部类，即派生类的同名内部类和基类的内部类是完全独立的两个实体，各自在自己的命名空间里，但也可以显式的声明派生类的内部类继承了基类的内部类</p>
</li>
</ul>
</li>
</ul>
<h1 id="2、容器和泛型"><a href="#2、容器和泛型" class="headerlink" title="2、容器和泛型"></a>2、容器和泛型</h1><p>通常程序总是根据运行时才知道的某些条件去创建新对象，在此之前，不会知道所需对象的数量，甚至不知道确切的类型，除了编译器所支持的数组类型（一旦生成，其容量就不能改变），Java 实用类库还提供了一套容器类来解决这个问题。</p>
<h2 id="2-1-Collection-序列"><a href="#2-1-Collection-序列" class="headerlink" title="2.1 Collection 序列"></a>2.1 Collection 序列</h2><p><code>Collection</code>是一个独立元素的序列接口，<code>Collections</code>是一个工具类，包含有各种关于<code>Collection</code>操作的重载方法。</p>
<img src="Collection.png" alt="Collection" style="zoom:100%;" />

<ul>
<li><p><code>Iterator</code></p>
<ul>
<li><p><code>Collection</code>扩展了<code>Iterable</code>，<code>Iterable</code>代表其实现是可以遍迭代的，所有的<code>Collection</code>都可以通过<code>iterator</code>方法来获取迭代器<code>Iterator</code>，也可以用 foreach 语法遍历</p>
</li>
<li><p><code>Iterator</code>代表的是迭代的方式，其工作是遍历并选择序列中的对象，客户端程序员不必知道或关心序列底层的结构，统一了对序列的访问方式</p>
</li>
<li><p><code>Iterator</code>工作在一个独立的线程中，并且拥有一个互斥锁，<code>Iterator</code>被创建之后会建立一个指向原来对象的单链索引表，当原来的对象数量发生变化时，这个索引表的内容不会同步改变，按照 fail-fast 原则<code>Iterator</code>会立即抛出<code>CocurrentModificationException</code>，因此，<code>Iterator</code>在工作时不允许改变被迭代的对象序列，但可以使用<code>Iterator</code>本身的<code>remove</code>来删除对象，该方法会在删除当前迭代对象的同时维护索引的一致性</p>
</li>
<li><p><code>Iterator</code>通常被称为轻量级对象，其创建代价很小</p>
</li>
</ul>
</li>
<li><p><code>Queue</code></p>
<ul>
<li><p><code>Queue</code>只允许在一端插入对象，并从另外一端移出对象</p>
</li>
<li><p><code>Queue</code>常被当做一种可靠的将对象从程序的某个区域传输到另一个区域的途径</p>
</li>
<li><p><code>Deque</code>是双向队列，允许在两端插入和移出对象</p>
</li>
<li><p><code>PriorityQueue</code>是优先级队列（堆），始终移出优先级最高的元素对象，并将插入的对象按照优先级排序</p>
</li>
<li><p><code>LinkedList</code>和<code>PriorityQueue</code>之间的差异在于排序行为而不是性能</p>
</li>
</ul>
</li>
<li><p><code>List</code></p>
<ul>
<li><p><code>List</code>按照插入的顺序保存元素，确定一个元素是否属于<code>List</code>，发现某个元素的索引，以及移除元素操作都会用到<code>equals</code>方法，因此<code>List</code>的行为根据<code>equals</code>的行为而有所变化</p>
</li>
<li><p><code>ArrayList</code>和<code>LinkedList</code>都是<code>List</code>类型，两者的不同之处在于底层结构和执行某些类型的操作性能，以及<code>LinkedList</code>还实现了<code>Deque</code>，具备了<code>List</code>中未包含的额外方法，比如需要栈的行为时，应当使用<code>LinkedList</code></p>
</li>
<li><p><code>ArrayList</code>是一个可改变大小的数组，<code>LinkedList</code>是一个双向链表，在<code>List</code>中间插入和删除，对于<code>LinkedList</code>来说都是廉价操作，但对于<code>ArrayList</code>来说是昂贵的操作，<code>ArrayList</code>更适用于根据下标来随机访问元素，而<code>LinkedList</code>在随机访问时相对较慢</p>
</li>
<li><p><code>ArrayList</code>的<code>subList</code>方法返回的是用<code>SubList</code>类型（<code>ArrayList</code>的内部类）表示的原<code>List</code>的视图，对视图的所有操作其实依旧是在操作原列表，<code>SubList</code>与<code>ArrayList</code>之间没有继承关系，不能强转</p>
</li>
<li><p>为了避免在数组存在大量空位的情况下序列化大量 null 元素，<code>ArrayList</code>的底层的<code>Object</code>数组被声明成了<code>transient</code>，在默认的序列化机制中并没有序列化数组数据，而是自定义了<code>writeObject</code>和<code>readObject</code>方法来实现序列化操作</p>
</li>
<li><p><code>Vector</code>是线程安全的，读写都加了<code>synchronized</code>锁，多线程并发时无法同时读和写，每次扩容时增加一倍，在单线程环境下<code>ArrayList</code>代替了<code>Vector</code>，<code>ArrayList</code>不是线程安全的，每次扩容时增加 50%，而并发环境下则更推荐使用<code>CopyOnWriteArrayList</code>（读写分离，可以同时读和写）</p>
</li>
</ul>
</li>
<li><p><code>Set</code></p>
<ul>
<li><p><code>Set</code>不能有重复元素，一般用于测试归属性，因此查找就成为了<code>Set</code>中最重要的操作</p>
</li>
<li><p>不同于<code>Queue</code>和<code>List</code>，<code>Set</code>并未在<code>Collection</code>的基础上添加新的接口（<code>TreeSet</code>除外），具有和<code>Collection</code>完全一样的接口，没有任何额外的功能，区别只在于行为不同</p>
</li>
<li><p><code>HashSet</code>、<code>TreeSet</code>和<code>LinkedHashSet</code>都是<code>Set</code>类型，但不同的<code>Set</code>实现存储元素的方式是不同的</p>
</li>
<li><p><code>HashSet</code>是用的是相当复杂的方式（散列函数）来存储元素的，同时也是最快的获取元素方式，是默认的选择</p>
</li>
<li><p><code>Set</code>存储的顺序一般并无实际意义，但如果存储顺序很重要，那么可以使用<code>TreeSet</code>或者<code>LinkedHashSet</code></p>
</li>
<li><p><code>TreeSet</code>将元素存储在红黑树数据结构中（元素必须实现<code>Comparable</code>接口），按照比较结果的升序保存对象</p>
</li>
<li><p><code>LinkedHashSet</code>因为查询速度的原因也使用了散列，但是还是使用了双向链表来维护元素的插入顺序，按照被添加的顺序保存对象</p>
</li>
<li><p>在迭代访问时维护了顺序的<code>TreeSet</code>和<code>LinkedHashSet</code>反而比<code>HashSet</code>更快，对于插入操作，<code>LinkedHashSet</code>的代价比<code>HashSet</code>更高，这是由维护双向链表所带来额外开销造成的</p>
</li>
<li><p><code>BitSet</code>是位集合，底层数据结构是由一个<code>long</code>型数组所表示的位数组，如果第 n 位为 1，则表明数字 n 在该数组中（只使用一个比特位就完成了数字 n 的存储），一般只用于数字的存储和去重，不适合存储一些差值比较大的数（高位和低位之间的比特位都浪费了），<code>BitSet</code>只是名字中有 Set，但其实既没有实现<code>Collection</code>接口，也没有实现<code>Iterable</code>接口</p>
</li>
</ul>
</li>
</ul>
<h2 id="2-2-Map-映射"><a href="#2-2-Map-映射" class="headerlink" title="2.2 Map 映射"></a>2.2 Map 映射</h2><p><code>Map</code>是一组成对的“键值对”对象，将键对象和值对象关联在一起。<code>Map</code>可以使用<code>entrySet</code>和<code>values</code>方法产生<code>Collection</code>。<code>Map</code>的插入操作会随着<code>Map</code>尺寸的变大而明显变慢，查找的代价通常比插入要小得多。</p>
<img src="Map.png" alt="Map" style="zoom:40%;" />

<ul>
<li><p><code>Hashtable</code></p>
<ul>
<li><p><code>Hashtable</code>是线程安全的，读写都加了<code>synchronized</code>锁，多线程并发时无法同时读和写，锁粒度太大</p>
</li>
<li><p><code>Hashtable</code>的默认初始容量为 11，默认的加载因子为 0.75，即当元素个数超过容量的 75% 时，会进行扩容，容量会扩大为原来的两倍加 1，并将原来的元素重新分配到新的桶中</p>
</li>
</ul>
</li>
<li><p><code>HashMap</code></p>
<ul>
<li><p><code>HashMap</code>不是线程安全的，单线程环境下<code>HashMap</code>代替了<code>Hashtable</code>，而并发环境下则更推荐使用<code>ConcurrentHashMap</code>（可以同时读和写）</p>
</li>
<li><p><code>HashMap</code>的默认初始容量为 16，默认的加载因子为 <a href="https://www.yuque.com/hollis666/niq4hm/qq99gipzlvhzcuer">0.75</a>，扩容时容量会扩大为原来的两倍，并将原来的元素重新分配到新的桶中</p>
</li>
<li><p><code>HashMap</code>的键和值都允许为 null，可以通过<code>containsKey</code>方法来区分到底是不含有某个键还是某个键映射的值是 null</p>
</li>
<li><p>与<code>HashSet</code>一样，<code>HashMap</code>也提供了最快的查找技术，也没有按照任何明显的顺序来保存其元素，是默认的选择</p>
</li>
<li><p><code>HashMap</code>的底层是哈希数组（数组是效率最高的存储和随机访问对象引用序列的方式），哈希的价值在于速度，使得查询得以快速进行，数组中每一个存放元素的位置可以看做一个桶，key 的哈希值就是其对应的桶在数组中的下标</p>
</li>
<li><p><code>HashMap</code>通过<code>(key.hashCode ^ (key.hashCode &gt;&gt; 16)) &amp; (table.length - 1)</code>来定位 key 应当位于哪个桶</p>
<ul>
<li><p>由于<code>X % 2^n = X &amp; (2^n - 1)</code>，<code>&amp;</code>是基于内存的二进制直接运算，比转换成十进制的取模运算快得多，因此使用位运算代替取模运算，这也是<code>HashMap</code>的容量一定要是 2^n 的原因</p>
</li>
<li><p>将<code>key.hashCode</code>的高 16 和低 16 进行异或而不是直接使用<code>key.hashCode</code>是为了进行扰动计算，将高位和低位的特征结合起来，尽量令任何一位的变化都能对最终的结果产生影响，降低哈希冲突的概率</p>
</li>
<li><p>在自定义生成散列码时，应当更关注生成速度而非唯一性，且必须基于对象的内容而非地址来生成尽可能均匀分布的散列码（<code>int</code>型），由于<code>enum</code>定义了固定数量的实例，所以<code>EnumMap</code>和<code>EnumSet</code>实现了完美的散列函数</p>
</li>
</ul>
</li>
<li><p>为了解决数组容量固定的问题，不同的键可以产生相同的下标，即可能有<a href="https://www.yuque.com/hollis666/niq4hm/pogt662wy87z24dr">冲突</a>，因此每个桶中存放的元素是<code>Entry</code>类型（<code>Map</code>的内部接口）的单个键值对/链表/包含双向链表的<a href="https://www.yuque.com/hollis666/niq4hm/zx609g">红黑树</a>，当散列函数接近完美时，每个桶中存放的就是单个键值对或比较短的链表，当链表长度达到 8 时进化为红黑树，当树节点个数小于 6 时再退化为链表</p>
</li>
<li><p>进化后的树结构选择红黑树是因为红黑树是一颗平衡树，不会在极端情况下自动退化为链表，但又不会像 AVL 树那样严格要求绝对平衡进而导致在删除和插入节点时过于频繁地左旋和右旋，因此红黑树是一个比较合适的选择，红黑树包含双向链表是为了方便退化为链表</p>
</li>
<li><p>当使用自定义类作为<code>HashMap</code>的键时，一定要同时重载<code>hashCode()</code>和<code>equals()</code>方法，但不要必须实现<code>Comparable</code>接口，<code>hashCode()</code>用于定位 key 应当位于哪个桶（这一步的定位很快），<code>equals()</code>用于定位 key 位于桶中链表/红黑树的哪个节点（这一步的定位可能慢一些），如果实现了<code>Comparable</code>接口，则红黑树使用该<code>Comparable</code>接口进行比较，如果没有实现，则使用一个默认的仲裁比较方法</p>
</li>
</ul>
</li>
<li><p><code>ConcurrentHashMap</code></p>
<ul>
<li><p><code>ConcurrentHashMap</code>的默认初始容量为 16，默认的加载因子为 0.75，扩容时容量会扩大为原来的两倍，会使用分段锁和锁分离将锁粒度缩小为单个桶</p>
</li>
<li><p><code>ConcurrentHashMap</code>和<code>Hashtable</code>中的键和值都不允许为 null，这是为了避免二义性（不含有某个键还是某个键映射的值是 null），这种二义性在并发情况下无法通过<code>containsKey</code>方法进行区分</p>
</li>
<li><p><code>ConcurrentHashMap</code>在初始化时，首先判断是否有多线程在操作（通过记录当前操作线程数的<code>sizeCtl</code>变量判断），若没有其他线程则通过 CAS 修改<code>sizeCtl</code>变量后进行正常初始化，若存在多线程则通过<code>Thread.yield</code>让出 CPU 时间片，等待下一次唤醒</p>
</li>
<li><p><code>ConcurrentHashMap</code>在添加元素时，如果这个 key 所在的桶为空，则使用 CAS 操作来添加新节点，如果桶不为空，则使用<code>synchronized</code>锁住这个桶节点（而不是锁住整个哈希表）再将新节点插入链表或红黑树中</p>
</li>
<li><p><code>ConcurrentHashMap</code>在扩容时，并没有一味地通过 CAS 或锁去限制多线程，而是通过 CPU 核数为每个线程划分桶迁移任务，即利用多线程来加速扩容</p>
</li>
<li><p><code>ConcurrentHashMap</code>在遍历时，提供一种弱一致性迭代器，该迭代器可以获取到迭代器创建之后被添加到<code>ConcurrentHashMap</code>中的元素，但也可能会获取到迭代器创建之后从<code>ConcurrentHashMap</code>中删除的元素</p>
</li>
</ul>
</li>
<li><p><code>LinkedHashMap</code></p>
<ul>
<li><p><code>LinkedHashMap</code>按照插入顺序或者是最少使用的顺序保存键，顺序规则可在构造器中设置</p>
</li>
<li><p><code>LinkedHashMap</code>也通过散列来提升查询速度，只比<code>HashMap</code>慢一点，但在迭代访问时反而比<code>HashMap</code>更快，这是因为它使用链表维护内部次序</p>
</li>
</ul>
</li>
<li><p><code>TreeMap</code></p>
<ul>
<li><p><code>TreeMap</code>具备<code>Map</code>中未包含的额外方法，是唯一带有<code>subMap()</code>方法的<code>Map</code>，可以返回一个子树</p>
</li>
<li><p><code>TreeMap</code>基于红黑树实现，键元素必须实现<code>Comparable</code>接口，按照比较结果的升序保存键，因此查询速度有所下降</p>
</li>
</ul>
</li>
</ul>
<h2 id="2-3-容器的使用"><a href="#2-3-容器的使用" class="headerlink" title="2.3 容器的使用"></a>2.3 容器的使用</h2><p>数组与容器的区别有三方面：效率、类型和能力</p>
<ul>
<li><p>效率：由于数组就是一个简单的线性序列，是 Java 中效率最高的存储和随机访问对象引用序列的方式（<code>ArrayList</code>的效率比数组低很多），为这种速度所付出的代价是数组对象的大小被固定，并且在其生命周期内不可改变，数组强调的是性能而非灵活性</p>
</li>
<li><p>类型：数组和泛型不能很好地结合，擦除会移除参数化类型信息，而数组必须知道它们所持有的确切类型来强制保证类型安全，因此 Java 不能实例化具有参数化类型的数组（但可以声明一个参数化类型的数组引用），而泛型可以指定容器要持有什么类型的对象，可以在编译期（而非运行期）防止将错误类型的对象放置到容器中，泛型容器几乎总是较泛型数组更好的选择</p>
</li>
<li><p>能力：容器即存放要使用的对象的地方，比数组更加灵活，具备更多不同的功能，Java 容器类是最具重用性的类库之一，当需要再数组上执行更加复杂的操作的，需要评估到底是使用数组还是更加灵活的容器，只有在已证明性能存在问题，并且切换到数组对性能提高有所帮助时，才应该将程序由容器重构为使用数组</p>
</li>
</ul>
<p>快速失效（fail-fast）是一种理念，在系统设计中，fail-fast 系统是一种可以立即报告任何可能表明故障的情况的系统，一旦发生故障，直接停止正常操作并以异常的方式上报故障，而不是试图继续可能存在问题的过程。在 Java 容器中有用到 fail-fast 原则进行设计，如果存在多个线程同时修改同一个容器的内容或者是在迭代过程中增加或移除元素，就会触发 fail-fast，抛出<code>CocurrentModificationException</code>。如果需要在遍历时修改集合，可以使用普通的<code>for</code>循环，或者使用迭代器本身的<code>remove</code>，或者使用<code>stream</code>的<code>filter</code>方法。fail-safe 则是为线程安全的并发集合准备的，避免了多线程并发以及迭代过程中增加或移除元素时触发 fail-fast 导致不断抛出异常，但在并发及迭代期间并不保证数据的强一致性，详细参见 <a href="../../../../2022/05/08/java-concurrency/">Java Concurrency</a> 的 5.3.1 小节。除了直接使用 JUC 包，还可以通过给非并发容器加锁、使用<code>ThreadLocal</code>将容器放到单个线程内访问、使用<code>Collections.synchronizedXXX</code>方法获取线程安全的容器、使用不可变的容器类等方式来保证容器的线程安全。</p>
<p>数组和容器所存储的元素集合都可以生成<code>Stream</code>，<code>Stream</code>不是一种数据结构，只是某种数据源的一个视图，<code>Stream</code>的思想是将要处理的元素集合看作一种流，可以对流进行筛选、排序、聚合等处理，对<code>Stream</code>的任何处理都不会修改其背后的数据源，而是会产生一个新的<code>Stream</code>/新的集合/其他结果。<code>Stream</code>的中间操作（<code>filter</code>, <code>map</code>, <code>limit</code>, <code>sorted</code>, <code>distinct</code>）的结果是<code>Stream</code>，<code>Stream</code>最终操作（<code>forEach</code>, <code>count</code>, <code>collect</code>）就是在消费<code>Stream</code>，<code>Stream</code>只能被消费一次，消费之后不能再次使用流，也不能再使用任何中间操作。对于有序的<code>stream</code>，并发可能会降低性能，此时应该比较使用并发，如果无法避免使用并发，可在使用前通过<code>unorder</code>将该<code>Stream</code>转为无序的。</p>
<h2 id="2-4-类型信息和泛化"><a href="#2-4-类型信息和泛化" class="headerlink" title="2.4 类型信息和泛化"></a>2.4 类型信息和泛化</h2><p>运行时类型信息可以在程序运行时发现和使用类型信息，类型信息是由称为<code>Class</code>对象的特殊对象完成的，它包含了与类有关的信息，每一个 Java 类都有一个<code>Class</code>对象。Java 有两种方式可以在运行时识别类型信息</p>
<ul>
<li><p>一种是传统的 RTTI，它假定在编译时就已经知道了所有的类型（Java 的容器和泛型系统会确保这一点），编译器在编译时打开和检查<code>.class</code>文件</p>
</li>
<li><p>另一种是反射机制（指程序在运行时能够获取类的类型信息），对于那些<code>.class</code>文件在编译时不可获取的匿名对象来说，反射在运行时打开和检查<code>.class</code>文件，从而确定那些匿名对象类型，<code>Class</code>类和<code>java.lang.reflect</code>库一起对反射的概念进行了支持</p>
</li>
</ul>
<p>Java 类都是在第一次被使用时（创建第一个对类的静态成员的引用或者使用<code>new</code>操作符创建类的新对象），由类加载器执行以下这三个步骤来实现为使用该 Java 类而做的准备工作，在第一个步骤中会将 Java 类的<code>Class</code>对象动态加载到 JVM 中的，一旦其<code>Class</code>对象被载入内存，它就被用来创建这个类的所有对象，Java 使用<code>Class</code>对象来执行其 RTTI。</p>
<ul>
<li><p>加载：查找字节码，并从这些字节码中创建一个<code>Class</code>对象，由类加载器执行</p>
</li>
<li><p>链接：验证类中的字节码，解析这个类创建的对其他类的所有引用</p>
</li>
<li><p>初始化：如果该类具有超类，则对其初始化，执行静态初始化器和静态初始化</p>
</li>
</ul>
<p>无论何时，只要想在运行时使用类型信息，就必须首先通过反射机制获得对恰当的<code>Class</code>对象的引用，获得<code>Class</code>对象的引用有以下方式，第三种方式是最简单、安全、高效的，因为它在编译时就会受到检查，不需要置于<code>try</code>语句块中，这种方式不仅可以应用于普通的类，也可以应用于接口、数组以及基本数据类型。第一、二种方式会完整执行加载、链接和初始化这三个步骤，但第三种方式仅仅只是获得<code>Class</code>引用时，不会进行初始化。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">Class</span> <span class="variable">c</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    c = Class.forName(<span class="string">&quot;User&quot;</span>);</span><br><span class="line">&#125; <span class="keyword">catch</span> (ClassNotFoundException e) &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(e);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">User</span> <span class="variable">user</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">User</span>();</span><br><span class="line">c = user.getClass();</span><br><span class="line"></span><br><span class="line">c = User.class;</span><br></pre></td></tr></table></figure>

<p>反射破坏了封装性，降低了代码可读性和可维护性，此外，由于反射涉及动态解析，因此不能执行 JVM 的 JIT 优化，在通过反射来调用对象的方法时参数需要从方法数组中遍历查找，做很多额外检查，反复在<code>Object</code>类型和真正类型之间包装盒拆包，这些动作不仅消耗时间，还会产生很多需要垃圾回收的对象，因此反射会导致性能下降，在业务代码中应该尽量避免使用反射。</p>
<p>泛化的类型信息<code>Class&lt;?&gt;</code>（<code>?</code>是无限制通配符，表示任何事物）等价于普通的类型信息<code>Class</code>，但由于<code>Class&lt;?&gt;</code>可以放松声明变量时的限制，表示明确选择了一个非具体的类引用（并非是碰巧或者由于疏忽）。范围类型信息<code>Class&lt;? extends XXX&gt;</code>被限定为某种类型，或该类型的任何子类型的<code>Class</code>引用，从而提供编译期类型检查，而普通的类型信息<code>Class</code>直到运行时才能发现使用错误，就不如编译期检查方便。因此，泛化的类型信息优于普通的类型信息。</p>
<p>通过 RTTI 或者反射在 Java 程序运行时识别类型信息后，就可以使用类型信息进行类型转换时，需要注意的是任何向下的类型转换前都需要先做类型检查，除了通过查询<code>Class</code>对象获取运行时类型来进行类型检查外（明确具体类型的检查，比如派生类和基类是不同的类型），还可以使用<code>instanceof</code>关键字进行类型检查（某个范围的类型检查，比如派生类也是基类这个类型）。</p>
<p>面向对象的目的是在凡是可以使用多态的地方都使用多态机制，只在必须的时候使用 RTTI 和反射。</p>
<h2 id="2-5-泛型及其局限"><a href="#2-5-泛型及其局限" class="headerlink" title="2.5 泛型及其局限"></a>2.5 泛型及其局限</h2><p>多态是泛化机制的一种（将方法的参数类型设置为基类，该方法则可以接收该基类的任何派生类作为参数），但是泛化机制希望达到的目的是编写更通用的代码，需要通过各种途径来放松对代码将要作用的类型的限制，编写能够尽可能广泛地应用的代码，使得代码能够应用于“某种不具体的类型”，而不是一个具体的接口或者类，同时不丢失编译期的静态类型检查的好处。与其使用<code>Object</code>，不如暂时不指定类型，而是使用类型参数，然后在使用这个类时再用实际的类型替换此类型参数。</p>
<p>泛型（适用于许多许多的类型）实现了参数化类型的概念，可以用于类，也可以仅仅用于类方法，即是否拥有泛型方法与其所在的类是否是泛型没有关系，在使用参数化类型时，编译器会负责转型操作，并且保证类型正确。容器是促成泛型出现的原因之一，泛型用于指定容器要持有什么类型的对象。</p>
<p>类型化参数和它们在有用的泛型代码中的应用，通常比简单的（多态）类替换要更复杂，因此对于能使用类替换的情况就不必使用泛型，只有希望代码使用的类型参数比某个具体类型更加“泛化”（代码能够跨越多个类工作）时，使用泛型才有所帮助。比如使用泛型元组（tuple）可以一次性返回多个对象（<code>return</code>语句只允许返回单个对象），并能在编译期即确保类型安全。元组是一个容器对象，可以具有任意长度，元组中的对象可以是任意不同的类型。元组将一组对象直接打包存储于其中的一个单一对象，允许读取其中元素，但是不允许向其中存放新的对象。</p>
<p>Java 泛型是使用擦除来实现的，泛型类型只有在静态的类型检查的编译期间才出现，此时，编译器会把程序中所有的泛型类型信息都擦除替换为它的第一个非泛型边界（比如<code>T</code>会被擦除替换为<code>Object</code>，<code>X1&lt;T&gt;</code>会被擦除替换为<code>X1</code>，<code>X2&lt;T extends X3&gt;</code>会被擦除替换为<code>X2&lt;X3&gt;</code>）这是一种参数类型合并，将泛型类型实例关联到同一个份字节码上，编译器为多个泛型类型只生成一份字节码，因此这些泛型类型是不能在运行时出现的类型，在泛型代码内部，无法获得任何有关泛型参数类型的信息，无法在类型参数上执行基于类型的语言操作（比如转型、<code>instanceof</code>、<code>new</code>对象，<code>new</code>数组、反射、重载等），运行时类型不存在泛型类型，泛型类的所有静态变量都是共享同一份的。</p>
<p>为了实现泛型的迁移，每个类库和应用程序都必须与其他所有的部分是否使用了泛型无关，必须不具备探测其他类库是否使用了泛型的能力，因此，某个类库使用了泛型这样的证据必须被“擦除”，擦除使得类型参数无法具体化，但这也使得泛型代码和非泛型代码共存成为可能，在不破坏现有类库的情况下，实现了从非泛型代码到泛型代码的转变，此外，这也意味着泛型的使用并不是强制的。</p>
<p>泛型是在 Java 语言已经被广泛应用之后才添加到 Java 中的特性，而不是一开始就设计到 Java 语言中的，基于擦除实现的 Java 泛型存在局限，并未达到解耦类或方法与所用类型之间的约束这种程度，比如编写真正泛化的“持有器”类（Java 容器）相当简单（ Java 泛型远不止类型安全的容器这么简单），但编写能够操作其泛型类型的真正泛化的“操作器”类则较为复杂（可能需要配合使用反射、适配器等各种设计模式才能实现），需要理解 Java 泛型的边界在哪里，理解了边界所在，知道了某个技术不能做到什么，才能更好的做到所能做的。</p>
<h1 id="3、I-O-系统"><a href="#3、I-O-系统" class="headerlink" title="3、I/O 系统"></a>3、I/O 系统</h1><p>一个好的输入/输出（I/O）系统要涵盖所有的可能性，不仅存在各种 I/O 源端和想要与之通信的接收端（文件、控制台、网络链接等），而且还需要以各种不同的方式与它们进行通信（顺序、随机存取、缓冲、二进制、按字符、按行、按字等）。</p>
<h2 id="3-1-I-O-类库"><a href="#3-1-I-O-类库" class="headerlink" title="3.1 I/O 类库"></a>3.1 I/O 类库</h2><ul>
<li><p><code>File</code>类</p>
<ul>
<li><p><code>File</code>类的名称有一定的误导性，实际上它既能代表一个特定文件的名称，又能代表一个目录下的一组文件的名称（FilePath 对这个类来说是个更好的名字）</p>
</li>
<li><p>除了代表已经存在的文件或者目录，<code>File</code>对象还可以创建新的目录或尚不存在的整个目录路径，可以查看文件的特性（大小、修改日期、读、写），可以检查该<code>File</code>对象代表的是文件还是目录</p>
</li>
<li><p>当<code>File</code>对象值的是一个文件时，可以删除文件，当<code>File</code>对象指的是一个文件集时，可以对此集合调用<code>list()</code>方法，从而返回一个字符数组</p>
</li>
</ul>
</li>
<li><p>流</p>
<ul>
<li><p>流是代表任何有能力产出数据的数据源对象或者是有能力接收数据的接收端对象，屏蔽了实际的 I/O 设备中处理数据的细节（管道流的价值体现在多线程任务之间的通信，详细见 <a href="../../08/java-concurrency/">Java Concurrency</a>）</p>
</li>
<li><p>任何自<code>InputStream</code>或<code>Reader</code>派生而来的类都含有<code>read()</code>方法，用于读取单个字节或者字节数组，任何自<code>OutputStream</code>或<code>Writer</code>派生而来的类都含有<code>write()</code>方法，用于写单个字节或者字节数组</p>
</li>
<li><p>很少使用单一的类来创建流对象，Java 为了创建某个结果流，其实需要通过叠加多个 I/O 对象来提供所期望的功能（装饰器设计模式），装饰器模式提供灵活性的同时也增加了代码的复杂性，使得记住如何打开文件变成一件相当困难的事情，这就是 Java I/O 类库操作不便的原因所在</p>
</li>
</ul>
</li>
<li><p><code>InputStream</code>和<code>OutputStream</code>类</p>
<ul>
<li><p><code>InputStream</code>用来表示那些从不同数据源产生输入的类，这些数据源包括字节数组，<code>String</code>对象，文件，管道，由其他种类的流组成的序列，Internet 连接等</p>
</li>
<li><p>每一种数据源都有相应的<code>InputStream</code>子类，另外<code>FilterInputStream</code>是<code>InputStream</code>的抽象子类，用于为装饰器类提供基类，是装饰器的必要条件，装饰器类可以把属性或有用的接口与输入流连接在一起</p>
</li>
<li><p><code>OutputStream</code>用来决定输出所要去往的目标，这些目标包括字节数组，文件或者管道</p>
</li>
<li><p><code>FilterOutputStream</code>为装饰器类提供了一个基类，是装饰器的必要条件，装饰器类可以把属性或者有用的接口与输出流连接起来</p>
</li>
<li><p>无论读和写数据的平台多么不同，只要两个平台都有 Java，<code>DataOutputStream</code>和<code>DataInputStream</code>可以保证准确的读写数据（XML 是另一种解决不同计算平台之间移动数据的方式，且不要求平台必须有 Java）</p>
</li>
<li><p><code>InputStream</code>和<code>OutputStream</code>继承层次结构还包括支持读写压缩格式的数据流</p>
</li>
</ul>
</li>
<li><p><code>Reader</code>和<code>Writer</code>类</p>
<ul>
<li><p><code>Reader</code>和<code>Writer</code>并非是用于替代<code>InputStream</code>和<code>OutputStream</code>的类，<code>InputStream</code>和<code>OutputStream</code>在以面向8位字节流形式的 I/O 中提供极有价值的功能，而<code>Reader</code>和<code>Writer</code>则提供兼容16位 Unicode 与面向字符的 I/O 功能</p>
</li>
<li><p>一般尽量尝试使用<code>Reader</code>和<code>Writer</code>，当发现程序代码无法编译成功，就会发现不得不使用面向字节的<code>InputStream</code>和<code>OutputStream</code></p>
</li>
<li><p>当需要把来自字节层次结构中的类和字符层次结构中的类结合起来使用时，<code>InputStreamReader</code>和<code>OutputStreamWriter</code>可以作为适配器类来将<code>InputStream</code>和<code>OutputStream</code>转换为<code>Reader</code>和<code>Writer</code></p>
</li>
</ul>
</li>
</ul>
<h2 id="3-2-标准-I-O"><a href="#3-2-标准-I-O" class="headerlink" title="3.2 标准 I/O"></a>3.2 标准 I/O</h2><p>程序的所有输入都可以来自于标准输入，所有输出都可以发送到标准输出，所有的错误都可以发送到标准错误，标准 I/O 的意义在于很容易地将程序串联起来，一个程序的标准输出可以成为另一个程序的标准输入。</p>
<p>按照标准 I/O 模型，Java 提供了<code>System.in</code>，<code>System.out</code>和<code>System.err</code>，其中<code>System.out</code>和<code>System.err</code>都已经事先被包装成了<code>PrintStream</code>对象，这意味着我们可以立即使用<code>System.out</code>和<code>System.err</code>，而<code>System.in</code>是一个没有被包装的未经加工的<code>InputStream</code>，这意味着使用<code>System.in</code>之前需要对其进行装饰（和大多数流一样，通常需要包装成<code>BufferedReader</code>或者<code>BufferedInputStream</code>，从而进行缓冲。</p>
<p>Java 的<code>System</code>类提供了一些静态方法运行对标准 I/O 进行重定向，当输出内容太多滚动太快以至于无法阅读时，就需要进行输出重定向，当需要重复测试某个特定用户的输入序列的命令程序时，就需要进行输入重定向。标准 I/O 重定向操纵的是字节流，而不是字符流，因此使用的是<code>InputStream</code>和<code>OutputStream</code>，而不是<code>Reader</code>和<code>Writer</code>。</p>
<h2 id="3-3-新-I-O"><a href="#3-3-新-I-O" class="headerlink" title="3.3 新 I/O"></a>3.3 新 I/O</h2><p>Java 在<code>java.nio.*</code>包中引入了新 I/O 类库，其目的在于提高速度，速度的提高来自于所使用的结构更接近于操作系统执行 I/O 的方式：通道、缓冲器以及内存映射文件。</p>
<p>需要读写的字节流数据只需要和缓冲器（<code>ByteBuffer</code>）进行交互，而缓冲器则与通道（<code>FileChannel</code>）进行交互。</p>
<ul>
<li><p>通道与通道可以直接相连，通道可以在文件内随处移动，通道可以锁定文件的某些区域用于独占式访问</p>
</li>
<li><p><code>ByteBuffer</code>是唯一直接与通道进行交互的缓冲器，是将数据移进移出通道的唯一方式</p>
</li>
<li><p><code>ByteBuffer</code>只能保存字节类型的数据，但是它可以从其所容纳的字节中产生出各种不同基本类型的方法</p>
</li>
<li><p>nio 的目标就是快速移动大量数据，<code>ByteBuffer</code>的大小就显得尤为重要，必须通过实际运行应用程序来找到最佳尺寸</p>
</li>
</ul>
<p>内存映射文件允许创建和修改那些因为太大而不能放入内存的文件，内存映射文件使得程序员可以假定这个文件都放在内存中，而且可以完全把它当做非常大的数组来访问极大地简化了用于修改文件的代码。</p>
<ul>
<li>注意必须指定映射文件的初始位置和映射区域的长度，这意味着可以映射某个大文件的较小的部分</li>
<li>即使建立映射文件的花费很大，但是整体受益比起 I/O 流来说还是很显著的，映射文件访问可以显著的加快速度</li>
<li>底层操作系统的文件映射工具是用来最大化地提高性能。</li>
</ul>
<p>文件加锁机制运行同步访问某个作为多进程之间或者多线程之间共享资源的文件，即文件锁对其他的操作系统进程是可见的，Java 的文件加锁直接映射到了本地操作系统的加锁工具。</p>
<ul>
<li>当底层操作系统支持时，文件锁可以设置为独占锁或者共享锁，如果操作系统不支持，那么就会使用独占锁</li>
<li>文件映射通常应用于极大的文件，那么就需要对这种巨大的文件进行部分加锁，以便其他进程可以修改文件中未被加锁的部分</li>
<li>Java 虚拟机会自动释放文件锁或者关闭加锁的通道，也可以在程序中显式地释放文件锁</li>
</ul>
<p>同步和异步描述的是被调用方，同步指被调用方在接到调用后会立即执行要做的事情，异步指被调用方在接到调用后会去执行要做的事情但不保证会立即执行。阻塞和非阻塞描述的是调用方，阻塞指调用方在发出调用之后要一直等待被调用方返回，非阻塞指调用方在发出调用之后不需要等待，可以去做自己的事情。阻塞与否和同步与否之间没有必然联系。</p>
<ul>
<li>BIO（Blocking I/O）是同步阻塞 I/O，是 JDK 1.4 之前的传统 I/O 模型，线程发起 I/O 请求后会一直阻塞直到缓冲区数据就绪，再进行下一步操作，适用于连接数目比较小且固定的架构，对服务器资源要求比较高，程序直观简单易理解</li>
<li>NIO（Non-Blocking I/O）是同步非阻塞 I/O，JDK 1.4 开始支持，线程发起 I/O 请求后，不需要阻塞而是立即返回，用户线程不原地等待 I/O 缓冲区，可以先做一些其他操作，只需要定时轮询检查 I/O 缓冲区数据是否就绪即可，适用于连接数目多且连接比较短的架构，编程比较复杂</li>
<li>AIO（Asychronous I/O）是异步非阻塞 I/O 模型， JDK 7 开始支持，线程发起 I/O 请求后，不需要阻塞而是立即返回，也不需要定时轮询检查结果，异步 I/O 操作之后会回调通知调用方，适用于连接数目多且连接比较长的架构，充分调用 OS 参与并发操作，编程比较复杂</li>
</ul>
<h2 id="3-4-序列化"><a href="#3-4-序列化" class="headerlink" title="3.4 序列化"></a>3.4 序列化</h2><p>持久性意味着一个对象的生存周期并不却取决于程序是否正在运行，它可以生存于程序的调用之间，在程序终止后仍能继续保存该对象的信息，在下次运行程序时该对象可以被重建并且拥有的信息与上次程序运行时的信息相同（这一过程可以通过网络进行），这也可以弥补不同操作系统之间的差异。一个严格的持久性机制可以考虑 Hibernate 之类的工具，而对象序列化可以视作是一种轻量级持久性，轻量级是指不能用某种持久关键字来简单的定义一个对象并让系统自动维护其他细节问题，而是需要在程序中显示地序列化和反序列化还原，几乎所有的商用编程语言都有序列化的能力。</p>
<p>Java 原生的对象序列化机制是基于字节的，可以将<code>String</code>、枚举以及那些实现了<code>Serializable</code>接口的对象（包含对象的类名和实例变量，不包含方法和类静态变量）转换为一个字节序列，因此需要使用<code>InputStream</code>和<code>OutputStream</code>继承层次结构（<code>ObjectInputStream</code>和<code>ObjectOutputStream</code>）。Jackson、<a href="https://www.yuque.com/hollis666/niq4hm/sexwwk">fastjson</a>、Gson 这样的 JSON 序列化库或其他 XML 库使用反射机制来访问对象的字段，并将它们转换成 JSON 或 XML 格式，这种情况下的对象序列化与<code>Serializable</code>接口无关。对象序列化的概念加入到 Java 主要是为了支持两种特性：一是 Java 远程方法调用，当向远程对象发送消息时，需要通过对象序列化来传输参数和返回值；二是保存设计阶段的 Java Beans 的状态信息并在程序启动时进行后期恢复。</p>
<p>序列化接口<code>Serializable</code>本身没有方法或字段，仅用于标识可序列化的语义，实现了<code>Serializable</code>接口的类被标识为可序列化的类，可序列化的类的子类自动也被标识为可序列化的类而不需要再显式地实现<code>Serializable</code>接口。可序列化的类可以显式定义一个<code>serialVersionUID</code>变量作为该类的序列化版本（方便项目升级），如果没有显式定义该变量，JVM 会根据编译的 Class 文件信息自动生成一个<code>serialVersionUID</code>，自动生成的<code>serialVersionUID</code>会随着类的 Class 文件或 JVM 的变化而变化。在进行反序列化时，JVM 会把传进来的字节流中的<code>serialVersionUID</code>与本地类的<code>serialVersionUID</code>进行比较，只要比较结果是相同的就认为是相同的类（即便序列化属性有所变化），可以进行反序列化，否则就视作字节流中的内容被篡改，会抛出<code>InvalidClassException</code>。</p>
<p>当需要控制对象的某个部分不被序列化时，有两种解决方式，一种是使用<code>transient</code>关键字关闭被修饰字段的序列化，当对象被反序列化还原时，该字段就会变成默认值；另一种是添加（而非覆盖或者实现）名为<code>writeObject()</code>和<code>readObject()</code>的方法，这样一旦对象被序列化或者被反序列化还原，就会自动调用这两个方法，而不是使用默认的序列化机制。当程序试图序列化一个对象时，会先检查该对象是否已经被序列化，只有对象从未在此 JVM 被序列化过，才会将此对象序列化为字节序列，否则只是存储第一次序列化结果的引用，同一对象不会被多次序列化（即便对象发生了变化）。POJO 类中的任何布尔类型的变量名都不要以 is 开头，这是因为名称以 is 开头的布尔变量的 get 方法也是以 is 开头，那么在反序列化解析时就会找不到名称为去掉 is 的属性，进而抛出异常。</p>
<p>对于普通的 Java 类来说，反序列化会通过反射以及 Unsafe 直接分配内存的机制来创建类目标类的一个新实例，这个过程会递归地反序列化目标类的可序列化的父类实例直到找到一个不可序列化的父类（比如<code>Object</code>类），对于不可序列化的父类，则调用该父类的无参构造函数，整个过程并不会调用目标类的构造函数，即使目标类的构造函数是私有的，也对反序列化没有影响，因此在这种场景时，需要注意是否存在对单例的破坏。当需要确保某个对象的反序列化不破坏单例时，可以添加（而非覆盖或者实现）名为<code>readResolve()</code>的方法，在该方法中指定对象的生成策略，比如直接返回单例对象而不是生成新对象。对于枚举类型来说，反序列化是通过<code>java.lang.Enum</code>的<code>values</code>方法来根据名字查找枚举元素的，这个过程并不会使用反射，并且编译器不允许任何对这种序列化与反序列化机制的定制，禁用了<code>writeObject()</code>、<code>readObject()</code>、<code>readObjectNoData</code>、<code>writeReplace</code>和<code>readResolve</code>等方法，因此枚举的反序列化并不存在对单例的破坏。</p>
<p>上述基于<code>Serializable</code>接口的序列化是自动序列化，系统自动存储必要的信息，Java 内建原生支持，易于实现，只需要实现该接口即可，无需任何代码支持；而继承了<code>Serializable</code>接口的<code>Externalizable</code>接口是强制自定义的序列化，由程序员决定存储哪些信息，<code>Externalizable</code>接口的实现类必须实现<code>writeExternal</code>和<code>readExternal</code>方法，在这两个方法中定义序列化与反序列化的实现细节，此外还必须提供一个<code>public</code>无参构造器，在反序列化时就会调用该构造器。<code>Externalizable</code>较<code>Serializable</code>性能略好一些。</p>
<h1 id="4、日志"><a href="#4、日志" class="headerlink" title="4、日志"></a>4、日志</h1><p>日志用于没有 debug 工具时的线上应用监控，bug 的跟踪定位等，应该做到内容关键有效且便于定位。</p>
<h2 id="4-1-日志级别"><a href="#4-1-日志级别" class="headerlink" title="4.1 日志级别"></a>4.1 日志级别</h2><p>Log4j 的级别类<code>org.apache.log4j.Level</code>里面定义了日志级别，常用的级别如下：</p>
<ul>
<li><p>ERROR：系统发生了错误事件，但仍然不影响系统的继续运行</p>
</li>
<li><p>WARN： 系统在业务处理时触发了异常流程，但系统可恢复到正常态</p>
</li>
<li><p>INFO： 记录系统关键信息，旨在保留系统正常工作期间关键运行指标</p>
</li>
<li><p>DEBUG： 可以将各类详细信息记录到DEBUG里，起到调试的作用，包括参数信息，调试细节信息，返回值信息等</p>
</li>
</ul>
<p>日志优先级别标准顺序为：ALL &lt; TRACE &lt; DEBUG &lt; INFO &lt; WARN &lt; ERROR &lt; FATAL &lt; OFF，那么如果日志级别设置 INFO，就只有输出级别为 INFO 以及级别大于 INFO 的日志才会正常输出。</p>
<h2 id="4-2-记录时机"><a href="#4-2-记录时机" class="headerlink" title="4.2 记录时机"></a>4.2 记录时机</h2><p>日志的写入操作通常是一个相对耗时的 I/O 操作，一方面可以通过使用异步日志来避免每次日志记录都同步写入磁盘，主线程可以继续执行其他任务而不是因日志记录而阻塞，日志写入操作则由后台线程负责处理，可以提高应用程序的响应性和吞吐量；另一方面可以去除一些不必要的日志记录，有必要日志记录的一些时机如下：</p>
<ul>
<li><p>系统初始化：系统初始化时会依赖一些关键配置，根据参数不同会提供不一样的服务，将系统的启动参数记录INFO日志，打印出参数以及服务启动完成状态</p>
</li>
<li><p>业务流程与预期不符：常见的合适场景包括外部参数不正确，数据处理问题导致返回码不在合理范围内等等</p>
</li>
<li><p>系统核心的关键动作：系统中核心角色触发的业务动作是衡量系统正常运行的重要指标，建议记录 INFO 级别日志，比如微服务各服务节点交互等</p>
</li>
<li><p>捕获到异常：是系统告知开发人员需要加以关注的，根据实际情况使用 WARN 或者 ERROR 级别</p>
</li>
<li><p>外部接口日志：与外部系统的交互涉及到责任问题，建议将原始数据文件内容写入日志或数据库，核心处理逻辑关键业务数据也尽量写入日志；如果涉及到重发，建议将处理失败的原始数据文件日志写入数据库，以便重发执行</p>
</li>
</ul>
<h2 id="4-3-日志规范"><a href="#4-3-日志规范" class="headerlink" title="4.3 日志规范"></a>4.3 日志规范</h2><p>记录日志应该遵守的一些规范如下：</p>
<ul>
<li><p>使用 SLF4J 中的 API 进行日志打印</p>
</li>
<li><p>日志输出必须采用 UTF-8 字符集，使用英文</p>
</li>
<li><p>不允许记录日志后又抛出异常，要么只记录错误日志，要么直接抛出异常</p>
</li>
<li><p>在日志中输出打印整个异常，而不是仅仅打印错误信息或仅仅堆栈信息</p>
</li>
<li><p>禁止<code>system.out</code>用于日志记录</p>
</li>
<li><p>线上必须关闭 DEBUG 级别日志</p>
</li>
<li><p>日志输出，必须使用<code>&#123;&#125;</code>占位符的方式，字符串相加会有性能问题</p>
</li>
<li><p>日志中不允许出现计算或方法调用，防止在打印日志的时候报错</p>
</li>
<li><p>输出的 POJO 类必须重写<code>toString</code>，否则只输出对象的 hashCode 值，没有参考意义</p>
</li>
<li><p>禁止记录大量对于排查故障毫无意义的日志信息，日志信息一定要带有业务信息</p>
</li>
<li><p>不可以将敏感业务信息记录入日志文件</p>
</li>
<li><p>严防日志占满磁盘，定期检查磁盘（确定是否有磁盘告警）</p>
</li>
<li><p>不要在大循环中循环打印日志</p>
</li>
<li><p>统一使用<code>log4j2.xml</code>或<code>logback.xml</code>配置，所有的 jar 包中不建议包含日志配置文件，避免干扰实际的业务系统</p>
</li>
</ul>
<h2 id="4-4-日志框架"><a href="#4-4-日志框架" class="headerlink" title="4.4 日志框架"></a>4.4 日志框架</h2><p>SLF4J (Simple Logging Facade for Java) 是可以用于各种 Java 日志框架的广义接口 (facade/abstraction)，允许用户选择实际希望使用的日志框架 (logging, logback, log4j)。诸如库或框架之类的嵌入式组件不应该声明依赖于任何 SLF4J 所绑定/提供的日志框架，而应该只声明依赖于 SLF4J。</p>
<p>启用 SLF4J 的库意味着只需要添加一个强制依赖项，即 slf4j-api.jar，此外，需将一个且仅一个选择的日志框架绑定放到适当的类路径位置上（slf4j-api.jar的版本与绑定框架的版本需要相匹配），不要在类路径上放置多个绑定。要切换日志框架，只需替换类路径上的日志框架绑定。如果在类路径上没有找到绑定/提供程序，那么 SLF4J 将默认为无操作实现。</p>
<p>Log4j 是 Apache 的一个开源日志框架，也是市场占有率最多的一个框架，Logback 被开发为 Log4j 的更强大的替代品，Logback 和 SLF4J 是互补的，可以一起使用，也可以不一起使用。Log4j 2是 Log4j 的升级版，修复了 Logback 架构中的一些固有问题。Log4j 2有点类似于Logback+SLF4J，因为它提供了一个 facade API（Log4j - API，与 SLF4J 相媲美）和一个实现（Log4j -core，与 Logback 相媲美）。</p>
<p>推荐使用 SLF4J + Logback 或者使用 Log4j 2。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> org.slf4j.Logger;</span><br><span class="line"><span class="keyword">import</span> org.slf4j.LoggerFactory;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">HelloWorld</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Logger</span> <span class="variable">logger</span> <span class="operator">=</span> LoggerFactory.getLogger(HelloWorld.class);</span><br><span class="line">        logger.info(<span class="string">&quot;Hello World&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="4-5-分布式日志系统"><a href="#4-5-分布式日志系统" class="headerlink" title="4.5 分布式日志系统"></a>4.5 分布式日志系统</h2><p>分布式日志系统可以对集群中的各个机器上的日志做统一收集、存储和管理，避免在分析日志时需要要去各个机器分别查看日志，可以通过自建 ELK 来实现分布式日志系统。</p>
<p>ELK 指 Elasticsearch、Logstash 和 Kibana，其中，Elasticsearch 提供分析、查询、存储数据等功能，Logstash 提供日志的采集和过滤，Kibana 提供友好的图形化界面，帮助信息汇总。</p>
<p>有时候还是避免不了去服务器上查看日志，<a href="https://www.yuque.com/hollis666/niq4hm/fr5h634v474sgo7q">在 Linux 上查看和分析日志方式</a></p>
<h1 id="5、其他补充"><a href="#5、其他补充" class="headerlink" title="5、其他补充"></a>5、其他补充</h1><h2 id="5-1-final"><a href="#5-1-final" class="headerlink" title="5.1 final"></a>5.1 final</h2><p><code>final</code>通常指无法改变，不想做改变可能出于设计或者效率的考虑，应当尽可能从设计的角度来决定是否使用<code>final</code>，而不是出于试图提高性能的目的来使用<code>final</code></p>
<ul>
<li><p><code>final</code>数据</p>
<p>通常是基本数据类型，使数值恒定不变，而对于对象引用，使引用恒定不变，但对象自身是可以修改的（Java 并未提供任何使对象恒定不变的途径，但可以自己编写类以取得使对象恒定不变的效果）</p>
<p>Java 允许生成被声明为<code>final</code>但又未给定初值的域，但编译器都确保这种<code>final</code>域在使用前必须被初始化</p>
</li>
<li><p><code>final</code>方法</p>
<p>确保任何继承类都无法重写该方法</p>
<p>类中所有的<code>private</code>方法都隐式地指定为<code>final</code></p>
</li>
<li><p><code>final</code>类</p>
<p>确保无法继承该类</p>
<p><code>final</code>类的域可以根据个人的意愿选择为是或者不是<code>final</code>，相同的规则适用于定义为<code>final</code>的域，但<code>final</code>类的中所有的方法都隐式指定为<code>final</code></p>
</li>
</ul>
<h2 id="5-2-异常"><a href="#5-2-异常" class="headerlink" title="5.2 异常"></a>5.2 异常</h2><p>异常的一些好处：</p>
<ul>
<li>Java 用异常来提供一致的错误报告模型，使得程序构件能够与客户端代码可靠地沟通问题</li>
<li>异常使得问题发生时强制程序停止运行，告知出现了什么问题，然后强制程序处理问题，并返回到稳定状态</li>
<li>如果在当前的环境中还没有足够的信息来解决某个问题，可以通过异常来将这个问题提交到一个更高级别的别的环境中，期望在那里做出正确的决定，即将正常主干代码和错误处理代码分开</li>
<li>异常往往能够降低错误处理代码的复杂度，只需在异常处理程序这一个地方进行错误处理，如果不使用异常，那么就必须在程序的许多地方去进行特定的错误处理</li>
</ul>
<p><code>Throwable</code>是 Java 中最顶级的异常类，被用来表示任何可以作为异常被抛出的类，<code>Throwable</code>可分为<code>Error</code>和<code>Exception</code>，<code>Error</code>用来表示运行期间的系统错误（比如<code>OutOfMemoryError</code>、<code>StackOverflowError</code>等），不能指望程序自身来处理这类问题，除了退出运行别无选择，程序中需要关心的基类型是<code>Exception</code>，<code>Exception</code>可分为受检异常和非受检异常。</p>
<p>如果一个方法可能抛出受检异常（比如 I/O 操作时找不到文件等），就代表该方法的调用者需要明确处理一些特殊情况（throw 或者 catch），否则代码无法通过编译。非受检异常则是运行时异常，继承自<code>RuntimeException</code>，针对非受检异常的显式处理不是必须的，如果代码中没有 catch 非受检异常，JVM 会自动将其抛出并中断程序的执行，究其根本，<code>RuntimeException</code>代表的是编程错误，是程序员在编写代码时就要进行检查的不应在运行期间发生的错误（比如空指针、数组越界等）。</p>
<p>不必拘泥于 Java 中已有的异常类型，可以自定义继承自<code>Exception</code>的异常类，也可以给异常类增加更多方法来得到更强的功能，但是使用程序包的客户端程序员可能仅仅只是查看一个抛出的异常类型，也不进行其他操作，所以对异常添加的其他功能一般也用不上，异常对象中有意义的信息通常也就是异常类型和类名，除此之外不包含任何有意义的内容。</p>
<p>在捕获异常时，可以通过直接捕获<code>Exception</code>来捕获所有的编程活动相关的异常，但最好把它放在处理程序列表的末尾，以防它抢在其他处理程序之前先把类型更加明确的异常子类捕获了。一旦捕获了异常，绝对不能什么都不做，也不能只是使用<code>e.printStacktrace</code>，如果不明确应当如何处理，则不应捕获，而是向上抛出。如果在捕获异常之后抛出了另外一种异常，那么有关原来异常发生点的信息回丢失，剩下的是与新的异常抛出点有关的信息。</p>
<p><code>finally</code>块用于进行一些确保一定要执行的除释放存储空间之外的清理工作，甚至在异常没有被当前的异常处理程序捕获的情况下，异常处理机制也会在跳到更高一层的异常处理程序之前执行当前层级的<code>finally</code>块，但是守护线程的<code>finally</code>块并不保证执行，详细参见 <a href="../../../../2022/05/08/java-concurrency/">Java Concurrency</a>。在涉及<code>break</code>和<code>continue</code>时，搭配<code>finally</code>使用即可实现<code>goto</code>功能，因此 Java 里就没有必要使用<code>goto</code>语句了。此外，如果<code>try</code>块中发生异常，那么<code>catch</code>中的<code>return</code>语句会覆盖<code>try</code>中的<code>return</code>语句，无论是否发生异常，<code>finally</code>块中的<code>return</code>语句将覆盖<code>try</code>和<code>catch</code>块中的<code>return</code>语句。</p>
<p>在覆盖方法时，派生类方法只能抛出基类方法的异常声明里列出的那些异常，不过基类方法的异常声明无需出现在派生类的异常声明中。但这个异常限制对构造器则有所不同，派生类构造器可以抛出任何异常，但不能捕获基类构造器抛出的异常，派生类构造器的异常说明里必须包含基类构造器的异常说明。 </p>
<h2 id="5-3-字符串"><a href="#5-3-字符串" class="headerlink" title="5.3 字符串"></a>5.3 字符串</h2><p><code>String</code>是使用最广泛的数据结构，为了降低大量<code>String</code>创建的资源耗费，所以 Java 提供了对<code>String</code>的缓存功能（字符串池）来节省内存空间资源，那么两个内容相同的<code>String</code>变量可以指向字符串常量池中的同一个<code>String</code>对象，这也就要求<code>String</code>必须具备不可变性，此外，<code>String</code>在 Java 应用程序中广泛用于存储敏感信息，因此保护<code>String</code>不被修改对于提升整个应用程序的安全性也至关重要。</p>
<p><code>String</code>类被声明为<code>final</code>，这意味着它不能被继承，<code>String</code>类中用<code>final</code>修饰<code>byte[]</code>类型的字符串值，一旦值被初始化就不能再指向其他数组，<code>String</code>没有提供用于修改字符串值的公共方法，那些涉及到所谓的字符串修改的公共方法都是通过创建一个新的<code>String</code>对象并返回来实现的，综上所述，<code>String</code>对象是不可变的。此外，<code>String</code>有长度限制，编译期的长度限制是 2^16 -1，运行期的长度限制是 2^31 - 1。</p>
<p>不可变对象在完全创建后其内部状态保持不变，指向它的任何引用都不可能改变它的值，具有只读特性，可以安全地在多个线程之间共享，但不可变性也会带来一定的效率问题，例如对<code>String</code>对象使用<code>+</code>运算符时可能需要创建很多需要垃圾回收的中间<code>StingBuilder</code>对象（如果是简单的字符串常量间的静态拼接，就不存在这个问题，因为编译器在编译阶段会直接计算出结果）。</p>
<p>因此，在进行字符串变量间的动态拼接（尤其是在循环体中）时，多线程并发情况下使用<code>StringBuffer</code>，非线程并发的情况下一般使用<code>StringBuilder</code>，<code>StringBuffer</code>和<code>StingBuilder</code>类似，区别在于<code>StringBuffer</code>的操作方法使用<code>synchronized</code>进行声明，是线程安全的方法，而<code>StingBuilder</code>则不是线程安全的，在引入了偏向锁和锁升级后，无锁竞争时的<code>StringBuffer</code>和<code>StringBuilder</code>的性能是一致的，所以非线程并发时使用<code>StringBuffer</code>其实也可以，并不会带来性能上的下降。</p>
<p>在 JDK 9 之前，<code>String</code>内部使用字符数组<code>char[]</code>来表示，为了避免有些只需要占据一个字节的字符由于使用<code>char</code>而占据了两个字节，JDK 9 引入了字符串压缩的概念，在<code>String</code>内部使用字节数组<code>byte[]</code>来表示字符，当字符串中所有字符都可以用单个字节表示时，内部使用字节数组来保存一半所需的空间，但如果存在一个字符需要超过一个字节来表示时，将继续使用 UTF-16 的字符数组，<code>String</code>内部还通过一个名为<code>coder</code>的变量来标识这两种情况。</p>
<p><code>String.intern</code>方法会把字符串池中没有的字符串实例的引用放入字符串池中，并返回该引用，如果在这之前字符串池中已经存在一个等于该字符串的实例，<code>String.intern</code>方法则会直接返回这个已存在的实例的引用，这就确保了一般情况下相同内容的字符串在内存中只有一个实例，例外情况是使用<code>new</code>在堆中创建与字符串常量池中已有字符串实例内容相同的新实例。</p>
<p>Java 字符串常量有两种进入字符串池的途径，一种是作为字面量（字面量是源码中用于表达一个固定值的表示法，指由字母、数字等构成的字符串或者数值，只可以右值出现），先在编译期进入 Class 文件常量池表，再在运行期类加载后（具体是在第一次被调用时，JVM 开始对 Class 文件进行解析）被存放到字符串池中，另一种是在运行期间通过<code>String.intern</code>方法被放入字符串池中，详细参见 <a href="../../../../2023/12/09/java-virtual-machine/">Java Virtual Machine</a> 中的 2.1.1 和 3.2.1 小节。</p>
<p>最后再补充一个关于<code>toString</code>方法使用的错误示例：希望打印对象的内存地址时，调用以下代码会产生异常，这是因为在将<code>InfiniteRecursion</code>对象自动转换为<code>String</code>类型时，会调用<code>this</code>上的<code>toString</code>方法，于是就发生了递归调用。为了避免这个问题，应当将<code>this</code>修改为<code>super</code>。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">InfiniteRecursion</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">toString</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;InfiniteRecursion address&quot;</span> + <span class="built_in">this</span> + <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">        <span class="comment">// 应当修改为</span></span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;InfiniteRecursion address&quot;</span> + <span class="built_in">super</span>.toString() + <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>UUID 是全局唯一标识符，是指在一台机器上生成的数字，目标是保证在同一时空中的所有机器上都是唯一的。UUID 的生成通常是在本地基于随机数生成器、时间戳、MAC 地址等<a href="https://www.yuque.com/hollis666/niq4hm/pi2zfc9ykug141im">生成算法</a>，生成的 UUID 由 32 位 16 进制数表示，共 128 bit，具有极高的唯一性，几乎不可能重复。由于随机生成的 UUID 具备不可预测性，无任何含义，不适合页面展示，适用于需要保密的应用场景。由于可以在不同的机器上生成 UUID，因此可以用于分布式系统中。</p>
<p>正则表达式是一种强大而灵活的文本处理工具，提供了一种完全通用的方式来解决各种字符串处理相关的问题，比如匹配、选择、编辑以及验证（参考<code>java.util.regex.Pattern</code>），正则表达式是昂贵的操作，不应在循环中大量执行。</p>
<h2 id="5-4-字符编码"><a href="#5-4-字符编码" class="headerlink" title="5.4 字符编码"></a>5.4 字符编码</h2><p>字符编码是一套法则，使用该法则能够对自然语言的字符集合进行配对。</p>
<p>ASCII 码对英语字符与二进制之间的关系做了统一的规定，一共 128 个字符。</p>
<p>Unicode 字符集是计算机科学领域里的一项业界标准，对世界上大部分的文字系统（包括中文）进行了整理、编码，使得计算机可以用更为简单的方式来呈现和处理文字。可扩展置标语言（XML）、Java 编程语言以及现代操作系统都采用 Unicode 编码。Unicode 虽然统一了编码，但没有规定如何存储（考虑到字符集合太大，如果规定则每个字符需要用很多个字节进行编码和存储，是极大的空间浪费），因此产生了一些编码长度不同的中间格式的字符集（称为 Unicode Transformation Format），常见的有 UTF-7、UTF-7.5、UTF-8、UTF-16 以及 UTF-32，这些字符集都是 Unicode 的一种实现方式。</p>
<p>此外，还有一些常见的中文编码有 GBK、GB2312、GB18030，这些编码与 Unicode 相比，都是针对更小的字符集合，从而采用更短的编码方式，单个字符占据更小的存储空间。</p>
<p>Java 中的<code>char</code>类型表示一个占据两个字节的 Unicode 字符，因此<code>char</code>类型可以存储 Unicode 字符集中的所有字符，但是在使用时需要注意确保 Java 源码文件本身、编译器以及运行时环境都支持 Unicode 字符集，还需要注意字符编码以及字符串长度问题。</p>
<h2 id="5-5-注解"><a href="#5-5-注解" class="headerlink" title="5.5 注解"></a>5.5 注解</h2><p>注解也被称为元数据，提供了一种形式化的在代码中添加信息的方法（比注释性文字更优），这些元数据信息保存在 Java 源代码中，而不是保存在外部文档中，这使得可以在稍后某个时刻非常方便地使用这些数据。</p>
<p>元注解是 Java 提供的可以用于定义注解的基本注解，通过元注解，可以自定义其他功能的注解，常用的元注解如下</p>
<ul>
<li><p><code>@Target</code></p>
<ul>
<li><p>用于告知Java将自定义的注解放在何处，比如类、方法、构造器、变量上等，是一个枚举类型，有如下属性值；</p>
</li>
<li><p><code>ElementType.CONSTRUCTOR</code>代表用于描述构造器；</p>
</li>
<li><p><code>ElementType.FIELD</code>代表用于描述成员变量、对象、属性（包括<code>enum</code>实例）；</p>
</li>
<li><p><code>ElementType.LOCAL_VARIABLE</code>代表用于描述局部变量；</p>
</li>
<li><p><code>ElementType.METHOD</code>代表用于描述万法；</p>
</li>
<li><p><code>ElementType.PACKAGE</code>代表用于描述包；</p>
</li>
<li><p><code>ElementType.PARAMETER</code>代表用于描述参数；</p>
</li>
<li><p><code>ElementType.TYPE</code>代表用于描述类、接口（包括注解类型）或<code>enum</code>声明。</p>
</li>
</ul>
</li>
<li><p><code>@Retention</code></p>
<ul>
<li><p>用于说明自定义注解的生命周期，在注解中有三种生命周期，是一个枚举类型，有如下属性值；</p>
</li>
<li><p><code>RetentionPolicy.RUNTIME</code> 代表始终不会丢弃，运行期也保留该注解，通常使用这种方式；</p>
</li>
<li><p><code>RetentionPolicy.CLASS</code>代表类加载时丢弃，默认使用这种方式；</p>
</li>
<li><p><code>RetentionPolicy.SOURCE</code>代表编译阶段丢弃，所以不会写入字节码，<code>＠Override</code>、<code>＠SuppressWarnings</code>都属于这类注解。</p>
</li>
</ul>
</li>
<li><p><code>@Inherited</code></p>
<ul>
<li><p>用于标记被标注的类型的注解是可以被继承的（默认情况下父类的注解不会被子类继承）；</p>
</li>
<li><p>如果一个使用了<code>＠lnherited</code>修饰的注解类型被用于一个类，则这个注解将继续被用于该类的子类。</p>
</li>
</ul>
</li>
<li><p><code>@Documented</code></p>
<ul>
<li>用于标记是否将信息添加到 Java 文档当中。</li>
</ul>
</li>
<li><p><code>@interface</code></p>
<ul>
<li><p>用于声明一个注解；</p>
</li>
<li><p>其中的每一个方法实际上是声明了一个配置参数;</p>
</li>
<li><p>方法的名称就是参数的名称，返回类型就是参数的类型;</p>
</li>
<li><p>返回值类型只能是基本类型、<code>Class</code>、<code>String</code>、<code>enum</code>。</p>
</li>
</ul>
</li>
</ul>
<p>注解一般户包含一些元素以表示某些值，没有元素的注解称为标记注解，注解元素可用的类型有基本类型、<code>String</code>、<code>Class</code>、<code>enum</code>、<code>Annotation</code>、前面这些类型的数组。注解元素不能有不确定的值，要么必须具有默认值，要么在使用注解时提供元素的值，对于非基本类型的注解元素，不能以<code>null</code>作为值。</p>
<h2 id="5-6-枚举"><a href="#5-6-枚举" class="headerlink" title="5.6 枚举"></a>5.6 枚举</h2><p>枚举类型是由一组固定常量（解语法糖得到的是<code>public static final</code>修饰的枚举类成员字段）组成合法的类型，创建枚举时，编译器会生成一个相关的类并在该类中自动插入静态的<code>values()</code>方法，这个类继承自<code>Enum</code>类（Java 的单继承结构使得该类不能再继承其他类），同时该类是一个不可子类化的<code>final</code>类。枚举类型除了不能继承其他类也不能被继承以外，可以看作是一个常规的类，即可以在枚举中添加变量和方法。</p>
<p><code>Enum</code>类实现了<code>Comparable</code>和<code>Serializable</code>接口，具备<code>compareTo()</code>方法，枚举实例可以使用==来比较，编译器会自动提供<code>equals()</code>和<code>hashCode()</code>方法。枚举实例虽然可以具有不同的行为，但它们不是类型，不能将其作为方法签名中的参数类型来使用，最好的办法是将枚举用在<code>switch</code>语句中，或者使用<code>EnumMap</code>来实现多路分发，<code>EnumMap</code>是专门为枚举设计的一种性能非常好的<code>Map</code>，详细介绍见 2.2 小节。</p>
<p>对一个枚举实例进行反序列化是通过<code>java.lang.Enum</code>的<code>values</code>方法来根据名字查找枚举元素的，这个过程并不会使用反射，并且编译器不允许任何对这种序列化与反序列化机制的定制，禁用了<code>writeObject()</code>、<code>readObject()</code>、<code>readObjectNoData</code>、<code>writeReplace</code>和<code>readResolve</code>等方法，因此枚举的反序列化并不存在对单例的破坏。</p>
<p>对于枚举而言，实现接口是使其子类化的唯一办法，可以在一个接口内部，创建实现该接口的枚举，那么枚举元素依旧保持接口的特性，可以向上转型为接口，因此可以进一步实现枚举的枚举，实现某种程度上的枚举子类化。</p>
<h2 id="5-7-新特性"><a href="#5-7-新特性" class="headerlink" title="5.7 新特性"></a>5.7 新特性</h2><p>JDK 6/7 中对<code>synchronized</code>锁进行了很多优化，锁消除、锁粗化、锁升级（偏向锁、轻量级锁、适应性自旋）等。</p>
<p>JDK 8 中提供了 Lambda 表达式（思想是传递运算，而非传递数据，是一种语法糖）、Stream、Optional、线程安全的 DateTimeFormatter等新特性，还对 HashMap 进行了一些<a href="https://www.yuque.com/hollis666/niq4hm/cgben69hc08cpng7">改变</a>。</p>
<p>JDK 10 中提供了本地变量类型推断，可以通过<code>var</code>声明变量并在赋值的右边提供实现类型，不需要显式地规范变量的类型，是一种语法糖。</p>
<p>JDK 13 中提供了<code>yield</code>语句来返回一个值并跳出当前<code>switch case</code>块（区别于<code>return</code>跳出当前方法）， 提供了 Text Blocks 文本块预览特性，避免了对大多数转义序列的需要，以可预测的方式自动格式化字符串。</p>
<p>JDK 14 中提供了<code>instanceOf</code>模式匹配、<code>Records</code>。<code>instanceOf</code>模式匹配允许同时进行类型判断和类型转换，省略了判断之后再显式强制转换的步骤。<code>Records</code>为声明类提供了一种紧凑的语法，用于创建一种只有字段的类，编译器会自动创建所有的方法并让所有字段参与<code>hashCode</code>等方法，使得纯数据类从几行代码简化为一行代码。</p>
<p>JDK 15 中提供了封闭类/接口，使用<code>sealed</code>修饰符声明并通过<code>permit</code>子句指定允许扩展/实现封闭类/接口的类。</p>
<p>JDK 19 中提供了协程。</p>
<p>JDK 21 中提供了虚拟线程，详细参见 <a href="../../../../2022/05/08/java-concurrency/">Java Concurrency</a>。</p>
<h2 id="5-8-SPI"><a href="#5-8-SPI" class="headerlink" title="5.8 SPI"></a>5.8 SPI</h2><p>应用开发人员使用 API 定义软件组件之间交互的规则和约定的接口，API 提供方制定接口并完成对接口的不同实现，API 调用方只需调用即可；框架扩展人员使用 SPI 定义应用程序中可拔插的服务实现，SPI 提供方制定服务并提供可拔插的实现方式，SPI 调用方可以选择使用提供方提供的内置实现，也可以自己实现。</p>
<p>SPI 适用于调用者需要根据实际使用需要来启用、扩展、或者替换框架的实现策略的场景，比如数据库驱动加载接口实现类的加载、JDBC 加载不同类型数据库的驱动、日志门面接口实现类加载、SLF4J 加载不同提供商的日志实现类等，Spring 中也大量使用了 SPI。</p>
<h2 id="5-9-Unsafe"><a href="#5-9-Unsafe" class="headerlink" title="5.9 Unsafe"></a>5.9 Unsafe</h2><p><code>sun.misc.Unsafe</code>类是 Java 中的一个底层类，提供了硬件级别的原子操作，可以对堆外内存进行直接的内存操作（是 JVM 开的后门），包括内存分配和对象实例化。</p>
<ul>
<li><p><code>Unsafe</code>是 Java 的内部 API，并不属于 Java 标准库的一部分，<code>Unsafe</code>的行为在不同的 JDK 版本和不同 JVM 实现中可能会有差异，会引发代码的不可移植性</p>
</li>
<li><p><code>Unsafe</code>包含了很多基础操作，比如数组操作、对象操作、内存操作、CAS 操作、线程操作（park/unpark）、栅栏操作，JUC 包等一些三方框架都使用<code>Unsafe</code>来保证并发安全</p>
</li>
<li><p><code>Unsafe</code>的功能是强大而危险的，可以绕过 Java 的安全机制，它所分配的内存需要手动 free 而不被 GC 回收，可能会导致内存泄漏、非法访问、数据损坏等安全问题</p>
</li>
<li><p><code>Unsafe</code>被设计的初衷并不是希望被一般开发者使用，它的构造方法时私有的，所以不能通过<code>new</code>或工厂方法去得到<code>Unsafe</code>实例，可以采用反射获取<code>Unsafe</code>实例</p>
</li>
<li><p>Java 鼓励使用构造函数和工厂方法来创建对象，以确保对象的正确初始化，并维护对象的不变性，使用<code>Unsafe</code>创建对象并不符合 Java 面向对象的原则</p>
</li>
</ul>
<p>综上所述，不建议直接在生产环境中使用<code>Unsafe</code>。</p>
<h2 id="5-10-拷贝"><a href="#5-10-拷贝" class="headerlink" title="5.10 拷贝"></a>5.10 拷贝</h2><p>拷贝对象时，浅拷贝是指只复制对象的地址，而不是对象本身，原始对象和浅拷贝得到的对象实际上是共享同一个内存地址的；深拷贝是指将对象及其所有属性都复制到另一个全新的对象中，原始对象和深拷贝得到对象位于不同的内存地址，互不影响。深拷贝有两种实现方法，一个是实现<code>Cloneable</code>接口并重写<code>clone</code>方法，另一个是序列化与反序列化。</p>
<p>调用一个对象的<code>clone</code>方法时，JVM 就会创建一个新的对象，将前面对象的内容全部拷贝进去（并不会调用构造函数），如果只实现了<code>Cloneable</code>接口而没有重写<code>clone</code>方法，则会默认使用<code>Object</code>类中的<code>clone</code>方法（这是一个 Native 方法），此时只能实现浅拷贝，要实现深拷贝就必须重写<code>clone</code>方法，要重写<code>clone</code>方法就必须实现<code>Cloneable</code>接口。</p>
<p>先把对象序列化成某种格式流，再从该格式流中反序列化对象，默认就会得到新的对象，序列化的方法可以 Java 原生的序列化机制、各种 JSON 工具等。</p>
<h2 id="5-11-文件处理"><a href="#5-11-文件处理" class="headerlink" title="5.11 文件处理"></a>5.11 文件处理</h2><p>通常看到的 xlsx 文件其实是一个将若干个 XML 格式的纯文本文件压缩到一起的高度压缩文件，解压后的 xlsx 文件包含的内容可能会扩大为好几倍，Excel 就是读取这些压缩文件的信息，最后展现出一个完全图形化的电子表格。</p>
<p>Apache POI 是一个非常流行的文档处理工具，通常被用于处理 Excel，当 POI 在处理 xlsx 文件时，会把整个内容都加载到内存中，实际处理的大小并不是看到的 xlsx 文件大小，因此会很容易出现内存溢出。</p>
<p>POI 中提供了如下<code>WorkBook</code>来操作 Excel</p>
<ul>
<li><p><code>SSFWorkbook</code>用于处理 Excel 的 .xls 格式</p>
</li>
<li><p><code>XSSFWorkbook</code>用于处理 Excel 的 .xlsx 格式，支持更大的数据集和更多的功能，如更好地样式和公式支持，也会占据比<code>SSFWorkbook</code>更多的内存</p>
</li>
<li><p><code>SXSSFWorkbook</code>用于处理 Excel 的 .xlsx 格式，是<code>XSSFWorkbook</code>的流式版本，专门设计用于处理大数据集，通过将数据写入临时文件而非全部保留在内存中，显著减少内存消耗，避免内存溢出</p>
</li>
</ul>
<h2 id="5-12-定时任务"><a href="#5-12-定时任务" class="headerlink" title="5.12 定时任务"></a>5.12 定时任务</h2><p>定时任务可以定时执行的原理是通过操作系统提供的定时器实现的，定时器可以周期性地发出中断信号，以便操作系统或其他应用程序可以在指定的时间间隔内执行某些任务，操作系统中常见的定时任务管理工具有 crontab（Linux 系统）、Windows Task Scheduler（Windows 系统）。</p>
<p>Java 提供如下方式来实现定时任务</p>
<ul>
<li><p>原生特性，使用简单，不需要依赖第三方调度框架和类库，非常轻量级，但依赖 JVM 进程，一般需要配合数据库的持久化一起使用，不便于集群多节点配合</p>
<ul>
<li><p><code>Timer</code>类和<code>TimerTask</code>类，精度不高，单线程执行，某个任务执行时间长或者抛出未捕获异常都会影响到后续任务的执行</p>
</li>
<li><p><code>ScheduleExecutorService</code>类，比<code>Timer</code>更精准，支持多个任务并发执行</p>
</li>
<li><p><code>DelayQueue</code>类，本质是一个带有延迟时间的无界阻塞队列，元素必须实现<code>Delayed</code>接口，当从<code>DelayQueue</code>中取出一个元素时，如果其延迟时间还未到达，则会阻塞等待直到延迟时间到达</p>
</li>
</ul>
</li>
<li><p>Spring 类库的<code>@Scheduled</code>注解</p>
</li>
<li><p>Quartz 任务调度框架的<code>JobDetail</code>和<code>Trigger</code>对象，支持任务的并发执行和动态调度</p>
</li>
<li><p>xxl-job 是一个分布式定时任务调度平台，支持集群部署，可以满足高并发、大数据量的任务调度需求</p>
</li>
<li><p>Elastic-Job 是一个分布式任务调度框架，支持分布式部署，提供高并发、高可用性、高可扩展性、大数据量的任务调度需求</p>
</li>
</ul>
<p>此外，也可以自定义算法来实现定时任务</p>
<ul>
<li><p>小顶堆</p>
<ul>
<li>可以作为管理定时事件的数据结构，每个事件包含触发时间戳和要执行的任务信息，最紧要触发的任务一直位于堆的根部，从而高效地触发最近需要触发的定时事件，Java 中的<code>Timer</code>类和<code>DelayQueue</code>类都是基于小顶堆实现的</li>
</ul>
</li>
<li><p>链表</p>
<ul>
<li>可以作为管理定时事件的数据结构，每个节点包含触发时间戳和任务信息，链表中的节点按照触发时间戳从小到大排列，通过遍历链表可以找到最近触发的定时事件</li>
</ul>
</li>
<li><p>时间轮</p>
<ul>
<li><p>是一种用于处理定时任务和调度的常见算法，算法需要定义一个时间轮盘，在轮盘中划分出槽位，每个槽位表示一个时间段（秒级、分钟级、小时级等），将需要定时执行的任务挂到这些槽位中，随着轮盘指针随着时间推移而不断旋转，指针指向的槽位中的任务就会定时触发，会在线程池中执行被触发的任务，常见的应用时间轮算法的框架和库如下</p>
</li>
<li><p>Netty，使用时间轮算法来处理定时任务和超时检测，时间轮用于管理通道的超时和重连机制</p>
</li>
<li><p>Akka，使用时间轮算法来管理和触发并发任务，使得 Akka 能够支持高并发和复杂的任务调度需求</p>
</li>
<li><p>Kafka，使用时间轮算法来管理消息的过期和删除，以释放存储空间</p>
</li>
<li><p>Hystrix，使用时间轮算法来管理命令执行和熔断状态的转换</p>
</li>
<li><p>Disruptor，使用时间轮算法来管理任务的并发执行，以提高处理大量事件的性能</p>
</li>
</ul>
</li>
</ul>
<h1 id="6、参考资料"><a href="#6、参考资料" class="headerlink" title="6、参考资料"></a>6、参考资料</h1><ul>
<li>《Thinking in Java (Fourth Edition)》</li>
<li><a href="https://www.slf4j.org/manual.html">https://www.slf4j.org/manual.html</a></li>
<li><a href="https://developer.aliyun.com/article/694075">https://developer.aliyun.com/article/694075</a></li>
<li><a href="https://www.cnblogs.com/9dragon/p/10901448.html">https://www.cnblogs.com/9dragon/p/10901448.html</a></li>
<li><a href="https://juejin.cn/post/6973664796709404708">https://juejin.cn/post/6973664796709404708</a></li>
<li><a href="https://tech.meituan.com/2014/03/06/in-depth-understanding-string-intern.html">https://tech.meituan.com/2014/03/06/in-depth-understanding-string-intern.html</a></li>
</ul>
]]></content>
  </entry>
  <entry>
    <title>Redis</title>
    <url>/2024/02/18/redis/</url>
    <content><![CDATA[<p>Redis 是一个内存数据库，设计目标是高性能、高可用、高可扩展性以及最终一致性。</p>
<h1 id="1、模式"><a href="#1、模式" class="headerlink" title="1、模式"></a>1、模式</h1><h2 id="1-1-集群模式"><a href="#1-1-集群模式" class="headerlink" title="1.1 集群模式"></a>1.1 集群模式</h2><p>Redis 主要有三种集群模式</p>
<ul>
<li>主从复制模式<ul>
<li>主从复制模式是 Redis 最简单的集群模式，包括一个主节点和多个从节点，主节点会负责所有的读写操作，从节点作为主节点的数据副本只能负责读操作，当主节点发生故障时，需要手动将一个从节点升级为主节点，实现故障转移，这种模式主要是为了解决单点故障问题</li>
<li>主从复制模式提供了数据备份功能，简单易用，适用于读多写少的场景，并且具有很好的扩展性，可以通过增加更多的从节点来让集群的读能力不断提升，但是故障转移时需要人工介入，没有容错和恢复机制，任意节点的故障都会导致客户端部分读写请求失败</li>
</ul>
</li>
<li>哨兵模式<ul>
<li>哨兵模式是在主从复制的基础上增加了哨兵节点，哨兵节点是一种特殊的 Redis 节点，用于监控主节点和从节点的状态，当主节点发生故障时，哨兵节点可以自动进行故障转移，即选择一个合适的从节点升级为主节点，并通知其他从节点和应用程序进行更新，这种模式主要是为了解决自动容错和恢复问题</li>
<li>每个 Redis 实例都可以作为哨兵节点，通常需要部署多个哨兵节点来确保故障转移的可靠性，哨兵节点定期向所有主节点和从节点发送 PING 命令，如果在指定时间内未收到 PONG 响应，哨兵节点则将该节点标记为主观下线，如果一个节点被多数哨兵节点标记为主观下线，那么该节点被标记为客观下线</li>
<li>当主节点被标记为客观下线时，哨兵节点会触发故障转移过程，它会从所有健康的从节点中选举一个新的主节点，并将所有从节点切换到新的主节点，哨兵节点可以通过发布订阅功能来通知客户端有关主节点状态变化的消息，客户端收到消息后自行更新配置，将新的主节点信息应用于连接池，实现自动故障转移</li>
</ul>
</li>
<li>Redis Cluster 模式<ul>
<li>Redis Cluster 模式是 Redis 推荐的分布式集群解决方案，会将数据自动划分为多个数据分片，每个分片都有一个主节点和多个从节点，每个节点都可以单独对外提供读写服务，采用主从复制模式来提供高可用性，采用哨兵模式来提供故障转移</li>
<li>数据分片是将整个数据集划分为固定数量（2^14 = 16384）个槽，每个数据都能唯一地被映射到一个槽位上，心跳数据包含了所有的原始槽配置，16384 个槽位大约需要 2K 的空间，Redis Cluster 会将主节点控制在 1000 个以下，并将所有槽位尽量均匀地分给这些主节点（一个主节点可能会负责多个槽）</li>
<li>Redis Cluster 模式是适用于大规模应用的解决方案，能够自动管理数据分片和故障转移，不存在单点故障，减少了运维负担，提供了更好的横向扩展和容错能力，具备高性能、高吞吐量、高可用性以及高数据冗余</li>
</ul>
</li>
</ul>
<p>分布式 Redis 集群默认采用异步复制，即便可以使用 WAIT 命令对特定数据进行同步复制，但 WAIT 仅能确保数据在 Redis 实例中有指定数量的副本被确认，依旧不能将一组 Redis 实例转变为强一致性的分布式系统，因此 Redis 集群无法保证强一致性。</p>
<h2 id="1-2-通信协议"><a href="#1-2-通信协议" class="headerlink" title="1.2 通信协议"></a>1.2 通信协议</h2><ul>
<li>Redis 采用自己设计的一种基于 TCP 协议的文本协议（Redis Serialization Protocol, RESP）进行客户端与服务端之间的通信</li>
<li>RESP 的每条请求命令由多个参数组成，命令名称就是第一个参数，RESP 的请求和响应都以<code>\r\n</code>作为分隔符，简单、高效、易于解析</li>
<li>除了基本的 GET、SET 命令操作，Redis 还支持事务、Lua 脚本、管道等高级功能，这些功能都是基于 RESP 实现的</li>
</ul>
<h2 id="1-3-并发模型"><a href="#1-3-并发模型" class="headerlink" title="1.3 并发模型"></a>1.3 并发模型</h2><ul>
<li>Redis 操作基本都是基于内存的，基本不存在磁盘 I/O，几乎不存在 CPU 资源浪费，无需通过多线程技术来提升 CPU 利用率，因此 Redis 使用复杂度更低的单线程处理数据请求即可，单线程是指 Redis 只有网络请求模块和数据操作模块是单线程的，其他的诸如持久化模块、集群支撑模块等是多线程的）</li>
<li>在单线程的基础上，Redis 还采用 I/O 多路复用来通过单个线程同时处理多个客户端连接，提升了 I/O 利用率，随着业务 QPS 增大，由于 I/O 多路复用本质上是同步阻塞型 I/O，此时，限制 Redis 的性能瓶颈就是网络 I/O</li>
<li>在 Redis 6.0 中，引入了多线程机制来减少了网络 I/O 等待，也更加充分地利用了 CPU 多核优势，该多线程机制仅针对网络请求和网络响应，数据的读写操作仍然是单线程处理的，因此并不会存在并发问题</li>
</ul>
<h2 id="1-4-事务机制"><a href="#1-4-事务机制" class="headerlink" title="1.4 事务机制"></a>1.4 事务机制</h2><ul>
<li>Redis 事务的主要目的是保证多个命令执行的并发原子性，即多个命令操作不可拆分，不会被打断</li>
<li>Redis 事务不支持回滚，在事务执行过程中发生错误会继续执行剩下的命令，因此无法保证数据库事务原子性</li>
<li>不支持回滚是因为回滚会对 Redis 的设计简洁性和使用性能产生重大影响，且 Redis 一般用作缓存，而不是作为需要处理复杂事务的关系型数据库，Redis 的事务执行出错的原因应当是在编码阶段解决的，不应该在执行过程中出现，不应该引入回滚机制来处理执行错误</li>
</ul>
<h2 id="1-5-原子操作"><a href="#1-5-原子操作" class="headerlink" title="1.5 原子操作"></a>1.5 原子操作</h2><ul>
<li>原子性执行 Lua 脚本<ul>
<li>Lua 是一种高效、轻量、小巧、可扩展的脚本语言，可以在多种操作系统上运行，设计目的是嵌入应用程序中，为应用程序提供灵活的扩展和定制功能，在功能上完全可以取代 Shell、Perl</li>
<li>Redis 会将 Lua 脚本封装成一个单独的事务，这个单独的事务在 Redis 服务器运行过程中，新的客户端请求会被暂存起来直到 Lua 脚本处理完毕后才会恢复请求，也就是说 Lua 脚本的执行不可拆分，执行中间不会被其他命令插入</li>
<li>如果 Lua 脚本中的命令产生错误，事务不会回滚，即 Redis 仅保证 Lua 脚本执行的并发原子性，但不保证事务原子性</li>
</ul>
</li>
<li>原子性执行命令<ul>
<li>Redis 中的所有命令都是在主线程中顺序执行的，每个命令在执行时不会被其他命令打断，因此所有命令的执行都可以保证并发原子性</li>
<li>虽然单个命令本身是原子性的，但是在实际应用中，多个命令组合可能会导致数据一致性问题，这种情况下需要通过 Redis 事务或分布式锁来保证数据的一致性</li>
</ul>
</li>
</ul>
<h2 id="1-6-Pipeline-机制"><a href="#1-6-Pipeline-机制" class="headerlink" title="1.6 Pipeline 机制"></a>1.6 Pipeline 机制</h2><p>在没有 Pipeline 时，每执行一个 Redis 命令，客户端都需要等到服务响应之后才能发送下一个命令，这种往返通信在网络延迟较高的环境中会显著影响性能，Redis 的 Pipeline 机制主要用于在单个请求/响应周期内执行多个命令，是一种用于优化网络延迟的技术。</p>
<p>在 Pipeline 模式下，客户端可以一次性发送多个命令到 Redis 服务器，无需等待每个命令的响应，Redis 服务器会依次执行这批命令并一次性返回响应。</p>
<h1 id="2、存储"><a href="#2、存储" class="headerlink" title="2、存储"></a>2、存储</h1><h2 id="2-1-内存管理"><a href="#2-1-内存管理" class="headerlink" title="2.1 内存管理"></a>2.1 内存管理</h2><ul>
<li>Redis 将数据存储在内存中，内存的数据读写本身就比磁盘更快，Redis 还采用一些复杂的内存管理方式，也支持很多内存优化策略</li>
<li>Redis 的虚拟内存机制会在 Redis 使用的内存超过了指定阈值时，将部分不常用的键值对转移到磁盘上，而在需要访问被转移到磁盘上的数据时，又将数据读取到内存中，虚拟内存机制虽然可以节省内存，但同时也会带来一定的性能损失，在实际应用中应该根据具体的应用场景和硬件条件进行调整</li>
<li>Redis 的内存淘汰策略用于在内存满了之后决定哪些 key 被删除，策略如下<ul>
<li>noeviction，不淘汰任何 key，而是直接返回错误信息</li>
<li>allkeys-lru，淘汰最近最少使用的 key</li>
<li>volatile-lru，在设置了过期时间的 keys 中，淘汰最近最少使用的 key</li>
<li>allkeys-random，随机淘汰一个 key</li>
<li>volatile-random，在设置了过期时间的 keys 中，随机淘汰一个 key</li>
<li>volatile-ttl，在设置了过期时间的 keys 中，淘汰剩余时间最短的 key</li>
<li>volatile-lfu，在设置了过期时间的 keys 中，淘汰访问频率最低的 key</li>
<li>allkeys-lfu，淘汰访问频率最低的 key</li>
</ul>
</li>
</ul>
<h2 id="2-2-数据持久化"><a href="#2-2-数据持久化" class="headerlink" title="2.2 数据持久化"></a>2.2 数据持久化</h2><ul>
<li>Redis 通过一些持久化方式（RDB、AOF、混合）来将数据持久化到磁盘上，从而尽可能避免数据丢失</li>
<li>RDB 是将 Redis 的内存中的数据定期保存到磁盘上，以防止数据在 Redis 进程异常退出等情况下丢失，快照文件小、恢复速度快，适合做备份和灾难恢复，但依旧可能会丢数据（最后一次快照之后的数据）</li>
<li>AOF 是将 Redis 所有的写操作追加到 AOF (Append Only File) 文件的末尾，从而记录 Redis 服务器运行期间所有的修改，当 Redis 重启时可以通过执行 AOF 文件中保存的写操作来恢复数据，可以实现更高的数据可靠性，支持更细粒度的数据恢复，适合做数据存档和备份，但文件大占用空间多，每次写操作都需要写磁盘，即写操作负载高</li>
<li>AOF 有三种数据写回策略，分别是 Always（每个写命令执行完立马同步地将日志写回到磁盘）、Everysec（每个写命令执行完先把日志写到 AOF 文件的内存缓冲区，每隔一秒把缓冲区内容写回磁盘）、No（每个写命令执行完先把日志写到 AOF 文件的内存缓冲区，由操作系统决定何时将缓冲区内容写回磁盘）</li>
<li>RDB 和 AOF 混合持久化会在开头将持久化数据以 RDB 的格式写入到 AOF 文件开头，之后的数据再以 AOF 格式化追加到文件末尾，从而结合 RDB 和 AOF 的优点，但会使得 AOF 文件的可读性变差</li>
<li>持久化机制也不是完全可靠的（即便是基于 Always 的 AOF 持久化），并不能完全保证数据不会丢失</li>
</ul>
<h2 id="2-3-数据过期"><a href="#2-3-数据过期" class="headerlink" title="2.3 数据过期"></a>2.3 数据过期</h2><ul>
<li>Redis 通过设置过期时间来控制键值对的生命周期，过期策略采用定期删除和惰性删除相结合的方式</li>
<li>定期删除是指 Redis 默认每隔 100 ms 就随机抽取一些设置了过期时间的 key，将已过期的 key 删除但不会立即释放内存，而是把这些 key 标记为已过期并放入一个专门的链表中，当 Redis 的内存使用率达到一定阈值时，会这些已过期的 key 进行一次内存回收，可以确保过期的 key 能够被及时删除，但是扫描 key 会占用 CPU 资源，可能会影响 Redis 性能</li>
<li>惰性删除是指一个已经过期的 key 并不会被马上删除，而是在访问这个 key 时才会触发删除操作，可以节省 CPU 资源，但是会占用更多内存空间</li>
<li>由于 Redis 并不保证数据在过期时能被立即删除，因此基于过期消息来驱动业务并不靠谱，延迟时间可能会很长，还缺乏对这种过期消息的持久化，可能会直接丢消息，更好的方式参见 4.2 小节</li>
</ul>
<h2 id="2-4-数据结构"><a href="#2-4-数据结构" class="headerlink" title="2.4 数据结构"></a>2.4 数据结构</h2><p>Redis 提供多个数据结构，比如字符串、哈希表、列表、集合、有序集合、地理坐标、Stream 等，这些数据结构都被实现得非常高效，能够在 O(1) 的时间复杂度内完成数据读写</p>
<ul>
<li>字符串<ul>
<li>Redis 本身是通过 C 语言实现的，C 语言中的字符串以<code>\0</code>结尾，这意味着起码无法存储<code>\0</code>字符，C 语言的字符串操作都需要从头开始遍历直到找到<code>\0</code>，操作效率低</li>
<li>考虑到字符串在 Redis 中使用非常广泛，并且需要非常高效地支持任意字符的存储，Redis 并没有直接使用 C 语言中的字符数组的方式来实现字符串，而是自己实现了一个 Simple Dynamic Strings (SDS)</li>
<li>为了解决 C 语言中的字符串的问题，Redis 在字符串中增加一个表示分配给该字符数组的总长度的<code>alloc</code>字段和一个表示字符串现有长度的<code>len</code>字段，在做追加操作时如果<code>len</code>超过<code>alloc</code>则重新再申请新空间</li>
</ul>
</li>
<li>哈希表<ul>
<li>Redis 通过渐进式 rehash 实现哈希表的扩容，这种渐进式 rehash 会分多个步骤逐渐完成扩容，期间可以继续提供读写服务，不会由于一次性扩容和大量元素迁移导致线程阻塞并对性能造成影响</li>
<li>Redis 哈希表底层使用了两个全局哈希表（表1 和表 2），并维护一个初始值为 -1 的下标来记录 rehash 的下标位置，当开始向 Redis 哈希表中插入数据时，底层只使用一个哈希表（表 1），随着数据增多，底层将另一个哈希表（表 2）容量扩大一倍，并在后续有对 Redis 哈希表的增删改查操作时，就将表 1 的 rehash 下标位置的桶中的数据迁移到表 2 中，并将 rehash 下标加一自增，然后对表 2 进行相应的操作，直到表 1 中的元素全部迁移完成后互换表 1 和表 2 指针</li>
</ul>
</li>
<li>有序集合<ul>
<li>ZSet（也称为 Sorted Set）内部维护了一个有序字典，这个字典的元素中既包括了一个成员，也包括了一个分值，这种结果可以帮助用户实现记分类型的排行榜数据</li>
<li>ZSet 的实现有压缩列表 ZipList 和跳跃表 SkipList，在 Redis 5.0 中新增了一个紧凑列表 ListPack，ListPack 通过连续存储元素来节约内存空间，ListPack 就是为了代替 ZipList，在 Redis 7.0 中已经彻底不再使用 ZipList</li>
<li>SkipList 使用了跳表（带多级索引的有序链表）和字典（哈希表），每个元素按照其分值大小在跳表中进行排序，跳表的插入、删除和查找的时间复杂度都是 O(logn)，哈希表用来实现元素到分值的映射关系（元素作为键，分值作为值），哈希表的插入、删除和查找的时间复杂度都是 O(1)，可以保证比较好的性能</li>
<li>当 ZSet 的元素数据比较少时（元素数量少于 128，每个元素长度都小于 64 字节），Redis 会采用 ListPack 来存储，当 ZSet 的元素增多时，Redis 会自动将 ListPack 转换为 SkipList，以保持元素的有序性并支持范围查询，这个过程中 Redis 会遍历 ListPack 中所有元素，按照元素的分数值依次将它们插入到 SkipList 中</li>
</ul>
</li>
<li>Stream<ul>
<li>Redis Stream 是 Redis 5.0 中新增的数据结构，可以被视为一个消息队列（在 Redis 5.0 之前，可以通过 Redis 的发布订阅（pub/sub）实现消息队列，但是这种方式无法进行消息持久化，一旦出现网路断开、Redis 宕机等，消息就会被丢弃）</li>
<li>Stream 底层采用类似于日志的数据结构，每个 Stream 都是由一个或多个日志实现的，每个日志包含多个消息，每个消息都有一个唯一 ID 和一些附加字段（消息体、时间戳等），并且按照添加的顺序进行排序，可以向 Stream 中添加消息、读取消息、删除消息以及订阅消息</li>
<li>Stream 主要用于处理有序的、可追溯的消息流，提供了消息的持久化、主备复制、消息分组以及消费者分组等功能，可以让多个消费者并发地处理消息流，支持竞争式消费和共享式消费</li>
<li>基于 Stream 的消息队列一般用于实时消息传递和事件驱动的应用程序中，例如即时通讯、日志处理、实时数据更新、缓存刷新等</li>
</ul>
</li>
</ul>
<h2 id="2-5-键值对设计"><a href="#2-5-键值对设计" class="headerlink" title="2.5 键值对设计"></a>2.5 键值对设计</h2><p>在设计 Redis 的 key 和 value 时，应当以数据存储和检索效率为原则进行设计</p>
<ul>
<li>设计 key<ul>
<li>具备良好的可读性和简洁性，尽量使用短且有意义的 key（过长的 key 太占用内存空间）</li>
<li>避免在 key 中使用特殊字符，命名中尽量只包含大小写字母、数字、竖线、下划线、英文句点和英文冒号</li>
<li>使用命名空间前缀来区分不同部分的 key</li>
</ul>
</li>
<li>设计 value<ul>
<li>根据数据的特性选择合适的数据结构，从而提高操作效率</li>
<li>尽量将大数据分割为多个小 value，避免大 key，从而提高性能和降低内存使用</li>
<li>设置适当的过期时间，从而降低内存使用</li>
<li>尽量先对数据进行压缩再存储，从而降低内存使用</li>
</ul>
</li>
</ul>
<h1 id="3、问题"><a href="#3、问题" class="headerlink" title="3、问题"></a>3、问题</h1><h2 id="3-1-热-Key-问题"><a href="#3-1-热-Key-问题" class="headerlink" title="3.1 热 Key 问题"></a>3.1 热 Key 问题</h2><p>当使用 Redis 作为存储时，如果在某个时间段内，突发大量针对某一个 key 的访问，就会使得流量集中在一些极少数的物理资源上，这就是热 key 问题，针对这一问题的主要处理方式如下</p>
<ul>
<li>事前预测一些可能性热 key，在客户端、服务端或者代理层实时的统计一些可能性热 key</li>
<li>针对热 key 加分片或者加后缀来将一个热 key 拆分成多个 key，令请求尽可能分散到不同机器上</li>
<li>针对热 key 加缓存，令用户请求尽可能提前返回，减少系统交互，减少用户的访问链路长度</li>
<li>缓存多了就成为了多级缓存，注意不要使用单个缓存服务器，而是使用缓存服务器集群</li>
</ul>
<h2 id="3-2-大-Key-问题"><a href="#3-2-大-Key-问题" class="headerlink" title="3.2 大 Key 问题"></a>3.2 大 Key 问题</h2><p>大 key 是指 Redis 中存储了大量数据的 key，这个 key 对应的 value 占用空间很大，通常在字符串、列表、集合等类型出现的比较多，大 key 不仅占用内存，影响性能，还会使得多个服务节点之间的内存使用不均匀，影响 Redis 备份、迁移和恢复，关于大 key 的搜索会更加困难，大 key 数据的过期删除也比较耗时，针对大 key 问题的主要处理方式如下</p>
<ul>
<li>有选择地删除一些访问频率低的大 key，或者为大 key 设置合理的缓存 TTL</li>
<li>将大 key 拆分为多个小一些的 key，或者通过 Redis Cluster 模式将大 key 分散到不同服务节点上</li>
<li>将大 key 放在单独的数据库中，方便实现对大 key 的针对性部分迁移</li>
</ul>
<h2 id="3-3-缓存击穿"><a href="#3-3-缓存击穿" class="headerlink" title="3.3 缓存击穿"></a>3.3 缓存击穿</h2><p>缓存击穿指当某个访问频率比较高的 key 的缓存过期后大量并发请求同时访问该 key 时，就会瞬间击穿缓存服务器直接访问数据库，令数据库负载过高</p>
<ul>
<li>可以通过定时任务在 key 临近过期时去更新这个 key 的数据并重新设置过期时间</li>
<li>可以在发现缓存中的数据为 NULL 时先获取互斥锁，再去从数据库加载数据，数据加载到缓存之后再释放锁，期间其他针对该 key 的请求都被阻塞直到数据被加载缓存中</li>
</ul>
<h2 id="3-4-缓存穿透"><a href="#3-4-缓存穿透" class="headerlink" title="3.4 缓存穿透"></a>3.4 缓存穿透</h2><p>缓存穿透指服务器缓存和数据库中都没有符合条件的数据，业务系统每次都绕过缓存服务器查询下游数据库，缓存完全失去了应有的作用</p>
<ul>
<li>缓存穿透很多时候是由大量随机生成 key 的恶意请求导致的（随机生成的 key 肯定是缓存和数据库中都没有的）</li>
<li>可以通过缓存空值来直接返回 NULL，避免频繁访问数据库，但这个 NULL 值一定要设置过期时间</li>
<li>可以通过布隆过滤器来过滤那些针对一定不存在的 key 的请求，布隆过滤器是 Redis 提供的一种概率性数据结构，可以高效地检测一个元素是否存在于一个集合中，占用内存少</li>
</ul>
<h2 id="3-5-缓存雪崩"><a href="#3-5-缓存雪崩" class="headerlink" title="3.5 缓存雪崩"></a>3.5 缓存雪崩</h2><p>缓存雪崩是指大量缓存同时过期或者缓存服务宕机，所有请求都直接访问数据库，令数据库负载过高</p>
<ul>
<li>可以尽量给大量 key 设置不同的过期时间，避免都在同一时间过期，并通过定时任务定时刷新数据并重新设置过期时间</li>
<li>可以采用集群方式部署缓存，避免单点缓存故障</li>
</ul>
<h2 id="3-6-缓存和数据库不一致"><a href="#3-6-缓存和数据库不一致" class="headerlink" title="3.6 缓存和数据库不一致"></a>3.6 缓存和数据库不一致</h2><p>数据库更新操作和缓存更新操作这两步操作之间是无法确保没有其他线程进行操作的（即操作原子性无法保证），一旦多线程并发更新数据库和缓存，就会导致缓存和数据库数据不一致。</p>
<p>可以通过延迟双删来更新数据并保证缓存和数据库之间的数据一致性</p>
<ul>
<li>延迟双删指先删除缓存，再更新数据库，最后再删除缓存，优先考虑删除缓存而不是更新缓存，这样处理更加简单且不容易出错</li>
<li>更新数据库之间如果没有删除缓存，那么如果在数据库更新之后的缓存删除失败了，后续通过缓存拿到的数据就都是错误的，所以先确保缓存已经删除了，再去更新数据库</li>
<li>更新数据库之后如果没有删除缓存，那么如果在数据库更新期间存在其他请求通过读操作顺便地将更新之前的数据再加载回缓存，后续通过缓存拿到的数据依旧都是错误的，所以在数据库更新之后再重新删一次缓存，确保缓存中没有脏数据</li>
<li>更新数据库之后的缓存删除也可以改成借助数据库 BinLog，订阅到数据库变更消息之后异步地删除缓存</li>
</ul>
<h2 id="3-7-缓存集群之间不一致"><a href="#3-7-缓存集群之间不一致" class="headerlink" title="3.7 缓存集群之间不一致"></a>3.7 缓存集群之间不一致</h2><p>即便使用集群模式，依旧可能出现主节点在数据还未同步到其他从节点时发生故障，后续新选出的主节点并不具备和原主节点一致的数据</p>
<ul>
<li>数据丢失<ul>
<li>数据丢失是数据不一致的一种情况，比如基于 Redis 集群的分布式锁就可能无法顺利在节点间同步已经被获取的锁，进而发生锁丢失</li>
<li>红锁（RedLock）是 Redis 提出的一个多节点分布式锁算法，旨在解决单节点 Redis 分布式锁可能存在的单点故障和锁丢失问题</li>
<li>RedLock 在进行加锁操作时，RedLock 会向每个 Redis 节点发生相同的命令请求，每个节点都会去竞争锁，如果在大多数节点上成功获取了锁，那么就认为加锁成功，从而避免主节点故障又未能及时将锁同步到其他节点的情况</li>
<li>RedLock 并没有完全解决 Redis 分布式锁的问题，在脑裂的情况下可能会出现多个客户端同时持有锁</li>
</ul>
</li>
<li>脑裂<ul>
<li>脑裂是网络分区故障的一种具体表现，也是数据不一致的一种导致原因，是指集群中的出现多个节点都认为自己是主节点，进而导致数据不一致、数据丢失、重复写入等问题，一般发生在网络中断或主节点出现问题的时候</li>
<li>网络中断和主节点故障都是可能导致脑裂的原因，网络故障或网络分区会导致集群不同子集之间的网络通信中断，进而导致一部分节点被划分到了单独的一个网络中，这部分节点找不到主节点就会重新选出一个新的主节点，集群中就出现了多个主节点；主节点出现问题后又快速恢复了，这期间有部分从节点又重现选出了新的主节点，集群中就出现了多个主节点</li>
<li>Redis 可以通过配置来尽量规避脑裂问题，但无法彻底杜绝</li>
</ul>
</li>
<li>时间漂移<ul>
<li>时间漂移也是数据不一致的一种导致原因，是指不同的机器之间的时间可能存在微小的不一致，进而导致分布式系统的数据不一致（比如锁失效时间不一致，然后有的 Redis 已经解锁并使得新的客户端能够获取到的锁）</li>
<li>RedLock 可以使用 NTP 等工具来同步不同机器之间的事件，尽量避免时间漂移</li>
</ul>
</li>
</ul>
<h2 id="3-8-使用注意"><a href="#3-8-使用注意" class="headerlink" title="3.8 使用注意"></a>3.8 使用注意</h2><ul>
<li>避免使用 KEYS 命令获取所有 key，该命令会遍历所有 key，可能会长时间阻塞 Redis 主线程</li>
<li>避免使用 FLUSHALL 或 FLUSHDB 命令清空 Redis，这会清空所有数据库中的所有数据，不仅仅是当前数据库</li>
<li>对于写操作频繁的数据，可以使用哈希表结构（可以做部分更新，减少网络传输数据量），并考虑使用 Redis 持久化机制进行数据持久化，以保证数据可靠性</li>
<li>避免在 Lua 脚本中使用死循环，这会导致 Redis 主线程被无限阻塞</li>
<li>避免在 Redis 实例上进行复杂的计算逻辑，这会导致 Redis 主线程被阻塞</li>
<li>对于高并发场景，可以使用 Redis 的分布式锁机制</li>
<li>对于高可用场景，可以使用 Redis Cluster 进行搭建</li>
</ul>
<h1 id="4、应用"><a href="#4、应用" class="headerlink" title="4、应用"></a>4、应用</h1><p>Redis 的主要应用有缓存、消息队列、延迟消息队列、分布式锁、分布式限流、分布式 Session、排行榜、地理位置应用，布隆过滤器等。</p>
<h2 id="4-1-消息队列"><a href="#4-1-消息队列" class="headerlink" title="4.1 消息队列"></a>4.1 消息队列</h2><ul>
<li>Redis 的发布订阅（pub/sub）机制<ul>
<li>无法进行消息持久化，一旦出现网路断开、Redis 宕机等，消息就会被丢弃，在高频次请求下性能表现较差</li>
</ul>
</li>
<li>Redis Stream<ul>
<li>Redis Stream 是 Redis 5.0 中新增的数据结构，可以被视为一个消息队列</li>
<li>Stream 底层采用类似于日志的数据结构，每个 Stream 都是由一个或多个日志实现的，每个日志包含多个消息，每个消息都有一个唯一 ID 和一些附加字段（消息体、时间戳等），并且按照添加的顺序进行排序，可以向 Stream 中添加消息、读取消息、删除消息以及订阅消息</li>
<li>Stream 主要用于处理有序的、可追溯的消息流，提供了消息的持久化、主备复制、消息分组以及消费者分组等功能，可以让多个消费者并发地处理消息流，支持竞争式消费和共享式消费</li>
<li>基于 Stream 的消息队列一般用于实时消息传递和事件驱动的应用程序中，例如即时通讯、日志处理、实时数据更新、缓存刷新等</li>
</ul>
</li>
</ul>
<h2 id="4-2-延迟消息队列"><a href="#4-2-延迟消息队列" class="headerlink" title="4.2 延迟消息队列"></a>4.2 延迟消息队列</h2><ul>
<li>数据过期监听机制<ul>
<li>由于 Redis 并不保证数据在过期时能被立即删除，更不保证过期消息能够被立即发出，因此基于过期消息来驱动业务并不靠谱，延迟时间可能会很长，还缺乏对这种过期消息的持久化，可能会直接丢消息</li>
</ul>
</li>
<li>有序集合 ZSet<ul>
<li>将超时时间设置为元素的分值 score，Redis 会对 ZSet 按照 score 进行排序，然后再开启 Redis 扫描任务获取当前时间超过 score 的元素从而驱动相关业务操作</li>
<li>基于 ZSet 的延迟消息队列可以借助 Redis 的持久化、高可用机制来避免数据丢失，但是需要基于 ZSet 来自行编写代码，且在高并发场景下可能会出现重复消息</li>
</ul>
</li>
<li>Redission<ul>
<li>Redisson 是一个基于 Redis 的 Java 客户端框架，提供了分布式延迟队列 RDelayedQueue（底层就是 ZSet），允许以指定的延迟时长将元素放入队列中并起一个延时任务，任务到期时会将元素取出来返回给客户端使用</li>
<li>Redisson 的 RDelayedQueue 可以解决 ZSet 中的消息重复问题，使用简单，稳定性和性能都比较好</li>
</ul>
</li>
</ul>
<h2 id="4-3-分布式锁"><a href="#4-3-分布式锁" class="headerlink" title="4.3 分布式锁"></a>4.3 分布式锁</h2><ul>
<li>SETNX<ul>
<li>多个 Redis 客户端同时通过 SETNX 命令尝试获取锁，Redis 的单线程特性会确保只有一个客户端可以获取锁成功</li>
<li>获取到锁的客户端宕机重启后无法释放锁，因此请求锁的同时也应当设置一个过期时间来确保锁一定会被释放，避免死锁，但是过长的过期时间会影响分布式锁的并发性能</li>
<li>如果需要支持可重入，则需要在获取锁时通过一个全局唯一标识来识别特定线程，根据这个标识来判断尝试获取锁的线程是否已经持有了锁，并额外维护一个重入次数的字段</li>
<li>这种方式实现的分布式锁使用简单，便于理解，性能较高，但锁无法续期，可能会出现死锁（如果没有设置过期时间的话）</li>
</ul>
</li>
<li>Redisson<ul>
<li>Redisson 提供了包括分布式锁功能，支持分布式锁的可重入、公平锁、联锁、读写锁、阻塞或非阻塞以及 RedLock 等</li>
<li>Redisson 引入看门狗机制来在 Redisson 实例运行期间不断延长锁的有效期直到释放锁（这个后台任务是基于 JVM 运行的），如果在加锁时指定了超时时间则不会续期，如果 Redis 线程中断、服务宕机下线等则会停止续期</li>
</ul>
</li>
</ul>
<h2 id="4-4-分布式限流"><a href="#4-4-分布式限流" class="headerlink" title="4.4 分布式限流"></a>4.4 分布式限流</h2><p>滑动窗口是一种流量控制策略，窗口会随着时间推移而不断滑动，在窗口内允许的操作数量是固定的，用于控制一定时间内允许执行的操作数量或请求频次，这种平滑地控制流量而不是简单地设置固定的请求次数或速率，可以使得系统更加灵活地应对突发流量，不会为固定速率的限制而浪费资源或降低系统性能。</p>
<p>Redis 可以通过 ZSet 在每一次接收到请求时记录下请求的时间戳和请求的数据，但只记录特定时间窗口内的请求，丢弃窗口之外的请求。</p>
<h2 id="4-5-布隆过滤器"><a href="#4-5-布隆过滤器" class="headerlink" title="4.5 布隆过滤器"></a>4.5 布隆过滤器</h2><p>布隆过滤器是一种快速检索元素是否可能存在于一个集合中的数据结构，可以在空间和时间上实现比较高的效率</p>
<ul>
<li>基本原理是利用多个哈希函数将一个元素映射成多个位并将这些位设为 1，当查询一个元素是否存在时，如果该元素所对应的比特位均为 1，则该元素可能存在于集合中，否则则可能不存在</li>
<li>由于哈希冲突无法确定判断一定存在，只能判断可能存在和一定不存在，可以通过降低哈希冲突以及引入更多的哈希算法来将降低误判的概率。此外，在删除元素时可能会影响到其他元素</li>
</ul>
<p>布隆过滤器的典型应该场景有</p>
<ul>
<li>网页爬虫程序使用布隆过滤器来过滤已经爬取过的网页，避免重复爬取和资源浪费</li>
<li>缓存系统使用布隆过滤器判断一个查询是否可能存在于缓存中，从而提高查询效率，也经常用来解决缓存穿透的问题</li>
<li>黑名单过滤器使用布隆过滤器来判断用户是否存在于黑名单中，从而阻止恶意请求</li>
</ul>
<p>Java 可以使用 Google Guava 库、Apache Commons 库以及 Redis 来实现布隆过滤器</p>
<h1 id="5、补充"><a href="#5、补充" class="headerlink" title="5、补充"></a>5、补充</h1><h2 id="5-1-不同缓存类型"><a href="#5-1-不同缓存类型" class="headerlink" title="5.1 不同缓存类型"></a>5.1 不同缓存类型</h2><ul>
<li><p>本地缓存</p>
<ul>
<li>将数据存储在单个应用程序的内存中，访问速度快、易于使用和管理，但不能跨多个节点共享缓存，存在一致性问题使其无法用于集群环境，适合单个应用程序的性能优化</li>
<li>为了提升缓存的效率，本地缓存通常采用 Key-Value 结构进行数据存储，本地缓存作为一个全局可访问的变量，需要考虑线程安全问题，本地缓存会占用 JVM 堆内存，需要考虑存储空间问题、过期时间和清除策略</li>
<li>推荐使用的比较成熟的本地缓存框架是 Caffeine，Caffeine 是 Spring 5 中默认支持的本地缓存，采用 W-TinyLFU 缓存失效算法，性能良好，支持异步 Cache，很多工作都是交由线程池去做的，支持写入外部资源</li>
</ul>
</li>
<li><p>分布式缓存</p>
<ul>
<li>将数据存储在多个节点的内存中，这些节点可以在不同的服务器，甚至是不同的地理位置上，可以支持多个应用程序共享数据，提高系统的可伸缩性和可用性，管理和维护成本较高，需要考虑数据一致性和故障恢复等问题</li>
<li>Redis 就是一个分布式缓存框架</li>
</ul>
</li>
<li><p>多级缓存</p>
<ul>
<li>多级缓存是比较常见的一种性能优化手段，一般就是本地缓存加上分布式缓存，优先查询本地缓存，如果本地缓存中查不到，再查询分布式缓存并将其保存到本地缓存，多级缓存的问题在于缓存数据一致性</li>
<li>一般是将变化不频繁且能够接受一定程度的不一致的数据考虑放到本地缓存中（变化频繁的数据会带来严重的一致性问题，和本地缓存的思想是相悖的），基于业务能够接受的不一致时长来设置本地缓存的失效时长</li>
</ul>
</li>
<li><p>近端缓存</p>
<ul>
<li>通常是指位于网络边缘、距离用户位置更近的缓存，用于在网络上尽可能快地向用户提高内容，减少用户请求的响应时间和带宽占用，典型例子是 CDN，详细参见 <a href="../../../../2023/11/06/computer-networking/">Computer Networking</a> 的 2.5 小节</li>
<li>由于应用服务器比分布式缓存距离用户也更近一些，因此和应用服务器部署在一起的本地缓存也可以称为近端缓存</li>
</ul>
</li>
</ul>
<h2 id="5-2-缓存失效算法"><a href="#5-2-缓存失效算法" class="headerlink" title="5.2 缓存失效算法"></a>5.2 缓存失效算法</h2><p>当缓存中存储地对象过多时，需要通过缓存失效算法选择出需要被淘汰的对象，常见的缓存失效算法如下</p>
<ul>
<li>FIFO<ul>
<li>选择最先进行缓存的数据，使用队列，淘汰队头</li>
</ul>
</li>
<li>LRU<ul>
<li>选择最久没有被访问的数据，可以使用链表，每次访问缓存数据后将其移动到链表头部，淘汰链表尾部</li>
<li>在 Redis、Memcached 中有被广泛使用</li>
</ul>
</li>
<li>LFU<ul>
<li>选择最小频率被访问的数据，可以对每个缓存数据块进行引用计数，具有相同计数的数据块则按照时间排序，淘汰排序后末尾的数据块</li>
<li>通常能够实现最佳的缓存命中率，但需要给每个缓存数据块维护频率信息，每次访问缓存都需要更新，需要较大的空间，时间性能也较差</li>
<li>无法很好的清除那种早期访问频率很高，后期不再访问的数据，也容易淘汰刚刚加入缓存的数据块</li>
</ul>
</li>
<li>W-TinyLFU<ul>
<li>是基于窗口（W 就是 Window）的近似虽少使用算法，根据数据的访问模式动态地调整缓存中数据的淘汰策略，综合了 LRU 和 LFU 的长处，高命中率、低内存占用，是一种高效的缓存淘汰算法，主要用于处理大规模缓存系统中的淘汰问题</li>
<li>使用 LRU 作为窗口缓存，让数据块能够有机会在窗口缓存中积累它的频率，避免淘汰刚刚加入缓存的低频数据，使用 SLRU 作为主缓存，数据块被挤出窗口缓存时，会在过滤器和主缓存中最容易被淘汰的数据块进行竞争，如果频率大于主缓存中最低频的数据块，才能进入主缓存</li>
</ul>
</li>
</ul>
]]></content>
  </entry>
  <entry>
    <title>Remote Procedure Call</title>
    <url>/2024/02/21/rpc/</url>
    <content><![CDATA[<h1 id="RPC"><a href="#RPC" class="headerlink" title="RPC"></a>RPC</h1><p>远程过程调用（Remote Procedure Call，RPC）的调用方和被调用方是位于不同独立系统上的进程，调用请求和响应需要通过网络通信来传输。</p>
<p>注：泛化调用是指在没有服务提供方提供的 API 时，调用方对服务进行调用，并且可以拿到调用结果，一般在测试集成工具、网关服务中较多使用泛化调用。</p>
<h2 id="RPC-框架"><a href="#RPC-框架" class="headerlink" title="RPC 框架"></a>RPC 框架</h2><p>RPC 框架使得这个网络远程通信过程对调用方和被调用方来说是透明的，双方都感觉调用就好像发生在自己本地一样。</p>
<p>RPC 框架中主要有 Provider、Consumer、Registry 这三个角色，Provider 在启动后主动向 Registry 注册机器 IP、Port 以及提供的服务列表， Consumer 在启动后向 Registry 获取所需服务的 Providers 列表。</p>
<p>RPC 框架涉及到的相关技术如下</p>
<ul>
<li><p>Java 动态代理，一般通过代理来处理远程调用交互，开发者无需关心如何远程调用，只需要专注业务</p>
</li>
<li><p>序列化，为了能够在网络上传输和接收 Java 对象，需要对对象进行序列化和反序列化</p>
</li>
<li><p>NIO，一般选择 Netty 作为底层 I/O 通信框架</p>
</li>
<li><p>服务注册中心，可以选择 Redis、Zookeeper、Consul、Etcd</p>
</li>
</ul>
<h2 id="RPC-和-HTTP"><a href="#RPC-和-HTTP" class="headerlink" title="RPC 和 HTTP"></a>RPC 和 HTTP</h2><p>RPC 通常需要包含传输协议和序列化协议的实现，HTTP 就是一种传输协议（详细见 <a href="../../../../2023/11/06/computer-networking/">Computer Networking</a> 的 2.2 小节）</p>
<ul>
<li><p>RPC 可以基于 TCP 协议来实现，也可以直接基于 HTTP 协议来实现</p>
</li>
<li><p>RPC 允许更加深层次的定制和优化，HTTP 的定制能力则较低</p>
</li>
<li><p>RPC 的设计目的就是用于高效的内部服务通信，HTTP 的设计目的是更加通用的传输协议</p>
</li>
<li><p>RPC 可以像直接调用本地方法一样调用远程代码，使用方便，而 HTTP 调用需要拼接复杂的报文（Header、Body）</p>
</li>
<li><p>不是所有编程语言和操作系统都支持相同的 RPC 协议，HTTP 是一种几乎所有的编程语言和操作系统都支持的通用协议</p>
</li>
<li><p>RPC 采用更加紧凑的数据格式，使用更加轻量高效的序列化协议，可以更加有效地利用网络带宽和存储空间，在传输效率上通常比 HTTP 更高，HTTP 在灵活性和可访问性上进行了优化，而不是仅仅专注于性能</p>
</li>
<li><p>RPC 主要用于公司内部服务之间的互相调用，性能消耗低，传输效率高，服务治理方便，网络交互链路短，HTTP 主要用于对外的跨语言和跨平台的异构环境，公网通信的一次交互可能需要经过较多的中间节点</p>
</li>
</ul>
<h1 id="Dubbo"><a href="#Dubbo" class="headerlink" title="Dubbo"></a>Dubbo</h1><p>Dubbo 是阿里开源的一个 Java 高性能 RPC 框架，可以和 Spring 框架无缝集成，可以支持<a href="https://www.yuque.com/hollis666/niq4hm/lkqnmplc1rz02zmi">多种调用协议</a>。</p>
<h2 id="Dubbo-架构"><a href="#Dubbo-架构" class="headerlink" title="Dubbo 架构"></a>Dubbo 架构</h2><ul>
<li><p>config 配置层，对外配置接口</p>
</li>
<li><p>proxy 服务代理层，将远程调用透明化</p>
</li>
<li><p>registry 注册中心层，封装服务地址的注册与发现</p>
</li>
<li><p>cluster 路由层，封装多个服务提供者的路由及负载均衡，并桥接注册中心</p>
</li>
<li><p>monitor 监控层，监控 RPC 调用次数和调用时间</p>
</li>
<li><p>protocol 远程调用层，封装 RPC 调用</p>
</li>
<li><p>exchange 信息交换层，封装请求响应模式</p>
</li>
<li><p>transport 网络传输层</p>
</li>
<li><p>serialize 数据序列化层</p>
</li>
</ul>
<h2 id="远程调用过程"><a href="#远程调用过程" class="headerlink" title="远程调用过程"></a>远程调用过程</h2><p>一次完整的远程服务调用分为服务注册、服务发现和服务调用三个过程</p>
<ul>
<li><p>服务注册</p>
<ul>
<li><p>服务提供者在启动时向注册中心注册自己提供的服务以及服务相关的信息（名称、版本号、IP 地址、端口号、协议、权重等）</p>
</li>
<li><p>Dubbo 支持多种注册中心，如 Redis、Zookeeper 、Nacos 等</p>
</li>
<li><p>在使用 Redis 时，会通过 Redis 的消息订阅发布机制来实现服务注册和发现</p>
</li>
<li><p>在使用 Zookeeper 时，会通过 Zookeeper 的 watch 机制来监听服务提供者列表的变化</p>
</li>
</ul>
</li>
<li><p>服务发现</p>
<ul>
<li><p>服务消费者在启动时需要向注册中心订阅自己所需的服务</p>
</li>
<li><p>服务消费者通过注册中心来获取服务提供者列表</p>
</li>
<li><p>服务提供者列表发生变化时注册中心会主动通知服务消费者进行变更</p>
</li>
</ul>
</li>
<li><p>服务调用</p>
<ul>
<li><p>Dubbo 使用动态代理技术生成一个代理类，该代理类实现了本地接口，在调用本地接口方法时，该代理类会将参数封装成请求消息</p>
</li>
<li><p>Dubbo 会将请求进行序列化，通过网络传输将请求转发到远程服务提供者并接收请求返回的响应，Dubbo 将返回值进行反序列化</p>
</li>
<li><p>Dubbo 支持多种序列化协议，如 Hessian、Java 原生的序列化、JSON 等，以适应不同性能和兼容性</p>
</li>
<li><p>Dubbo 支持多种网络通信协议，如 Dubbo 协议、HTTP 协议、Hessian 协议等</p>
</li>
<li><p>Dubbo 支持不同的通信模式，可以使用长连接或短连接模式，可以使用 Netty 等其他高性能的通信框架，还可以设置心跳来保持连接的稳定性</p>
</li>
<li><p>Dubbo 支持多种路由策略来实现负载均衡，包括随机路由、轮询路由、一致性哈希路由等，根据路由规则可以将服务请求路由到指定的服务提供者上</p>
</li>
<li><p>Dubbo 会对服务调用进行监控，包括调用次数、调用时间、响应时间、异常次数、异常信息等</p>
</li>
</ul>
</li>
</ul>
<h2 id="缓存机制"><a href="#缓存机制" class="headerlink" title="缓存机制"></a>缓存机制</h2><p>Dubbo 支持服务端结果缓存和客户端结果缓存，Dubbo 缓存机制的主要作用在于缓存服务调用的响应结果，减少重复调用，提高调用性能，但注意缓存导致的数据不一致问题。</p>
<ul>
<li><p>服务端结果缓存可以提高响应速度和系统吞吐量，实现方式如下</p>
<ul>
<li><p>LRU Cache，缓存空间不足时会基于 LRU 算法来清除最近最少使用的缓存</p>
</li>
<li><p>Thread Local Cache，每个线程都拥有一个缓存实例，缓存结果只对当前线程可见</p>
</li>
<li><p>Concurrent Map Cache，基于 ConcurrentMap 实现的缓存，支持并发读写，效率较高</p>
</li>
</ul>
</li>
<li><p>客户端结果缓存可以降低系统负载，实现方式如下</p>
<ul>
<li><p>LRU Cache，缓存空间不足时会基于 LRU 算法来清除最近最少使用的缓存</p>
</li>
<li><p>Thread Local Cache，每个线程都拥有一个缓存实例，缓存结果只对当前线程可见</p>
</li>
</ul>
</li>
</ul>
<h2 id="优雅下线"><a href="#优雅下线" class="headerlink" title="优雅下线"></a>优雅下线</h2><ul>
<li><p>在操作系统层面，不建议使用<code>kill -9</code>来强硬结束进程，更优雅的方式是<code>kill -15</code>在下线之间进行一些收尾动作处理</p>
</li>
<li><p>在容器层面，Docker 提供了类似<code>kill -9</code>的<code>docker kill</code>和类似<code>kill -15</code>的<code>docker stop</code></p>
</li>
<li><p>在 JVM 层面，JVM 提供了类似<code>kill -9</code>的强制关闭、类似<code>kill -15</code>的正常关闭（JVM 可以做一些清理动作）以及异常关闭，此外，开发者也可以基于 JDK 的 shutdown hook 来自定义一些清理动作</p>
</li>
<li><p>在 Spring 层面，Spring 提供了事件机制来监听 Spring 容器的关闭事件并做一些特殊的处理（本质也是 JDK 的 shutdown hook）</p>
</li>
</ul>
<p>Dubbo 基于 Spring 的事件机制完成优雅停机</p>
<ul>
<li><p>服务提供方在应用下线时，先标记为不接受新请求（如果有请求过来直接报错），然后检测线程池中是否有正在运行的线程，等待正在运行的线程执行完毕</p>
</li>
<li><p>服务消费方在应用下线时，不再发起新的调用请求，然后检测是否存在还未返回的远程请求，等待未返回的远程请求返回</p>
</li>
</ul>
]]></content>
  </entry>
  <entry>
    <title>Operating Systems</title>
    <url>/2023/08/20/operating-systems/</url>
    <content><![CDATA[<h1 id="1、引言"><a href="#1、引言" class="headerlink" title="1、引言"></a>1、引言</h1><p><strong>程序</strong>最初以某个可执行格式驻留在磁盘上，是存在磁盘上面的一些指令和静态数据。<strong>程序运行之前</strong>首先需要操作系统从磁盘上读取这些字节，将代码和所有静态数据/初始化变量加载到内存中，接着为程序的运行时栈分配一些内存（也可能为堆分配一些内存，堆可能会随着程序运行变大），并执行一些与 I/O 相关的初始化任务，最后启动程序，在入口（<code>main()</code>）处令程序开始运行。<strong>程序运行</strong>其实意味着执行指令，执行指令意味着 CPU 从内存中获取一条指令，对这条指令进行解码，然后执行它，然后执行下一条指令，直到程序运行完成。</p>
<p>操作系统令程序运行起来，并将这种运行中的程序及其访问的系统的部分概括抽象为<strong>进程</strong>，操作系统创建了第一个进程（称为 init 进程）来启动系统中所有其他进程。<strong>程序启动时</strong>操作系统会在虚拟内存中给新进程分配一块专有区域来存储该进程用到的数据和代码，并将 CPU 的控制权转移到新创建的进程中，进程的机器状态指进程可以读取或更新的内容（由内存、寄存器以及持久存储设备组成），进程可以访问的内存是该进程的地址空间。</p>
<ul>
<li>进程可以处于以下这五种状态<ul>
<li>初始（initial），进程在创建时处于状态</li>
<li>就绪（ready），进程已准备好运行，但未获得 CPU 时间片</li>
<li>运行（running），进程获得 CPU 时间片，正在执行指令</li>
<li>阻塞（blocked），进程执行了某种操作，但需要等待操作完成，比如硬盘 I/O</li>
<li>最终/僵尸（final），进程已退出但尚未清理</li>
</ul>
</li>
<li>现代操作系统提供以下进程 API<ul>
<li>创建：创建新进程，运行指定的程序</li>
<li>销毁：很多进程会在运行完成后自行退出，但是对于失控的进程，用户可以强制销毁</li>
<li>等待：等待进程停止运行</li>
<li>其他控制：比如暂停正在运行的进程，恢复暂停的进程等</li>
<li>状态：获得有关进程的状态信息</li>
</ul>
</li>
<li>常见的进程间通信方式如下<ul>
<li>管道，是一种半双工的通信方式，允许一个进程写入数据到管道，另一个进程从管道中读取数据，一般用于父子进程间的通信</li>
<li>命名管道，允许不相关的进程（不具备父子关系的进程）通过给定名称的命名管道来进行通信</li>
<li>消息队列，是一种异步通信方式，一般用于分布式系统</li>
<li>共享内存，多个进程可以同一块物理内存映射到各自的地址空间中，实现共享内存</li>
<li>信号量，是一种用于进程同步和互斥的通信方式，进程可以通过信号量对资源进行加锁和解锁</li>
<li>套接字，是一种用于不同主机的进程的网络通信方式，也可以用于同一主机的不同本地进程间的通信</li>
<li>文件映射，将磁盘中的某个文件同时映射到多个进程的地址空间中，实现共享数据</li>
</ul>
</li>
</ul>
<p>操作系统就是一类通过虚拟化、并发、持久性来让多程序运行变得简单高效的软件，建立抽象，最小化开销，进程彼此隔离，不间断可靠运行是操作系统的主要设计目标。</p>
<ul>
<li>虚拟化指操作系统将<strong>物理资源（处理器、内存和磁盘）</strong>转换为更通用、更强大更易于使用的虚拟形式（因此有时也将操作系统称为资源管理器或者虚拟机），为应用程序提供了一个关于程序运行、内存分配以及文件访问的标准库</li>
<li>并发指操作系统同时运行多个进程，或者在进程当中又同时运行多个线程（并发问题并不局限于操作系统本身）</li>
<li>持久性指数据被永久地存储下来，内存中的数据并非持久性的，操作系统提供一种通过系统调用来访问硬件设备的标准和简单的方法（因此操作系统有时被视为标准库），将数据持久到磁盘等硬件中，操作系统中管理磁盘的软件通常称为文件系统。</li>
</ul>
<h1 id="2、虚拟化-CPU"><a href="#2、虚拟化-CPU" class="headerlink" title="2、虚拟化 CPU"></a>2、虚拟化 CPU</h1><p>一个正常的系统可能会有上百个进程在同时运行，操作系统将有限个 CPU 虚拟化为看似无限数量的 CPU，令一个进程只运行一个时间片，从而让多个程序看似同时运行，这就是基于时分共享的<strong>虚拟化 CPU</strong>，其开销在于性能损失，单个进程的运行会变慢。</p>
<p>注：GPU（图像处理单元）和 CPU（中央处理单元）是计算机中两种不同类型的处理器，在设计和功能上有很大的区别。CPU 旨在执行各种通用任务，具有较少的核心，但每个核心非常强大且灵活；GPU 最初是为图像渲染和图像处理而设计的，具有大量的小核心，适合并行处理，这些核心可以同时处理大量相似的重复性任务，这种任务类型的表现会比 CPU 更加高效。</p>
<h2 id="2-1-CPU-控制权"><a href="#2-1-CPU-控制权" class="headerlink" title="2.1 CPU 控制权"></a>2.1 CPU 控制权</h2><p>内核是操作系统的核心，负责管理和控制计算机硬件资源，提供各种系统服务，操作系统将应用程序和操作系统内核进行了隔离，并通过不同的特权级别（用户模式和内核模式）以及系统调用协调用户进程和内核，操作系统内核工作在内核态特权模式下，具有最高权限，可以访问所有的硬件资源和底层系统资源，用户进程工作在用户模式下，只能通过系统调用来进行用户态和内核态之间的切换，从而间接访问被授权的资源，这使得进程能够执行 I/O 和其他一些受限制的操作，但又不能让进程完全控制系统。</p>
<p>当多进程以协作方式运行时，操作系统假定进程会友好运行，并不会主动打断进程，那么只有当进程主动发起系统调用或者重启时，进程才会被中断，如果进程通过系统调用来试图访问非法内存或执行非法指令，操作系统才会终止进程。当多进程以非协作方式运行时，预先设置的时钟会定时中断当前正在运行的进程，此时该进程的用户寄存器由<strong>硬件隐式保存</strong>，使用该进程的内存栈，接着操作系统获得 CPU 控制权，非协作模式下的时钟中断可以防止协作模式下的进程死循环。</p>
<p>一旦操作系统获得 CPU 控制权，就必须通过调度程序（scheduler）决定是继续运行当前正在运行的进程，还是切换到另一个进程，如果是后者，则需进行上下文切换。</p>
<p>上下文切换意味着操作系统需要为当前正在执行的进程保存一些值（<strong>软件显式保存</strong>），并为即将执行的进程恢复一些值（这些值具体指通用寄存器，程序计数器，内核栈指针，并且都保存在内存中而不是磁盘中，从而令切换效率更高），内核通过调用被中断进程的上下文，进入用于上下文切换的底层汇编代码，并返回即将执行的进程的上下文，最后操作系统将 CPU 控制权转移给即将执行的进程，此时上下文切换完成。</p>
<h2 id="2-2-多进程调度"><a href="#2-2-多进程调度" class="headerlink" title="2.2 多进程调度"></a>2.2 多进程调度</h2><p>任务在 I/O 期间并不会使用 CPU，调度程序显然要在某个任务发起 I/O 请求时做出决定，在 CPU 上运行另一个 CPU 密集性任务，从而更好地利用 CPU，即多进程并发运行时，操作系统需要某种调度策略来在中断时决定应当运行哪个进程，并进行上下文切换。</p>
<p>进程的工作负载（任务完成时间）和比较不同调度策略所使用的指标（周转时间和响应时间）是构建调度策略的关键部分。周转时间指任务到达至任务完成之间的时间，包含了任务等待执行和任务真正执行的时间，响应时间指任务到达至任务首次开始执行的时间，即任务初次等待执行的时间。</p>
<p>1）先进先出/先到先服务（FIFO/FCFS），简单且易于实现，但平均周转时间和响应时间都较长（尤其是在完成时间较长的任务先到达时），总体性能不佳。</p>
<p>2）短任务优先（SJF）是一种非抢占式的调度策略，能保证对同时到达的任务，将完成时间较短的任务先执行，平均周转时间较短，平均响应时间较长，而当完成时间较长的任务先到达时，平均周转时间和响应时间都较长，总体性能依旧不佳。</p>
<p>3）最短完成时间优先/抢占式最短作业优先（STCF/PSJF）是添加了抢占机制的 SJF，每当新任务进入系统，会确定剩余工作和新工作中的剩余时间最少的任务来优先执行，平均周转时间达到理论最短，平均响应时间依旧较长（尤其是在完成时间较长优先级较低的任务先到达时）。</p>
<p>4）轮转（RR）在一个时间切片（又称调度量子，其长度必须是时钟中断周期的倍数）内运行一个任务，然后切换到运行队列中的下一个任务（而不是运行一个任务直到结束），直到所有任务都完成，平均响应时间较短，但拥有几乎最长的平均周转时间。时间切片越短，平均响应时间就越小，但频繁的上下文切换将影响整体性能，因此时间切片的长度需要在系统响应时间和上下文切换成本之间进行权衡。</p>
<p>5）多级反馈队列（MLFQ）有多个互相独立的队列，每个队列有不同的优先级，从而利用 STCF 优化平均周转时间或者利用 RR 优化平均响应时间，并利用任务最近的运行行为历史预测任务的未来执行情况，从而动态调整任务应该归属于哪个优先级队列。</p>
<ul>
<li>总是优先执行优先级较高的队列中的任务</li>
<li>同一个队列中的任务具备同样的优先级，轮流执行</li>
<li>任务刚进入系统时，加入优先级最高的上层队列</li>
<li>任务在用完其在某一层队列中的时间配额之前（假定为交互型任务）优先级不变，一旦时间配额用完（假定为密集型任务），降低其优先级，移入下一级队列</li>
<li>经过一段时间 S，就将所有任务都重新加入最高优先级队列（避免优先级低的任务长时间饥饿）</li>
</ul>
<p>MLFQ 的各项参数并没有显而易见的取值，需要利用对任务工作负载的经验对调度程序进行调优，例如不同队列设置可变的时间切片长度，高优先级队列通常有较短的时间切片，低优先级队列通常有较长的时间切片。</p>
<p>6）比例份额/公平份额按照一定概率随机选择应该运行哪个任务，越是应该频繁运行的进程，越是应该拥有更高的概率被选中。这种随机决策的方式可以避免奇怪的边角最差情况，且由于不需要记录太多状态，非常轻量，计算便捷，做出决策的速度很快，但是不能很好地适应 I/O，且难以确定各个任务应该分配设置多大的份额/选中概率。</p>
<h2 id="2-3-多核-CPU-调度"><a href="#2-3-多核-CPU-调度" class="headerlink" title="2.3 多核 CPU 调度"></a>2.3 多核 CPU 调度</h2><p>上文所述调度策略均是在单核 CPU 的前提下提出的，而针对多核 CPU，则存在一些新的问题需要在调度策略中加以考虑。</p>
<p>1）缓存一致性问题</p>
<p>CPU 的硬件缓存是很小但很快的存储设备，通常拥有内存中最热的数据的备份，相比之下，内存很大且拥有所有的数据，但访问数据较慢。由于大多数程序都存在时间局部性和空间局部性，硬件系统可以根据局部性来很好地预测那些数据可以放入缓存中（时间局部性指一个数据被访问后，很有可能会在不久的将来被再次访问；空间局部性指一个数据被访问后，很有可能会紧接着访问它周围的数据）。</p>
<p>通过将频繁访问的数据放在缓存中，系统似乎拥有又大又快的内存。然而，当系统具备多核 CPU 时，每个 CPU 都具备自己的缓存，但这些 CPU 共享同一个内存，那么当更改后的缓存中的数据没有及时刷新到内存及其他缓存中时，就会出现缓存一致性问题。</p>
<p>针对缓存一致性问题，硬件通过监控内存访问来建立底层一致性协议，保证共享内存的唯一性，但应用程序依旧需要通过互斥原语（比如锁），才能保证跨 CPU 访问（尤其是写入）数据的正确性，但是随着 CPU 数量的增加，访问同步共享数据会变得很慢。</p>
<p>2）缓存亲和度问题</p>
<p>一个进程在某个 CPU 上运行时，会在该 CPU 的缓存中维护许多状态，该进程下次在该 CPU 上运行时，由于缓存中的数据会执行的更快，但是如果该进程下次是在另一个 CPU 上运行，会由于需要重新加载数据而较慢，因此多核 CPU 调度应考虑到这种缓存亲和性问题，尽可能将进程保持在同一个 CPU 上。</p>
<p>多核 CPU 调度策略如下</p>
<p>1）单队列多处理器调度（SQMS），直接将原有的单核 CPU 调度策略用于多核 CPU 的情况，区别仅仅在于每个选择多个任务进行执行（选择的任务个数对应 CPU 的个数），实现起来很简单，但随着 CPU 的个数增大，多个 CPU 对于访问该队列的锁竞争增强，系统会花费越来越多的时间在锁的开销上，也无法很好的处理缓存亲和度的问题。</p>
<p>2）多队列多处理器调度（MQMS），每个 CPU 都有一个队列，每个队列可以使用不同的调度规则，系统依照一些启发性规则（比如随机或者选择较空的队列）将其放入某个调度队列中，这样可以避免数据共享带来的缓存一致性问题，也具备良好的缓存亲和度和可扩展性，但需要通过不断地任务迁移来实现良好的负载均衡性，任务迁移的实现方式及频率是问题所在。</p>
<p>并非所有的问题都有简洁明了最优的解决方案，真正的目标在于避免灾难。</p>
<h2 id="2-4-CPU-多级缓存"><a href="#2-4-CPU-多级缓存" class="headerlink" title="2.4 CPU 多级缓存"></a>2.4 CPU 多级缓存</h2><p>CPU 和主存的处理速度上存在一定的 gap，CPU 和主存之间的高速缓存可以避免 CPU 每次操作内存都进行长时间等待。高速缓存的特点是速度快、容量小，昂贵。在程序的运行过程中，会将运算需要的数据从主存中复制一份到 CPU 的高速缓存中，CPU 在计算时就可以直接从高速缓存中读取数据并直接向其写入数据，运算结束之后再将高速缓存中的数据刷新到主存中，并且随着 CPU 能力的不断提升，一层高速缓存渐渐地无法满足要求了，由此衍生出了多级缓存。</p>
<p>按照数据读取顺序和与 CPU 结合的紧密程度，CPU 缓存可以分为一级缓存（L1）、二级缓存（L2）、三级缓存（L3），每一级缓存中所存储的全部数据都是下一级缓存的一部分，这三级缓存的技术难度和成本是逐渐递减的，容量是逐渐递增的。多核 CPU 的每个核心都有各自的 L1（甚至 L2），并共享 L3（或者 L2）。在程序运行过程中，CPU 首先从 L1 中查询数据，如果没有再从 L2 中查询，如果没有再从 L3 中查询，如果没有再从主存中查询。</p>
<p>CPU 多级缓存之间的数据可能出现不一致的现象，通常通过在总线加锁或者缓存一致性协议来解决这个问题，早期的 CPU 使用前者，这是因为 CPU 和其他部件都是通过总线来进行通信的，但是这会使得加锁期间其他 CPU 无法访问内存，进而导致效率低下，因此缓存一致性协议逐渐成为主流，最出名的缓存一致性协议是 Intel 的 MESI 协议（不同的 CPU 可能采用不同的缓存一致性协议），MESI 协议中，每个缓存可能有四种状态</p>
<ul>
<li>M（Modified），数据有效，数据被修改了，修改结果仅存在于本缓存中，和主存中的数据不一致</li>
<li>E（Exclusive），数据有效，数据和主存中的数据一致，数据只存在于本缓存中</li>
<li>S（Shared），数据有效，数据和主存中的数据一致，数据存在于很多缓存中</li>
<li>I（Invalid），数据无效</li>
</ul>
<p>MESI 的核心是当 CPU 写数据时，如果发现写操作的变量是共享变量，就会将状态设置为 Modified， 并发出信号通知其他 CPU 将该变量的缓存置为 Invalid，当其他 CPU 需要读取该变量又发现自己的缓存中的该变量状态是 Invalid 时就会从主存中读取到缓存并设置状态为 Exclusive 或 Shared，当状态是 Exclusive 或 Shared 时就会直接从缓存中读取，当状态是 Modified 时就会先将数据写回主存再从主存中读取，这保证了每个缓存中的使用的共享变量的副本是一致的。</p>
<p>注：MESI 是硬件层面的协议，关注 CPU 缓存之间的一致性问题，是 CPU 设计的一部分，对于操作系统和上层应用来说是透明的；而 JMM（Java 内存模型）是 Java 中抽象出的软件层面的概念，关注 Java 多个线程之间的共享变量的可见性、有序性和原子性问题</p>
<h2 id="2-5-性能衡量指标"><a href="#2-5-性能衡量指标" class="headerlink" title="2.5 性能衡量指标"></a>2.5 性能衡量指标</h2><p>负载（Load）和 CPU 利用率是衡量系统性能的两个不同的指标</p>
<ul>
<li><p>CPU 利用率</p>
<ul>
<li>表示 CPU 正在执行指令（非闲置状态）的时间比例， 关注 CPU 的忙碌程度，高 CPU 利用率表示 CPU 正在积极工作，CPU 利用率越高越好</li>
<li>CPU 利用率急剧升高的检查方向有：内存泄漏导致的频繁 GC，频繁创建耗时对象，死循环等</li>
</ul>
</li>
<li><p>Load</p>
<ul>
<li>通常指一段时间内系统等待处理的的工作量，关注系统中等待运行的工作量，高 Load 意味着有很多进程在等待使用 CPU，可能会导致系统响应的变慢甚至死机，Load 越低越好</li>
<li>Load Average 通常表示在过去一段时间内运行队列的平均长度，运行队列长度是指在某一时刻处理就绪状态和运行状态的进程数量的和（包括正在使用 CPU 和进程和等待 CPU 的进程）</li>
<li>CPU 使用、内存使用、I/O 消耗三者共同构成了 Load，任意一项使用过多都会导致 Load 急剧增大，可以根据机器的实际情况，以最近一个月的 Load 平均值为基线，日常 Load 一旦与基线差距太多就需要介入检查</li>
<li>一般检查方向有：机器本身的硬件性能问题，应用内存泄漏导致的频繁 GC，死锁导致的长时间阻塞，大字段的读写，慢 SQL 等</li>
</ul>
</li>
</ul>
<h1 id="3、虚拟化内存"><a href="#3、虚拟化内存" class="headerlink" title="3、虚拟化内存"></a>3、虚拟化内存</h1><p>用户程序生成的每个地址都是虚拟地址，每个进程访问自己的私有且连续的虚拟地址空间，多个进程间的虚拟地址彼此独立，操作系统高效地将虚拟地址映射到机器的物理内存上，而进程对此过程毫无感知，这就是<strong>虚拟化内存</strong>。</p>
<h2 id="3-1-进程地址空间"><a href="#3-1-进程地址空间" class="headerlink" title="3.1 进程地址空间"></a>3.1 进程地址空间</h2><p>操作系统将物理内存抽象为地址空间/虚拟内存，程序中打印出来的地址都是地址空间/虚拟内存中的虚拟地址，只有操作系统和硬件才知道物理地址。一个进程的地址空间/虚拟内存是运行的程序所看到的系统中的内存，包含运行的程序的所有内存状态，比如代码指令，用来保存函数调用信息的栈，以及用来管理动态分配的堆等。</p>
<p>UNIX/C 程序使用<code>malloc()</code>和<code>free()</code>来在堆内存中申请和释放空间，Java 程序使用<code>new</code>来分配一个新对象的内存，并由 JVM 自动回收不再引用的内存，无需显式释放内存。关于内存分配和释放的一些常见错误和后果如下</p>
<ul>
<li><p>忘记分配内存就直接使用引用，会发生段错误</p>
</li>
<li><p>没有分配足够的内存，会产生内存溢出</p>
</li>
<li><p>忘记初始化分配的内存就使用引用，可能会读取到一些随机和有害的东西</p>
</li>
<li><p>忘记释放内存，会产生内存泄漏进而导致内存不足，需要重新启动（进程退出时操作系统会清理释放其分配的所有页面）</p>
</li>
<li><p>在使用完之前就释放内存，这种错误称为悬挂指针，可能会导致程序崩溃或覆盖有效的内存</p>
</li>
<li><p>重复释放内存或者错误的使用<code>free()</code>，产生的结果是不确定的，崩溃是常见的</p>
</li>
</ul>
<h2 id="3-2-空闲空间管理"><a href="#3-2-空闲空间管理" class="headerlink" title="3.2 空闲空间管理"></a>3.2 空闲空间管理</h2><p>用于管理空闲空间的数据结构通常称为空闲列表（不一定真的是列表这一数据结构），该结构包含了管理内存区域中所有空闲块的引用。如果将需要管理的空间被划分为固定大小的单元，那么就只需要维护这些大小固定的单元的列表，如果有请求，就返回列表中的第一项。而用户级的内存分配库（<code>malloc()</code>和<code>free()</code>），或者操作系统分段都需要管理大小不同的空间单元（malloc 库管理进程中堆的页，操作系统管理进程的地址空间）。</p>
<p>理想的分配程序可以同时保证快速和碎片最小化，一些基本的策略选择如下（但由于分配及释放的请求序列由用户程序决定，是随意的，任何特定的策略在某组不匹配的输入下都会变得非常差）</p>
<p>1）最优匹配，遍历整个空闲列表，找到和请求大小一样或更大的空闲块，在这组候选中选择最小的一块返回，只需要遍历一次，尽量避免了空间浪费。</p>
<p>2）最差匹配，遍历整个空闲列表，找到和请求大小一样或更大的空闲块，在这组候选中选择最大的一块并将其分割出满足用户需求的块返回后，将分割剩余的块再加入空闲列表，只需要遍历一次，但会导致过量的碎片，还有很高的开销。</p>
<p>3）首次匹配，遍历空闲列表直到找到一个足够大的块，将请求的空间返回，将剩余的空间再加入空闲列表，不需要完整遍历整个空闲列表，有速度优势，但有时会让空闲列表开头的部分有很多碎片，因此分配程序如何管理空闲列表的顺序就变得很重要，可以令空闲块按内存地址有序，那么合并操作就会很容易，从而减少碎片。</p>
<p>4）下次匹配，与首次匹配的区别在于每次查找时都维护一个指针，指向上一次查找数据的位置，那么每次查找就从指针指向位置开始查找，从而将查询操作扩散到整个列表中去，而不是集中在列表开头，性能与首次匹配很接近，但避免了完整遍历整个列表。</p>
<p>5）分离空闲列表，如果某个应用程序经常申请一种或几种大小的内存空间，那就用一个独立的列表，只管理这样大小的对象，在这个独立列表中，碎片将不再是问题，而其他大小的请求都交给更通用的内存分配程序。</p>
<p>6）伙伴系统，空闲空间从概念上被看成大小为 2^N 的大空间，当有一个内存分配请求时，空闲空间被递归地一分为二，直到刚好可以满足请求的大小，然后返回给用户，这种策略的特殊之处在于很容易确定任意一个块的伙伴（和块一样大小），当块被释放时，分配程序会检查伙伴块是否空闲，如果是，就合并这两块，这个递归合并过程继续上溯，直到合并这个内存区域，或者某一个块的伙伴还没有被释放。</p>
<h2 id="3-3-硬件地址转换"><a href="#3-3-硬件地址转换" class="headerlink" title="3.3 硬件地址转换"></a>3.3 硬件地址转换</h2><p>应用程序每次使用内存引用时，硬件会通过地址转换将指令中的虚拟地址重定位/转换为数据实际存储的物理地址，而操作系统则需要设置好硬件，管理好内存，记录被占用和空闲的内存位置。操作系统应当保证应用程序可以以任何方式访问到自己的内存空间，且只能访问它自己的内存空间。</p>
<h3 id="3-3-1-MMU"><a href="#3-3-1-MMU" class="headerlink" title="3.3.1 MMU"></a>3.3.1 MMU</h3><p>每个 CPU 有两个硬件寄存器：基址寄存器和界限寄存器（有时称为限制寄存器），统称为内存管理单元（MMU）。</p>
<p>当程序真正开始执行时，操作系统会为进程的地址空间找到内存空间，决定进程在物理内存中的实际加载地址，将其标记为被占用，将起始地址记录在基址寄存器中，<strong>而进程所产生的所有内存引用，只需加上基址寄存器中的内容，就重定位/转换为数据实际存储的物理地址（界限寄存器则用于确保这个物理地址在进程地址空间的范围内）</strong>，这个地址转为过程完全由硬件处理，没有操作系统的介入。</p>
<p>当进程结束时（正常退出或因行为不端被强制终止），操作系统会回收进程所有的内存，根据需要清除相关的数据结构，将其加入空闲空间列表，后续可给其他进程或者操作系统使用。</p>
<p>当上下文切换时，操作系统在内核模式下，通过一些特殊的特权指令（由硬件提供）来修改（保存和恢复）基址寄存器和界限寄存器，用户模式下的应用程序无法执行特权指令，而在应用程序尝试修改基址寄存器和界限寄存器，或者尝试非法访问内存时，CPU 会产生异常，并安排操作系统的异常处理程序去进行相关处理（通常是终止进程）。</p>
<p>当进程停止（没有占用 CPU 运行）时，操作系统可以改变其地址空间的物理位置，即将地址空间拷贝到新位置，在进程结构中更新保存的基址寄存器，当该进程恢复执行时，它的新基址寄存器就会被恢复，然后再次开始运行，这是它的指令和数据就都在新的内存位置了。</p>
<p>这种运行时发生的地址转换技术一般被称为动态重定位，动态重定位可以在进程开始运行后改变其地址空间，使得用户能够将地址空间放在物理内存的任何位置，同时又能确保进程只能访问自己的地址空间。但是该技术将进程的地址空间放在固定大小的槽块中，当进程的栈和堆并不大时，会导致该<strong>进程所占据的这块内存区域中大量空间被浪费，即导致大量内部碎片</strong>，此外，当剩余可用的内存无法提供完整的地址空间时，将无法继续运行新进程。</p>
<h3 id="3-3-2-分段"><a href="#3-3-2-分段" class="headerlink" title="3.3.2 分段"></a>3.3.2 分段</h3><p>一个段是地址空间里的一个连续定长的区域，在典型的地址空间中有三个逻辑不同的段：代码、栈和堆。分段就是给地址空间内的每个逻辑段分配一对基址寄存器和界限寄存器，<strong>此时进程所产生的内存引用，需要先减去其所在段的起始虚拟地址（段内偏移），再加上这个段所对应的基址寄存器中的内容，就重定位/转换为数据实际存储的物理地址，这个段所对应的界限寄存器则用于确保这个物理地址在段的地址空间的范围内</strong>（进程虚拟地址所使用的段以及各个段的起始地址可以在进程虚拟地址的开头几位来显式地标识出来）。</p>
<p>这种分段的地址转换使得操作系统可以将不同的段放到不同的物理内存区域，只有进程已用的内存才在物理内存中分配空间，避免了大量内存碎片，能更好地支持稀疏地址空间，算法简单，开销小，速度快。此外，为了进一步节省内存，可以在进程地址空间之间共享一些物理内存段（比如代码共享），因此，物理内存中的一个段可以映射到多个虚拟地址空间。</p>
<p><strong>由于每个进程都有一些段，每个段的大小也可能不同，那么物理内存中会出现很多不连续的空闲空间的奇怪小洞，很难分配给新的段或者扩大已有的段，这些空间被称为外部碎片</strong>。为了减少外部碎片，操作系统先停止进程，将被停止进程的数据复制到连续的内存区域中，改变它们的段寄存器的值，指向新的物理地址，然后再切换到原进程，并得到足够大的连续空闲物理内存，不过这样的紧凑物理内存的成本很高，一般会占用大量的 CPU 时间。</p>
<p>比紧凑物理内存更简单的做法是利用空闲列表管理算法，试图保存大的内存块用于分配，相关的算法有很多，过多的算法也说明这个问题并没有最好的解决方式（无论哪个算法，都无法完全消除外部碎片，只能是试图减小它）。但是如果在一开始分配的时候就控制每个段的大小都保持一致，就可以避免这些外部碎片的出现。</p>
<h3 id="3-3-3-分页"><a href="#3-3-3-分页" class="headerlink" title="3.3.3 分页"></a>3.3.3 分页</h3><p>不同于大小不一的逻辑段，分页指操作系统将进程地址空间分割成固定大小的单元页从而避免空间碎片化，相应地，将物理内存看成是定长槽块的阵列，叫做页帧，每个这样的页帧包含一个虚拟内存页，连续的虚拟页可能对应不连续的位于不同位置（位于物理内存或硬盘设备）的物理页帧。</p>
<p>操作系统为每个进程保存一个页表，用于记录地址空间的每个虚拟页号（VPN）所对应的页表项，页表项中有页对应的物理页帧号（PFN）本身以及许多不同的位</p>
<ul>
<li>有效位用于指定特定地址转换是否有效（进程地址空间中未被使用的都被标记为无效），无效的地址空间不会被分配物理页帧，如果进程尝试访问这种无效内存，操作系统就会终止进程</li>
<li>保护位/读写位表明页是否可以读取、写入和执行，以保护位不允许的方式访问页，操作系统就会终止进程</li>
<li>存在位表示该页是在物理内存还是在硬盘上（交换操作系统将很少使用的页面移到硬盘，硬盘和物理内存间的页交换用于提供大于物理内存的地址空间）</li>
<li>脏位表明页面被带入内存后是否被修改过</li>
<li>参考位/访问位有时用于追踪页是否被访问，也用于确定哪些页很受欢迎，因此应该保留在内存中</li>
<li>用户/超级用户位用于确定用户模式进程是否可以访问该页面</li>
</ul>
<p>页表可以变得非常大，比小段表或基址/界限对要大得多，所以 MMU 并不用于存储当前正在运行的进程的页表，而是将每个进程的页表都存储在内存中，<strong>此时针对进程所产生的内存引用，首先将需要访问的内存引用转换为二进制形式，从中检查其对应的虚拟页号以及页内偏移量，接着通过页表的基址寄存器和界限寄存器查找页表所在的物理地址，从页表中找到虚拟页号所对应的物理页帧，物理页帧中对应的页内偏移量就是需要数据实际存储的物理地址（将虚拟地址的二进制中的代表虚拟页号的高位转换为物理页帧号，低位的代表页内偏移量的位保持不变，就得到了真实的物理地址的二进制）</strong>。</p>
<p>由于页是固定大小的单元，分页不会导致外部碎片，且支持稀疏虚拟地址空间（进程地址空间中未被使用的内存不会被分配物理页帧），尽可能减少了进程地址空间的内部碎片（依旧存在页内内部碎片），但基于分页的地址转换过程额外开销很多（需要一次额外的内存访问用于访问页表），导致系统运行速度过慢，并占用太多额外内存（内存被页表塞满而不是有用的应用程序数据），导致内存浪费。</p>
<h3 id="3-3-4-TLB"><a href="#3-3-4-TLB" class="headerlink" title="3.3.4 TLB"></a>3.3.4 TLB</h3><p>地址转换旁路缓冲存储器（TLB）是频繁发生的虚拟到物理地址转换的硬件缓存，可以加速基于页表的地址转换，<strong>每次内存访问时，首先从虚拟地址中提取虚拟页号，然后硬件检查 TLB 中是否有该虚拟页号所对应的 TLB 项，如果有就可以直接从 TLB 项中得到物理页帧号，与虚拟地址中的偏移量组合得到期望的物理地址，而无需访问页表（页表有全部的转换映射），如果没有命中 TLB，硬件抛出异常，暂停当前指令流，将特权级别提升至内核模式，操作系统执行“TLB 未命中程序”来按照上一节所述过程查找页表并更新 TLB（为了充分利用局部性原理），接着硬件会重试，此时就会命中 TLB</strong>。</p>
<p>一条 TLB 项包含虚拟页号，物理页帧号以及其他位。其他位中的保护位用来标识该页是否有访问权限（例如代码页被标识为可读和可执行，堆的页被标识为可读和可写）；有效位用来标识该项是不是有效地转换映射（不同于页表项中的有效位用于标识该页是否被进程申请使用，TLB 的有效位只是指出该 TLB 项是否是缓存了地址转换映射，比如系统启动时，所有的 TLB 项通常被初始化为无效状态，一旦程序开始运行并访问自己的虚拟地址，TLB 就会慢慢填满，有效的项很快会充满 TLB）。在上下文切换时，确保将要运行的进程不会错误地使用前一个进程的虚拟地址到物理地址转换映射，此时可以将所有 TLB 项的有效位设置为无效，也可以给所有的 TLB 项添加一个地址空间标识符/进程标识符来区分属于不同进程的 TLB 项。</p>
<p>大的缓存注定慢，缓存如果要追求快速，那缓存就必须小，TLB 是小而快的缓存，这种结构也导致一些问题</p>
<ul>
<li>TLB 未命中：命中 TLB 时，地址转换的时间开销可以忽略不计（此时性能就像内存没有虚拟化一样），但如果未命中，那么就必须访问页表来进行地址转换，会带来很大的内存访问开销（尤其是页表结构复杂时），相对于大多数 CPU 指令，内存访问的开销很大</li>
<li>超出 TLB 覆盖范围：在向 TLB 插入新项时，会替换一个旧项，TLB 中的页项数是保持不变的，如果一个程序短时间内访问的页数超过了 TLB 中的页数，就会产生大量的 TLB 未命中，这种现象称为超出 TLB 覆盖范围，是相当严重的问题</li>
<li> TLB 未命中的无限递归：为了避免 TLB 未命中的无限递归，可以把操作系统关键时刻需要使用的代码和数据（比如“TLB 未命中程序”）也放到 TLB 中</li>
</ul>
<h3 id="3-3-5-小页表"><a href="#3-3-5-小页表" class="headerlink" title="3.3.5 小页表"></a>3.3.5 小页表</h3><p>更小的页表可以降低页表的内存消耗，减少页表本身对内存空间的浪费（作为代价， TLB 未命中时的处理也就更加复杂），小页表有以下实现方式</p>
<ul>
<li>更大的页，可以把关键数据结构放在程序地址空间的某些区域，这些区域被映射到更大的页（对更大的页的支持通常被数据库管理系统利用，它们的数据结构比较大，而且是随机访问），更大的页可以增加 TLB 的有效覆盖率，但会导致页内产生太多内部碎片</li>
<li>混合分段分页，此时不再为进程的整个地址空间提供单个页表，而是为每个逻辑分段分别提供一个页表，每个段的基址/界限寄存器保存该段的页表的开头/结尾物理地址，但依旧存在分段导致的外部碎片问题</li>
<li>更稀疏也更复杂的多级页表结构（树形数据结构），并用页目录来记录页表的哪些页被分配了页表项并驻留在内存中<ul>
<li>多级页表无需连续驻留在物理内存中</li>
<li>多级页表所使用的内存空间与进程地址空间正在使用的内存量成比例</li>
<li>在命中 TLB 时，由于无需访问页表，性能没有变化</li>
<li>在TLB 未命中时，需要从内存加载多次（次数取决于页表的级数）才能从页表中获得正确的页表项，TLB 未命中的成本更高了</li>
<li>以“页表本身的所有内容都能放入一页”为目标来确定页表的级数</li>
</ul>
</li>
<li>反向页表，页表中的项代表物理页（而非虚拟页），页表项记录哪个进程正在使用此物理页，以及该进程的哪个虚拟页映射到此物理页</li>
<li>将页表的一部分交换到磁盘，即内存中只保留小部分页表</li>
</ul>
<h2 id="3-4-更大存储空间"><a href="#3-4-更大存储空间" class="headerlink" title="3.4 更大存储空间"></a>3.4 更大存储空间</h2><h3 id="3-4-1-硬盘设备"><a href="#3-4-1-硬盘设备" class="headerlink" title="3.4.1 硬盘设备"></a>3.4.1 硬盘设备</h3><p>并不是所有的正在运行的进程的地址空间/虚拟内存都能放入物理内存，即并不是所有的页都常驻在物理内存中，为了支持更大的地址空间，操作系统将当前没有在使用的地址空间用一个大而慢的设备（硬盘，SSD 等）存储起来，从而构建出比真实物理内存更大的虚拟内存的假象。</p>
<p>硬盘上有一部分空间（称为<strong>交换空间</strong>）用于物理页在内存和硬盘之间的移入和移出，操作系统以页为单位读取或者写入交换空间，硬盘交换空间的大小决定了系统在某一时刻能够使用的最大内存页数，即最大虚拟内存空间。当内存空间已满或者接近满时，没有足够的空间内存用于存储交换空间换入的页，此时操作系统需要换入页的同时换出一个页到交换空间中，或者操作系统通过一个<strong>交换守护进程或页守护进程</strong>来在一定条件下提前换出页，始终在内存中预留一些空闲空间（只要操作系统在运行，这一过程就不会停歇）。</p>
<p>页表的页表项通过存在位来表示该页是在物理内存还是在磁盘上，访问不在物理内存中的页（当然也不在 TLB 中）就称为页错误，此时硬件触发异常，并将控制权移交给操作系统，操作系统会执行“页错误处理程序”，<strong>首先从页表项中得到所需的页的硬盘地址，并检查内存是否有可用的空闲页，如果没有则通知后台分页线程按需释放页，当线程释放一定数目的页时会唤醒原来的线程，原线程发送请求到硬盘，将页读取到内存中，当硬盘 I/O完成时，操作系统会在页表项中将此页标记为存在，在页表项中更新此页的物理页帧号，并将此页更新到 TLB 中，最后硬件重试访问指令，此时命中 TLB，直接得到所需要的物理内存地址</strong>。I/O 操作是昂贵的，当硬盘 I/O 在运行时，进程将处于阻塞状态，操作系统可以自由地运行其他可执行的进程。</p>
<p>将多个要写入的页聚集或分组，同时执行多个交换过程，这种合并操作可以一次写入原本多次要写入的数据，减少硬盘的寻道和旋转开销，从而提高硬盘的效率。</p>
<h3 id="3-4-2-交换策略"><a href="#3-4-2-交换策略" class="headerlink" title="3.4.2 交换策略"></a>3.4.2 交换策略</h3><p>如果换出了不合适的页会导致巨大的性能损失（程序以磁盘的速度运行，比内存速度慢一万到十万倍），交换策略用于选择需要换出的页。</p>
<p>1）FIFO，页在进入内存时放入一个队列，永远换出队列尾部的页，实现相当简单</p>
<p>2）RAND，随机选择需要换出的页，实现相当简单</p>
<p>3）LRU，以历史访问情况作为参考，永远换出最不经常使用的页，记录并查找最少访问页的代价可能比较高，且不会在多个进程间公平分享内存</p>
<p>4）近似 LRU，不要求必须找到绝对最旧的页，只是找到差不多最旧的页作为换出页，页命中率是接近 LRU，但是实现的代价可能会小很多</p>
<p>对于符合局部性原理的程序，使用 LRU 效果最佳；对于随机访问页的程序，LRU，FIFO 甚至是随机换出页的效果差别都不大；对于顺序访问页的程序，使用随机换出页的方式最佳，此时 LRU 和 FIFO 的效果都很差。</p>
<p>换出干净页（指内存没有修改过的页）只需将其从内存中去掉，无需写回磁盘，换出的成本很低，而换出脏页（内存修改过的页）必须将其写回磁盘，这很昂贵，因此一般倾向于优先换出干净页。</p>
<h1 id="4、并发"><a href="#4、并发" class="headerlink" title="4、并发"></a>4、并发</h1><p>一方面，操作系统本身就是一个并发程序，它必须小心的访问自己的内存；另一方面，操作系统需要用锁和条件变量来支持多线程并发运行的应用程序。</p>
<h2 id="4-1-基于线程的并发"><a href="#4-1-基于线程的并发" class="headerlink" title="4.1 基于线程的并发"></a>4.1 基于线程的并发</h2><h3 id="4-1-1-规范"><a href="#4-1-1-规范" class="headerlink" title="4.1.1 规范"></a>4.1.1 规范</h3><ul>
<li>多线程程序会有多个执行点（即多个程序计数器，多个栈），在共享的进程空间中存取指令并执行，共享堆内或者其他全局可访问的数据</li>
<li>当多个线程在同一个 CPU 上执行时，就需要进行线程的上下文切换，与进程上下文切换不同的是，线程的上下文切换时进程地址空间保持不变，则不需要切换当前使用的页表</li>
<li>每个线程都有自己的栈和线程局部变量，这都是线程私有的，其他线程不应访问，线程也不应返回自己的局部变量（因为线程返回时线程局部变量所引用的内存已经释放了）</li>
<li>同一进程的多个线程访问共享变量的代码段称为临界区，临界区不能由多个线程同时执行</li>
<li>通过互斥量/锁来避免临界区的不合时宜的中断和线程切换，从而保证临界区的操作原子性，当线程需要抢夺多个锁来才能进入临界区时，需要注意预防死锁</li>
<li>通过条件变量来作为线程间的通知等待信号，实现线程间的交互，也保证多线程按照期望的顺序执行</li>
<li>尽可能简单，尽可能只在真正需要时才使用并发，尽可能避免复杂的不必要的线程交互，尽可能使用已被证实的线程交互方式</li>
</ul>
<h3 id="4-1-2-线程的实现"><a href="#4-1-2-线程的实现" class="headerlink" title="4.1.2 线程的实现"></a>4.1.2 线程的实现</h3><p>线程的实现方式主要如下</p>
<ul>
<li>使用内核线程实现<ul>
<li>内核线程就是直接由操作系统内核支持的线程，这种线程由内核来完成线程切换，内核通过调度器来对线程进行调度，并负责将线程的任务映射到各个 CPU 上，并向应用程序提供 API 接口来管理线程</li>
<li>应用程序一般不会直接使用内核线程，而是使用轻量级进程（内核线程的一种高级接口），这才是通常意义上所讲的线程，每个轻量级进程都由一个内核线程支持，只有先支持内核线程，才能有轻量级进程</li>
<li>轻量级进程由内核线程支持，因此其局限在于所有操作（创建、调度等）都需要进行系统调用，需要在用户态和内核态之间切换，需要消耗一定的内核资源，一个系统能够支持的轻量级进程的数量是有限的</li>
</ul>
</li>
<li>使用用户线程实现<ul>
<li>在用户空间创建线程库，通过运行时系统来完成线程的管理，这种线程的操作完全是在用户空间由用户程序自行完成的，操作系统的内核仅仅只是管理进程，而对进程中的这种线程无感知，这种线程的操作也不涉及系统调用</li>
<li>在多核 CPU 系统中，如果将线程映射到多个 CPU 上是一个难题</li>
</ul>
</li>
<li>使用用户线程 + 轻量级进程混合实现<ul>
<li>线程的创建通过线程库在用户空间完成，但是线程的调用由内核来完成，多个用户线程通过多路复用来复用多个内核线程</li>
</ul>
</li>
</ul>
<h3 id="4-1-2-互斥量-锁"><a href="#4-1-2-互斥量-锁" class="headerlink" title="4.1.2 互斥量/锁"></a>4.1.2 互斥量/锁</h3><p>锁实质是一个互斥变量（mutex）。</p>
<ul>
<li>锁变量保存了锁在某一时刻的状态，可用（available/unlocked/free）代表没有线程持有锁，被占用（acquired/locked/held）表示有一个线程持有锁，正处于临界区</li>
<li>锁变量还隐藏了其他的信息，比如持有锁的线程，请求获取锁的线程队列，这些信息会隐藏起来，锁的使用者不会发现这些信息</li>
<li>只有持有锁变量的线程才能进入临界区，线程只有退出临界区才释放锁变量，因此，锁可以用来保证临界区代码段能够像单条原子指令一样执行</li>
<li>通常使用不同的锁来保护不同的数据和结构，从而尽可能降低锁的粒度/保护范围，细粒度的锁允许更多的线程进入临界区</li>
<li>锁为程序员提供了最小程度的调度控制，将原本由操作系统调度的混乱状态变得可控程度更高一点</li>
</ul>
<p>应该尽可能避免使用锁，除非确信必须使用，高效的锁应当以低成本的硬件和操作系统支持来提供正确互斥，公平竞争以及良好的性能。</p>
<p>1）基于中断</p>
<ul>
<li>对于操作系统本身，可以通过在进入临界区之前关闭中断，在结束临界区之后打开中断，那么在临界区内不会由于中断导致线程切换，从而提供了正确互斥</li>
<li>但是关闭中断的方式无法工作在多 CPU 上，因为其他线程可以运行在其他 CPU 上，也不允许应用于应用程序，因为这会令操作系统失去对应用程序的控制，效率低，甚至会导致应用程序无法工作</li>
</ul>
<p>2）基于自旋（是最简单的一种锁）</p>
<ul>
<li>硬件提供三种原子操作指令（测试并设置指令、比较并交换指令、获取并增加指令），线程一直自旋来尝试执行某种指令，只有一个线程能够执行成功，即只有一个线程能够获取锁，从而提供了正确互斥</li>
<li>基于测试并设置指令或比较并交换指令的自旋锁不保证公平性，自旋的线程在竞争条件可能会永远自旋，即饿死，而基于获取并增加指令的自旋锁可以保证公平性</li>
<li>非抢占式的单 CPU 无法使用自旋锁，因为占据 CPU 的自旋线程永远不会放弃 CPU，而多 CPU 以及抢占式的单 CPU 则存在一些性能问题，因为竞争锁的线程会自旋整个 CPU 时间片，N 个线程竞争时会浪费 N-1 个 CPU 时间片</li>
</ul>
<p>3）基于队列和休眠</p>
<ul>
<li>操作系统提供原语<code>yield()</code>，令线程主动放弃 CPU 进入休眠，当线程不能获取锁时不进入自旋，而是将自己加入队列，然后让出 CPU 进入休眠</li>
<li>通过队列来控制哪个线程会获得锁，实现了公平</li>
<li>通过休眠来避免自旋线程浪费整个时间片，但系统可能依旧存在频繁的线程上下文切换</li>
</ul>
<p>4）两阶段锁（由 Linux 操作系统提供）</p>
<ul>
<li>两阶段锁的第一阶段会先自旋一段时间，希望可以获取那种即将被释放的锁，如果第一阶段没有获取锁，那么第二阶段会进行休眠直到锁可用，一般通过固定自旋的次数来区分第一阶段和第二阶段</li>
</ul>
<h3 id="4-1-3-条件变量"><a href="#4-1-3-条件变量" class="headerlink" title="4.1.3 条件变量"></a>4.1.3 条件变量</h3><p>条件变量用于帮助线程判断是否某一条件满足（比如其他线程是否执行完毕），可以作为线程间的通知等待信号，从而实现线程间的交互（应当尽可能减少不必要的线程交互），也保证多线程按照期望的顺序执行。</p>
<p>条件变量实质是一个显式队列，当线程持有锁并发现该条件不满足时，线程把自己加入队列，然后通过调用<code>wait()</code>进入休眠，当另外某个线程持有锁并改变上述条件状态后，就通过调用<code>signal()</code>来尝试唤醒等待该条件的线程，等待该条件的线程则结束休眠并尝试获取锁，若获取到锁则可以继续运行。</p>
<ul>
<li><p>始终使用<code>while</code>而不是<code>if</code>来判断条件变量</p>
</li>
<li><p>在调用<code>wait()</code>和<code>signal()</code>时，应当确保已经持有锁，当<code>wait()</code>和<code>signal()</code>的返回时则代表锁被释放，这样可以确保<code>wait()</code>和<code>signal()</code>不会同时被调用，避免正在调用<code>wait()</code>的线程错过唤醒信号</p>
</li>
<li><p>根据等待条件的不同，合理使用不同的条件变量，以便正确地发送信号，明确真正应该被唤醒的线程，尽量避免广播式唤醒所有等待线程</p>
</li>
</ul>
<p>补充：信号量是有一个整数值（这个值就是等待线程的个数，但通常不会暴露给信号量的使用者）的对象，信号量根据这个整数值来决定其行为，可以实现不同功能的锁以及条件变量。</p>
<h3 id="4-1-4-数据结构"><a href="#4-1-4-数据结构" class="headerlink" title="4.1.4 数据结构"></a>4.1.4 数据结构</h3><p>高效的并发数据结构应当保证功能正确，线程安全以及良好的并发访问性能，理想情况下，多处理器上运行的多线程就像单线程一样快，这种总工作量增多，但是并行执行完成任务的时间没有增加的状态称为完美扩展。</p>
<p>如果数据结构导致的运行速度不是太慢，那就足够了，如果简单的方案就能工作，就不需要复杂的设计，如果让应用的某一小部分变快，却没有提高整体的性能，其实没有价值，不成熟的优化是坏事的根源。</p>
<p>1）计数器（最简单的一种数据结构）</p>
<p>可扩展的计数器很重要，否则运行在 Linux 上的工作在多核机器上将遇到严重的扩展性问题，懒惰计数器就是一个扩展的并发计数器。</p>
<p>懒惰计数器通过多个局部计数器和一个全局计数器来实现一个逻辑计数器，其中每个 CPU 核心有一个局部计数器，每个局部计数器以及全局计数器都有一个锁，此时同一个 CPU 上的线程通过局部锁来保证线程安全，不同 CPU 上的线程不会竞争保证良好的可扩展性，此外局部计数器通过全局锁来定期将值转移给全局计数器并将自身置零，更新全局计数器的频率越高，计数器的准确性越高，但性能会变差，准确性和性能之间存在权衡。</p>
<p>2）并发链表</p>
<p>如果每个节点都有一个锁，那么与整个链表一个锁相比，允许更多的线程去访问链表，提升了链表操作的并发程度，但遍历链表时，需要频繁的获取锁和释放锁，开销巨大，很难比单锁链表的更快。更多并发不一定更快，如果方案带来了大量的开销，那么高并发就没有什么意义。</p>
<p>3）并发队列</p>
<p>并发队列使用两个锁，一个队头锁，一个队尾锁，这使得入队和出队可以并发执行。</p>
<h2 id="4-2-基于事件的并发"><a href="#4-2-基于事件的并发" class="headerlink" title="4.2 基于事件的并发"></a>4.2 基于事件的并发</h2><p>针对基于线程的并发，开发者只是创建了线程，然后就依赖操作系统能够合理地调度线程，开发者无法控制多线程在某一时刻的调度，正确处理基于线程的并发，并且实现在各种不同负载下都能够良好运行的通用调度，是很有难度的。</p>
<p>并发并不仅仅是基于线程实现，一些 GUI 应用或者某些类型的网络服务器常常采用基于事件的并发方式</p>
<ul>
<li>采用基于事件的并发通过事件处理程序来显式地控制对各个事件的调度</li>
<li>对于基本事件的并发，某种 I/O 导致的阻塞会阻止所有进展，为了避免长期甚至无期限地阻塞，通常会指定超时并使用异步 I/O（对于不支持异步 I/O 的系统，纯基于事件的并发无法实现）</li>
<li>异步 I/O 使应用程序能够发出 I/O 请求，并在 I/O 完成之前立即将控制权返回给调用者，需要提供另外的接口让应用程序能够确定各种 I/O 是否已完成，或者通过某种信号在异步 I/O 完成时通知应用程序（应用程序通过预先设置的信号处理程序来对捕捉到的信号进行处理）</li>
<li>基于事件的并发很难在发出异步 I/O 时，打包一些程序状态，以便下一个事件处理程序在 I/O 最终完成时使用，这不同于基于线程的并发直接由线程栈来保存状态信息</li>
</ul>
<h1 id="5、持久化"><a href="#5、持久化" class="headerlink" title="5、持久化"></a>5、持久化</h1><h2 id="5-1-I-O-设备"><a href="#5-1-I-O-设备" class="headerlink" title="5.1 I/O 设备"></a>5.1 I/O 设备</h2><h3 id="5-1-1-基本概念"><a href="#5-1-1-基本概念" class="headerlink" title="5.1.1 基本概念"></a>5.1.1 基本概念</h3><p>一个标准设备包含1）向系统其他部分展现的硬件接口和交互协议，大概会包含一些存储设备状态、接收命令以及设备数据的寄存器；2）实现设备对外展示接口的内部结构，可能是几个芯片甚至成百上千行固件（固件指硬件设备中的软件）。CPU 通过某种专有的内存总线连接到系统内存，I/O 设备（显卡）通过常规的 I/O 总线连接到系统，磁盘、鼠标及其他最慢的设备通过外围总线连接到系统。</p>
<p>操作系统通过操作系统通过 I/O 指令（I/O 指令是特权指令，操作系统是唯一可以直接与设备交互的实体）或者内存映射 I/O （内存映射 I/O 指硬件将设备寄存器作为内存地址提供）来与设备进行交互，通过设备驱动程序（是操作系统中明确知道设备如何工作的软件，驱动程序代码在整个内核代码中占比非常大）将设备接口纳入操作系统。因此，操作系统可以通过调用设备接口轮询确认设备是否进入可以接受命令的就绪状态，设备就绪后，操作系统发数据以及命令到设备，设备执行命令，操作系统轮询设备是否执行完成命令。</p>
<p>为了避免操作系统轮询浪费 CPU 时间片，可以由设备在命令完成后抛出一个硬件中断，引发 CPU 跳转执行预先定义好的中断服务程序，而在中断抛出之前，操作系统可令 CPU 切换至其他进程，但对于处理操作系统请求很快的高性能设备来说，使用中断反而会拖累性能，此时使用轮询更佳。此外，网络场景也更适合使用轮询，因为此时大量的数据包请求中断很有可能会导致操作系统发生活锁，即不断处理中断而无法处理用户层的请求，而轮询的方式可以更好地控制系统的行为，允许 Web 服务器先服务一些用户请求，再检查网卡设备是否有更多数据包到达。</p>
<h3 id="5-1-2-磁盘驱动器"><a href="#5-1-2-磁盘驱动器" class="headerlink" title="5.1.2 磁盘驱动器"></a>5.1.2 磁盘驱动器</h3><p>磁盘驱动器作为 I/O 设备中的一种，一直是计算机系统中持久数据存储的主要形式。磁盘驱动器有一个或多个圆形盘片，磁盘的所有盘片都围绕主轴连接在一起，主轴连接到一个电机，当驱动器接通电源时，电机以一个恒定的速度旋转盘片。盘片的两面都称为表面，表面有磁性层，一个表面包含数以千计的同心圆，每个同心圆是一个磁道，数据在磁道中被编码，当需要读写时，磁盘臂在表面上移动，将磁头定位在期望的磁道上，通过引入磁性变化来永久存储数据，因此即使断电，磁盘驱动器也能持久存储数据位。</p>
<p>磁盘盘片表面的磁道可以被划分为不同扇区（512 字节块），现代磁盘驱动器可以视为一组扇区，扇区编号是驱动器的地址空间，磁盘只能以扇区大小的块或其倍数写入，但是驱动器制造商唯一保证的是单个 512 字节的写入是原子的。当需要读写时，磁盘驱动器首先需要将磁盘臂移动到正确的磁道（这就是寻道过程），接着等待期望的扇区旋转到磁头下（这种旋转等待时间称为旋转延迟），最后数据从表面读取或写入表面，这就是完整的 I/O 过程（寻道和旋转都是昂贵的磁盘操作）。应当尽可能以顺序方式将数据传输到磁盘，并从磁盘传输数据，如果顺序不可行，至少应考虑以大块传输数据，越大越好，如果 I/O 是以小而随机方式完成的，则性能将受到显著影响。</p>
<p>现代磁盘驱动器的另一重要组成部分是缓存（又称为磁道缓冲区，大约 8 MB 或 16 MB），驱动器使用这些内存来保存从磁盘读取或写入磁盘的数据，从而令驱动器快速响应所有后续对同一数据块的请求。在向磁盘写入数据时，将数据写入缓存后就回报写入完成称为后写缓存/立即报告，将数据实际写入磁盘后才回报写入完成称为直写，后写缓存会使驱动器看起来更快，但可能有危险。</p>
<p>对于给定的一组 I/O 请求，可以由操作系统先通过 I/O 合并将连续的小请求块合并一个大请求块，再通过磁盘调度程序检查请求并决定下一个要调度的请求，磁盘调度程序通过估计请求的查找和可能的旋转延迟，可以很好估计每个请求任务大概需要多长时间，因此可以贪婪的选择先服务花费时间最少的请求，即遵循 SJF。此外，最短寻道时间优先（SSTF）按磁道对 I/O 请求队列排序，选择先服务最近磁道上的请求，但会有饥饿问题；最近块优先（NBF）选择先服务最近扇区块地址上的请求，同样会有饥饿问题。</p>
<p>在现代系统中，操作系统调度程序通常会选择它认为最好的几个请求，并将它们全部发送到磁盘，磁盘可以接受多个分离的请求，它们本身具有复杂的内部调度程序，可以利用磁头位置、详细的磁道布局信息、磁盘自身的寻道和旋转速度等内部知识，来很准确地通过最短定位时间优先（SPTF）选择先服务可以最先定位到的块（理论上最佳的请求）。</p>
<h3 id="5-1-3-磁盘阵列"><a href="#5-1-3-磁盘阵列" class="headerlink" title="5.1.3 磁盘阵列"></a>5.1.3 磁盘阵列</h3><p>随着需要存储的数据越来越多，I/O 操作可能成为拖慢整个系统的瓶颈，因此考虑廉价冗余磁盘阵列（RAID）技术。RAID 外部看起来像一个磁盘/一组可以读取或写入的块，内部实际使用多个磁盘、内存以及一个或多个处理器，并行使用多个磁盘可以大大加快 I/O 时间，此外通过某种形式的冗余，RAID 可以容许损失一个磁盘并保持运行，就像没有发生错误一样，因此，RAID 实现了一个更快、更大、更可靠的磁盘系统（其实就像一个专门用于管理一组磁盘的计算机系统，运行专门用于操作 RAID 的软件）。</p>
<p>当文件系统向 RAID 发出逻辑 I/O 请求时，RAID 内部计算要访问的磁盘，然后发出物理 I/O 以完成请求，每个逻辑读 I/O 对应一个物理读 I/O，每个逻辑写 I/O 对应 N 个物理写 I/O（N 为数据副本的个数）。RAID 以轮转方式将磁盘阵列的块分布在磁盘上，在对数组的连续块进行请求时，从阵列中可以获取最大的并行性，块越小，意味着许多文件将跨多个磁盘进行条带化，增加了对单个文件的读取和写入的并行性，但跨多个磁盘访问块的定位时间会增加。此外，RAID 可以透明地为主机系统服务，即可以简单地用 RAID 替换磁盘，而不需要更换一行软件，操作系统和客户端应用程序无须修改就可以继续运行。</p>
<h2 id="5-2-I-O-操作"><a href="#5-2-I-O-操作" class="headerlink" title="5.2 I/O 操作"></a>5.2 I/O 操作</h2><h3 id="5-2-1-基本概念"><a href="#5-2-1-基本概念" class="headerlink" title="5.2.1 基本概念"></a>5.2.1 基本概念</h3><p>主机的网络驱动接收到消息之后，会向内核申请空间，在收到完整的数据包后将其复制到磁盘或内核空间的缓存中。用户应用程序以用户模式运行，用户模式下的应用程序无法访问机器的硬件资源，不能发起对磁盘的 I/O 请求，不能访问任何物理内存页或在网络上发送数据包。</p>
<p>当应用程序需要进行 I/O 操作时，将会发起<strong>系统调用</strong>，此时控制权转移到预先设置的操作系统中，操作系统以<strong>内核模式</strong>运行，可以完全访问硬件资源，可以通过 DMA 把数据从磁盘拷贝到内核空间缓存区，然后 CPU 再把数据从内核空间拷贝到用户空间，对于 Java 程序还需要从堆外内存拷贝到堆内存。</p>
<p>当操作系统完成系统调用请求的服务时，将控制权交还给用应用程序，返回到用户模式，接着再由用户程序进行处理。</p>
<ul>
<li><p>系统调用非常强大，比如 UNIX 系统所采用的<code>fork()</code>、<code>wait()</code>及<code>exec()</code>这些系统调用可以很灵活创建和操作进程</p>
</li>
<li><p>零拷贝就是通过各种方式来减少 CPU 参与数据拷贝的次数，常见的零拷贝方式有 DMA、mmap、sendfile、direct I/O</p>
<ul>
<li>DMA (Direct Memory Access) 的作用就是直接将 I/O 设备的数据拷贝到内核缓冲区中，这个过程避免了 CPU 的参与</li>
<li>mmap (memory map，内存映射) 就是将内核态和用户态的内存映射到一起，避免来回拷贝，系统会自动将用户修改后的脏页回写到对应的磁盘上，内核的修改也会直接反映到用户，并实现不同用户进程之间的文件共享，既完成了对文件的读写操作又不必进行系统调用，但 mmap 使用时必须事先指定好的内存映射的大小，且必须要在内存中找到一块连续的地址块，不适合变长文件和超大文件</li>
<li>sendfile 只会做文件传输，而不通过用户态进行干预，即不需要进行涉及用户态的拷贝</li>
<li>direct I/O 指数据不经过内核态，而是由 I/O 设备直接拷贝到用户态的内存中，此时操作系统不再负责缓存之类的管理，这就必须交由应用程序自己去做</li>
</ul>
</li>
<li><p>同步与异步描述的是被调用者，阻塞和非阻塞描述的是调用者，同步异步与阻塞非阻塞之间没有必然关系</p>
<ul>
<li>同步指被调用者接到调用后立即执行，调用者的调用可以得到结果</li>
<li>异步指被调用者接到调用后仅保证会执行但不保证会立即执行，执行结束后会去通知调用者</li>
<li>阻塞指调用者在发出调用后需要一直等待直到被调用者执行完成</li>
<li>非阻塞指调用者在发出调用后不需要等待，可以去做自己的事情</li>
</ul>
</li>
</ul>
<h3 id="5-2-2-I-O-模型"><a href="#5-2-2-I-O-模型" class="headerlink" title="5.2.2 I/O 模型"></a>5.2.2 I/O 模型</h3><p>当用户进程需要进行 I/O 读操作时，将会经历1）发起系统调用，向内核发送读请求；2）内核向硬件发送读指令，并等待读就绪；3）DMA 将要读取的数据复制到指定的内核缓存区中；4）内核将数据从内核缓存区拷贝到用户进程空间中这些阶段，这整个过程可能使用五种不同的 I/O 模型。</p>
<ul>
<li><p>同步阻塞型 I/O 模型，从系统调用到数据从内核拷贝到用户空间并返回，这整个 I/O 操作过程中，用户进程始终都是阻塞</p>
</li>
<li><p>I/O 多路复用模型，多个进程 I/O 可以注册到同一个管道上，这个管道会统一和内核进行交互，本质上也是同步阻塞型 I/O，用户进程先调用 select、poll 或  epoll，select、poll 和  epoll 都会等数据到达内核（用户进程阻塞于 select 或 poll ）时返回，此时用户进程再发起系统调用等待数据从内核缓存区拷贝到用户进程空间中（非阻塞）</p>
</li>
<li><p>同步非阻塞型 I/O 模型，用户进程在系统调用后立即返回，用户进程定时轮询系统调用是否返回数据，只有在系统调用还未返回数据（即数据还未到达内核）时用户进程是非阻塞的，在数据到达内核缓存区后用户进程需要阻塞等待内核将数据从内核缓存区拷贝到用户进程空间中</p>
</li>
<li><p>信号驱动 I/O 模型，用户进程通过调用 sigaction 注册信号函数，等内核准备好数据（非阻塞）时中断当前用户进程，执行信号函数，此时用户进程再发起系统调用等待数据从内核缓存区拷贝到用户进程空间中（阻塞）</p>
</li>
<li><p>异步 I/O 模型，调用 aio_read 令内核把数据准备好并复制到用户空间，这整个 I/O 操作都完成后执行信号函数，通知用户进程 I/O 操作已经完成，用户进程全程都不关心具体 I/O 实现，始终都是异步非阻塞的</p>
</li>
</ul>
<p>注：select、poll、epoll 都是 Linux 中常见的 I/O 多路复用技术，可以用于同时监听多个文件描述符，当任意一个文件描述符就绪时，就能够非阻塞地读写数据</p>
<ul>
<li><p>select 是最原始的 I/O 多路复用技术，几乎在所有的平台中都支持，缺点是单个进程最多只能监听 1024 个文件描述符，需要遍历所有的文件描述符，开销随着文件描述符数量增加而线性增大</p>
</li>
<li><p>poll 在 select 的基础上增加了支持监听更多的文件描述符的能力，但需要遍历所有的文件描述符，开销随着文件描述符数量增加而线性增大</p>
</li>
<li><p>epoll 在 poll 的基础上进一步优化了复杂度，依旧可以支持更多的文件描述符，也不需要遍历所有的文件描述符，具有更高的效率</p>
</li>
</ul>
<h2 id="5-3-文件系统技术"><a href="#5-3-文件系统技术" class="headerlink" title="5.3 文件系统技术"></a>5.3 文件系统技术</h2><h3 id="5-3-1-文件和目录"><a href="#5-3-1-文件和目录" class="headerlink" title="5.3.1 文件和目录"></a>5.3.1 文件和目录</h3><p>存储虚拟化有两个关键的抽象</p>
<ul>
<li>文件<ul>
<li>文件是一个线性字节数组，每个字节都可以读写</li>
<li>每个文件都有一个用户可见名和一个用户不可见的 inode 号与之关联，</li>
<li>用户可见的文件名通常包含由<code>.</code>分隔的两部分，第一部分是任意名称，第二部分通常用于指示文件的类型</li>
<li>创建文件后会得到一个文件描述符，文件描述符是一个进程私有的整数，是一种权限/一个不透明的句柄/指向文件类型对象的指针，可以使用文件描述符来读写文件</li>
<li>对于每个进程打开的文件，操作系统都会跟踪一个“当前”偏移量，这将决定下一次读写开始时的位置</li>
</ul>
</li>
<li>目录<ul>
<li>每个目录也都有一个用户可见名和用户不可见的 inode 号与之关联</li>
<li>目录的内容非常具体，包含一个名字对（用户可读名和 inode 号）列表，列表中每个条目都指向文件或其他目录，从而构建目录树/目录层次结构</li>
<li>目录层次从根目录开始，并使用某种分隔符来命名后续子目录，目录和文件可以具有相同的名称，只要它们绝对路径名不同即可</li>
</ul>
</li>
</ul>
<p>文件系统为每个文件/目录保存一种持久数据结构 inode，inode 中保存了文件/目录的一些元数据信息（inode 号、大小、所有权、引用计数以及何时被修改等信息），inode 号在特定文件系统中是唯一的。操作系统并不了解文件的内部结构，仅仅只是通过文件系统将这些数据永久存储在磁盘上（文件系统技术大部分发展都是基于磁盘驱动器的行为），并确保再次请求数据时，得到原来存储的内容。</p>
<p>文件系统提供了一种统一的接口/方式（系统调用）来对位于磁盘、U 盘等其他设备上的文件/目录进行创建、重命名、访问、删除、文件读写等操作。但是目录的格式被视为文件系统元数据，因此永远不能直接写入目录，只能间接更新目录（比如在目录中创建文件、目录或其他对象类型）。可以有多个用户可见名连接到同一个 inode，那么在删除文件/目录时，其实是解除用户可见名和 inode 之间的连接，并减少 inode 的引用计数，只有 inode 的引用计数为零时，文件系统才会释放 inode 和相关数据块，从而真正“删除”文件。</p>
<h3 id="5-3-2-基本文件系统"><a href="#5-3-2-基本文件系统" class="headerlink" title="5.3.2 基本文件系统"></a>5.3.2 基本文件系统</h3><p>文件系统在磁盘上使用某种数据结构（块、树或其他对象）来组织其数据和元数据，并将进程所发出的系统调用映射到对该数据结构的操作上。文件系统中的大多数空间用于存放用户数据，存放用户数据的磁盘区域称为数据区域，存放文件的元数据信息（inode）的磁盘区域称为 inode 表，用于记录该特定文件系统信息的区域称为超级块，还有一部分区域用于记录 inode 或数据块是空闲还是已分配的。</p>
<p>在一个给定的磁盘分区上创建一个特定类型的文件系统时，可以通过将该文件系统挂载到另一个文件系统中，那么就可以将这两个文件系统树合并为一个，即可以统一在这台机器的文件系统树访问所有文件系统，而不是拥有多个独立的文件系统。挂载文件系统时，操作系统首先读取超级块，初始化各种参数，然后将该卷添加到文件系统树中。</p>
<p>当进程发出系统调用来打开某个文件时，文件系统首先需要从文件系统的根目录（记为<code>/</code>）开始遍历路径名，直到找到所需文件的 inode（这里的 I/O 量与路径名的长度成正比），获取文件的一些基本信息（根目录的 inode 是“众所周知”的），进行最后的权限检查，在每个进程的打开文件表中，为此进程分配一个文件描述符，并将它返回给用户（当文件被关闭时，文件描述符应该被释放，此处不涉及任何 I/O）。</p>
<p>从磁盘读取文件涉及到 3 次 I/O：读 inode，更新 inode 以及读取真正的数据块，从磁盘写入文件至少涉及到 5 次 I/O：读 inode，写 inode，读空闲块数据结构，更新空闲块数据结构以及写入真正的数据块（可能还需要更新父目录）。读取和写入可能是昂贵的，会导致许多磁盘 I/O，因此，大多数文件系统使用系统内存来缓存重要的块，读取时可能会直接命中缓存，写入时也可以延迟写入到磁盘。许多现代操作系统将虚拟内存页和文件系统缓存页集成到统一页面缓存中，从而在虚拟内存和文件系统之间更灵活地分配内存。</p>
<h3 id="5-3-3-快速文件系统"><a href="#5-3-3-快速文件系统" class="headerlink" title="5.3.3 快速文件系统"></a>5.3.3 快速文件系统</h3><p>快速文件系统（FFS）保持了与基本文件系统相同的接口，但具有不同的内部实现。FFS 令文件系统的结构和分配策略具有<strong>磁盘意识</strong>，即通过合适的数据结构将文件系统的数据高效组织起来，并使用高效的分配策略来为数据分配磁盘空间，从而提高性能。</p>
<p>FFS 将磁盘划分为一些分组，称为柱面组/块组，每个组中都有超级块的一个副本，并记录每组的 inode 和数据块是否已分配，FFS 将相关的数据放置在同一组中，尽量避免穿越磁盘的长时间寻道</p>
<ul>
<li>放置目录时，倾向于将目录数据和 inode 放在空闲较多的柱面组中</li>
<li>放置文件时，首先一般情况下确保将文件的数据块分配到与其 inode 相同的组中，防止 inode 和数据之间的长时间寻道，其次将位于同一目录中的所有文件，放在它们所在目录的柱面组中</li>
<li>有个例外是针对大文件，为了避免大文件将填满它首先放入的块组，FFS 会将一定数量的块分配到第一个块组，接着不断将文件的下一个”大“块放在另一个利用率低的块组中</li>
<li>针对容易导致块内部碎片的小文件，FFS 首先通过缓冲延迟写入小文件，针对无法延迟写入的情况则引入了子块来存放小文件，而不是直接使用磁盘的数据块，只有当所有子块的总空间达到磁盘数据块时，FFS 将子块的内从复制到数据块中，并释放子块以备将来使用</li>
</ul>
<h3 id="5-3-4-日志结构文件系统"><a href="#5-3-4-日志结构文件系统" class="headerlink" title="5.3.4 日志结构文件系统"></a>5.3.4 日志结构文件系统</h3><p>由于内存大小不断增长，可以尽可能在内存中缓存更多的数据，那么读取操作将尽可能地在缓存中进行处理，磁盘流量将大多由写入操作组成。日志结构文件系统（LFS）首先将所有更新（包括元数据）缓冲在内存段中，当段已满时，会在一次长时间的顺序传输中写入磁盘，并始终将段写入到磁盘的空闲位置（LFS 永远不会覆写现有数据），由于 LFS 每次写入的段很大且都是顺序写入，尽可能减少了那些难以优化的磁盘寻道和旋转成本，每次写入时的定位成本也由真正的数据传输所摊销，因此可以有效地使用磁盘，LFS 的性能接近其峰值。</p>
<p>LFS 会反复将最新版本的文件写入磁盘上的新位置，此过程在保持效率的同时，意味着会在整个磁盘分散旧版本的文件结构，这些旧版本可以进行跟踪保留并允许用户恢复旧文件版本（这样的文件系统称为版本控制文件系统），也可以当做是需要定期收集清理的垃圾，LFS 清理程序按段工作，从而为后续写入清理出大块空间。</p>
<h3 id="5-3-5-分布式文件系统"><a href="#5-3-5-分布式文件系统" class="headerlink" title="5.3.5 分布式文件系统"></a>5.3.5 分布式文件系统</h3><p>复杂的服务是利用成千上万台机器来提供的，单个机器、磁盘、网络和软件都会不时故障，分布式的核心在于通过机器间互相合作，可以构建一个看起来很少失败的系统服务。分布式 C/S 计算的首次使用之一，是在分布式文件系统领域，这种场景下，服务器负责将数据存储在其磁盘上，客户端文件系统通过网络请求文件服务器的数据，这种设置允许多个客户端之间轻松共享数据，也方便管理备份数据。</p>
<p>1）Sun 网络文件系统（NFS）在客户端和服务器之间采用无状态的通信消息格式，重点实现了简单快速的服务器崩溃恢复</p>
<ul>
<li>无状态指每个客户端都发送完成请求所需的所有信息，每个服务器都完全根据请求信息执行，客户端和服务器不需要状态就能够发送或者响应请求，双方都不关注不假设对方的当前状态</li>
<li>NFS 协议采用文件句柄来唯一地描述文件或目录，文件句柄有三个重要组件：卷标识符用于告知服务器请求指向哪个文件系统，inode 号告知服务器请求访问该分区中的哪个文件，世代号用于在复用 inode 号递增它从而确保具有旧文件句柄的客户端不会意外地访问新分配的文件</li>
<li>大多数 NFS 请求都是幂等的，这意味着操作执行多次的效果与执行一次效果相同，因此客户端能够在请求超时后简单重试请求（任何读操作都是幂等的，而更新操作必须仔细考虑是否具有幂等性）</li>
<li>为了提高客户端性能，客户端文件系统会在内存中缓存文件数据和元数据，并将其作为写入的缓冲区来延迟实际写入，这时多个客户端之间就会存在缓存一致性问题，因此客户端需要定期检查服务器文件元数据来确定缓存中的数据是否已更改，这种频繁的检查会限制服务器响应的客户端数量，从而限制可扩展性</li>
<li>NFS 是基于块的协议，执行的 I/O 与读写的大小成比例</li>
</ul>
<p>2）Andrew 文件系统（AFS ）通过全文件缓存和回调让客户端与服务器之间的交互尽可能的少，重点实现了良好的可扩展性，且客户端性能接近本地性能</p>
<ul>
<li>AFS 打开文件时，客户端通常会从服务器接收最新的一致副本，并在客户端的本地磁盘上进行全文件缓存，后续的文件读写操作将被重定向到本地文件系统而不与服务器进行通信</li>
<li>AFS 引入了回调的概念，当客户端缓存的文件被修改时，服务器将通知客户端，通过将此状态添加到服务器，客户端不再需要联系服务器已查明缓存的文件是否仍然有效，更不用依赖频繁的低级检查来确保缓存一致性</li>
<li>AFS 通过文件标识符（FID）替代路径名来指定客户端感兴趣的文件，FID 包括卷标识符、文件标识符和“全局唯一标识符”，因此服务器不需要沿着这个路径名来查找所需的文件，而是客户端沿着路径名查找并缓存结果，从而减少服务器上的负载</li>
<li>客户端崩溃重启后应当将所有的缓存视为可疑，主动向服务器询问缓存是否仍然有效，服务器崩溃重启后丢失了所有回调信息，此时需要主动通知所有的客户端将其所有本地缓存视为可疑，并且在使用之前重新检查文件有效性</li>
<li>AFS 是基于文件的协议，在进行小数据量的读写时依旧要整个文件的 I/O</li>
</ul>
<h2 id="5-4-存储可靠性"><a href="#5-4-存储可靠性" class="headerlink" title="5.4 存储可靠性"></a>5.4 存储可靠性</h2><h3 id="5-4-1-崩溃一致性"><a href="#5-4-1-崩溃一致性" class="headerlink" title="5.4.1 崩溃一致性"></a>5.4.1 崩溃一致性</h3><p>文件系统的数据结构必须持久存储在断电也能保留数据的设备上，根据上文，从磁盘写入文件至少涉及到 5 次 I/O（3 次写 I/O），磁盘一次只提交一次写入，那么当多次写 I/O 之间发生断电和崩溃时，就会导致崩溃一致性问题。</p>
<p>早期的文件系统通过阶段性运行 fsck 来查找并修复文件系统中的数据一致性问题，fsck 在文件系统挂载并可用之前运行，在 fsck 运行期间文件系统中没有其他活动正在进行，但随着磁盘卷容量的增长，fsck 扫描整个磁盘的时间逐渐变长，运行性能逐渐变差。许多现在文件系统都使用日志的方式来解决一致性问题（记录更新的确切物理内容的日志为物理日志，记录更新逻辑表达的日志称为逻辑日志，逻辑日志更加紧凑且复杂）。</p>
<p>更新磁盘时，在覆写结构之前，首先在磁盘的某个总所周知的位置写下一点小注记，描述将要做的希望保证原子性的事情，这个注记就是“预写”部分，注记写入某个结构就组织成了“日志”，并通过在日志的开始和结束块中加入包含日志内容的校验和，来确保在日志写入期间没有发生崩溃；接着将待处理的元数据和数据更新写入文件系统中的最终磁盘位置（这个过程称为加检查点）；最后通过日志文件系统释放已完成的事务在日志中占用的空间，从而允许重用日志空间（日志被视为循环数据结构）。</p>
<p>如果在写入日志期间发生崩溃，只需简单地跳过待执行的更新；如果在日志写入完成后加检查点完成前发生崩溃，文件系统将扫描日志，查找已提交到磁盘的日志事务（而不需要通过扫描整个磁盘来检查问题），然后这些事务被重放（在删除目录时会在日志中写入撤销记录，那么在重放日志时，任何被撤销的数据都不会被重放），文件系统再次尝试将事务中的块写入它们最终的磁盘位置。因为恢复是一种罕见的操作，所以这种设计上的冗余写入并不会造成坏影响。</p>
<p>这种记录了用户数据的日志（称为<strong>数据日志</strong>）使得每次写入磁盘的流量加倍，在写入日志和写入主文件系统之间，存在代价高昂的寻道，这为某些工作负载增加了显著的开销，因此考虑<strong>元数据日志/有序日志</strong>。元数据日志和数据日志的区别在于，直接将用户数据写入最终磁盘位置而不写入日志，只将元数据写入日志（这两步都完成后才视为日志写入完成，随后加元数据检查点……），即先写入被指对象，再写入指针。</p>
<h3 id="5-4-2-数据完整性"><a href="#5-4-2-数据完整性" class="headerlink" title="5.4.2 数据完整性"></a>5.4.2 数据完整性</h3><p>除了磁盘完全无法工作的崩溃情况，还有可能磁盘似乎可以正常工作但只是无法访问部分块或部分块保存了错误的内容。</p>
<p>现代存储系统用于保持数据完整性的主要机制称为校验和，校验和就是一个函数的结果，函数以一块数据作为输入，产生数据内容的小摘要，此摘要称为校验和（除了数据内容，还可以在校验和中添加更多的信息，比如磁盘号、扇区号等），校验和是现代系统中快速有效地检测讹误的常用方法。校验和和数据一起存储，数据和校验和被打包为磁盘的一个扇区大小一起写入，在访问时确认数据的当前校验和和原始存储值是否匹配，从而检测数据是否以某种方式被破坏或改变。存储校验和是在存储一种冗余信息，而冗余的存在是错误检测和恢复的关键。</p>
<h1 id="6、参考资料"><a href="#6、参考资料" class="headerlink" title="6、参考资料"></a>6、参考资料</h1><ul>
<li>《Operating Systems: Three Easy Pieces》</li>
</ul>
]]></content>
  </entry>
  <entry>
    <title>Test Driven Development</title>
    <url>/2022/09/30/tdd/</url>
    <content><![CDATA[<h1 id="1、概述"><a href="#1、概述" class="headerlink" title="1、概述"></a>1、概述</h1><p>单元测试（unit test）是为了检验程序的正确性。一个单元可能是单个程序、类、对象、方法等，它是应用程序的最小可测试部件，通常由开发人员编写，旨在验证代码的正确性和可靠性，通常是自动化的，可以快速执行。</p>
<p>在编写 UT 时，应当遵循一些规范：</p>
<ul>
<li><p>代码简单易懂，层次清晰，和业务代码一样保持 clean，不可能再为测试代码编写测试；</p>
</li>
<li><p>每个测试都互相独立，不依赖运行顺序，测试保持可用并具有确定的运行结果；</p>
</li>
<li><p>注意测试边界条件和异常情况，尽可能测出所有可能出现的场景；</p>
</li>
<li><p>不要盲目追求覆盖率，每个测试都要有断言，否则这个测试毫无意义。</p>
</li>
</ul>
<p>与单元测试不同，集成测试依赖于真实的环境以及组件，因此如果一个测试需要使用真实的系统时间，真实的文件系统或者一个真实的数据库，那么就属于集成测试，集成测试结果更加不稳定，通常由测试人员编写，旨在验证整个系统或模块间的交互是否符合需求和规范。</p>
<h1 id="2、Junit"><a href="#2、Junit" class="headerlink" title="2、Junit"></a>2、Junit</h1><p>Java 平台使用的测试框架是 JUnit，JUnit 是白盒测试，知道测试如何完成功能和完成什么样的功能。</p>
<p>Junit5 提供了以下注解（<strong>Junit4 和 Junit5 的注解名称存在区别</strong>）</p>
<ul>
<li><p><code>@Test</code></p>
<ul>
<li><p>用于标注测试方法；</p>
</li>
<li><p>每次运行一个<code>@Test</code>方法前，Junit首先创建一个<code>XxxTest</code>实例；</p>
</li>
<li><p>每个<code>@Test</code>方法内部的成员变量都是独立的，不能也无法把成员变量的状态从一个<code>@Test</code>方法带到另一个<code>@Test</code>方法；</p>
</li>
<li><p>Junit5中<code>@Test</code>不再有参数，每个参数都被移到了一个函数中。</p>
</li>
</ul>
</li>
<li><p><code>@BeforeEach</code>和<code>@AfterEach</code></p>
<ul>
<li><p>在每个测试方法前后自动运行；</p>
</li>
<li><p>用于初始化和清理实例变量，在各个测试方法中互不影响（是不同的实例）；</p>
</li>
<li><p>编写测试前准备、测试后清理的固定代码（称之为Fixture）;</p>
</li>
<li><p>好的UT永远不会用到<code>@AfterEach</code>，如果用到了那么很可能是因为使用了实际的数据库等外部资源，所编写的其实是集成测试。</p>
</li>
</ul>
</li>
<li><p><code>@BeforeAll</code>和<code>@AfterAll</code></p>
<ul>
<li><p>在所有测试方法前后运行；</p>
</li>
<li><p>用于初始化和清理静态变量，必须被标注为静态方法；</p>
</li>
<li><p>在各个测试方法中均是唯一相同实例，会影响各个<code>@Test</code>方法。</p>
</li>
</ul>
</li>
<li><p><code>@ExtendWith</code></p>
<ul>
<li><p>在JUnit中有很多运行器负责调用测试代码；</p>
</li>
<li><p>每个运行器都有特殊功能，应根据需要选择不同的运行器来运行测试代码；</p>
</li>
<li><p>Junit5中<code>@ExtendWith</code>是可重复的，可以使用多个运行器，这意味着多个扩展可以很容器的组合在一起。</p>
</li>
</ul>
</li>
<li><p><code>@Transactional</code></p>
<ul>
<li>测试完成后就会回滚，不会产生垃圾数据。</li>
</ul>
</li>
<li><p><code>@Disabled</code></p>
<ul>
<li>执行测试时将忽略掉此方法；</li>
<li>如果用于修饰类，则忽略整个类。 </li>
</ul>
</li>
</ul>
<h1 id="3、Mockito"><a href="#3、Mockito" class="headerlink" title="3、Mockito"></a>3、Mockito</h1><p>如果要测试的对象依赖于另一个无法控制或者还未实现的对象，那么就应该使用 Stub（存根），Stub 是对系统中存在的一个依赖项（或者协作者）的可控制的替代物，通过使用 Stub，在测试代码时无需直接处理这个依赖项。</p>
<p>如果要验证被测试对象是否按预期的方式调用了该被测试对象，并因此导致单元测试通过或失败，那么就应该使用 Mock。Mock 对象会保存交互的历史记录，这些记录之后用于预期的验证，通常每个测试最多有一个 Mock。</p>
<p>Stub 和 Mock 都是伪对象，一个伪对象究竟是 Stub 还是 Mock ，取决于它在当前测试中的使用方式。如果这个伪对象用来检验一个交互，它就是 Mock 对象，否则就是 Stub 对象。 Stub 对象不会导致测试失败，但 Mock 对象可以。</p>
<p>如果需要创建真实对象，那么就应该使用 Spy。使用 Spy 时将调用真正的方法（除非方法被 stubbing），Spy 与 Mock 相反，Mock 对象在调用未 stubbing 的方法时返回缺省值，而 Spy 对象在调用未 stubbing 的方法时返回真实调用值。</p>
<p>Mockito 框架可以与JUnit结合使用，可用于创建和配置伪对象。Mockito 提供了以下 API</p>
<ul>
<li><p><code>mock(Class&lt;?&gt; tClass)</code>：返回一个伪对象，可声明未 stubbing 时真实调用的缺省值</p>
</li>
<li><p><code>@Mock</code>注解配合<code>MockitoAnnotations.initMocks</code>或者<code>@ExtendWith(MockitoExtension,class)</code>一起使用，用于声明一个 Mock 对象</p>
</li>
<li><p><code>@MockBean</code>用于需要依赖 Spring 容器的测试，并在替换 Spring 容器中的 Bean，或者增加 Bean</p>
</li>
<li><p><code>@InjectMocks</code>用于声明并创建需要进行测试和方法调用的真实 Class 实例</p>
</li>
<li><p><code>verify(T mock)</code>：验证 Mock 对象的行为是否发生及行为发生的次数</p>
</li>
<li><p><code>when(T mock).thenReturn(Object obj)</code>：控制 Stub 对象的返回</p>
<ul>
<li><p>不能用于 Spy 对象</p>
</li>
<li><p>stubbing 可以被覆盖，真正的返回取决于最后一次 stubbing </p>
</li>
<li><p><code>thenCallRealMethod</code>显示指定某些情况下调用真实实现</p>
</li>
<li><p>尽量不使用<code>thenAnswer</code></p>
</li>
</ul>
</li>
<li><p><code>doxxx(Object obj).when(T mock)</code>：stubbing void 方法或者 <strong>spy 对象</strong>上的方法，或者用于多次 stubbing 相 同的方法，以在测试过程中更改模拟的行为</p>
</li>
<li><p><code>spy(new xxx())</code>：返回一个真实的 Spy 对象</p>
</li>
<li><p><code>spy(Class&lt;?&gt; tClass)</code>可为一个抽象类强行创建出实例进行测试</p>
</li>
</ul>
<h1 id="4、PowerMock"><a href="#4、PowerMock" class="headerlink" title="4、PowerMock"></a>4、PowerMock</h1><p>算是 Mockito 的一个扩展，用于 Mock 静态方法和私有方法。</p>
]]></content>
  </entry>
  <entry>
    <title>2022.8.29 - 2022.9.2</title>
    <url>/2022/09/01/week-1/</url>
    <content><![CDATA[<div class="hbe hbe-container" id="hexo-blog-encrypt" data-wpm="Oh, this is an invalid password. Check and try again, please." data-whm="OOPS, these decrypted content may changed, but you can still have a look.">
  <script id="hbeData" type="hbeData" data-hmacdigest="23f2459aa1de48d05eb6474628d4fe17321b68a818b6a076b7d094eed94c5252">a99f2d1cd7f89812758242c57c62a59fe859e32cc19116fcceb1abacce500da0960986acd07eddb3568f524414b51feed7a27390ead2b4e38ef97ca6a69051de3eed1dc0ef3d5dbd0adc8ea0315c70bf7a5da8be0cbb0af4d53a0a17af2dc55c33755fa623c7a3ed6013fe0e940979ae5d4ee6ed5af7396da742bf3ee8dc5b34bd15d8ef4fc5fdd125f32532744f97ddc0651eaa5a5cf1c8e9ee906af2a205b30ff111e8003e20d9fe8c95977448df23cefc9366339e2531a29db42eda4ab96fbb7230c354accb5cc97704556342bcaec84b209204b4de93d65ef14980dae0043f59466f228587fa66545c4f0bec1ae837fa7f34640cfd6e9b9f823a7308ed8196bc27b692192a3d2b388cfb45b2959a434c585cabfc54cd0856a55ed205d3001d8cb239517816b3d3a8380e868dc0bbf15808b947d576c71f6424cadb83eff0b72445d6e69cc345cc2ab39c2ab6babb8c1ef274e6cf18e05ccc1f265a5276170c3556bf26902c9bfb9e2f2c1b4eeecd6b33d1fd59dabdb59837af389b5a51baf5421b449aca61f9cf4f1afa63bf3e625edec37a5983dae157abe990e6adf6dc1f47e26eae79744cf49d0207728a9ef3ceb334f6d64a6069d2571827e7c7f6b2c909b2ceaff35f82967d94595531f47476c79b211413a6233ba8a53b81ee260b34a6e7dd6829767f12f652623865cdf26caf00295cb63742e583bdea6277514597e05aceee13edaa8bf2a8d46d770524a1b27d912842a299f7869105028df12111dfb1c7f91f6a74542b082f0f0642815a04dee7004f9a058f0b4331fad3f8d06ab1ac00fc916f583235e0592a28a5be3847131a71ae742e084e7d69bd19e389305dc30041d510882e2822a0e3080267445dff2a6c1592ce044a0e22e2bdfd307953b4226cbfddf8b2f4c7816f0c0b8c8fb90987e834819c6cf55c4a8f232ed41a1a31f228e6b16d46e98115a38b32f6ba9117fdc5d065d058408b1167c47e0d5c4c566f5cd10f92deed02ae2ee0f1e2ca6182513099b2921c2a082fcb37cc13228f8669bb0154bda0901f2766bd767ca206afa0f82c7c370490031833f0e37133e2a9d367b4017f6d75f91ec0db61ae9e33073e16cb3e82c587c9feade2bfedbe8f2269409cd98100a7cc8843bc8dbc69e8da54f6b21de0a42eeaac3e7529f17c4488ae5073239856a4d3771b83732a7203205b51fd96a407a95782a03f44408704c9d29e9637484540f97b0fc447406f64bee5c889ea7e577abc8300b5fcd71ce512698e54b9f8ab93a993fb62854f9e6f133f5c3484b083c853794d671673a2183d1a7eadd3b12951007f3b255e282bc1dd7021f2fa855472d6d47d65b4f71bce0728dc003aee6286b07546a29431d6f92ec0c861e5db2b4b04bd26d3244bb252fcd96a8f4a6ff8822cf68eed282c104592d18552bccddb84a09b7c92ba9e84ebd5105ef7b0f8e052f0128d83199b07015a22c342c39ffe5e4c1fe74ebf2762b159c73ef87691bda6e5baddf6bbeb9ebcf2421ed2938f44967925eb82831a0c2e121cedf54b2a77ed1e819f4f99230bd2052c45f8a2302948a83a3527da1b445544f4ba23b91bd49f8b765c12b7967dcf2421a21950125b0367b87d27d2775496f4cbff37c26fcfdbae3cd83ecfec7d642b63a4a24f309fd5b4981473c427b2ca1490c5c3ba2bac3f573b46cae3a13cef6036f3bfda273146c10f58082eef17ceb2004c74f4bc5cb711a652a2361696d3f390061007131907ff0ee198f1464a8c432381727bad9969084ca0fe196377e64f20722343a66e7a4be1f69709c6528d8209d09ce1a774dfd72cd0d2f130fb93b940e9cd86b3c7e1a99f68530e7b1edcb7e2fa1ebd60fe28309360127f63f4b8e2fd6f7d5ce4af5ca064071fbf913dee0b77ab9578988c54d32a02779538a4e5d1e29f0f0e00e0dabc6402781282fbd80fb93b7eae67e1103bc57f475fbbd70191e497798d170582f78684823729aacfa09a52b650f12e669aebf4194ac9caf0b12524995f8e2767a9435d95d705141683bc4d361436edf4893e5a619716b0b313fb98062d18b043b925745ee0aba913956c438f23b7bf1f75ac9dbca48b0a2f1be93aff3bd40a808e757940277e58e04a0ad6fb1a226456628224746e180ba0056786dfb62ac0a29d284ee97235a858c45355631a499bc39444863727b3562313863bede03a6aad384a5f41cde1535c85567c2dd489e78958a39289f10716e0f67140d45c556c7bf9901140bea4c94ba33a6b2c845a0d6c80aca908436ce4f6940f85059ee406ae301d0a0b5377ae5f2a60b8e0009a21b23d441c7a6febd3ba5e74e860c90e86300db92bd1ed014148aea4d62cb4c94d5a0f4e8ef2f8e6216d046ba1d425b45b76eb03e2deac531ce0f42a1a9fe8a97e375124ca5ddbd86c3a2d508e0a71078ddbedd55737ea57cf6b7866226620ba864f91d480cec2f3ad2766fd993f2c8483aece2dd1c670afe507dfff7ba78c71b712a659dfabca4156e3cfa579503a7025823b86e5a2915467c40e92fb8a938146bce7b82a625fca865b096850206543c5e58386835505003a992e2be0d2b6b43e63dd131115eb04e7e83b9a45e1e8aecd55abbd95622a0096e5fa410594e4536a9bba15f2018b871829040129b584e66961a9a9580bb99cb122574846ddc12c4becc3bc6e6fe6d381d15b1da9a84de2f8056cfb062e5f104229698bc46c1f056a1f62f8452644d0b7430fb91d2e25e065db19566ba29b5c6737b260e6314b65439a1a4adad1a1b90147c476b63324dbb5aeb3b51951bc8a3b107f558f465bdb43badae80b17276dfd9ce44105398f4a133fd5c6b04b9e393d3bab8d693d78905cbc272abbaf3591558b154a10df5722c7df881e88615f960873209421cac0f87d48c5cbfb22121a55e8b33b58085c0235b84785f739c9e15cf4dc0736a3ff2625810fba8a1175582e079a1ee96e3fc3b71cf700b03aa4c47e8cf223efdc11d3af78dd7388004cb1d4f67087f0b21aebda05fc4931bf213621bf9b224aec827c8c5ee33894a7a0da810958af08614d386830312641ec8c2ed05e51b77bb9a8d3be56f8268825e85cad8d49ed55c78974847d93b97808b0242ac13c6b32da101b821501922ac3b2d95b6cde66d79d29bace1497fa59762ecbdb9139cc33fed739b8cedc3205c78362eb8cd89d3e4c84f2d880eb0f3fdbe64534ddcc40839efea4b1c3edcffc1a08e60c3de00d86fb106ca2d6e41c1a1d8be4f8e2f984f7cdbdc83bb262c998ed44041461cada097661c5055d921c63349df0eb67484e00753dbd4b3dd339eca7cc8283e39d5cfe0d07b072c74af9994c62812de491195d5142db723e0ffd90311d824faa53af8acb1e05097b2b8e5a8e44a845a427ebf249836bd1761491c5ed2f0227a2b579c8a928f53d9da65cc64851367c2a28cee5982b804be4db1ac02efe34bca436742591874012b661fa8e37891cf53f3f6b45547ecb685f084a8ee9bdefdd46ea5683e60450072be8761f96d866da786507b2e236640f383202ede6fd1c28c761c17924942bb438773d494bba756da41252f371c6bf6584e9110140ef20b02ebb6c688f830cd00493cf255fec8027435b0fee31daff5ffaafee7b782b42f97a5a40bdf6faf59237737f93e8eaaede50e834e6ce0425b872da3449af6c8330250886a31cef13342861eaabffcba28e2f4800f601b2c002235a25d1df3731dba1e7960af834763e0f2f0964b0704afef9537207561a40bfe9b5da1196704da2d10f760fd5818e617d29052b5322c4fcdc0e5bafd303e26a8e74d68744744a7248241c83ebccb0852da6fc8dbab7a85cb7355e3e6ef341cef9c784067832aaf8cfb7c0be187852db83b5fc7a6780a56d9983fbf24fd67108172171fd737796a34f0bc5e344eebac00b727cd45ba9acb71c9ac1e07b366e0f8b04bd6c605ba7e71c0544210aa0d1c3688c37104fa89b89c599105f5ba0dd36beef0acfec119055948f026aab1f22bb5d5b79f2a59ca6d3616a0d1257ae25cecb2599f424b656cf9e27c63c1663457a43dc806dde706c02596482331b2ce3ab983da33c37e94e348b5123dcc36bea7e37c8c88eb6d1fa4666a88d938068ec7f51d431e62e839fbc1380ad5585038ab086e6cd33e41cc8f8f751d89d31ac43afde1f74c9871fa245e3b3ddc2e5794bd277371182d4b71102433671d35feddc8c0d9251c29265277d2874e8b2adce019f174b38c519298cc32d53ff8febb44270f10859154571ec1e037a9af0cc86978bf75ce3ef6268cc73bf6528c69cbbf38d4d233a9a9be4d4486953bc67e51bb4532696f86e67ee1e5bd60c90abf87b8a1a633c8a86799e507fb106be70157807249f2934b5b4b44f19578776526f04f46b621e11130cc9361230545dd27f61ba05d304f223ab8330f90eabbf5af4adad8387f6c1698e09233d6d594eb617a49e7b9c2cb0ab098e6da1099885658b74a90f709f65eea6820dd3fc1674a3511e7d270e0fa9e1042b349bce6ea92ac94881d4518151de2f1689bf9be725a3c3a4daa57538fbdaf554436aae3a305f50e20a78a88f628bd8f2c8da8e6ddb81bc5090d8633e0deebf90f45c5e4010ccbb3bc96a32e42a8c0c4a968d7fe8536b27e490994551ec9878f802a24d214d2f48d2dc35dc3d68097fecb725360f7b87ee2337c9562118382d03df8deb02eb1dcbd85554a726a8e8b3618599d134924a422910a226d300876328018a98d4698fc0ee8ee499ba3af20191f3bc9fdacbd722968a3fcbf44481da65f7fa17fb728b4a8fa5fd1db5f3c21b16f3ab6f69e2c3cc6a6423f476f8a296c6bdd96b15b83a36eba56ccb0a84f0b27d8f432299e249f1bf37f4c13e0dc561360f2747ec1c7a741f7297861348991391c170b3f72d2ff0d24efd20f196000149cacf068a299e99a45934fbf24e92f3d31a4681217799b41160a5b02fdad72588c4e61219d0394d97cc9855225136c0307085921b6c385958ccf967692b841dfbf131f65212226686ee45c7737ad23f6a62e2e2017e105c1e1d5bd75a1e5ebaca8a67ec6085acd629b3187a03ad5c3d41f89f47857a34281efa54e48f5015c62086ed2af1eaf8af64add288ae32c4cee2bede33bb403a3a237eb725a2f7e33cbe57a553e4e37a839bd024ca3079afcc8f53aaf2c6af6ba0771d528913d426b20b85c3696f7d11b552ae76930cd852658de4bbe72a4d052001d41aa2971c878de8678713f424872654bed7d82bdf8f3d9251b619da17299432cd26b7a6c9b8e01fb109f7536d5c741a91f7f6e090af6067d41bb0cef72348634bcc302ceffc7d1348568026b9bdb4690c6e56b79d209f22a8d323ee44978290ea51d697ac79dbca9f287a4792e346f2eda6f0167fa16871c54a6ea35a811fbb89d461f1e8659ba72ab0363a09f1b46d01a514f3623eac4ec59621ebd45c0fff8f46dcf2bfec317b9aae73932c5e4b6779e67dcef6b1105147a92ab5636de61053143539ddedddb1f2c8e5749bcda0fd3b19cdc34707e63d58ec5fe6fd18dfedf2372f9a6d5a1fd83306542fd44f1add76f9af04fd233898791dd39c1fe5ad5b7268b2f548a3a20ec6bca330f09281be0c4c3e5efa8f8fa010c51cd43081c94a41d466bedc33eaeacf1ce781b79603e8c3d1edc7be6ac9e9297eff673e06eb71bf5c633daaac6d2ecc1b9b78c2233ff52d18e2e25dfed7a71ae89a713ccf98c1656cdbe72e8ce1ea1b2bfe942b3b645bf635a97eb0eabe06eccf82ef7d1a08443f39d6a4f5a326cc236ab974489080305b03356186bd9a51207bad988ec34a6fb308ab2300e15f4455266bf5127fcbda33156fadb4556a58b53176d6455740d9eef2a79ebda4cb84ca8d813fe0a873839a2f252307b7137c5c0f13686a38bd4aa0af923f3c9b3f12a544e48bbfc1ceed5c3c0050e92276a5900a4d9a8be6180e2918b9b6f9fefa1af71909ec3c667a0ffc348578bc8d82d7ba4a02b76d4d447a546db2aaf223f516a70f2ff50fb378a00050a67c6dcf5af4136398ca4708456e6b92ccfe8f2bddc688ae876c3c0ae47c56bfd2accff16b281a9e9b40fd0fd06e2f8cb6893fe4be47fd848a4db6d001e546c5c2f20e02b2e002efdaba89bca55b8af5e7a0202ce221f89b485276a7daee135ca01067d674e78f10727b8ee36af2a29ae4bc402fc7389157217fab427e3e9db8d2ad93fdf741b0933a408144eb2c2a395d2f8261708259cb81189685603f8002715e157ae571daf9c60567273b5789b8bef58bf7b777a54b024c4f6988b5550b2fe278d2c139245512a59e63ff5522e90c395fd89cb79764289450d9033041a2ed0dc24d37fd0a7b4218c51ccaa6028985060352c50230951d8a07a526ce94535edf0e5716d806e070b6fc6ba51cbf09827c4beef680c3386d67f6d643b644eb48dea9161d3ff8be909c7b5a368de960a7f3ff05fb20e3dc0956a5e075b8c46f09d2b66802921e4ca70b5c0bd3e5ea0270525a4865d8b96cbe0a9fd3fbeff0b84f958ea2e20b72f2e678205bdf5ac3d42cedc2c434004b15bf30f116fe946a59a9a0247330abe1092c2c6d37f75a01e453a491d34cf75f7ac4ca39a6ffb861414db8a8dc4e39fe3b11ef4daad726b9ab35ec35f4baba5ca0a0a5f3682a39637db6eef8e18d9204d42ea8fe31f39b533c44c25d1b7cd90454e9f005de12ba6ae7cd501252ebb47849c688a5689f6912631bf7cb93622b4c95d3df030cb903ad779af6f7743c5c8e0628dbf4d8a6e9c2132a10e9666cee90c0b4cadaba376f97fd43de3af15f719f9a34ac9ed153d64ac8a255b96b8e79ae6d22c1706c88281c43da8ef6a77126dc3bfea1ade0cde27c8d23986f64d9a0960a9ebbc2a2467bee8f91e994ec5fedd5852aa4bb0347c4c8142d590953ac044fa798c7be592ad77f8c9e7c683ec7c54de26ef9892c4785390043201e73c8fc56f3ed98f06f14faf8ef91a184c61195fa1028bd886c7180b218ac4fa6af7f07818b960b3a8f7487b326a67a54c45efaba8459f1c1e89a02269d7b3cd473de694be7d2304c8d40d1490adafacbf5d0a487d40d3cb86aa5794f3e15add50e48a8e6ccc56b5eeb89378c9a31814b821c4130f7f284f622aab2b32cdb5583f7cec5b7d76daf530d9cfbe1d42b4dc21813089648e851eea482e2b9a6ae1a956c1dcf7df9b1e180f533760f36ee8dcd2a375ce0b96952a7f971b04b0753e7dc73402b220a2e5623182c8907820d6ff57b3a6f61b871393f984e1225ed26592428f8d70f4a04ef10d824dbe3dfd10626d449e46fab71043a978a73ff01032281ae490501b1669c4f86bbbbf8f1466a7a4eec9b4b15f73a68ec0ee8d86a5fdff86cec63cb1f6774221a8f80d020c05bc71506c825ef9710fe21f9b4b7238c6a018ef9390afff7f509d316bf64a41906d0de388dd232731b82340352925c3774a8557797600ac933499186983a69a216b0c33c4f0689a273080aed2e2d44b87066aea8098edc7c36a611b47591930c0c3bde13b2905e72f899045802ab1cf3e516488bbb24563bb12df505ca7f5b0fdfc7328b1ec33b4449ae7d68906a9bdf3ee380b46ef13e701ebca620c850c349ecd1c9d11e86016a6c057a3857c84d7a9a96b10d0a5e6826c242e631e235807d671dbdd46565a8c161214b56209fba3e4d744181cfc1906a7ad7549f54076cab057d7aa2dc027ac74d7bf719d87418a3637ae0080e953675781d339100fe60a831125ad695134b555d41339a23b0d12c630dfe3c5c99bad3fdb796d12e67c3fb2c9b678b7624f05c62378f48e3e9b9803b20ab8640faee86147051cfdaa34a0743d414dc68636bca0ea41ad73e736dda916bce2b6733e947ee00cd2377cebd2588e0c60bbe45818566983cf6375a1c3174d10a883ced63e75932d0ab24d5101ea3d9d9f5898818812159fa7c7c17d9f9bb075a76caf6d9a6d89aaa41e4c1ba3720cf1b59a24d7992763810619646f5cc056e898d011f76ae2590317f5640647fa2d2a391b92d0e1425d52c22d73e5f070c0ff54fad728ca6bb2e25e49d4b731550c2d048a9da0b0b8b310911e8c24919348561ac82544573ab3874d85eff0993b73a89772c821d952ab74bd16c485c48ec1515575b603bb0975b4fe8e32cbb1ae25d71c4a44cd42885e57f5112654b4f08a83ff0d65afbc4f48c39e79834024b811619773631ee4db752355e7d6731ca6ed89505de681555f5f02fb1a73bdadd799b0e33f4adb36e4af27e1ead35d80219be34f80d04dbf2c42eb8e1ea5911565be7a8c29e825fbd2fe827467a6f21cf3927a02c3de27b50198419da1df758235c21abfc9b649d2aec8a0133a074554e8e70c9fbd29a861cccb395bd881d5c3b2e59f82b6bda52588de3c8b0faa42ab1f3c3291bcc14f84472b3373d3ca4fa99d3ce5aa649672d3c90134c35a824f54f0cf78ed171a6eb9e20b083111992965de09dc1b0ba32a4a6a089e8d0756cd985638ed21e165070e14f014b9c7a020a296efe80a38bca388cccbaabc2a4c12289dcf2f4c73fe5332f45ad80c154f7703235a9cb1eadc524ffae36c0dff4c9a3bf982aa0777a546a5344760bfbb8ab9c6c399305b423231d6f16f67de59e5884789b149b97b032ca51b377839d026be9cf526b81137875555d245ea06a90d47884c2e38abf9f7a0b55cade727d0a63814173cd2e2684ad3c04b871bb6a8ec98f83c655b01366c1c43275267a3d8e7959769814b76684ece68246d202f3e1d1b18215cc316cb53a559c1a5e3af836d9f997af6b2dbba4fe29cba2a2fa8c927e41822913a1e9ebd78b35c3659ffc5b11284fc941b7086db30abcc154bf539909b0786c6840bed7d7a7d4f989f31ca11297e789688018e55cc269de2e84578aab926e00601d28ad0bad3d57e6bf049a2f64438f3bb4008ee1443d6068968897b748ddd6b274666f6d2958b88b9af5a8fb540abe593f958f3c1a07f37941535da5e7f66f85c581b696e77a8dafe7fce68c8cc10c9166f3e11be7661a93b28a3573772c7c98d756cb0f0f225dddee80549d9679ee7cc3e04d712aea318991eaf7154b6c34216b9edfca21a7193b551d693ac1c26b4a03ff31b6faab59c5970f15e6033384cd276b7a2f5bd06f2bac6e9f2171091e066f6d524e0bf3021f275be63d510efd7271f6683a082efe5837e015fa07890b0789c5704936590b5dea29dfef09626f5a1e656a039b39c9f39a26a4e7652898387721a740726ae124316805072e6300ee06322cf497702de88b303eae977b7de316f97df5c96c6c30e0e61c230a79cd37022235cce5b5c894ba1a1aa770fc31fedfc33997e2f57b885d0ca5bf99ea555d1043a3dbacb585fbebf8e1c4fd1e6abe4c123181c795aab2cbe01f165989f3c6f3b5d41487aabe9c115421c5394aba22e43ef9a1ae9da1392acbdeb346ec5829329c473a8068b34aa34168dd652050c2424498ac0addc9fa59845955fcd4842200e6b72450a7879bb10e2be1da68781a6146dfb5fb6698a123ca52dd8b8dc5bf775fe99c95e75e12d6c4bf5d64bcc9892d2c2bc46dd769fb897eb652a0178c56869d02f35b8a870484586466ae25e49fe8bd4c981c13e867976f0ba594419b1ed0b87d3d640b879443f77f60c128ed73410efe3c6e778113b9de88f03bbe8aff7db5c2cda03a38ea3ee9e495b2e16a3357bc6239f65ec8e40fe3ab8e0d268fa04190f9a882aa29455a602590e817a3e6d55c1e8854dd1abe551a38f473f6a00e73500b762646f229cabb79dfa7ba13001ceb814faa77368f93141d1695943c763cf91cb9fef5280a553ce95590696d42ab5b0a503d2c24fb52adc2ad559f57b92b546085b9f1b28b2393afd13b23059e1a1704510235bf758bd853be7504486436567edcddbcb8690ec371d92dcaf4548c7d39d5f88e778e02a1ceb3537a11347801f484a18a6a97ed423d989e7b24128e77c13109d6060d7688c06cdeeb35e53ddcf48d80087af857adb443645c5f23945a8022b4e7849f4d90a372422670970b56dd6293f456422b5438bc2161358de2899d66f3d8e762cb1a684576cca543bc3f256028909e5b9dda3aa5ba57e4cfda3495faff3c97e8805f4a65b611421a6bb5328c0b525a55a255361e2f4d2c6a84a3cb809ae2c4f93c06ac961445e1a322e6543b1ecb877fd9771c8303b4fc514460fc9e5f278faa76c0d6fc8f096237b1a896ba63090bb0184aa2c6f6af5f35467212d9476ab32811bc6a6e50051ff68054917841804dd947417e14df17afe563b47faee05609bc1db2158d940f25a263f29540c86474078dfdd8fcb8d42bdbd9b9d083404fba86b83d70960d10d62dc3716976fa94ba0aa0023d1d8c5a4be434db2d0444707379631ac3483baec572a322d5bd49073303a1c57f03223055d0b31f1f4145d5307ced139270f7e86845d885c7a53202ed1686cfd2963d90716a2f3d14838c060e6292f27c2a9fad2bee3341cf9f87b5f3855988787fd92e893c897b3ceb9dcef54a895894a98d2fde4e5e844caa7f0b5f98cebcdff275e7d58c2a3a7c8c01e9c4087b87603798da8304e7f84d01e3902571a7bd0d45c16f7102fc9dd40a069b9d633270f2401dc8515d48cef0808d53fb853e31868ae473da5380aa31e01ba78410cc7766687e19b0bfe05bf5411132ea628afc0caa86fba6553b0b5b605c82dbf96217aa5e21da6824663e60566752e553b6d3358a21e875652374da06efc19d087ecc739010c5ea5cb760a3c3fbd7905b72533498f3175a5c64f5521f2254d853370f02efb81f3372a35786ff019f81ec8d5f21f98bb717ff18ff9a01c29e74bc7165fa42113b036d16800bf9c604096fb058c1a7ac6eb42ad32944169d7a402ab93c6bc7243b539ab4f9f067db427fa748d641a5a422ae189220ac6b4e1d32db784f5e58485767c5c59d066faba7a4c7d816848615e7505be5d10061eb21ff86ce7e09b5aba130b75d20f304356d1cc9ab0283e8fa58055c8bd819a7b1ea1df32a040da67a90588ad3daa4212fe1d95bbfc6d199afba586682ea3bf9891c9a86b4c9f2ae7a4123b4cd858f2ac0eed04a488437e5c34199c3c5632697692453209246152ca9f650034d4473db3fac40cf283a7ee69cad411e4a67e76235b9cae6bb550f95f079fd11bd87267ed7e6d0406d962258c313df3f27644e1fc58eb011161c674175626563d2e1db9bc14a3c2fe3f0f235042d59edf66c22f6209bc5bba05cba759424c2867c1db2dd8092abb3bd3266e65ccfa7e95bb39971ba4b55a62dea153a3b9c658bb9bc3cf0f828a3cd7748d7695c6d2a7ad4c6968e59cbc53feef5b2ee8bcc6fa36360b998a614575f8cd389649393dd1f99034e86c03908b961d4bf98e15bcb75274ba7f1bc213cc43c29f6e95f8d95c47c7edcbb7595f5119031905123497f0bbe15dbeefaa1f7c04c2bff3126a816a26046549412f9428335a4570809e6645cd6bd17f4f108e24f3346aa318d6e5601b7105635f5462ee719612e3eecf22e2432acef62bc8b5a15486369e4f0ad3b74a0a1adc895f27a84f40e0836132aea1f668c0161082ece65861b400da44804a2a581692026366976313bc6fa57c323dbec8a5d5afd4c68c7a5dc6029779f02a4c34e5c8a52a6650c00b1fb1674fa3906de539d0526e03e22360d14f2d68a59c38dd6992201f43b9085f6a5b9c79f539b45ee334fa93dc553f67e5b6f34de2fb46d9d20dea7a47515964875a9f5ea5f393e5630d81e5ab75ced88d021d22ab6e3524737279ca750fd431fb668111570efa8f923dbf00934f36f1a3c5939c6287e3be018100a1c9be8ea0dadc613aaa72b8b5cde50f596b210cfddfa3250f0bc936b7fe8e72cc8b029179e9353da0bf2e114d3322963cf8b6b876a9ab690ab44e081692e5fa9a16fb49349a6fb4ef91eaae9c9663bd608bd30ac1397f3daf2b40816199b91de209041d102678463caf2b59e5a31c368f8761ccbb72fc4d44d0be78ce378e75d7f1f75b94260051e252000fc94da4081f6bbd2d4645519e689fd13ebe8410bafbb446cc9e945e323b3b98ce35e482b6c506ab994b30bb354d262561d07cabbaec51322abe8bee92e75bdfc77e1ab683d176f1bd1a8999e04109f2c22ba6929f118e947cc52771cc58a8f807951418bcb58a4e852700e6129b9a5a170d1b037055c7e0ed59dd0cdcbf4f22fd5f74233a33c04d624937c62c5e241d3f4c6bdc0fd6dab2c7de3f824928ae346f8ffc680b882af58591671b31f69b00a4bd11f4963b36b9eb639ab87701ccfc8d674d62b16e2a862d3c85d057145ecf39f59085f2ae77023dca37a20fc202e6c7b77799950197365af0f67e13645e2b8573f9115b7c417d25281ecb2a43992e644c0de6f510e83abbaef8f6b1529d662dd1a3054fd2c930884bd8c51c76105232e43d37b2c4ca89184983f2661dde9520c5a99092d47a0acfe467a4fb8b3a6d8c45f44552eaf3198478b2e4ca00de12b361a6ee8e2999e36aedfe14e947f20976872eca34875efdc1bfe0f995b89b3d8df0698ae9aade1ce017f4eaa812c0db7270393280e40e62d5e7125210fad8817491bff0f711d8b2b7d489f5186868ee5c13d148c9bf90ddb83f7666ea75e154a4b40cd92b31a15ee0eefbab60e0125a9b858fc71f0db691c83c258e934addf69693cb60db79cc6bf0b9237c0223e6121f2efb1fbcc4ed479f9d55594c4677fbb6dda9df5e7bfb8ae54c4c73efd8af42edca6b5d84a081587f434f1f08bdede9c7a017002954d32796d6bd2af63ab2d2886b3fb0c2bafd35ef74156e7c376625369f5ba12f1048378af19b7a4cdc8ad4b76e163f64256823eb68444a8b1565d685dd8fcbc2e1fdc9b1095364e533884041827eb2ee473a6a52212330d3af4475e4d41232daab17670e530931f694968811d25a8c4f3412c76c65e6ca6f91321abe6e7ccee76ed4cfe0bb905d1191b721afcd9674369a4ce12c4f83a99c26f44749bf6b9cab09ae5ce12f99bb7eae9bc7aae040cfdbb275304688714d73bb2dad89dfe106dc4039744f1b5051b111d5f91dc1f3d264faac47a3ab7ee04b89c533066b042be30ce2999a0eabf7565239a287a949ffd866583c1101bdec79d7e5efe2ac4dbf914ee186dc53585d1f66043ce4629440f32e2acb27297b373d62e1d41e1d3730749d79722889f4f65146e03c89c8baf80af0af100a829f13ef918cac2199f59aac9dee60022ac50ea079820a5583680d310195d1c2d8770ceeea99e83bf5297670484ec8789bfb6b870ffeab46b0e2137d7bd33cfc1fe3cf7f061ab8d2ad7073b90eacd22cb3f496eef6bb5f3ebbc1f2fdd7875f510a82abc5f192f91240c0a0f427ed5bffa26ef1fe23c7378a6c41bbc4b501d8b6be108e4234b5531218f0f6c75992a2f1428a648cf9ca07678b196c42ad92fe77fbb70e814ff0714c2afcfe5a17a3420dca14acaf159fded3a46ffe0d96be207b10de2170e6de9e2842c8e8fab5726c89e4f5d818c8416e05e9ad33aebf9ab0c2acb172c99f0b88a758119105038de2573fabf660647d230aa0d9a9ab7aa1a110004322034415d702ee82b71ac19c0d46f074f5ed22df4bb4c99bac98f559ae87742d83ddb2c8354eb81a633ccd23c57595042f57fc31af550dd7f2877661e6974cc8cecefa9a9ac62e31b3aeecbde1f4f3e33a71ad07cbf871018eb7b072484e7693207408e575c7e2c6f0932d791ad62f3742d195ee65992881a1890cfe7eb5685c5cd12ccdf1495edd9f205527d39153220c85fe8abe4a83ff2c887b5abbb7a513daf453da96bf3cbd4cf5b87d52562f4ff5879aa0b667dab96383ef530767da4b9643e8573fac8903a96e59ea28d51f0814dcf9c330da3217bdf8a8d40980cc5a56e2e97c27175b28972be7440c49dad03f3d1f94d6a3976d86bef67538a5c586f8b37c13122e8bfd9c86eb20f7b073ad9719310fd902355356406bf46e37c993386b6f2fc38b3ea90981863fa8b30ddac5e3c4d1aca928f1c3805aebcc25a51778d51348cdace271c6d4018dbaefa0b749d912aedc407f9bb876714a70bd1a6d968dc588fdadd34e0f93cd376fd9cdd52d4a462d69b13ba9c061391beff23102a0df549e14e185f658f27456602c7a2f66ea5621c1ac350a4a62ab124ea2726a9969678220c008c1c3ad1755cd2b9dca0a0df416c768590a974a019a95bffa10e9aa8db3cbd4bd49f36d766573818e57e0b4bc3c73ff5ff8fa12d00c558ca24af47b9096b66607d80ac023ba98edd163fdfd84e98b1e1a41c41626168cd7563d1985bd80e50b9729a758def3b81871543da7f38854cf336a4da12221d2997e4d2c0e363d9d6d1e4a4dd44bcd1a90dcb0c232eaa94400cc2189d232e2bb24f71e43bf4fc50aa5505cb005ff2a12819775c018824b7d26f05972836b5fa785a4e715c92865d008fe39c2428169a128baf5bc5aa8be8ed6e029396d533da409c8f772de721a57029c85cad8e5ce4d3ddf3963c60ae15482288a9aa7176a36723a84b56de8f8926269df3e4386fba2e7ee62ab5794ccb999eb6358984439c4c6069852fd1fe79fe23978c5d358e7a07dcb0039a1df3267173a162f34e42567c16610a3c4c56d22c9e1d408fd9008980bb103091dbb3e3783fb754390dadb2d3610670450e53602ac86458778b3e6956f647c7b5d46b3c2f3984bdac995c6503fca4959db8b6315ef32f3c887a2a0c9d4abef71f0548074e15125e0dfe273099e37004569ff1d2aab73bfd72d7bf6b5ea5250d8200fff91c99290453d62d245c5cfb8551ef968cba116e2e0d6c235bc55fa6f37cba804fcf41ef851873a3416ef8af00eef7a84aa79ee35f4fc7f2ab4e70ca3815a696a1e4d34a2859b68178ff8265c83d8873b7fbe48062a36094a4aa0777b3600e17637add7b4ccbf844e7e4ece7be208e2ad2a942c240e7cef4a219e79a4f7bfb60331616f1bf6e6851a2437257a522e3e207ef8ef170e993cfd9b0dd8e19f36bf95a3a6173b4b1b489c57ff5a15200989c659ce5c465d0ac96556c85e7aaa4e07a5b46fd16394f994aed2520a7a892a74ae94d665b99ae67280a2845b0fd022afa0f4d44bd8c5693ede5a766fb08666eb749b5512549289672d64cc44b88609aee350c7160bb4c2b6c745af548d577eecccb5a025b4c3a0062990dc5bcb142f01a347344356385c72786629f13eb0e2e206aeb50eb5252d025034eef03b1df305400651164d1060aee394929a46fcdadde3a1d65d233925db17c98e929f979f736f599a2a173ef903e8370b865dc25324b06e8403faa17cd2b39040104dbcbe621e9788beaa27fbb492fc569bbec6e9e683f7bdc9faf774cc21cc59a3039a0b451908332c5105885fb0f8cff15891af91fbfdeabbaf6106ece8587a4565aa529a7a59f8e2e10002d930df193aa672278c8635f8b4bb260e38a177747beca32ead0c40ab874bf69333beebaf4559ad6cd6886d630e86547b698a1c25c4d734e0d9f43a8e013fb7189ecc524471603235e8dba8eead6e1cad01e07c73eb7b3c99e002576db57afc06e0b37727412e5fc3f0dc7f604413f502b9212ff3d113e139b4c6b87127d60c53085ecfab7d4e9cd989dc351003c61c490b0f2a9d43acc3402d4d7c513ef280eb727b2a2d76d9bcea938f29d968741c963aaf90ef3cade075c974272a0083bb90332434670f0dac5e16ec3622fa62dbcacbc7fa7746e83c7bfe44fab1847bc793afa3dae84f52e4489a4cff07f5f86c1b2c642f1c462da1cf2b6f293cef159c7f9d17ec7880c62b8e35bed620f051fcb59c4ed9fec3f3f4e2e6d6ba3c0b6674ffa8527c911a08de533fa74ac35342f87fedaaf4fbfd337710a3722de6ced513040ab9c59236c6a9d926e0b5b669c682df3d165deae84b599583fb6eb21e3c359166e553ba3c480a3f6a8ca42e95a6b5699aeb8b332a48aa52889f99d9a9bc456ede4a1528a0092ef98b9155f01e1d4837bb3d13560cab81684cfc393961604fbad4e1f0a23a6ad428592df6c7316058071d728141ac5ca262ba26145f29f07f127803f2a2dc374517cdf4635d3376ae80ea23bdf2d6ac352f2fcdbd6937c2c808caaf53f07b97b03610a0223fb41c6e63e2a3fc72c31895eb2c40ff240490499a9fd1030f755c14944911993b0f9d063b572dc0a3ff99d361d7085e9314c2f0dad15762ddfec5a1e37e3067d220ac5f16b5b7b0e8cb319c442387198b2902c7b5dd50284e5e3d95039c559fbd8fff9bfe209c22ac81d7842574f50f4f732068ab48729af2d49b35323651a3d568bedab202a5ec5932f2abe8a2b8441a2e21c253fd19cd91605dd6ff0cec1cb4418d78a553cda319cdceaa5ec4bb6fb05eb494291bcf4d6a978b527fffae4e9fdf96d43fc6e1326371f83f9256a93851e97ade11f1ce079fc4adbb660577d557da50e58ccf9452c7f3b84a791c56d8d61fbf4c76bac47799b913003879d02016c213e180d6859e7c8e061a4f8aa5d2da544c330680db6932bf62a4a0c9f194f41f73ccb8b9fb0ee156ef40238d22f40e1854b47d9abb1fde3baf12d927e9fdbad353e4dcc9613aafff2d4e3c947590dc4ea4f0ac080256e5a22c48a14fb67ec9d414bd4de75e5cc4e83872055dbfdb36c1aa05406ee67fbce0f82c8581701d5bc425862a5fadfcada22b7cdb1ff9bcddfd6e23ae21fec1373bfe576663c52c5d6e6ccf237f56bb61dc9d0713c26cd372a72e277d108d04f41751011f4839dd8b41d97168d7f941bd4938273523d2041df2e86aeb72adbe6cdb0eb754a156a089b33d68350bbcc9dd78677eeb6b537316c772b820a28e664b7fbcb95d4e0336bf1e68fc38d246148e99a36b3df36a5133e68ed7143c58d898b1aba2dd8c588ad3d14584a117de64e3a57df61d1b4c5390c92bc389b58d2d3dd3a5b0050ebca6350469197f66cc6e4e84113c6c63e5ed737edded339ba1749ba6ec0468843b1c3d62e06e68a3cc5cfd8fd145768e4b9f08d8ea9b623ea0d7a641201b3e7ee6307f8b2aa0dea74fa51c826ba7708e12585b465bf1deb3d8d1ae32bcee15088c0131d8d5103111b7d92500437562083642fd14c07ebebbb64cbf545a7727be43c1471dc7c60b3e88a011db15b9ec700224db10a2017bf7ec06fe1910307d307e7ecaa7adb1fc490d9516856d8df66a4edf049510ae7d409e34ec860c025398bf22ada0ddb81fc68e829ad9bdb40a9b1d97ca96e2898c881a57fd1ea99d67d8b153e67fba4c5c885f2e583e8eb8c4094d4c392ac355e2a83e0c30b3b720756043c9109aacfc3f23917a7e6f622885e5254e4813ab45407dc836b3318b9c026f7d2935ab96bff1ad306c411a8e01fcb0428d625d069599b8c24019075575a62bbb2a0371b320b5af110103b5f91e51a16a4050c452f45d13b753c2482d669d340ea800bf8ea931dba3f5ff48a83f22a04161a178226c0289eca5cada19986d2559512452c968e53d48f16b4fad1908c30e6c23e3d6b0661616e1b6f7e23097a886fde0f18ed626c553a598763518e66372ccd425a79263ffacc7eb1442f2ff8634ec5fabe2fdd0791fab2ca90c69ecae0302bacd0cf26d23fd779c15609925c91365ffe8d57d1bbb519fdbe88b84fcdd47b5fdef79f6a1a17ad60a1fca68cfc06abd4ceec5e6a081a187c6bc9a6ab1f209d74d70902bc0284df656a08874f78a33367b2936ab167fe64df64ef4483c6495e8f7f1ed38195d13478e66c4399a1df6b756f12a55c9b60f474d18cb79a91202dd8186a14fef94c9f47840fe09533f472ee7c071003bb093d9852f7c5cb70aa3bc081cefdba31829a08aeb7765a37cef845a04fdf82216807e098e2fb73da9b3cd90fbfdde8ee0edb5d31ab282a02622a2e1ecdece88a26afd381c474aaa4ae5de0eec20fe4ae09ff37078df7d22336db6f6ea9d9a2a426ef20f382c35d89d23fb597a941299ac5a6bb9df755133758eb8926fba427dc9720cbffcbaf45515f82763c9a4eedb16e3b9c00f956d0dd7c64141efd41c0230a6f4bba2b2708bb52aa4eca8b7dd7f0faee91db0419ad9e59e1b677c0091d6d31c399fd7bf859c76db3e15ebcee118f31603e9de0debb110034b15d116808996377f09358bc393f3c54071e2f9bb3dadb1ff64f7cd75a364e12d2365c3134ad0ee021991a887abe829ea8c9ebdd0c92130df5a133c758b20276ba6fe117ac4c21de56c14bdc3156993b946564579285fe7b07c1799762787b579565b24499f966a992ba23e3c26febbb8e90f6dd2eee81800c3d08773fc1f567d814d8f8fc5f678369febb52cbfbef773ea3762e482f98e5e8131679e221e7d2e64bcf539741cfe9a7366727b3fe2c587638da45797b973416be889303545303def7e0b1a00a6e4be1037fc2fbd46711908bcd8f1a98ebf730f5fc2ec6f64566402c8c82c946eb390a9c84f22abad8276e7e14d93eb7a84768ef639117004d73d804bf539802313109665784a4af9cfbcb17441f2ca8e2aadb043a9a98d7e63eb4134af5acb57f940eb535508e00bf3555d3ea5d7b0c5b24d7be6213c73213f3183f5d81d794909a6f66b6e78d64c431152321fa33911de7f5b9202330660f0a9d59fd5b8153b5a9c3c3f7049d15b312a4d09ee8451dda07299ac38c09adddbc725dd445d0373b19dfde2fbcc9665491c68d91bfd5</script>
  <div class="hbe hbe-content">
    <div class="hbe hbe-input hbe-input-default">
      <input class="hbe hbe-input-field hbe-input-field-default" type="password" id="hbePass">
      <label class="hbe hbe-input-label hbe-input-label-default" for="hbePass">
        <span class="hbe hbe-input-label-content hbe-input-label-content-default">Hey, password is required here.</span>
      </label>
    </div>
  </div>
</div>
<script data-pjax src="/lib/hbe.js"></script><link href="/css/hbe.style.css" rel="stylesheet" type="text/css">]]></content>
  </entry>
  <entry>
    <title>Spring Framework</title>
    <url>/2022/05/10/spring/</url>
    <content><![CDATA[<h1 id="1、总概"><a href="#1、总概" class="headerlink" title="1、总概"></a>1、总概</h1><p>Spring 是一个取代了 EJB 的轻量级框架，它提供了一系列底层和基础设施，是以<strong>简化 Java EE 应用程序的开发</strong>为目标而创建的。</p>
<p>Spring Framework 主要包括几个模块：</p>
<ul>
<li>核心容器：Spring 最核心的部分，支持 IoC，所有 Spring 模块都构建于核心容器之上；</li>
<li>面向切面编程：是开发切面的基础；</li>
<li>Web 模块：提供了 SpringMVC 框架给 Web 应用；</li>
<li>数据访问与集成：支持 JDBC 和 ORM 的数据访问模块；</li>
<li>Test 模块：提供了⼀系列的 mock 对象实现，使得开发者能够很方便的进行测试。</li>
</ul>
<p>注：IoC 和 AOP 不是 Spring 提出的，但 Spring 很好的实现了这两个思想</p>
<p>通过这些模块，Spring 可以实现：</p>
<ul>
<li>基于 POJO 的轻量级和最小入侵性编程；</li>
<li>基于依赖注入和面向接口实现松耦合；</li>
<li>基于切面和惯例进行声明式编程；</li>
<li>基于切面和模板减少样板式代码。</li>
</ul>
<h1 id="2、IoC"><a href="#2、IoC" class="headerlink" title="2、IoC"></a>2、IoC</h1><h2 id="2-1-问题与解决"><a href="#2-1-问题与解决" class="headerlink" title="2.1 问题与解决"></a>2.1 问题与解决</h2><p>Java 组件在协助工作时，可能会反复实例化一些很复杂的组件，为了避免重复工作，考虑共享一些组件，但组件的共享会导致组件之间的依赖关系逐渐复杂，组件的创建、共享以及销毁也变得不好管理，即难以根据依赖关系创建、组装、获取和销毁组件，也很难进行单元测试。</p>
<p>传统应用程序中，组件的控制权在应用程序本身，即应用程序通过<code>new XXX</code>来创建<code>xxx</code>实例然后使用，在 IoC (Inversion of Control) 模式下，组件控制权发生了反转（从应用程序转移到 IoC 容器），IoC 容器负责创建和管理组件，应用程序只需要<strong>直接使用</strong>（通过<code>setXXX</code>方法或者带<code>XXX</code>参数的构造方法来注入<code>XXX</code>实例）由 IoC 容器已经创建好的组件。</p>
<p>IoC 和 DI 是从两个不同的角度来描述了同一件事情，IoC 是从对象的角度，对象的控制权转移（反转）给了容器；DI 是从容器的角度，容器将对象所依赖的其他对象注入进去。</p>
<p>Spring 的核心就是提供了一个<strong>可扩展的无侵入</strong>的 IoC 容器（容器是一种为特定组件的运行提供必要支持的一个软件环境，无侵入指应用程序的组件无需实现 Spring 的特定接口，对 Spring 的 IoC 容器无感知）， IoC 容器是 Spring 用来实现 IoC 的载体， IoC 容器实际上就是个 Map（key，value），Map 中存放的是各种对象。</p>
<p>在 Spring 的 IoC 容器中，所有的组件又称为 JavaBean，配置一个组件就是在配置一个 JavaBean。IoC 容器可以管理所有轻量级的 JavaBean 的生命周期，从而将JavaBean 的创建配置与使用相分离。IoC 容器在创建和装配 Bean 时需要知道 Bean 间的依赖关系，依赖关系可以通过 XML 文件或者注解这两种方式来进行配置，这种创建应用对象之间的依赖协作关系的行为通常被称为<strong>装配（wiring）</strong>。</p>
<h2 id="2-2-XML-配置"><a href="#2-2-XML-配置" class="headerlink" title="2.2 XML 配置"></a>2.2 XML 配置</h2><p>在后期维护时，XML 配置看起来非常清晰，但系统越大，配置内容就越大。</p>
<h3 id="2-2-1-使用步骤"><a href="#2-2-1-使用步骤" class="headerlink" title="2.2.1 使用步骤"></a>2.2.1 使用步骤</h3><p>1）通过 Maven 创建工程并引入<code>spring-context</code>依赖；</p>
<p>2）通过属性注入或者依赖注入编写组件；</p>
<p>3）根据组件间的依赖关系编写<code>application.xml</code>配置文件，定义需要实例化对象的类的全限定类名以及类之间依赖关系描述；</p>
<p>4）创建 IoC 容器实例，并加载配置文件，使得 Spring 的 IoC 容器创建并装配好配置文件中指定的所有 Bean，接着就可以从 Spring 的 IoC 容器中获取装配好的 Bean；</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">ApplicationContext</span> <span class="variable">context</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ClassPathXmlApplicationContext</span>(<span class="string">&quot;application.xml&quot;</span>);</span><br><span class="line"><span class="type">Product</span> <span class="variable">product</span> <span class="operator">=</span> (Product) context.getBean(Product.class);</span><br></pre></td></tr></table></figure>

<p>Spring 容器有两种，一种是<code>BeanFactory</code>接口（Bean 工厂），另一种是<code>ApplicationContext</code>接口（应用上下文）。通常情况下都会使用应用上下文，很少使用Bean 工厂。常用的<code>ApplicationContext</code>接口的实现类有以下三种：</p>
<ul>
<li><p><code>ClassPathXmlApplicationContext</code>：从类路径下的XML配置文件中加载上下文定义，把和上下文定义文件当做资源；</p>
</li>
<li><p><code>FileSystemXmlapplicationContext</code>：读取文件系统下的XML配置文件并加载上下文定义；</p>
</li>
<li><p><code>AnnotationConfigApplicationContext</code>：在纯注解模式下自动装配并加载上下文定义；</p>
</li>
<li><p><code>XmlWebApplicationContext</code>：读取Web应用下的XML配置文件并装载上下文定义。</p>
</li>
</ul>
<h3 id="2-2-2-静态装配"><a href="#2-2-2-静态装配" class="headerlink" title="2.2.2 静态装配"></a>2.2.2 静态装配</h3><ul>
<li><p>每个Bean都有一个<code>id</code>属性，<code>id</code>属性定义了Bean的唯一标识；</p>
</li>
<li><p><code>class</code>属性定义Bean的类的全限定类名（这会通过反射调用无参构造器）或者工厂类的全限定类名（和<code>factory-method</code>属性一起使用）来创建对象；</p>
</li>
<li><p><code>scope</code>属性指定了Bean的作用域，默认是<code>singleton</code>，Spring 官方提供的作用域如下，此外也可以自定义作用域；</p>
<table>
<thead>
<tr>
<th align="left">作用域</th>
<th>定义</th>
</tr>
</thead>
<tbody><tr>
<td align="left">singleton</td>
<td>一个 Bean 定义只有一个对象实例（默认）</td>
</tr>
<tr>
<td align="left">prototype</td>
<td>每次调用都创建一个实例，允许 Bean 的定义可以被实例化任意次</td>
</tr>
<tr>
<td align="left">request</td>
<td>用于一次 HTTP 请求，该 Bean 仅在当前 HTTP request 内有效</td>
</tr>
<tr>
<td align="left">session</td>
<td>用于一个 HTTP Session，该 Bean 仅在当前 HTTP session 内有效</td>
</tr>
<tr>
<td align="left">application</td>
<td>用于一个全局 HTTP Session，该 Bean 仅在当前应用启动时间内有效</td>
</tr>
</tbody></table>
</li>
<li><p><code>factory-bean</code>属性指定创建当前Bean的工厂Bean的唯⼀标识，当指定了此属性之后，<code>class</code>属性失效；</p>
</li>
<li><p><code>factory-method</code>属性指定创建Bean的工厂方法，从而能够代替构造方法创建Bean，如果和<code>class</code>属性搭配使用，则方法必须是<code>static</code>的；</p>
</li>
<li><p><code>init-method</code>和<code>destory-method</code>属性分别指定Bean的初始化和销毁方法，<code>init-method</code>属性要求是无参方法，<code>destory-method</code>属性只能对单例Bean起作用；</p>
</li>
<li><p><code>default-init-method</code>和<code>default-destory-method</code>属性为上下文中所有的Bean都分别指定默认了初始化和销毁方法；</p>
</li>
<li><p><code>lazy-init</code>属性默认为<code>false</code>，代表会立即加载Bean，也就是在Bean初始化后提前进行实例化；</p>
<ul>
<li><p>可以通过将<code>lazy-init</code>属性设为<code>true</code>来实现延迟初始化，也就是在第一次向容器<br>通过 getBean 索取 Bean 时才进行实例化；</p>
</li>
<li><p>对于<code>scope</code>属性设为<code>pototype</code>的Bean，<code>lazy-init</code>属性设置不起作用，即始终保持延迟初始化；</p>
</li>
</ul>
</li>
<li><p>通过<code>&lt;property name = &quot;…&quot; value = &quot;…&quot; /&gt;</code>或者<code>p:xxx = &quot;...&quot;</code>来注入数据类型；</p>
</li>
<li><p>通过<code>&lt;property name = &quot;…&quot; ref = &quot;…&quot; /&gt;</code>或者<code>p:xxx-ref = &quot;...&quot;</code>来注入另一个Bean；</p>
</li>
<li><p>通过<code>&lt;property name = &quot;…&quot;&gt; &lt;bean class = &quot;...&quot; /&gt; &lt;/property&gt;</code>来注入内部Bean，内部Bean无<code>id</code>属性；</p>
</li>
<li><p>通过<code>&lt;property name = &quot;...&quot;&gt; &lt;null/&gt; &lt;/property&gt;</code>来注入空值；</p>
</li>
<li><p>通过<code>&lt;property name = &quot;...&quot; &lt;list&gt; &lt;ref bean = &quot;...&quot; /&gt; &lt;/list&gt; &lt;/property&gt;</code>或者<code>&lt;property name = &quot;...&quot; &lt;set&gt; &lt;ref bean = &quot;...&quot; /&gt; &lt;/set&gt; &lt;/property&gt;</code>来注入数组类型或者Collection接口的实现类型；</p>
</li>
<li><p>通过<code>&lt;property name = &quot;...&quot; &lt;map&gt; &lt;entry key = &quot;...&quot; value = &quot;...&quot; /&gt; &lt;/map&gt; &lt;/property&gt;</code>来注入Map类型，其中<code>key</code>和<code>value</code>可以根据需要改为<code>key-ref</code>和<code>value-ref</code>；</p>
</li>
<li><p>通过<code>&lt;constructor-arg values = &quot;...&quot; /&gt;</code>或者<code>&lt;constructor-arg ref= &quot;...&quot; /&gt;</code>或者<code>&lt;constructor-arg&gt; &lt;bean class = &quot;...&quot; /&gt; &lt;/constructor-arg&gt;</code>来注入构造器参数（默认的无参构造器不需要这样注入参数。</p>
</li>
</ul>
<h3 id="2-2-3-动态装配"><a href="#2-2-3-动态装配" class="headerlink" title="2.2.3 动态装配"></a>2.2.3 动态装配</h3><p>在XML配置文件中除了静态定义依赖关系之外，还可以通过Spring表达式语言（Spring Expression Language, SpEL）在运行期将值动态装配到Bean的属性或者构造器参数中。比如<code>&lt;property name = &quot;...&quot; value = &quot;#&#123;SpEL表达式&#125;&quot; /&gt;</code>可以将<code>#&#123;&#125;</code>界定符中的SpEL表达式所计算得到的值装配到Bean属性中。</p>
<ul>
<li><p>SpEL表达式提供了多种运算符；</p>
<table>
<thead>
<tr>
<th align="left">作用域</th>
<th>定义</th>
</tr>
</thead>
<tbody><tr>
<td align="left">算术运算</td>
<td><code>+</code>、<code>-</code>、<code>*</code>、<code>/</code>、<code>%</code>、<code>^</code></td>
</tr>
<tr>
<td align="left">关系运算</td>
<td><code>&lt;</code>、<code>&gt;</code>、<code>==</code>、<code>&lt;=</code>、<code>&gt;=</code>、<code>lt</code>、<code>gt</code>、<code>eq</code>、<code>le</code>、<code>ge</code></td>
</tr>
<tr>
<td align="left">逻辑运算</td>
<td><code>and</code>、<code>or</code>、<code>not</code>、<code>！</code></td>
</tr>
<tr>
<td align="left">条件运算</td>
<td><code>？：</code></td>
</tr>
<tr>
<td align="left">正则表达式</td>
<td><code>matches</code></td>
</tr>
</tbody></table>
</li>
<li><p><code>+</code>运算符除了进行算法运算外，还可以用于进行字符串连接；</p>
</li>
<li><p>在XML配置文件中使用<code>&lt;=</code>和<code>&gt;=</code>符号时会报错，最好使用文本替代方式</p>
</li>
<li><p><code>?.</code>运算符可以代替<code>.</code>运算符来调用方法，并确保访问右边方法前，左边项的值不会为<code>null</code>；</p>
</li>
<li><p><code>T()</code>运算符可以用于调用类作用域的方法和常量，但该运算符的真正价值在于访问指定类的静态方法和常量；</p>
</li>
<li><p><code>x ? x : y</code>形式的三元运算符可以简写为<code>x ?: y</code>；</p>
</li>
<li><p><code>matches</code>运算符对<code>String</code>类型的文本（作为左边参数）应用正则表达式（作为右边参数）；</p>
</li>
<li><p><code>[]</code>运算符可以从用来获取<code>Map</code>、<code>Properties</code>中的成员以及字符串中的某个字符；</p>
</li>
<li><p><code>systemEnvironment</code>包含了应用程序所在的机器上的所有环境变量，<code>systemProperties</code>包含了Java应用程序启动时所设置的所有属性，都可以与<code>[]</code>运算符搭配使用；</p>
</li>
<li><p><code>.?[]</code>是一个查询运算符，用于从集合中创建出一个新的集合，新的集合中只存放原集合中符合中括号内的表达式的成员；</p>
</li>
<li><p><code>.^[]</code>和<code>.$[]</code>也是查询运算符，分别用于从集合中查询出符合中括号内的表达式的第一个匹配项和最后一个匹配项；</p>
</li>
<li><p><code>.![]</code>是投影运算符，用于从集合中的每个成员中选定特定的属性放入一个新的集合中；</p>
</li>
</ul>
<p>SpEL表达式虽然功能强大，但是终究是一个字符串，不易于测试，也没有IDE的语法检查的支持，只有在使用传统方式很难甚至不可能但使用SpEL却很简单的情况下才使用SpEL进行装配，尽量不要把过多逻辑放入SpEL。</p>
<h3 id="2-2-4-自动装配"><a href="#2-2-4-自动装配" class="headerlink" title="2.2.4 自动装配"></a>2.2.4 自动装配</h3><ul>
<li><p>通过<code>autowire = &quot;byName&quot; /&gt;</code>可以为属性自动装配ID与该属性的名字相同的Bean；</p>
</li>
<li><p>通过<code>autowire = &quot;byType&quot; /&gt;</code>可以为属性自动装配类型与该属性的类型相同的Bean；</p>
</li>
<li><p>通过<code>autowire = &quot;constructor&quot; /&gt;</code>可以为构造器自动装配类型与构造器入参类型相同的Bean，此时不需要再声明注入构造器参数；</p>
</li>
<li><p><code>byType</code>和<code>constructor</code>自动装配都具有一个局限性：如果存在多个与该属性的类型相同的Bean，Spring会抛出异常，因此，要么只允许存在一个Bean与需要自动装配的属性类型相匹配，要么将其他需要被排除的Bean的<code>autowire-candidate</code>属性设为<code>false</code>；</p>
</li>
<li><p>通过<code>autowire = &quot;autodetect&quot; /&gt;</code>可以首先尝试使用<code>constructor</code>自动匹配，如果没有发现与构造器相匹配的Bean时，将尝试使用<code>byType</code>自动匹配；</p>
</li>
<li><p>默认情况下，XML文件的<code>default-autowire</code>属性被设置为<code>none</code>，标示XML中所有的Bean都不使用自动装配，除非Bean自己配置了<code>autowire</code>属性；</p>
</li>
<li><p>通过将<code>default-autowire</code>属性设置为<code>byName</code>、<code>byType</code>、<code>constructor</code>、<code>autodetect</code>中的任意一个，则可以令每一个Bean的所有属性都使用所设置的自动装配方式；</p>
</li>
<li><p>即便设置了默认的自动装配方式，依旧可以在每个Bean中重新设置自动装配方式来覆盖默认设置，即便使用了自动装配，依旧可以混合使用显示的装配来覆盖自动装配；</p>
</li>
<li><p>当使用<code>constructor</code>自动装配时，必须自动装配构造器的所有入参，不能混合使用<code>constructor</code>自动装配和<code>&lt;constructor-arg</code>元素。</p>
</li>
</ul>
<h2 id="2-3-注解配置"><a href="#2-3-注解配置" class="headerlink" title="2.3 注解配置"></a>2.3 注解配置</h2><p>使用注解自动装配与在XML中使用<code>autowire</code>属性自动装配并没有太大差别，但使用注解方式允许更细粒度的自动装配，可以选择性地标注某一个属性来对其应用自动装配，使用也更加方便。但当需要修改一个Bean时，无法很好的确定到底有多少个其他的Bean依赖于这个被修改的Bean。</p>
<p>可以通过XML来配置第三方jar中的Bean，通过注解来配置自身开发的Bean，此时是XML+注解的配置模式，XML文件依旧存在，因此Spring IoC容器的启动依旧是从加载XML开始的。</p>
<h3 id="2-3-1-使用步骤"><a href="#2-3-1-使用步骤" class="headerlink" title="2.3.1 使用步骤"></a>2.3.1 使用步骤</h3><p>1）通过Maven创建工程并引入<code>spring-context</code>依赖；</p>
<p>2）在XML文件中进行配置；</p>
<ul>
<li><p>配置<code>&lt;context:annotation-config&gt;</code>元素，可以告知Spring使用基于注解的自动装配；</p>
</li>
<li><p>配置<code>&lt;context:component-scan&gt;</code>元素（除了完成与<code>&lt;context:annotation-config&gt;</code>元素一样的工作，还允许Spring自动检测Bean和定义Bean，此时不再需要<code>&lt;bean&gt;</code>元素）；</p>
</li>
<li><p>会扫描<code>base-package</code>属性所指定的包及其所有子包，并查找出能够自动注册为Spring Bean的类；</p>
</li>
</ul>
<p>3）定义配置类</p>
<ul>
<li><p>通过<code>@Configuration</code>和<code>@ComponentScan</code>注解编写<code>AppConfig</code>配置类；</p>
</li>
<li><p>通常将<code>AppConfig</code>配置类位于自定义的顶层包，其他Bean按类别放入子包；</p>
</li>
</ul>
<p>4）通过<code>@Component</code>和<code>@Autowired</code>等注解编写组件；</p>
<p>5）在<code>AppConfig</code>配置类的<code>main</code>函数中创建IoC容器实例，容器创建并装配好所有Bean，接着就可以从Spring的IoC容器中获取装配好的Bean。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">ApplicationContext</span> <span class="variable">context</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AnnotationConfigApplicationContext</span>(AppConfig.class);</span><br><span class="line"><span class="type">Product</span> <span class="variable">product</span> <span class="operator">=</span> (Product) context.getBean(Product.class);</span><br></pre></td></tr></table></figure>

<h3 id="2-3-2-自动装配"><a href="#2-3-2-自动装配" class="headerlink" title="2.3.2 自动装配"></a>2.3.2 自动装配</h3><p>Spring 支持字段注入、构造器注入、<code>setter</code>注入，但是 Spring 不建议使用基于字段的依赖注入，这是因为这种方式使得 Spring 作为外部容器却感知到一个被封装 Bean 内部的私有成员变量，破坏了封装性。以下注解均用于在类初始化之后注入 Bean，实现自动装配</p>
<ul>
<li><p><code>@Autowired</code></p>
<ul>
<li><p>是 Spring 容器提供的，作用于类的构造器、字段以及<code>setter</code>方法，相当于把指定类型（先是<code>byType</code>方式，再是<code>byName</code>方法）的 Bean 注入到指定字段，且不受限于<code>private</code>关键字；</p>
</li>
<li><p><code>@Autowired</code>默认在指定类型的 Bean 不存在时报错，而<code>@Autowired(required = false)</code>则不会报错，即找到指定类型时注入，没找到时注入<code>null</code>；</p>
</li>
<li><p><code>required</code>属性可以用于<code>@Autowired</code>所使用的任意地方，但当用于构造器装配时，只有一个构造器可以将<code>@Autowired</code>的<code>required</code>属性设置为<code>true</code>，其他构造器的<code>@Autowired</code>的<code>required</code>属性只能设置为<code>false</code>;</p>
</li>
<li><p>当使用<code>@Autowired</code>标注多个构造器时，Spring 会从满足装配条件的构造器中选择入参最多的那个构造器。</p>
</li>
</ul>
</li>
<li><p><code>@Qualifier(&quot;beanName&quot;)</code></p>
<ul>
<li><p>在存在多个相同类型的Bean的情况下，用于指定注入的Bean的别名，与<code>@Autowired</code>搭配使用，相当于把<code>byType</code>自动装配转换为<code>byName</code>；</p>
</li>
<li><p>通过<code>@Qualifier</code>可以创建自定义的限定器注解，然后通过自定义的限定器注解来代替<code>@Qualifier</code>来标注指定注入的Bean的范围。</p>
</li>
</ul>
</li>
<li><p><code>@Inject</code></p>
<ul>
<li><p>Java的<code>@Inject</code>几乎可以完全替代Spring的<code>@Autowired</code>；</p>
</li>
<li><p>与<code>@Autowired</code>不同的是，<code>@Inject</code>没有<code>required</code>属性，因此<code>@Inject</code>标注的依赖关系必须存在，如果不存在则会抛出异常。</p>
</li>
</ul>
</li>
<li><p><code>@Named</code></p>
<ul>
<li><p>相对于<code>@Autowired</code>所对应的<code>@Qualiflier</code>，<code>@Inject</code>所对应的是<code>@Named</code>；</p>
</li>
<li><p><code>javax.inject</code>包里有自己的<code>@Qualiflier</code>注解，但不建议使用该包中的<code>@Qualiflier</code>注解，而是鼓励使用该注解来创建自定义的限定器注解；</p>
</li>
<li><p>实际上，<code>@Named</code>就是使用<code>javax.inject</code>包中的<code>@Qualiflier</code>注解所创建的限定器注解。</p>
</li>
</ul>
</li>
<li><p><code>@Value</code></p>
<ul>
<li><p>用于某个属性、方法或者方法参数，并传入一个基本类型或者<code>String</code>类型的值来装配属性，<code>String</code>类型还可以是一个SpEL表达式，表达式的计算结果可以是任意类型；</p>
</li>
<li><p>用于注入资源，Spring提供了一个<code>org.springframework.core.io.Resource</code>（注意不是<code>javax.annotation.Resource</code>），它可以像<code>String</code>、<code>int</code>一样使用<code>@Value</code>注入；</p>
</li>
<li><p>当程序需要读取一个资源文件（比如配置文件等）中的内容时，可以在<code>Resource</code>类型的数据成员<code>resource</code>上标注<code>@Value(&quot;classpath:/logo.txt&quot;)</code>，然后直接调用<code>resource.getInputStream()</code>就可以获取到classpath中的<code>logo.txt</code>文件的输入流，避免了自己搜索文件的代码。</p>
</li>
</ul>
</li>
<li><p><code>@Resource</code></p>
<ul>
<li><p>由<code>javax.annotation.Resource</code>包提供，适用于包括 Spring 在内的所有IoC 容器，但在 Jdk 11 中已经移除，此时使用需要单独引入 jar 包</p>
</li>
<li><p>和<code>@Autowired</code>作用基本等价，区别在于只能作用于字段和<code>setter</code>方法，把指定类型（先是<code>byName</code>方式，再是<code>byType</code>方法）的 Bean 注入到指定字段；</p>
</li>
<li><p>指定 name 时找不到则抛出异常，指定 type 时找不到或是找到多个，都会抛出异常，既没有指定 name，又没有指定 type 时，自动按照<code>byName</code>自动装配。</p>
</li>
</ul>
</li>
</ul>
<h3 id="2-3-3-自动检测"><a href="#2-3-3-自动检测" class="headerlink" title="2.3.3 自动检测"></a>2.3.3 自动检测</h3><p>以下四个注解均用于声明Bean，实现自动检测。</p>
<ul>
<li><p><code>@Component</code></p>
<ul>
<li><p>默认定义了一个<code>id</code>为小写开头的类名的Bean，<code>@Component(&quot;...&quot;)</code>则显式定义了一个指定<code>id</code>的Bean；</p>
</li>
<li><p>如果一个 Bean 不知道属于哪个层，可以使用<code>@Component</code> 注解标注。</p>
</li>
</ul>
</li>
<li><p><code>@Controller</code> : 对应 Spring MVC 控制层，主要用于接受用户请求并调用 Service 层返回数据给前端页面。</p>
</li>
<li><p><code>@Service</code> : 对应服务层，主要涉及一些复杂的逻辑，需要用到 Dao 层。</p>
</li>
<li><p><code>@Repository</code>：对应持久层即 Dao 层，主要用于数据库相关操作。</p>
</li>
</ul>
<p>这四个注解的用法完全一样，只是为了更清晰的区分不同层次的 Bean。</p>
<p>在令 Spring 自动检测组件的过程中，也可以配置相关的过滤器来过滤组件扫描。</p>
<ul>
<li><p>在配置<code>&lt;context:component-scan&gt;</code>元素时，可以通过配置<code>&lt;context:include-filter</code>和<code>&lt;context:exclude-filter</code>子元素来设置过滤器，分别调整要扫描和不要扫描的类型；</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">context:component-scan</span></span></span><br><span class="line"><span class="tag">			<span class="attr">base-package</span> = <span class="string">&quot;...&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">context:include-filter</span> <span class="attr">type</span> = <span class="string">&quot;...&quot;</span> <span class="attr">expression</span> = <span class="string">&quot;...&quot;</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">context:exclude-filter</span> <span class="attr">type</span> = <span class="string">&quot;...&quot;</span> <span class="attr">expression</span> = <span class="string">&quot;...&quot;</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">context:component-scan</span>&gt;</span></span><br></pre></td></tr></table></figure></li>
<li><p>其中，<code>type</code>属性用于指定要使用的过滤器类型；</p>
<table>
<thead>
<tr>
<th align="left">过滤器类型</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><code>annotation</code></td>
<td>扫描使用指定注解所标注的类，由<code>expression</code>属性指定要扫描的注解</td>
</tr>
<tr>
<td align="left"><code>assignable</code></td>
<td>扫描派生于<code>expression</code>属性所指定类型的类</td>
</tr>
<tr>
<td align="left"><code>aspectj</code></td>
<td>扫描与<code>expression</code>属性所指定的AspectJ表达式所匹配的类</td>
</tr>
<tr>
<td align="left"><code>regex</code></td>
<td>扫描类名称与<code>expression</code>属性所指定的正则表达式所匹配的类</td>
</tr>
</tbody></table>
</li>
</ul>
<h3 id="2-3-4-基于-Java-的配置"><a href="#2-3-4-基于-Java-的配置" class="headerlink" title="2.3.4 基于 Java 的配置"></a>2.3.4 基于 Java 的配置</h3><p>在基于 XML 文件的配置中，Bean 的类型和 ID 都是由字符串来标示的，这就导致它们无法进行编译期检查，写起来也很繁琐，而<strong>在基于 Java 的配置中，则可以进行编译期检查来确保 Bean 的类型是合法类型</strong>。Spring Boot 偏向使用基于 Java 的配置。</p>
<ul>
<li><p><code>@Configuration</code></p>
<ul>
<li><p>通过在XML文件中配置<code>&lt;context:component-scan&gt;</code>元素，还可以告知Spring在包内自动加载使用<code>@Configuration</code>注解所标注的所有类；</p>
</li>
<li><p><code>@Configuration</code>注解等同于XML文件中的<code>&lt;beans&gt;</code>元素，它所标注的类是一个配置类；</p>
</li>
<li><p>配置类会包含一个或多个Spring Bean的定义，这些Bean的定义是使用<code>@Bean</code>注解所标注的方法。</p>
</li>
</ul>
</li>
<li><p><code>@Bean</code></p>
<ul>
<li><p>用于方法，当一个Bean不在<code>AppConfig</code>配置类所在的包中时，可以在<code>AppConfig</code>配置类中编写标注了<code>@Bean</code>的方法来创建并返回该Bean，方法名将作为该Bean的ID；</p>
</li>
<li><p>也可以通过<code>@Bean(&quot;...&quot;)</code>或者<code>@Bean</code>+<code>@Qualifier(&quot;...&quot;)</code>指定别名；</p>
</li>
<li><p>通过声明方法引用一个Bean并不等同于调用该方法，区别在于每次调用该方法都会得到一个新的实例，而通过<code>@Bean</code>标注时，Spring会拦截该方法的调用，并尝试在应用上下文中查找该Bean，这意味着该Bean是Singleton。</p>
</li>
</ul>
</li>
<li><p><code>@ComponentScan</code></p>
<ul>
<li><p>用于类，告知容器自动搜索当前类所在的包以及子包，可代替<code>&lt;context:component-scan&gt;</code>元素；</p>
</li>
<li><p>将所有标注为<code>@Component</code>、<code>@Controller</code>、<code>@Service</code>、<code>@Repository</code>的Bean自动创建出来，并根据<code>@Autowired</code>进行装配。</p>
</li>
</ul>
</li>
<li><p><code>@Import</code></p>
<ul>
<li><p>不需要把所有的配置都放到一个配置类中；</p>
</li>
<li><p><code>@Configuration</code>标注的配置类可以通过<code>@Import</code>来导入其他的配置类，把多个分开的容器配置合并在一个配置中。</p>
</li>
</ul>
</li>
<li><p><code>@ImportResource</code></p>
<ul>
<li><p>用于导入Spring的配置文件，让配置文件里面的内容生效；</p>
</li>
<li><p>如果必须要使用基于XML的配置，依旧定义一个<code>@Configuration</code>配置类，然后通过<code>@ImportResource</code>来加载XML配置文件。</p>
</li>
</ul>
</li>
</ul>
<h3 id="2-3-5-补充介绍"><a href="#2-3-5-补充介绍" class="headerlink" title="2.3.5 补充介绍"></a>2.3.5 补充介绍</h3><ul>
<li><p><code>@Scope</code></p>
<ul>
<li><p>用于类，单独使用<code>@Component</code>注解时会默认将组件标注为Singleton，即每次通过<code>getBean</code>方法获取到Bean总是同一个实例；</p>
</li>
<li><p>增加<code>@Scope</code>注解时，则可以将组件标注为不同的作用域的Bean，例如<code>@Scope(ConfigurableBeanFactory.SCOPE_PROTOTYPE)</code>将组件标注为Prototype（原型）。</p>
</li>
</ul>
</li>
<li><p><code>@PostConstruct</code></p>
<ul>
<li><p>用于Bean在注入必要依赖后的<code>init</code>方法，从而进行初始化；</p>
</li>
<li><p>Spring只根据<code>@PostConstruct</code>查找无参数方法，对方法名不作要求。</p>
</li>
</ul>
</li>
<li><p><code>@PreDestory</code></p>
<ul>
<li><p>用于Bean在容器关闭时的<code>shutdown</code>方法，从而进行相关的清理操作；</p>
</li>
<li><p>Spring只根据<code>@PreDestory</code>查找无参数方法，对方法名不作要求。</p>
</li>
</ul>
</li>
<li><p><code>@Primary</code></p>
<ul>
<li><p>在存在多个相同类型的Bean的情况下，用于指定优先注入的Bean，则注入时不需要指出该优先注入的Bean的别名；</p>
</li>
<li><p>相同类型的Bean只有一个可以指定为<code>@Primary</code>，其他必须用<code>@Qualiflier(&quot;beanNname&quot;)</code>指定别名。</p>
</li>
</ul>
</li>
<li><p><code>@PropertySource(&quot;app.properties&quot;)</code></p>
<ul>
<li><p>用于<code>AppConfig</code>配置类，告知容器自动读取名为<code>app.properties</code>的配置文件，接着可以使用<code>@Value(&quot;$&#123;key:defaultValue&#125;&quot;)</code>来注入配置文件中<code>key</code>的<code>value</code>，这比使用<code>@Value(&quot;classpath:/app.properties&quot;)</code>+输入流的方式来读取配置文件更加简单；</p>
</li>
<li><p>还有一种方式是先通过一个Bean（Spring容器中的默认类名称为<code>SmtpConfig</code>）持有所有的配置属性值，然后在其他Bean中使用<code>@value(&quot;#&#123;smtpConfig.property&#125;&quot;)</code>来注入属性值。</p>
</li>
</ul>
</li>
<li><p><code>@Profile</code></p>
<ul>
<li><p>用于配置不同环境下的Bean，程序运行时通过指定运行环境就可以使得容器只创建该环境下的Bean；</p>
</li>
<li><p>Spring提供了<code>native</code>（开发）、<code>test</code>（测试）和<code>production</code>（生产）这三种环境。</p>
</li>
</ul>
</li>
<li><p><code>@Conditional</code></p>
<ul>
<li>用于Bean声明；</li>
<li>提供了Bean的装载条件判断，从而确定是否创建该Bean。</li>
</ul>
</li>
</ul>
<h2 id="2-4-IoC-特性"><a href="#2-4-IoC-特性" class="headerlink" title="2.4 IoC 特性"></a>2.4 IoC 特性</h2><h3 id="2-4-1-工厂-Bean"><a href="#2-4-1-工厂-Bean" class="headerlink" title="2.4.1 工厂 Bean"></a>2.4.1 工厂 Bean</h3><p>Spring中Bean有两种，⼀种是普通 Bean，⼀种是工厂 Bean（<code>FactoryBean</code>），<code>FactoryBean</code>可以生成某个类型的 Bean 实例，可以借助于它自定义 Bean 的创建过程，一般用于创建比较复杂的需要通过特定创建方式的对象。</p>
<p>Spring 提供了工厂模式来创建 Bean，过程如下：</p>
<p>1）假如需要以工厂模式创建<code>Product</code>，首先需要定义一个工厂Bean（<code>ProductFactoryBean</code>），该工厂Bean需要实现<code>FactotyBean</code>接口；</p>
<p>2）Spring会优先实例化工厂Bean（<code>ProductFactoryBean</code>），然后通过工厂Bean的<code>getObject</code>方法创建真正的Bean（<code>Product</code>）；</p>
<p>3）因此，如果定义了一个工厂Bean，Spring创建的Bean实际上是这个工厂Bean的<code>getObject</code>方法所返回的Bean。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ProductFactoryBean</span> <span class="keyword">implements</span> <span class="title class_">FactoryBean</span>&lt;Product&gt; &#123;</span><br><span class="line">    </span><br><span class="line">    String product= <span class="string">&quot;P&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Product <span class="title function_">getObject</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="keyword">return</span> Product.of(product);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Class&lt;?&gt; getObjectType() &#123;</span><br><span class="line">        <span class="keyword">return</span> Product.class;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isSingleton</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="2-4-2-Bean-工厂"><a href="#2-4-2-Bean-工厂" class="headerlink" title="2.4.2 Bean 工厂"></a>2.4.2 Bean 工厂</h3><p><code>BeanFactory</code>接口（Bean工厂）是Spring框架中IoC容器的顶层接口，它只是用来定义一些基础功能和基础规范，是SpringIOC的基础容器。<code>ApplicationContext</code>是<code>BeanFactory</code>的一个子接口，具备<code>BeanFactory</code>提供的全部功能，是IoC容器的高级接口，比<code>BeanFactory</code>拥有更多的功能。</p>
<p>IoC容器初始化（获取<code>BeanFactory</code>）的关键之处在于<code>org.springframework.context.support.AbstractApplicationContext#refresh</code></p>
<p>1）在<code>AbstractApplicationContext</code>类的<code>refresh</code>方法中</p>
<ul>
<li><p>依次调用<code>obtainFreshBeanFactory</code>方法 –&gt; <code>refreshBeanFactory</code>方法和<code>getBeanFactory</code>方法；</p>
</li>
<li><p><code>AbstractRefreshableApplicationContext</code>类提供了<code>refreshBeanFactory</code>方法和<code>getBeanFactory</code>方法的具体实现来创建并返回Bean工厂；</p>
</li>
</ul>
<p>2）在<code>AbstractRefreshableApplicationContext</code>类的<code>refreshBeanFactory</code>方法中，完整代码如下</p>
<ul>
<li><p>以下代码的第8行，调用<code>createBeanFactory</code>方法来创建<code>DefaultListableBeanFactory</code>类型的<code>beanFactory</code>；</p>
</li>
<li><p>以下代码的第11行，调用<code>loadBeanDefinitions</code>方法来加载<code>beanFactory</code>中的<code>BeanDefinition</code>（JavaBean在IoC容器内部的数据结构类型）；</p>
</li>
<li><p><code>AbstractXmlApplicationContext</code>类提供了<code>loadBeanDefinitions</code>方法的具体实现；</p>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">refreshBeanFactory</span><span class="params">()</span> <span class="keyword">throws</span> BeansException &#123;</span><br><span class="line">    <span class="keyword">if</span> (hasBeanFactory()) &#123;</span><br><span class="line">        destroyBeans();</span><br><span class="line">        closeBeanFactory();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="type">DefaultListableBeanFactory</span> <span class="variable">beanFactory</span> <span class="operator">=</span> createBeanFactory();</span><br><span class="line">        beanFactory.setSerializationId(getId());</span><br><span class="line">        customizeBeanFactory(beanFactory);</span><br><span class="line">        loadBeanDefinitions(beanFactory);</span><br><span class="line">        <span class="built_in">this</span>.beanFactory = beanFactory;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">catch</span> (IOException ex) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">ApplicationContextException</span>(<span class="string">&quot;I/O error parsing bean definition source for &quot;</span> + getDisplayName(), ex);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>3）在<code>AbstractXmlApplicationContext</code>类的<code>loadBeanDefinitions</code>方法中，会依次调用多个类的<code>loadBeanDefinitions</code>方法，最终会调用到<code>XmlBeanDefinitionReader</code>类的<code>doLoadBeanDefinitions</code>方法；</p>
<p>4）在<code>XmlBeanDefinitionReader</code>类的<code>doLoadBeanDefinitions</code>方法中，截取了部分代码如下</p>
<ul>
<li><p>以下代码的第3行，调用<code>doLoadDocument</code>方法来读取XML信息，并保存到<code>Document</code>对象中；</p>
</li>
<li><p>以下代码的第4行，调用<code>registerBeanDefinitions</code>方法来解析<code>Document</code>对象，封装<code>BeanDefinition</code>对象并进行注册；</p>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">protected</span> <span class="type">int</span> <span class="title function_">doLoadBeanDefinitions</span><span class="params">(InputSource inputSource, Resource resource)</span> <span class="keyword">throws</span> BeanDefinitionStoreException &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="type">Document</span> <span class="variable">doc</span> <span class="operator">=</span> doLoadDocument(inputSource, resource);</span><br><span class="line">        <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> registerBeanDefinitions(doc, resource);</span><br><span class="line">        <span class="keyword">if</span> (logger.isDebugEnabled()) &#123;</span><br><span class="line">            logger.debug(<span class="string">&quot;Loaded &quot;</span> + count + <span class="string">&quot; bean definitions from &quot;</span> + resource);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> count;</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>5）在<code>XmlBeanDefinitionReader</code>类的<code>registerBeanDefinitions</code>方法中，完整代码如下</p>
<ul>
<li><p>以下代码的第4行的方法入参中，依次调用<code>createReaderContext</code>方法 –&gt; <code>getNamespaceHandlerResolver</code>方法 –&gt; <code>createDefaultNamespaceHandlerResolver</code>方法 –&gt; <code>DefaultNamespaceHandlerResolver</code>类的构造方法；</p>
</li>
<li><p>以下代码的第4行，调用<code>BeanDefinitionDocumentReader</code>接口的<code>registerBeanDefinitions</code>方法；</p>
</li>
<li><p><code>DefaultBeanDefinitionDocumentReader</code>类提供了<code>registerBeanDefinitions</code>方法的具体实现；</p>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">registerBeanDefinitions</span><span class="params">(Document doc, Resource resource)</span> <span class="keyword">throws</span> BeanDefinitionStoreException &#123;</span><br><span class="line">    <span class="type">BeanDefinitionDocumentReader</span> <span class="variable">documentReader</span> <span class="operator">=</span> createBeanDefinitionDocumentReader();</span><br><span class="line">    <span class="type">int</span> <span class="variable">countBefore</span> <span class="operator">=</span> getRegistry().getBeanDefinitionCount();</span><br><span class="line">    documentReader.registerBeanDefinitions(doc, createReaderContext(resource));</span><br><span class="line">    <span class="keyword">return</span> getRegistry().getBeanDefinitionCount() - countBefore;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>6）在<code>DefaultBeanDefinitionDocumentReader</code>类的<code>registerBeanDefinitions</code>方法中，会依次调用<code>doRegisterBeanDefinitions</code>方法 –&gt; <code>parseBeanDefinitions</code>方法 –&gt; <code>parseDefaultElement</code>方法 –&gt; <code>processBeanDefinition</code>方法；</p>
<p>7）在<code>DefaultBeanDefinitionDocumentReader</code>类的<code>processBeanDefinition</code>方法中，完整代码如下</p>
<ul>
<li><p>以下代码第2行，调用<code>parseBeanDefinitionElement</code>方法解析得到<code>BeanDefinitionHolder</code>对象；</p>
</li>
<li><p>以下代码第7行，依次调用<code>BeanDefinitionReaderUtils</code>类的<code>registerBeanDefinition</code>方法 –&gt;<code>BeanDefinitionRegistry</code>接口的<code>registerBeanDefinition</code>方法；</p>
</li>
<li><p><code>DefaultListableBeanFactory</code>类提供了<code>registerBeanDefinition</code>方法的具体实现；</p>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">processBeanDefinition</span><span class="params">(Element ele, BeanDefinitionParserDelegate delegate)</span> &#123;</span><br><span class="line">    <span class="type">BeanDefinitionHolder</span> <span class="variable">bdHolder</span> <span class="operator">=</span> delegate.parseBeanDefinitionElement(ele);</span><br><span class="line">    <span class="keyword">if</span> (bdHolder != <span class="literal">null</span>) &#123;</span><br><span class="line">        bdHolder = delegate.decorateBeanDefinitionIfRequired(ele, bdHolder);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// Register the final decorated instance.</span></span><br><span class="line">            BeanDefinitionReaderUtils.registerBeanDefinition(bdHolder, getReaderContext().getRegistry());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">catch</span> (BeanDefinitionStoreException ex) &#123;</span><br><span class="line">            getReaderContext().error(<span class="string">&quot;Failed to register bean definition with name &#x27;&quot;</span> +	bdHolder.getBeanName() + <span class="string">&quot;&#x27;&quot;</span>, ele, ex);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// Send registration event.</span></span><br><span class="line">        getReaderContext().fireComponentRegistered(<span class="keyword">new</span> <span class="title class_">BeanComponentDefinition</span>(bdHolder));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>8）在<code>DefaultListableBeanFactory</code>类中</p>
<ul>
<li><p>定义了如下所示的<code>beanDefinitionMap</code>和<code>beanDefinitionNames</code>域；</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/** Map of bean definition objects, keyed by bean name. */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Map&lt;String, BeanDefinition&gt; beanDefinitionMap = <span class="keyword">new</span> <span class="title class_">ConcurrentHashMap</span>&lt;&gt;(<span class="number">256</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">/** List of bean definition names, in registration order. */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">volatile</span> List&lt;String&gt; beanDefinitionNames = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;(<span class="number">256</span>);</span><br></pre></td></tr></table></figure></li>
<li><p>在<code>registerBeanDefinition</code>方法中，会把封装的 XML 中定义的 Bean信息封装得到的<code>BeanDefinition</code>类型的<code>beanDefinition</code>放入一个<code>beanDefinitionMap</code>，将<code>String</code>类型的<code>beanName</code>放入<code>beanDefinitionNames</code>中，从而完成注册。</p>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Still in startup registration phase</span></span><br><span class="line"><span class="built_in">this</span>.beanDefinitionMap.put(beanName, beanDefinition);</span><br><span class="line"><span class="built_in">this</span>.beanDefinitionNames.add(beanName);</span><br></pre></td></tr></table></figure>

<h3 id="2-4-3-Bean-的三级缓存"><a href="#2-4-3-Bean-的三级缓存" class="headerlink" title="2.4.3 Bean 的三级缓存"></a>2.4.3 Bean 的三级缓存</h3><p>Spring 的三级缓存就是三个<code>Map</code></p>
<ul>
<li><p>一级缓存中存放的完整创建好的单例 Bean 对象，在创建一个单例 Bean 时，会首先从一级缓存中尝试获取该 Bean 的实例，若能获取到则直接返回该实例，否则则继续创建该 Bean</p>
</li>
<li><p>二级缓存中存放的是尚未完全创建好的半成品单例 Bean 对象，存在循环依赖时就会创建这种半成品，当循环依赖的 Bean 创建完成后就将其存储到一级缓存中</p>
</li>
<li><p>三级缓存中存放的是单例 Bean 的创建工厂，当一个单例 Bean 被创建时，Spring 会首先将该 Bean 的创建工厂存储到三级缓存中，然后再执行 Bean 工厂的<code>getObject()</code>，生成该 Bean 实例对象并将其存储到一级缓存中</p>
</li>
</ul>
<p>Bean 之间的循环依赖一般都是设计有问题，应当尽可能避免，但如果两个 Bean 不可避免地需要循环引用，可以1）使用构造器注入并在某一个构造器中加入<code>@Lazy</code>注解使该类延迟初始化；2）使用 Spring 的三级缓存，此时 Spring 会提前暴露一个仅实例化而尚未完全初始化的半成品对象实例（对象初始化是可以延后的）。</p>
<ul>
<li><p>考虑到单例对象在容器运行期间的依赖关系不会发生变化，而原型对象的创建和初始化则可以发生多次，可以在容器运行期间动态变化，因此这种方案这只能对单例对象奏效</p>
</li>
<li><p>考虑到对象实例化过程中就会调用构造器，无法通过构造器来注入一个尚未完全创建的对象，因此这种方案要求依赖注入的方式不能都是构造器注入，在属性注入中，Spring 则可以顺利完成实例化过程从而先创建一个空对象或者半成品对象</p>
</li>
<li><p>对于普通对象来说，二级缓存就足够解决循环依赖问题了，但对于代理对象的循环依赖问题来说，如果没有三级缓存，则需要在二级缓存中存放半成品对象的代理对象，即在对象实例化之后初始化之前完成 AOP 代理，这就破坏了 AOP 代理的设计原则（原则是在原始 Bean 完全创建完成后再生成其代理 Bean，从而解耦原始 Bean 的创建和代理 Bean 的创建）</p>
</li>
<li><p>为了在遵守 AOP 代理原则的前提下解决代理对象的循环依赖问题，Spring 引入了保存对象工厂的三级缓存，通过对象工厂，如果循环依赖的 Bean 是代理 Bean，则工厂获取到的就是代理后的对象，如果对象没有被代理，那么工厂获取到的就是实例化的真实对象</p>
</li>
</ul>
<h3 id="2-4-4-Bean-的生命周期"><a href="#2-4-4-Bean-的生命周期" class="headerlink" title="2.4.4 Bean 的生命周期"></a>2.4.4 Bean 的生命周期</h3><p>在 IoC 容器的初始化过程中会对非懒加载的 Bean 定义完成资源定位，加载读取配置，并解析转化成 Spring 能够识别的<code>BeanDefinition</code>对象，最后将解析得到的<code>BeanDefinition</code>存到 HashMap 集合中（对于懒加载的 Bean 来说，其创建是在第一次调用<code>getBean</code>方法时完成的）。</p>
<img src="生命周期.jpg" alt="生命周期" style="zoom:100%;" />

<p>上图步骤 1-12 的关键调用点在<code>AbstractApplicationContext</code>类的<code>refresh</code>方法中</p>
<ul>
<li><p>调用<code>invokeBeanFactoryPostProcessors</code>方法，会实例化<code>BeanFactoryPostProcessor</code>实现类并执行其<code>postProcessBeanFactory</code>方法，对应上图步骤 1-2；</p>
</li>
<li><p>调用<code>registerBeanPostProcessors</code>方法，会实例化<code>BeanPostProcessor</code>实现类，对应上图步骤 3；</p>
</li>
<li><p>调用<code>finishBeanFactoryInitialization</code>方法，会通过反射执行 Bean 的构造方法（创建所有非懒加载的单例 Bean 实例）、注入属性、Bean Class 加载以及初始化，对应上图步骤 4-12，更多细节可查看 2.4.5 小节。</p>
</li>
</ul>
<h3 id="2-4-5-后置处理器"><a href="#2-4-5-后置处理器" class="headerlink" title="2.4.5 后置处理器"></a>2.4.5 后置处理器</h3><p>Spring提供了两种后置处理器<code>BeanFactoryPostProcessor</code>和<code>BeanPostProcessor</code>。从命名中可以看出区别：<code>BeanFactoryPostProcessor</code>是针对IoC容器（<code>BeanFactory</code>）初始化之后的后置处理器，<code>BeanPostProcessor</code>是针对Bean初始化之后的后置处理器。</p>
<p>1）<code>BeanFactoryPostProcessor</code>接口只提供了一个方法，该方法参数为<code>ConfigurableListableBeanFactory</code>；</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">BeanFactoryPostProcessor</span> &#123;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">postProcessBeanFactory</span><span class="params">(ConfigurableListableBeanFactory beanFactory)</span> <span class="keyword">throws</span> BeansException;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>ConfigurableListableBeanFactory</code>接口定义了一些方法，其中有个<code>getBeanDefinition</code>方法可以返回定义Bean的<code>BeanDefinition</code>对象，从而可以对定义的属性进行手动修改。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">ConfigurableListableBeanFactory</span> <span class="keyword">extends</span> <span class="title class_">ListableBeanFactory</span>, AutowireCapableBeanFactory, ConfigurableBeanFactory &#123;</span><br><span class="line">    BeanDefinition <span class="title function_">getBeanDefinition</span><span class="params">(String beanName)</span> <span class="keyword">throws</span> NoSuchBeanDefinitionException;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>2）定义一个类实现了<code>BeanPostProcessor</code>接口，默认是会对容器中所有的Bean进行处理，也可以通过方法参数来判断要处理的具体的某个Bean。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">BeanPostProcessor</span> &#123;</span><br><span class="line">    <span class="meta">@Nullable</span></span><br><span class="line">    <span class="keyword">default</span> Object <span class="title function_">postProcessBeforeInitialization</span><span class="params">(Object bean, String beanName)</span> <span class="keyword">throws</span> BeansException &#123;</span><br><span class="line">        <span class="keyword">return</span> bean;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Nullable</span></span><br><span class="line">    <span class="keyword">default</span> Object <span class="title function_">postProcessAfterInitialization</span><span class="params">(Object bean, String beanName)</span> <span class="keyword">throws</span> BeansException &#123;</span><br><span class="line">        <span class="keyword">return</span> bean;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="2-4-6-创建-Bean"><a href="#2-4-6-创建-Bean" class="headerlink" title="2.4.6 创建 Bean"></a>2.4.6 创建 Bean</h3><p>接2.4.3小节：</p>
<p>1）在<code>AbstractApplicationContext</code>类的<code>finishBeanFactoryInitialization</code>方法中，会调用<code>ConfigurableListableBeanFactory</code>接口的<code>preInstantiateSingletons</code>方法，<code>DefaultListableBeanFactory</code>类提供了<code>preInstantiateSingletons</code>方法的具体实现；</p>
<p>2）在<code>DefaultListableBeanFactory</code>类的<code>preInstantiateSingletons</code>方法中，截取了部分代码如下</p>
<ul>
<li><p>以下代码的第12行的<code>for</code>循环会触发所有非懒加载的单例Bean的初始化；</p>
</li>
<li><p>以下代码的第14行会判断是否是非懒加载的单例Bean，是的话则在IoC容器创建时创建Bean实例、依赖注入以及初始化；</p>
</li>
<li><p>以下代码的第32行会依次调用<code>AbstractBeanFactory</code>类的<code>getBean</code>方法 –&gt; <code>doGetBean</code>方法；</p>
</li>
<li><p>以下代码的第32行所触发的逻辑和懒加载时第一次调用<code>context.getBean(&quot;beanName&quot;)</code> 所触发的逻辑是一致的；</p>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">preInstantiateSingletons</span><span class="params">()</span> <span class="keyword">throws</span> BeansException &#123;</span><br><span class="line">    <span class="keyword">if</span> (logger.isTraceEnabled()) &#123;</span><br><span class="line">        logger.trace(<span class="string">&quot;Pre-instantiating singletons in &quot;</span> + <span class="built_in">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// Iterate over a copy to allow for init methods which in turn register new bean definitions.</span></span><br><span class="line">    <span class="comment">// While this may not be part of the regular factory bootstrap, it does otherwise work fine.</span></span><br><span class="line">    List&lt;String&gt; beanNames = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;(<span class="built_in">this</span>.beanDefinitionNames);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// Trigger initialization of all non-lazy singleton beans...</span></span><br><span class="line">    <span class="keyword">for</span> (String beanName : beanNames) &#123;</span><br><span class="line">        <span class="type">RootBeanDefinition</span> <span class="variable">bd</span> <span class="operator">=</span> getMergedLocalBeanDefinition(beanName);</span><br><span class="line">        <span class="keyword">if</span> (!bd.isAbstract() &amp;&amp; bd.isSingleton() &amp;&amp; !bd.isLazyInit()) &#123;</span><br><span class="line">            <span class="keyword">if</span> (isFactoryBean(beanName)) &#123;</span><br><span class="line">                <span class="type">Object</span> <span class="variable">bean</span> <span class="operator">=</span> getBean(FACTORY_BEAN_PREFIX + beanName);</span><br><span class="line">                <span class="keyword">if</span> (bean <span class="keyword">instanceof</span> FactoryBean) &#123;</span><br><span class="line">                    FactoryBean&lt;?&gt; factory = (FactoryBean&lt;?&gt;) bean;</span><br><span class="line">                    <span class="type">boolean</span> isEagerInit;</span><br><span class="line">                    <span class="keyword">if</span> (System.getSecurityManager() != <span class="literal">null</span> &amp;&amp; factory <span class="keyword">instanceof</span> SmartFactoryBean) &#123;</span><br><span class="line">                        isEagerInit = AccessController.doPrivileged((PrivilegedAction&lt;Boolean&gt;) ((SmartFactoryBean&lt;?&gt;) factory)::isEagerInit, getAccessControlContext());</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">else</span> &#123;</span><br><span class="line">                        isEagerInit = (factory <span class="keyword">instanceof</span> martFactoryBean &amp;&amp; ((SmartFactoryBean&lt;?&gt;) factory).isEagerInit());</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">if</span> (isEagerInit) &#123;</span><br><span class="line">                        getBean(beanName);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                getBean(beanName);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>3）在<code>AbstractBeanFactory</code>类的<code>doGetBean</code>方法中，截取了部分代码如下</p>
<ul>
<li><p>以下代码的第14行，通过<code>isPrototypeCurrentlyInCreation</code>方法来判断是否要获取一个正在被创建的原型Bean，是的话则直接抛出异常（原型Bean在创建之前会标记这个Bean正在被创建，等创建结束之后会删除标记），<strong>这代表Spring不支持原型 Bean的循环依赖，会直接抛出异常</strong>；</p>
</li>
<li><p>以下代码的第31行，会依次调用<code>AbstractAutowireCapableBeanFactory</code>类的<code>createBean</code>方法 –&gt; <code>doCreateBean</code>方法；</p>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">protected</span> &lt;T&gt; T <span class="title function_">doGetBean</span><span class="params">(String name, <span class="meta">@Nullable</span> Class&lt;T&gt; requiredType, <span class="meta">@Nullable</span> Object[] args, <span class="type">boolean</span> typeCheckOnly)</span>	<span class="keyword">throws</span> BeansException &#123;</span><br><span class="line">    <span class="type">String</span> <span class="variable">beanName</span> <span class="operator">=</span> transformedBeanName(name);</span><br><span class="line">    Object beanInstance;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// Eagerly check singleton cache for manually registered singletons.</span></span><br><span class="line">    <span class="type">Object</span> <span class="variable">sharedInstance</span> <span class="operator">=</span> getSingleton(beanName);</span><br><span class="line">    <span class="keyword">if</span> (sharedInstance != <span class="literal">null</span> &amp;&amp; args == <span class="literal">null</span>) &#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// Fail if we&#x27;re already creating this bean instance:</span></span><br><span class="line">        <span class="comment">// We&#x27;re assumably within a circular reference.</span></span><br><span class="line">        <span class="keyword">if</span> (isPrototypeCurrentlyInCreation(beanName)) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">BeanCurrentlyInCreationException</span>(beanName);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// Check if bean definition exists in this factory.</span></span><br><span class="line">        ...</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            ...</span><br><span class="line">            </span><br><span class="line">            <span class="comment">// Guarantee initialization of beans that the current bean depends on.</span></span><br><span class="line">            ...</span><br><span class="line">            </span><br><span class="line">            <span class="comment">// Create bean instance.</span></span><br><span class="line">            <span class="keyword">if</span> (mbd.isSingleton()) &#123;</span><br><span class="line">                sharedInstance = getSingleton(beanName, () -&gt; &#123;</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        <span class="keyword">return</span> createBean(beanName, mbd, args);</span><br><span class="line">                    &#125;</span><br><span class="line">                    ...</span><br><span class="line">                &#125;);</span><br><span class="line">                ...</span><br><span class="line">            &#125;</span><br><span class="line">            ...</span><br><span class="line">        &#125;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>4）在<code>AbstractAutowireCapableBeanFactory</code>类的<code>doCreateBean</code>方法中，截取了部分代码如下</p>
<ul>
<li><p>在以下代码的第9行，调用<code>createBeanInstance</code>方法，这里会通过反射调用构造器，创建了Bean对象（此时还未注入属性）；</p>
</li>
<li><p>在以下代码的第26行，调用<code>addSingletonFactory</code>方法，该方法的第二个入参是一个<code>ObjectFactory</code>类型，这里会<strong>将还未注入属性的Bean对象提前以<code>ObjectFactory</code>对象的形式暴露到IoC容器中，从而解决单例Bean的属性循环依赖问题（但无法解决构造器循环依赖问题，会直接抛出异常）</strong>；</p>
</li>
<li><p>在以下代码的第34行，调用<code>populateBean</code>方法，这里会对Bean注入属性；</p>
</li>
<li><p>在以下代码的第35行，调用<code>initializeBean</code>方法，这里会进行Bean Class加载以及Bean的初始化，更多细节可查看3.5.2小节。</p>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">protected</span> Object <span class="title function_">doCreateBean</span><span class="params">(String beanName, RootBeanDefinition mbd, <span class="meta">@Nullable</span> Object[] args)</span> <span class="keyword">throws</span> BeanCreationException &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// Instantiate the bean.</span></span><br><span class="line">    <span class="type">BeanWrapper</span> <span class="variable">instanceWrapper</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">if</span> (mbd.isSingleton()) &#123;</span><br><span class="line">        instanceWrapper = <span class="built_in">this</span>.factoryBeanInstanceCache.remove(beanName);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (instanceWrapper == <span class="literal">null</span>) &#123;</span><br><span class="line">        instanceWrapper = createBeanInstance(beanName, mbd, args);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">Object</span> <span class="variable">bean</span> <span class="operator">=</span> instanceWrapper.getWrappedInstance();</span><br><span class="line">    Class&lt;?&gt; beanType = instanceWrapper.getWrappedClass();</span><br><span class="line">    <span class="keyword">if</span> (beanType != NullBean.class) &#123;</span><br><span class="line">        mbd.resolvedTargetType = beanType;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    ...</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// Eagerly cache singletons to be able to resolve circular references</span></span><br><span class="line">    <span class="comment">// even when triggered by lifecycle interfaces like BeanFactoryAware.</span></span><br><span class="line">    <span class="type">boolean</span> <span class="variable">earlySingletonExposure</span> <span class="operator">=</span> (mbd.isSingleton() &amp;&amp; <span class="built_in">this</span>.allowCircularReferences &amp;&amp; isSingletonCurrentlyInCreation(beanName));</span><br><span class="line">    <span class="keyword">if</span> (earlySingletonExposure) &#123;</span><br><span class="line">        <span class="keyword">if</span> (logger.isTraceEnabled()) &#123;</span><br><span class="line">            logger.trace(<span class="string">&quot;Eagerly caching bean &#x27;&quot;</span> + beanName + <span class="string">&quot;&#x27; to allow for resolving potential circular references&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        addSingletonFactory(beanName, () -&gt; getEarlyBeanReference(beanName, mbd, bean));</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    ...</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// Initialize the bean instance.</span></span><br><span class="line">    <span class="type">Object</span> <span class="variable">exposedObject</span> <span class="operator">=</span> bean;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        populateBean(beanName, mbd, instanceWrapper);</span><br><span class="line">        exposedObject = initializeBean(beanName, exposedObject, mbd);</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="3、AOP"><a href="#3、AOP" class="headerlink" title="3、AOP"></a>3、AOP</h1><h2 id="3-1-问题与解决"><a href="#3-1-问题与解决" class="headerlink" title="3.1 问题与解决"></a>3.1 问题与解决</h2><p>假设业务的组件中有多个业务方法，每个业务方法除了要执行核心业务逻辑，还需要执行安全检查、事务管理等处理逻辑，这些处理逻辑会重复出现在每个四处分散的业务方法中。针对该问题可以使用代理模式，对每个执行业务方法的对象实现生成代理类，将这些处理逻辑放置在代理类当中，从而控制对原始对象的访问。</p>
<p>静态代理在编译期控制对对象的访问，这需要程序员手写很多代码，尤其是在需要代理的对象或类中方法比较多时，非常花费时间和精力，更简单的方法是将每一种处理看作一个切面，然后以某种自动化的方式将切面逻辑织入到核心逻辑中。动态代理则是在程序运行期间动态地控制对对象的访问，被广泛地用于许多 AOP 框架（例如 Spring AOP），为他们提供对方法的拦截过滤增强等。</p>
<p>依赖注入有助于应用对象之间的解耦，而 AOP (Aspect Oriented Programming) 把系统分解为不同的切面（比如安全检查、事务管理等处理），可以实现横切关注点与它们所影响的对象之间的解耦。AOP 是 OOP 的延续，OOP 是一种垂直纵向的继承体系，AOP 是一种横向抽取机制，将横切逻辑代码和业务逻辑代码分开，Java 中的 AOP 机制有：Java 代理、Spring 框架、AspectJ。</p>
<h2 id="3-2-术语介绍"><a href="#3-2-术语介绍" class="headerlink" title="3.2 术语介绍"></a>3.2 术语介绍</h2><ul>
<li><p><strong>连接点（Joinpoint）</strong></p>
<ul>
<li>连接点是应用执行过程中<strong>能够</strong>插入切面的所有点，是一种候选点；</li>
<li>切面代码利用这些点插入到应用的正常流程中，从而添加新的行为；</li>
<li>连接点模型有：字段连接点、构造器连接点、方法连接点；</li>
<li>Spring 只支持方法连接点，如果需要方法拦截之外的连接点拦截，可以转向更为强大的 Aspect。</li>
</ul>
</li>
<li><p><strong>通知（Advice）</strong> </p>
<ul>
<li><p>通知定义了切面是<strong>什么</strong>以及<strong>何时</strong>使用；</p>
</li>
<li><p>通知有以下五种类型；</p>
<table>
<thead>
<tr>
<th align="left">通知</th>
<th align="left">描述</th>
</tr>
</thead>
<tbody><tr>
<td align="left">Before</td>
<td align="left">在方法调用之前调用通知</td>
</tr>
<tr>
<td align="left">After-finally</td>
<td align="left">在方法完成之后调用通知，无论方法执行是否成功</td>
</tr>
<tr>
<td align="left">After-returning</td>
<td align="left">在方法成功执行之后调用通知</td>
</tr>
<tr>
<td align="left">After-throwing</td>
<td align="left">在方法抛出异常后调用通知</td>
</tr>
<tr>
<td align="left">Around</td>
<td align="left">通知包裹被通知的方法，在被通知方法的调用前和后执行自定义行为</td>
</tr>
</tbody></table>
</li>
<li><p>Spring所创建的通知都是由标准的Java类编写的。</p>
</li>
</ul>
</li>
<li><p><strong>切点（Pointcut）</strong></p>
<ul>
<li>切点定义了切面在<strong>何处</strong>使用，即哪些连接点会得到通知；</li>
<li>Spring 所定义的切点通常由 XML 文件或者注解来进行配置。</li>
</ul>
</li>
<li><p><strong>切面（Aspect）</strong></p>
<ul>
<li>切面是通知和切点的结合，切点和通知是切面的最基本元素；</li>
<li>通知和切点共同定义了关于切面的全部内容（什么、何时、何处）。</li>
</ul>
</li>
<li><p><strong>引入（Introduction）</strong></p>
<ul>
<li>引入允许在不修改现有类的情况下向现有类添加新方法或属性，令其具有新的行为和状态。</li>
</ul>
</li>
<li><p><strong>织入（Weaving）</strong></p>
<ul>
<li><p>织入是将切面应用到目标对象来创建新的代理对象的过程，切面在指定的连接点被织入到目标对象中；</p>
</li>
<li><p>在目标对象的生命周期里有以下三个时期可以进行织入；</p>
<table>
<thead>
<tr>
<th align="left">时期</th>
<th align="left">描述</th>
</tr>
</thead>
<tbody><tr>
<td align="left">编译期</td>
<td align="left">切面在目标类编译时被织入，比如 AspectJ</td>
</tr>
<tr>
<td align="left">类加载期</td>
<td align="left">切面在目标类加载到 JVM 时被织入</td>
</tr>
<tr>
<td align="left">运行期</td>
<td align="left">切面在应用运行的某个时刻被织入，比如 Spring AOP</td>
</tr>
</tbody></table>
</li>
<li><p>Spring 的 AOP 是基于 JVM 的动态代理实现的，在运行期将切面织入到 Spring 管理的 Bean 中， AspectJ AOP 是基于字节码操作实现的，在编译期织入切面；</p>
</li>
<li><p>Spring AOP 更加简单，AspectJ AOP 更加强大，如果切面比较少，那么两者性能差异不大，如果切面比较多，AspectJ AOP 比 Spring AOP 快很多。</p>
</li>
</ul>
</li>
</ul>
<h2 id="3-3-XML-配置"><a href="#3-3-XML-配置" class="headerlink" title="3.3 XML 配置"></a>3.3 XML 配置</h2><h3 id="3-3-1-使用步骤"><a href="#3-3-1-使用步骤" class="headerlink" title="3.3.1 使用步骤"></a>3.3.1 使用步骤</h3><p>1）通过Maven创建工程并引入<code>spring-aspects</code>依赖；</p>
<p>2）编写定义了切面逻辑的简单Java类；</p>
<p>3）在XML文件中将该类注册为Spring应用上下文中的一个Bean；</p>
<p>4）在XML文件中将该类配置为一个切面；</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">aop:config</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">aop:aspect</span> <span class="attr">id</span> = <span class="string">&quot;...&quot;</span> <span class="attr">ref</span> = <span class="string">&quot;...&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">aop:before</span> <span class="attr">pointcut</span> = <span class="string">&quot;...&quot;</span> <span class="attr">method</span> = <span class="string">&quot;...&quot;</span> <span class="attr">arg-names</span> = <span class="string">&quot;...&quot;</span> /&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">aop:after</span> <span class="attr">pointcut</span> = <span class="string">&quot;...&quot;</span> <span class="attr">method</span> = <span class="string">&quot;...&quot;</span> <span class="attr">arg-names</span> = <span class="string">&quot;...&quot;</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">aop:aspect</span>&gt;</span>                </span><br><span class="line"><span class="tag">&lt;/<span class="name">aop:config</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h3 id="3-3-2-配置元素"><a href="#3-3-2-配置元素" class="headerlink" title="3.3.2 配置元素"></a>3.3.2 配置元素</h3><ul>
<li><p>在<code>&lt;aop:config&gt;</code>元素内可以声明一个或多个通知器、切面或者切点；</p>
</li>
<li><p>在<code>&lt;aop:aspect&gt;</code>元素内可以声明一个简单的切面，<code>ref</code>属性引用了一个Bean，该Bean提供了在切面上通知所调用的方法；</p>
</li>
<li><p><code>&lt;aop:before&gt;</code>等元素分别定义不同的通知类型，<code>pointcut</code>属性定义了通知所应用的切点，<code>method</code>属性定义了切面上所调用的方法名，<code>arg-names</code>属性定义了所调用方法的入参；</p>
</li>
<li><p>如果有多个通知的<code>pointcut</code>属性值是一致的，那么可以通过以下配置方式来避免重复定义切点，其中，<code>&lt;aop-pointcut</code>元素中的<code>expression</code>属性定义了通知所应用的切点；</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">aop:config</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">aop:aspect</span> <span class="attr">ref</span> = <span class="string">&quot;...&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">aop:pointcut</span> <span class="attr">id</span> = <span class="string">&quot;xxx&quot;</span> <span class="attr">expression</span> = <span class="string">&quot;...&quot;</span> /&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">aop:before</span> <span class="attr">pointcut-ref</span> = <span class="string">&quot;xxx&quot;</span> <span class="attr">method</span> = <span class="string">&quot;...&quot;</span> <span class="attr">arg-names</span> = <span class="string">&quot;...&quot;</span> /&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">aop:after</span> <span class="attr">pointcut-ref</span> = <span class="string">&quot;xxx&quot;</span> <span class="attr">method</span> = <span class="string">&quot;...&quot;</span> <span class="attr">arg-names</span> = <span class="string">&quot;...&quot;</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">aop:aspect</span>&gt;</span>                </span><br><span class="line"><span class="tag">&lt;/<span class="name">aop:config</span>&gt;</span></span><br></pre></td></tr></table></figure></li>
<li><p><code>&lt;aop:before&gt;</code>等元素的<code>pointcut</code>属性以及<code>&lt;aop-pointcut</code>元素的<code>expression</code>属性的值是一个AspectJ切点表达式。</p>
</li>
</ul>
<h3 id="3-3-3-切点表达式"><a href="#3-3-3-切点表达式" class="headerlink" title="3.3.3 切点表达式"></a>3.3.3 切点表达式</h3><p>切点表达式指的是遵循特定语法结构的字符串，其作用是对符合语法格式的连接点进行通知。</p>
<p>在Spring AOP中，需要使用AspectJ的切点表达式来定义通知所引用的切点，比如表达式<code>execution(*A.B(..))</code>代表：</p>
<ul>
<li><p>使用<code>execution()</code>指示器来唯一选择<code>A</code>类（全限定类名）的<code>B</code>方法；</p>
</li>
<li><p>方法表达式以<code>*</code>开始，标识不关心方法的返回值类型；</p>
</li>
<li><p>方法参数列表为<code>(..)</code>，标识不关心方法的入参类型。</p>
</li>
</ul>
<p>需要注意的是：</p>
<ul>
<li><p>Spring仅支持AspectJ切点指示器的一个子集，<code>execution()</code>指示器就属于该子集；</p>
</li>
<li><p>当在Spring中尝试使用AspectJ子集之外的其他指示器时，会抛出异常；</p>
</li>
<li><p><code>bean()</code>指示器使用Bean的ID作为参数来限制切点只匹配特定的Bean，该指示器是由Spring 2.5新引入的。</p>
</li>
</ul>
<p>Spring支持的AspectJ切点指示器如下</p>
<ul>
<li><p><code>arg()</code>：限制连接点匹配参数为指定类型的执行方法</p>
</li>
<li><p><code>@args()</code>：限制连接点匹配参数由指定注解标注的执行方法</p>
</li>
<li><p><code>execution()</code>：用于匹配是连接点的执行方法</p>
</li>
<li><p><code>this()</code>：限制连接点匹配AOP代理的Bean引用为指定类型的类</p>
</li>
<li><p><code>target()</code>：限制连接点匹配目标对象为指定类型的类</p>
</li>
<li><p><code>@target()</code>：限制连接点匹配特定的执行对象，这些对象对应的类要具备指定类型的注解</p>
</li>
<li><p><code>within()</code>：限制连接点匹配指定的类型</p>
</li>
<li><p><code>@within()</code>：限制连接点匹配指定注解所标注的类型（当使用Spring AOP时，方法定义在由指定注解所标注的类里）</p>
</li>
<li><p><code>@annotation</code>：限制匹配带有指定注解连接点</p>
</li>
</ul>
<h3 id="3-3-4-引入新功能"><a href="#3-3-4-引入新功能" class="headerlink" title="3.3.4 引入新功能"></a>3.3.4 引入新功能</h3><p>切面除了能够为现有的方法增加额外的功能，还能为现有的Spring Bean增加新的方法。</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">aop:config</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">aop:aspect</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">aop:declare-parents</span> </span></span><br><span class="line"><span class="tag">           	<span class="attr">types-matching</span> = <span class="string">&quot;&quot;</span> <span class="attr">implements-interface</span> = <span class="string">&quot;&quot;</span> <span class="attr">default-impl</span> = <span class="string">&quot;&quot;</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">aop:aspect</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">aop:config</span>&gt;</span></span><br></pre></td></tr></table></figure>

<ul>
<li><p><code>&lt;aop:declare-parents&gt;</code>声明了此切面所通知的Bean在它的对象层次结构会中拥有新的父类型;</p>
</li>
<li><p>在这些Bean中，由<code>types-matching</code>属性指定的类型会实现由<code>implements-interface</code>属性指定的接口；</p>
</li>
<li><p>具体的实现由<code>default-impl</code>属性来直接标识或者由<code>delegate-ref</code>属性来间接委托。</p>
</li>
</ul>
<h2 id="3-4-注解配置"><a href="#3-4-注解配置" class="headerlink" title="3.4 注解配置"></a>3.4 注解配置</h2><p>在上一节的XML配置中，定义了切面逻辑的简单Java类中并没有任何地方让它成为一个切面，因此，不得不使用XML声明通知和切点。但是通过<code>@Aspect</code>注解，可以在不需要额外XML配置的情况下将简单Java类转换为一个切面。</p>
<h3 id="3-4-1-使用步骤"><a href="#3-4-1-使用步骤" class="headerlink" title="3.4.1 使用步骤"></a>3.4.1 使用步骤</h3><p>1）通过Maven创建工程并引入<code>spring-aspects</code>依赖；</p>
<p>2）使用<code>@Aspect</code>标注编写定义了切面逻辑的简单Java类（下文简称为切面Bean）；</p>
<p>3）使用<code>@Pointcut</code>定义一个可以在<code>@AspectJ</code>切面内可重用的切点；</p>
<ul>
<li><p><code>@Pointcut</code>注解的值是一个AspectJ切点表达式；</p>
</li>
<li><p><code>@Pointcut</code>注解所标注的是一个空的标识方法，供<code>@Pointcut</code>注解依附；</p>
</li>
<li><p>标识方法的方法签名相当于切点的名字，供通知拦截器引用；</p>
</li>
</ul>
<p>4）使用<code>@Before</code>等通知拦截器注解在切面Bean中编写拦截器代码（即切面逻辑）；</p>
<p>5）给<code>@Configuration</code>标注的配置类加上<code>@EnableAspectJAutoProxy</code>注解，使得IoC容器自动查找<code>@Aspect</code>所标注的Bean，并根据每个方法的通知拦截器将AOP织入到特定的Bean中。</p>
<h3 id="3-4-2-通知拦截器"><a href="#3-4-2-通知拦截器" class="headerlink" title="3.4.2 通知拦截器"></a>3.4.2 通知拦截器</h3><ul>
<li><p><code>@Before</code>：先执行拦截器代码，再执行目标代码，如果拦截器抛出异常，目标代码不执行；</p>
</li>
<li><p><code>@After</code>：先执行目标代码，再执行拦截器代码，无论目标代码是否抛出异常，拦截器代码都会执行；</p>
</li>
<li><p><code>@AfterReturning</code>：和<code>@After</code>的区别在于，只有目标代码正常返回时才会执行拦截器代码；</p>
</li>
<li><p><code>@AfterThrowing</code>：和<code>@After</code>的区别在于，只有目标代码抛出异常时才会执行拦截器代码；</p>
</li>
<li><p><code>@Around</code>：能在目标代码执行前后均执行拦截器代码，即便目标代码抛出异常，依旧继续执行拦截器代码，能够实现以上全部拦截器的功能。</p>
</li>
</ul>
<h3 id="3-4-3-精准指定切点"><a href="#3-4-3-精准指定切点" class="headerlink" title="3.4.3 精准指定切点"></a>3.4.3 精准指定切点</h3><p>除了使用 AspectJ 切点表达式，还可以考虑通过注解来标注需要拦截的方法，从而精准指定需要在何处织入切面。比如使用<code>@Transactional</code>注解去标注需要拦截的业务方法，即可精准指定需要在何处织入事务处理切面，实现声明式事务。</p>
<p><code>@Transactional</code></p>
<ul>
<li><p>往往在 service 层进行复杂业务场景中的多个事务方法互相调用时的事务传播控制，只有在使用基于接口的代理时才会生效；</p>
</li>
<li><p><code>rollbackFor</code>是用于指定触发事务回滚异常类型的事务属性，若不指定默认情况下只有<code>RuntimeExecption</code>和<code>Error</code>会触发回滚；</p>
</li>
<li><p><code>propagation</code>是用于指定事务传播级别的事务属性，Spring 规定了 7 种事务的传播级别：</p>
<ul>
<li>REQUIRED，如果不存在事务则开启一个事务，如果存在事务则加入之前的事务，总是只有一个事务在执行，是默认的传播机制，比如在写操作还未完成之前执行一些中间操作，这些中间操作应该使用这一级别，一旦中间操作报错则需回滚</li>
<li>REQUIRES_NEW，每次执行都新开一个事务</li>
<li>SUPPORTS，有事务则加入事务，没有事务则普通执行</li>
<li>NOT_SUPPORTED，有事务则暂停该事务，没有则普通执行，比如在写操作完成之后执行读操作，读操作应该使用这一级别，避免读操作报错导致前面的写操作回滚</li>
<li>MANDATORY，强制有事务，没有事务则报异常</li>
<li>NEVER，有事务则报异常</li>
<li>NESTED，如果之前有事务，则创建嵌套事务，嵌套事务回滚不影响父事务，但父事务回滚则影响嵌套事务</li>
</ul>
</li>
<li><p>声明式事务使用简单，对代码没有侵入性，也容易被开发者的忽略，进而在错误使用 AOP（类内部自调用、<code>static</code>方法、<code>final</code>方法、非<code>public</code>方法），或者在事务中加入一些分布式缓存、RPC、文件写入等无法回滚的操作，或者错误地设置了<code>rollbackFor</code>、<code>propagation</code>属性，又或者是在事务方法内部 catch 了异常等都会导致事务使用出问题；</p>
</li>
<li><p>除了基于<code>@Transactional</code>的声明式事务，Spring 还提供基于<code>TransactionTemplate</code>等核心接口的编程式事务，开发者可以在代码中手动控制事务的开启、提交、回滚等操作，此时业务代码中就会清清楚楚地看到事务的具体控制细节，绝对不会被开发者忽略。</p>
</li>
</ul>
<p>除了<code>@Transactional</code>注解，还可以自定义注解来标注需要拦截的方法，此时切面 Bean 中的切点表达式只需写为 AspectJ 指示器（自定义注解）这样的形式，即可在业务代码中通过自定义注解来精准指定需要在何处织入切面。</p>
<h3 id="3-4-4-引入新功能"><a href="#3-4-4-引入新功能" class="headerlink" title="3.4.4 引入新功能"></a>3.4.4 引入新功能</h3><p>在上文介绍了如何使用基于 XML 的 AOP 来为现有的 Spring Bean 增加新的方法，这一功能依旧可以使用基于注解的 AOP 来完成。</p>
<ul>
<li><p><code>@DeclareParents</code>等价于<code>aop:declare-parents&gt;</code>；</p>
</li>
<li><p><code>@DeclareParents</code>的<code>value</code>属性等同于<code>aop:declare-parents&gt;</code>的<code>types-matching</code>属性，标识应该被引入指定接口的Bean的类型；</p>
</li>
<li><p><code>@DeclareParents</code>的<code>defaultImpl</code>属性等同于<code>aop:declare-parents&gt;</code>的<code>default-impl</code>属性，标识所引入接口的实现；</p>
</li>
<li><p>被<code>@DeclareParents</code>所标注的<code>static</code>属性指定了将被引入的接口；</p>
</li>
<li><p><code>@DeclareParents</code>没有与<code>aop:declare-parents&gt;</code>的<code>delegate-ref</code>属性等价的属性。</p>
</li>
</ul>
<h2 id="3-5-AOP-特性"><a href="#3-5-AOP-特性" class="headerlink" title="3.5 AOP 特性"></a>3.5 AOP 特性</h2><h3 id="3-5-1-CGLIB"><a href="#3-5-1-CGLIB" class="headerlink" title="3.5.1 CGLIB"></a>3.5.1 CGLIB</h3><p>Spring 的 AOP 是基于 JVM 的动态代理实现的，在代理对象中织入切面逻辑。如果要代理的对象实现了某个接口，那么 Spring AOP 会使用基于反射的 <strong>JDK Proxy</strong> 去创建代理对象，而对于没有实现接口的对象，Spring AOP 会使用基于字节码处理框架的 <strong>CGLIB</strong> 生成一个被代理对象的子类来作为代理。需要注意的地方在于：</p>
<ul>
<li><p>Spring 通过 CGLIB 实现代理时要求原始类是可扩展的（非<code>final</code>）；</p>
</li>
<li><p>Spring 通过 <strong>CGLIB 创建的代理类不会初始化继承自原始类的任何成员变量</strong>，包括<code>final</code>类型的成员变量，也就是说，CGLIB 所创建的代理所继承的成员变量的值始终为<code>null</code>，因此加 AOP 很可能会导致 NPE；</p>
</li>
<li><p>以上 NPE 问题的解决方式是业务类通过<code>getXXX</code>方法而不是直接获取<code>XXX</code>变量的值，那么CGLIB 创建的代理类会覆写<code>getXXX</code>方法，从而返回原始业务类的<code>XXX</code>变量的值；</p>
</li>
<li><p>Spring 通过 <strong>CGLIB 创建的代理类无法覆写继承自原始类的<code>final</code>方法</strong>，即无法代理<code>final</code>方法。</p>
</li>
</ul>
<p>因此，为了正确使用 AOP：</p>
<ul>
<li><p>在访问被注入的 Bean 的成员变量时，总是调用<code>getXXX</code>方法而非直接访问字段；</p>
</li>
<li><p>编写可能会被代理的 Bean 时，避免编写<code>public final</code>方法。</p>
</li>
</ul>
<h3 id="3-5-2-创建代理-Bean"><a href="#3-5-2-创建代理-Bean" class="headerlink" title="3.5.2 创建代理 Bean"></a>3.5.2 创建代理 Bean</h3><p>接 2.4.5 小节：</p>
<p>1）在<code>AbstractAutowireCapableBeanFactory</code>类的<code>initializeBean</code>方法中，会依次调用<code>applyBeanPostProcessorsAfterInitialization</code>方法 –&gt; <code>BeanPostProcessor</code>接口的<code>postProcessAfterInitialization</code>方法，<code>AbstractAutoProxyCreator</code>类提供了<code>postProcessAfterInitialization</code>方法的具体实现；</p>
<p>2）在<code>AbstractAutoProxyCreator</code>类的<code>postProcessAfterInitialization</code>方法中，完整代码如下</p>
<ul>
<li><p>以下代码的第 5 行，检查当前 Bean 对象是否已经暴露过了，只有没有暴露过的对象，才生成其代理对象；</p>
</li>
<li><p>以下代码的第 6 行，会依次调用<code>wrapIfNecessary</code>方法 –&gt; <code>createProxy</code>方法，从而创建代理对象；</p>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> Object <span class="title function_">postProcessAfterInitialization</span><span class="params">(<span class="meta">@Nullable</span> Object bean, String beanName)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (bean != <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="type">Object</span> <span class="variable">cacheKey</span> <span class="operator">=</span> getCacheKey(bean.getClass(), beanName);</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">this</span>.earlyProxyReferences.remove(cacheKey) != bean) &#123;</span><br><span class="line">            <span class="keyword">return</span> wrapIfNecessary(bean, beanName, cacheKey);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> bean;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>3）在<code>AbstractAutoProxyCreator</code>类的<code>createProxy</code>方法中，截取了部分代码如下</p>
<ul>
<li><p>以下代码的第 7 行，调用<code>ProxyFactory</code>类的构造方法生成代理工厂，后续会将创建代理的工作交给<code>proxyFactory</code>；</p>
</li>
<li><p>以下代码的第 17 行，调用<code>ProxyFactory</code>类的<code>getProxy</code>方法来创建代理；</p>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">protected</span> Object <span class="title function_">createProxy</span><span class="params">(Class&lt;?&gt; beanClass, <span class="meta">@Nullable</span> String beanName, <span class="meta">@Nullable</span> Object[] specificInterceptors, TargetSource targetSource)</span> &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">this</span>.beanFactory <span class="keyword">instanceof</span> ConfigurableListableBeanFactory) &#123;</span><br><span class="line">        AutoProxyUtils.exposeTargetClass((ConfigurableListableBeanFactory) <span class="built_in">this</span>.beanFactory, beanName, beanClass);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="type">ProxyFactory</span> <span class="variable">proxyFactory</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ProxyFactory</span>();</span><br><span class="line">    proxyFactory.copyFrom(<span class="built_in">this</span>);</span><br><span class="line">    </span><br><span class="line">    ...</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// Use original ClassLoader if bean class not locally loaded in overriding class loader</span></span><br><span class="line">    <span class="type">ClassLoader</span> <span class="variable">classLoader</span> <span class="operator">=</span> getProxyClassLoader();</span><br><span class="line">    <span class="keyword">if</span> (classLoader <span class="keyword">instanceof</span> SmartClassLoader &amp;&amp; classLoader != beanClass.getClassLoader()) &#123;</span><br><span class="line">        classLoader = ((SmartClassLoader) classLoader).getOriginalClassLoader();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> proxyFactory.getProxy(classLoader);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>4）在<code>ProxyFactory</code>类的<code>getProxy</code>方法中，完整代码如下</p>
<ul>
<li><p>首先会依次调用<code>ProxyCreatorSupport</code>类的<code>createAopProxy</code>方法 –&gt; <code>getAopProxyFactory</code>方法 –&gt; <code>DefaultAopProxyFactory</code>类的<code>createAopProxy</code>方法，得到<code>AopProxy</code>类对象；</p>
</li>
<li><p>接着调用<code>AopProxy</code>类对象的<code>getProxy</code>方法得到代理类对象；</p>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> Object <span class="title function_">getProxy</span><span class="params">(<span class="meta">@Nullable</span> ClassLoader classLoader)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> createAopProxy().getProxy(classLoader);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>5）在 <code>DefaultAopProxyFactory</code>类的<code>createAopProxy</code>方法中，会判断创建代理对象时是使用 JDK 代理，还是使用 CGLIB，完整代码如下</p>
<ul>
<li><p>设置<code>proxyTargetClass=true</code>会强制使用 CGLIB；</p>
</li>
<li><p>没有设置参数并且对象类实现了接口则默认使用 JDK 代理；</p>
</li>
<li><p>没有设置参数并且对象类没有实现接口则也必须使用 CGLIB；</p>
</li>
<li><p>以<code>ObjenesisCglibAopProxy</code>类为例，它继承了父类<code>CglibAopProxy</code>的<code>getProxy</code>方法；</p>
</li>
<li><p>在<code>CglibAopProxy</code>类的<code>getProxy</code>方法中，最终会通过调用<code>createProxyClassAndInstance</code>方法来创建代理类，并生成一个代理类的实例。</p>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> AopProxy <span class="title function_">createAopProxy</span><span class="params">(AdvisedSupport config)</span> <span class="keyword">throws</span> AopConfigException &#123;</span><br><span class="line">    <span class="keyword">if</span> (!NativeDetector.inNativeImage() &amp;&amp; (config.isOptimize() || config.isProxyTargetClass() || hasNoUserSuppliedProxyInterfaces(config))) &#123;</span><br><span class="line">        Class&lt;?&gt; targetClass = config.getTargetClass();</span><br><span class="line">        <span class="keyword">if</span> (targetClass == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">AopConfigException</span>(<span class="string">&quot;TargetSource cannot determine target class: &quot;</span> + <span class="string">&quot;Either an interface or a target is required for proxy creation.&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (targetClass.isInterface() || Proxy.isProxyClass(targetClass) || ClassUtils.isLambdaClass(targetClass)) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">JdkDynamicAopProxy</span>(config);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">ObjenesisCglibAopProxy</span>(config);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">JdkDynamicAopProxy</span>(config);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h1 id="4、MVC"><a href="#4、MVC" class="headerlink" title="4、MVC"></a>4、MVC</h1><h2 id="4-1-问题与解决"><a href="#4-1-问题与解决" class="headerlink" title="4.1 问题与解决"></a>4.1 问题与解决</h2><p>由于 HTTP 协议的无状态性，基于 Web 的应用程序在状态管理、工作流等问题上面临着重大挑战，Spring MVC 就是为了解决这些问题而设计的。</p>
<p>Spring MVC 基于模型-视图-控制器（Model-View-Controller, MVC）模式实现，核心思想在于将业务逻辑、数据表示、数据显示都分离，有助于构建灵活、松耦合的 Web 应用程序。</p>
<p>整个 MVC 相当于三层架构中的 UI 表现层，通过 MVC 对 UI 层又进一步进行了分层，三者职责明确，且开发更简单</p>
<ul>
<li><p>Model 可以是一个 JavaBean，也可以是一个包含多个 JavaBean 的 Map，表示应用程序的核心业务逻辑和数据，用于处理数据的输入、输出、更新和存储等操作，只关注数据本身以及对数据的操作，而不关心数据的显示以及和用户的交互方式；</p>
</li>
<li><p>View 表示应用程序的用户界面，只负责把 Model 给“渲染”出来，显示出 Model 中的数据，可以与用户进行交互，只关心数据呈现以及与用户的交互，而不关心数据的处理或存储方式；</p>
</li>
<li><p>Controller 表示应用程序的处理逻辑，将用户的输入转化为对 Model 的操作，会调用业务处理方法并将得到的 Model 返回给 View，Controller 中尽量不放业务逻辑代码，实现了 View 和 Model 之间的解耦。</p>
</li>
</ul>
<h2 id="4-2-请求的生命周期"><a href="#4-2-请求的生命周期" class="headerlink" title="4.2 请求的生命周期"></a>4.2 请求的生命周期</h2><p>每当用户在 Web 浏览器中点击链接或者提交表单的时候，一个 Request 就开始工作了：</p>
<p>1）Request 首先会到达<code>DispatcherServlet</code>（前端控制器 Servlet，继承自<code>HttpServlet</code>）；</p>
<ul>
<li><p><code>DispatcherServlet</code>会查询一个或者多个<code>Handler mapping</code>（处理器映射）；</p>
</li>
<li><p><code>Handler mapping</code>根据 Request 所携带的 URL 信息来进行决策；</p>
</li>
<li><p><code>DispatcherServlet</code>根据查询结果来确定应该将 Request 委托给哪一个<code>Controller</code>（控制器）；</p>
</li>
</ul>
<p>2）Request 到达<code>Controller</code>后会卸下其负载（用户提交的信息）并等待<code>Controller</code>完成逻辑处理；</p>
<ul>
<li><p>设计良好的<code>Controller</code>本身几乎不处理工作，而是将业务逻辑委托给一个或多个服务对象；</p>
</li>
<li><p>在逻辑处理完成后，会产生一些信息，这些信息被称为 <strong>Model（模型）</strong>；</p>
</li>
<li><p>Model 需要被发送给一个 <strong>View（视图）</strong>，即以用户友好的方式进行格式化，一般是 HTML；</p>
</li>
<li><p><code>Controller</code>将 Model 数据打包，标示出用于渲染输出的 View 名称；</p>
</li>
<li><p><code>Controller</code>不会与特定的 View 相耦合；</p>
</li>
</ul>
<p>3）Request、Model 和 View 名称被<code>Controller</code>发送回<code>DispatcherServlet</code>；</p>
<ul>
<li><p>传递给<code>DispatcherServlet</code>的 View 名称仅仅是一个逻辑名，并不直接表示某个特定的 View；</p>
</li>
<li><p><code>DispatcherServlet</code>使用 ViewResolve（视图解析器）来为 View 的逻辑名称添加前后缀，然后查找一个特定的 View 实现模板；</p>
</li>
</ul>
<p>4）Request 的最后一站是 View 的实现模板，在这里 Request 交付 Model 数据，Request 的任务就完成了；</p>
<ul>
<li>View 模板通常是 JSP（JavaServer Page），但其他的 View 技术也可以使用；</li>
<li>View 模板通过 Model 数据会渲染输出一个 View，通过这个 View 将 Response 传递给客户端；</li>
</ul>
<p>至此，就完成了从 Request 离开浏览器到获取 Response 返回浏览器的过程。</p>
<h2 id="4-3-搭建步骤"><a href="#4-3-搭建步骤" class="headerlink" title="4.3 搭建步骤"></a>4.3 搭建步骤</h2><p>1）在web.xml文件中配置<code>DispatcherServlet</code>；</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">servlet</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">servlet-name</span>&gt;</span>spitter<span class="tag">&lt;/<span class="name">servlet-name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">servlet-class</span>&gt;</span></span><br><span class="line">        org.springframework.web.servlet.DispatcherServlet</span><br><span class="line">    <span class="tag">&lt;/<span class="name">servlet-class</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">load-on-startup</span>&gt;</span>1<span class="tag">&lt;/<span class="name">load-on-startup</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">servlet</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">servlet-mapping</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">servlet-name</span>&gt;</span>spitter<span class="tag">&lt;/<span class="name">servlet-name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">url-pattern</span>&gt;</span>/<span class="tag">&lt;/<span class="name">url-pattern</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">servlet-mapping</span>&gt;</span></span><br></pre></td></tr></table></figure>

<ul>
<li><p>由于<code>servlet-name</code>元素被配置为<code>spitter</code>，<code>DispatcherServlet</code>在加载时会从一个名为<code>spitter-servlet.xml</code>的文件来加载应用上下文；</p>
</li>
<li><p><code>servlet-mapping</code>元素的<code>url-pattern</code>属性将<code>DispatcherServlet</code>映射到<code>/</code>，声明了它会作为默认的servlet并且会处理所有的请求，包括对静态资源的请求；</p>
</li>
</ul>
<p>2）编写<code>spitter-servlet.xml</code>文件并配置注解驱动；</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">mvc:resources</span> <span class="attr">mapping</span> = <span class="string">&quot;/resources/**&quot;</span> <span class="attr">location</span> = <span class="string">&quot;/resources/&quot;</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">mvc:annotation-driven</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">context:component-scan</span> <span class="attr">base-package</span> = <span class="string">&quot;...&quot;</span> /&gt;</span></span><br></pre></td></tr></table></figure>

<ul>
<li><p><code>&lt;mvc:resources&gt;</code>元素建立了一个服务于静态资源的处理器，此时，所有的静态资源都必须放置在应用程序的/resources目录下；</p>
</li>
<li><p><code>&lt;mvc:annotation-driven/&gt;</code>标签与<code>DispatcherServlet</code>提供的处理器映射（<code>DefaultAnnotationHandlerMapping</code>）相结合就能实现基于注解的控制器类；</p>
</li>
<li><p>Spring也提供了其他类型的处理器映射，只需在Spring中配置该处理器映射Bean即可使用；</p>
</li>
<li><p><code>&lt;context:component-scan&gt;</code>元素将查找所有的控制器类并将其注册为Bean；</p>
</li>
</ul>
<p>3）编写首页控制器以及面向Spitter和Spittle的控制器，应当为应用程序所提供的每一种资源（而不是为每个用例）编写一个单独的控制器；</p>
<p>4）在<code>spitter-servlet.xml</code>文件中配置视图解析器</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span> = <span class="string">&quot;org.springframework.web.servlet.view.InternalResourceViewResolver&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span> = <span class="string">&quot;viewClass&quot;</span> </span></span><br><span class="line"><span class="tag">              <span class="attr">value</span> = <span class="string">&quot;org.springframework.web.servlet.view.JstlView&quot;</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span> = <span class="string">&quot;prefix&quot;</span> <span class="attr">value</span> = <span class="string">&quot;/WEB-INF/views/&quot;</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span> = <span class="string">&quot;suffix&quot;</span> <span class="attr">value</span> = <span class="string">&quot;.jsp&quot;</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure>

<ul>
<li><p>视图解析器<code>InternalResourceViewResolver</code>将View的逻辑名称与JSP（JavaServer Page）相匹配；</p>
</li>
<li><p><code>InternalResourceViewResolver</code>将View的逻辑名称添加前后缀得到View路径，并解析为View对象；</p>
</li>
<li><p>View对象将渲染的任务委托给视图模板，即将Request传递给JSP；</p>
</li>
<li><p>如果需要使用其他的视图解析器，同样需要在<code>spitter-servlet.xml</code>文件中将该视图解析器注册为一个<code>&lt;bean&gt;</code>；</p>
</li>
</ul>
<p>5）定义JSP视图并完成Spring应用上下文；</p>
<ul>
<li><p>Web层的配置都放在<code>spitter-servlet.xml</code>的文件中，这个文件会被<code>DispatcherServlet</code>加载，但还需要加载其他的配置文件；</p>
</li>
<li><p>通过使用<code>ContextLoaderListener</code>，能够加载其他的配置文件到一个Spring应用上下文中。</p>
</li>
</ul>
<h2 id="4-4-REST-功能"><a href="#4-4-REST-功能" class="headerlink" title="4.4 REST 功能"></a>4.4 REST 功能</h2><p>以信息为中心的表属性状态转移（Representational State Transfer, REST）已成为替换传统 SOAP Web 服务的流行方案，REST 就是将资源的状态以最合适的形式从服务器端转移到客户端（或者反之），RESTful 交互是同步的。</p>
<ul>
<li>表述性（Representational）：REST 资源可以用各种形式来进行表述，比如 XML、JSON 以及 HTML；</li>
<li>状态（State）：使用 REST 时，我们更关注资源的状态而不是对资源采取的行为，所有的资源都可以通过 URI 定位，而且这个定位与其他资源无关，也不会因为其他资源的变化而变化；</li>
<li>转移（Transfer）：REST 涉及转移资源数据，它以某一种表述形式从一个应用转移到另一个应用</li>
</ul>
<p>Spring 对 REST 的支持是构建在 Spring MVC 之上的，控制器可以处理所有的 HTTP 方法，包含四个主要的 REST 方法：GET、PUT、DELETE 以及 POST，分别对应对资源的检索、更新、删除和创建。通过适当设置<code>@RequestMapping</code>注解的<code>method</code>属性，就可以让<code>DispatcherServlet</code>把不同的HTTP方法的请求定向到特定的控制器方法上。</p>
<p>RESTful Web 服务与传统的 MVC 开发一个关键区别是返回给客户端的内容的创建方式：<strong>传统的 MVC 模式开发会直接返回给客户端一个视图，但是 RESTful Web 服务一般会将返回的数据以 JSON 的形式返回，实现前后端分离开发。</strong></p>
<p>可处理的 HTTP 方法具体介绍如下：</p>
<ul>
<li><p>GET</p>
<ul>
<li><p>可只直接使用<code>@GetMapping</code>注解；</p>
</li>
<li><p>是最常用的方法，可用于获取资源；</p>
</li>
<li><p>在浏览器中可以回退，请求会被浏览器主动缓存；</p>
</li>
<li><p>只能进行URL编码，只接收ASCII字符；</p>
</li>
<li><p>参数直接暴露在URL上，安全性较低，不能用于传递敏感信息。</p>
</li>
</ul>
</li>
<li><p>POST</p>
<ul>
<li><p>可只直接使用<code>@PostMapping</code>注解；</p>
</li>
<li><p>如果需要添加对象，可使用POST方法传递一个Model 对象；</p>
</li>
<li><p>访问同一地址时也需要再次提交请求，浏览器不会缓存请求；</p>
</li>
<li><p>除了URL，还支持多种编码方式；</p>
</li>
<li><p>参数可以放在request body 中，也可以通过URL传递。</p>
</li>
</ul>
</li>
<li><p>PUT</p>
<ul>
<li><p>可只直接使用<code>@PutMapping</code>注解；</p>
</li>
<li><p>如果对象需要更新，可使用PUT方法去发送请求。</p>
</li>
</ul>
</li>
<li><p>PATCH</p>
<ul>
<li><p>是一个新引入的方法，是对PUT方法的补充；</p>
</li>
<li><p>用来对己知资源进行局部更新，比如一个对象的部分数据而非整个对象数据。</p>
</li>
</ul>
</li>
<li><p>DELETE</p>
<ul>
<li><p>可只直接使用<code>@DeleteMapping</code>注解；</p>
</li>
<li><p>在执行前先查询是否有数据；</p>
</li>
<li><p>由于返回的是<code>void</code> 类型，要注意判断是否成功，可通过存储过程返回值来判断。</p>
</li>
</ul>
</li>
<li><p>OPTIONS</p>
<ul>
<li><p>用于获取当前URL所支持的方法；</p>
</li>
<li><p>返回的响应消患会在HTTP 头中包含“Allow”的信息，其值是所支持的方法， 如GET。</p>
</li>
</ul>
</li>
<li><p>HEAD</p>
<ul>
<li>代表发送HTTP 头消息，GET其实也带了HTTP 头消息。</li>
</ul>
</li>
<li><p>TRACE</p>
<ul>
<li>用于显示服务器收到的请求，从而进行测试或诊断。</li>
</ul>
</li>
</ul>
<h2 id="4-5-相关组件"><a href="#4-5-相关组件" class="headerlink" title="4.5 相关组件"></a>4.5 相关组件</h2><h3 id="4-5-1-控制器"><a href="#4-5-1-控制器" class="headerlink" title="4.5.1 控制器"></a>4.5.1 控制器</h3><ul>
<li><p><code>@Controller</code></p>
<ul>
<li>用于类，表明该类是MVC的控制器。</li>
</ul>
</li>
<li><p><code>@RequestBody</code></p>
<ul>
<li><p>用于请求方法参数；</p>
</li>
<li><p>可以将请求中的(JSON/XML）字符串绑走到相应的Bean 上，也可以将其分别绑定到对应的字符串上。</p>
</li>
</ul>
</li>
<li><p><code>@ResponseBody</code></p>
<ul>
<li><p>用于方法；</p>
</li>
<li><p>将请求方法返回的对象转换为指定格式（JSON/XML）后，再写入<code>Response</code>对象的<code>body</code>数据区。</p>
</li>
</ul>
</li>
<li><p><code>@RestController</code></p>
<ul>
<li><p>是Spring 4.0之后才有的注解；</p>
</li>
<li><p>是<code>@Controller</code>和<code>@ResponseBody</code>的结合；</p>
</li>
<li><p>用于标注REST风格的控制器；</p>
</li>
<li><p>告诉Spring将结果字符串直接呈现给调用者。</p>
</li>
</ul>
</li>
<li><p><code>@RequestMapping</code></p>
<ul>
<li><p>提供了“路由”信息，告诉Spring任何带有/路径的HTTP请求都应该映射到home方法；</p>
</li>
<li><p>用于类时，定义了这个控制器所处理的根URL路径；</p>
</li>
<li><p>用于方法时，表明该方法是一个请求处理方法，要处理指定URL下的请求；</p>
</li>
<li><p>请求处理方法的签名可以将任何事物作为入参；</p>
</li>
<li><p><code>value</code>属性用于指定请求的地址；</p>
</li>
<li><p><code>method</code>属性用于指定请求的类型（GET、HEAD、POST、PUT、PATCH、DELETE、OPTIONS、TRACE）；</p>
</li>
<li><p><code>consumes</code>属性用于指定请求的内容类型；</p>
</li>
<li><p><code>produces</code>属性用于指定返回的内容类型；</p>
</li>
<li><p><code>params</code>属性用于指定请求中必须包含的参数值；</p>
</li>
<li><p><code>headers</code>属性用于指定请求中必须包含的header值。</p>
</li>
</ul>
</li>
<li><p><code>@RequestParam</code></p>
<ul>
<li>用于请求方法参数，当查询参数与方法参数名不匹配时，可以通过该注解将两者绑定。</li>
</ul>
</li>
<li><p><code>@PathVariable</code></p>
<ul>
<li>用于请求方法参数，将请求中的变量映射到请求处理方法的参数上。</li>
</ul>
</li>
</ul>
<h3 id="4-5-2-Servlet"><a href="#4-5-2-Servlet" class="headerlink" title="4.5.2 Servlet"></a>4.5.2 Servlet</h3><p>Servlet 是<code>javax.servlet</code>包中定义的一个接口，除了Controller以外，有时也需要使用Servlet来实现拦截和监昕功能。</p>
<ul>
<li><p><code>@WebServlet(urlPattern = &quot;&quot;)</code></p>
<ul>
<li><p>用于注册Servlet实现类；</p>
</li>
<li><p>使得<code>DispatcherServlet</code>核心控制器知道它的作用，以及处理请求<code>urlpattern</code>。</p>
</li>
</ul>
</li>
<li><p><code>＠ServletComponentScan</code></p>
<ul>
<li><p>用于启动类；</p>
</li>
<li><p>以扫描注册指定包内的所有Servlet、Filter以及监听器。</p>
</li>
</ul>
</li>
<li><p><code>HttpServlet</code></p>
<ul>
<li><p>Servlet抽象类；</p>
</li>
<li><p>自定义的Servlet需要继承<code>HttpServlet</code>，并重写<code>doGet</code>方法。</p>
</li>
</ul>
</li>
</ul>
<h3 id="4-5-3-过滤器"><a href="#4-5-3-过滤器" class="headerlink" title="4.5.3 过滤器"></a>4.5.3 过滤器</h3><p>对于多个页面都需要进行的例如参数校验等功能，可以通过过滤器来实现，从而避免重复代码。定义一个过滤器应当：</p>
<ul>
<li><p>实现<code>Filter</code>接口；</p>
</li>
<li><p>实现<code>init</code>、<code>doFilter</code>、<code>destory</code>方法；</p>
</li>
<li><p>使用<code>@WebFilter(urlPatterns = &quot;&quot;)</code>注解标注；</p>
</li>
<li><p>使用<code>＠ServletComponentScan</code>注解标注启动类。</p>
</li>
</ul>
<h3 id="4-5-4-监听器"><a href="#4-5-4-监听器" class="headerlink" title="4.5.4 监听器"></a>4.5.4 监听器</h3><p>监听器用于监听Web应用程序中某些对象或信息的创建、销毁、增加、修改、删除等动作，然后做出相应的响应处理。当对象的状态发生变化时，服务器自动调用监听器的方法。具体应用有统计在线用户人数、在结用户、系统加载时的信息初始化等。</p>
<p>Servlet 中的监听器分为以下类型：</p>
<ul>
<li><p>监听<code>ServletContext</code>、<code>Request</code>、<code>Session</code>作用域的创建和销毁；</p>
<ul>
<li><p><code>ServletContextListener</code>；</p>
</li>
<li><p><code>HttpSessionListener</code>；</p>
</li>
<li><p><code>ServletRequestListener</code>；</p>
</li>
</ul>
</li>
<li><p>监听<code>ServletContext</code>、<code>Request</code>、<code>Session</code>作用域中属性的变化（增加、修改、删除）；</p>
<ul>
<li><p><code>ServletContextAttributeListener</code>；</p>
</li>
<li><p><code>HttpSessionAttributeListener</code>；</p>
</li>
<li><p><code>ServletRequestAttributeListener</code>；</p>
</li>
</ul>
</li>
<li><p>监听<code>HttpSession</code>作用域中对象状态的改变（被绑定、解除绑走、钝化、活化）；</p>
<ul>
<li><p><code>HttpSessionBindingListener</code>；</p>
</li>
<li><p><code>HttpSessionActivationListener</code>；</p>
</li>
</ul>
</li>
</ul>
<p>定义一个监听器应当：</p>
<ul>
<li><p>实现上述任意类型的监听器接口；</p>
</li>
<li><p>实现监听器接口中对应的方法；</p>
</li>
<li><p>使用<code>@WebListener</code>注解标注；</p>
</li>
<li><p>使用<code>＠ServletComponentScan</code>注解标注启动类。</p>
</li>
</ul>
<h3 id="4-5-5-异常"><a href="#4-5-5-异常" class="headerlink" title="4.5.5 异常"></a>4.5.5 异常</h3><p>Spring 提供的异常处理方案是利用切面技术实现的，会将异常处理切面织入到目标控制器中。</p>
<ul>
<li><p>异常类一般需要包含以下信息：</p>
<ul>
<li>唯一标示异常的 code；</li>
<li>HTTP状态码；</li>
<li>错误路径；</li>
<li>发生错误的时间戳；</li>
<li>错误的具体信息。</li>
</ul>
</li>
<li><p><code>RuntimeException</code></p>
<ul>
<li><p>一般处理的异常都是<code>RuntimeException</code>；</p>
</li>
<li><p>可以通过继承<code>RuntimeException</code>或新建<code>ResponseStatusException</code>（通过构造器来注入属性值）来定义自己的异常类型。</p>
</li>
</ul>
</li>
<li><p><code>@ControllerAdvice</code>或<code>@RestControllerAdvice</code></p>
<ul>
<li><p>可以用于定义异常处理类，默认对所有的<code>Controller</code>都有效；</p>
</li>
<li><p><code>@ControllerAdvice(annotations = &#123;RestController.class&#125;)</code>可以指定特定的注解，使得异常处理类只处理特定注解所标记的类抛出的异常；</p>
</li>
<li><p><code>@ControllerAdvice(&quot;&quot;)</code>可以指定特定的包名，使得异常处理类只处理特定包内抛出的异常；</p>
</li>
<li><p><code>@ControllerAdvice(assignableTypes = &#123;ExceptionController.class&#125;)</code>可以指定特定的<code>Controller</code>，使得异常处理类只处理特定<code>Controller</code>抛出的异常。</p>
</li>
</ul>
</li>
<li><p><code>@ExceptionHandler</code></p>
<ul>
<li><p>可以用于定义异常处理方法，可以拦截控制器中发生的异常；</p>
</li>
<li><p><code>@ExceptionHandler(value = XXXException.class)</code>可以指定特定的异常类型，使得异常处理方法只处理特定的异常类型。</p>
</li>
</ul>
</li>
</ul>
<h3 id="4-5-6-HTTP-客户端"><a href="#4-5-6-HTTP-客户端" class="headerlink" title="4.5.6 HTTP 客户端"></a>4.5.6 HTTP 客户端</h3><p>Spring 6.0 中内置 HTTP 客户端，使用<code>@HttpExchange</code>标注的服务接口被视为 HTTP 端点，可以调用得到指定路径的 HTTP 接口返回。</p>
<h1 id="5、ORM"><a href="#5、ORM" class="headerlink" title="5、ORM"></a>5、ORM</h1><h2 id="5-1-问题与解决"><a href="#5-1-问题与解决" class="headerlink" title="5.1 问题与解决"></a>5.1 问题与解决</h2><p>业务实体在内存中表现为对象，在数据库中表现为关系型数据。内存中的对象不会被永久保存，只有关系型数据库（或 NoSQL 数据库，或文件）中的对象会被永久保存。ORM（Object Relation Mapping）指对象关系映射，对数据库中的表和内存中的对象建立了映射关系，是连接数据库的桥梁，用于将程序中的数据对象自动持久化到关系数据库中。</p>
<ul>
<li><p>ORM 在一个地方定义数据模型，更容易更新和维护，ORM 框架一般以中间件的形式存在，目前比较常用的 ORM 有 Hibernate、JPA、MyBatis 等，可以非常方便自动地完成数据消毒、预处理、事务等</p>
</li>
<li><p>基于 ORM 的业务代码比较简答，代码量少，语义性好，容易理解，开发者不必编写冗杂甚至性能不佳的 SQL，还会迫使应用程序使用 MVC 架构，ORM 就是天然的 Model，这都使得代码更加清晰</p>
</li>
<li><p>ORM 并不是轻量级工具，需要花费一定的学习成本和配置</p>
</li>
<li><p>对于复杂的查询，ORM 要么是无法表达，要不是性能不如原生的 SQL</p>
</li>
<li><p>ORM 抽象掉了数据库层，开发者无法了解底层的数据库操作，也无法定制一些特殊的 SQL</p>
</li>
</ul>
<p>数据源是对数据库连接、连接中的事务操作以及事务提交或回滚的抽象，负责和实体数据库的连接，是被第三方数据库实现的（一般不会使用 ORM 框架自带的数据库连接）。Java 中的数据源被定义<code>DataSource</code>，<code>DataSource</code>接口由驱动程序供应商实现，作为<code>DriverManager</code>的替代，<code>DataSource</code>是获取连接的首选方式，数据库连接有以下实现方式</p>
<ul>
<li><p>基本实现，标准连接对象</p>
</li>
<li><p>连接池实现，该连接对象将自动参与连接池，与中间层连接池管理器一起工作</p>
</li>
<li><p>分布式事务实现，该连接对象可以用于分布式事务，并且几乎总是参与连接池</p>
</li>
</ul>
<h2 id="5-2-Hibernate"><a href="#5-2-Hibernate" class="headerlink" title="5.2 Hibernate"></a>5.2 Hibernate</h2><p>Hibernate 是强大、方便、全自动的 ORM 框架，开发者只需要定义好数据库的表字段和 Java POJO 的映射关系和规则即可，Hibernate 会开放出接口自动处理数据库表的 CURD，并按照规定好的规则映射到 POJO 中，这个过程中操作者完全不需要感知 SQL 逻辑，此外，Hibernate 的缓存系统会在出现脏数据时及时报错。Hibernate 适用于性能要求不太严苛的系统。</p>
<h2 id="5-3-MyBatis"><a href="#5-3-MyBatis" class="headerlink" title="5.3 MyBatis"></a>5.3 MyBatis</h2><p><a href="https://mybatis.org/mybatis-3/zh/index.html">MyBatis</a> 是一个小巧、简单、半自动化的 ORM 框架，可以使用简单的 XML 或注解来配置和映射原生信息，将接口和 Java 的 POJO 映射成数据库中的记录，免除了几乎所有的 JDBC 代码以及设置参数和获取结果集的工作（MyBatis3 提供的注解可以取代 XML），开发灵活性好，但开发者依旧需要自己编写 SQL 逻辑，这也意味可以定制动态 SQL，这是 Hibernate 所不具备的。MyBatis 适用于性能要求高、响应快、灵活的系统。</p>
<h3 id="5-3-1-动态参数"><a href="#5-3-1-动态参数" class="headerlink" title="5.3.1 动态参数"></a>5.3.1 动态参数</h3><p>在 MyBatis 的 mapper 文件中，可以使用<code>#&#123;&#125;</code>和<code>$&#123;&#125;</code>来作为动态参数的替换，<code>#&#123;&#125;</code>和<code>$&#123;&#125;</code>在预编译处理中是不一样的</p>
<ul>
<li><p>MyBatis 将<code>#&#123;&#125;</code>方式传入的参数当做字符串，在预处理节点会使用<code>?</code>替换，可以有效的避免 SQL 注入，能使用<code>#&#123;&#125;</code>的地方应尽量使用<code>#&#123;&#125;</code></p>
</li>
<li><p>MyBatis 不会对<code>$&#123;&#125;</code>方式传入的参数进行特殊处理，会直接将参数的值替换到 SQL 中，而不会进行参数值的安全转义或预处理，在一些情况下（比如动态传入排序列名，排序方式）无法使用<code>#&#123;&#125;</code>，只能使用<code>$&#123;&#125;</code></p>
</li>
<li><p>使用<code>$&#123;&#125;</code>时要注意会出现潜在的 SQL 注入问题，需要在应用程序中对输入参数进行严格的验证，确保输入符合预期格式</p>
</li>
</ul>
<p>此外，MyBatis 还提供了很多标签来支持动态 SQL 的生成，可以避免在编写 SQL 时出现重复的代码，提供代码的复用性和灵活性。</p>
<h3 id="5-3-2-缓存机制"><a href="#5-3-2-缓存机制" class="headerlink" title="5.3.2 缓存机制"></a>5.3.2 缓存机制</h3><p>SqlSession 是 MyBatis 对 SQL 执行的封装，真正的 SQL 处理逻辑要通过<code>Executor</code>来执行，MyBatis 在执行 SQL 查询时默认使用的<code>Executor</code>实现类是<code>CachingExecutor</code>类（这就是二级缓存）来检查缓存是否存在，如果没有命中缓存则会进入<code>BaseExecutor</code>（一级缓存）中继续执行，如果一级缓存没有命中的话，则通过数据源获取数据库连接，并调用 JDBC 执行真正的 SQL 逻辑，当获取到查询结果之后，就需要通过字段映射将每一行结果都分别封装为一个 Java 对象。</p>
<ul>
<li><p>一级缓存</p>
<ul>
<li><p>在同一个 session 中，MyBatis 会将执行过的 SQL 语句的结果缓存到内存中，下次再执行相同的 SQL 语句时，会先查看缓存中是否存在该结果，如果存在则直接返回缓存中的结果，不再执行 SQL 语句，这种一级缓存是默认开启的</p>
</li>
<li><p>一级缓存只是没有容量限定的<code>HashMap</code>，一级缓存最大范围是 SqlSession，有多个 SqlSession 或分布式环境下，范围为 SqlSession 的一级缓存会出现脏数据，建议设定缓存级别为 Statement</p>
</li>
</ul>
</li>
<li><p>二级缓存</p>
<ul>
<li><p>二级缓存是基于命名空间的缓存，可以在多个 SqlSession 之间共享缓存，但是可能会出现缓存数据更新不及时进而导致数据一致性问题</p>
</li>
<li><p>一般不使用 MyBatis 的二级缓存，而是直接使用第三方的缓存，实现更加精细灵活的缓存策略</p>
</li>
</ul>
</li>
</ul>
<h3 id="5-3-3-字段映射"><a href="#5-3-3-字段映射" class="headerlink" title="5.3.3 字段映射"></a>5.3.3 字段映射</h3><p>MyBatis 实现字段映射的代码主要在<code>ResultSetHandler</code>类中，该类是 MyBatis 查询结果集处理的核心类，负责将 JDBC ResultSet 对象转换成 Java 对象，并进行字段映射，步骤如下</p>
<ul>
<li><p>MyBatis 通过 JDBC API 向数据库发送 SQL 查询语句，并获得查询结果集</p>
</li>
<li><p>查询结果集中的每一行数据都被封装成一个 ResultSet 对象，MyBatis 遍历 ResultSet 对象中的数据</p>
</li>
<li><p>对于每一行数据，MyBatis 根据 Java 对象属性名和查询结果集中的列名进行匹配，将匹配成功的列数据映射到 Java 对象相应属性中</p>
</li>
<li><p>如果 Java 属性名和查询结果集中的列名不完全一致，MyBatis 可以通过 SQL 中通过 AS 来定义别名，或者使用 ResultMap 来定义 Java 对象属性和列的映射关系，对于一些复杂的映射关系，例如日期格式的转换、枚举类型的转换等，还可以通过自定义<code>TypeHandler</code>来实现</p>
</li>
<li><p>最终 MyBatis 将所有映射成功的 Java 对象封装成一个<code>List</code>返回</p>
</li>
</ul>
<h3 id="5-3-4-插件"><a href="#5-3-4-插件" class="headerlink" title="5.3.4 插件"></a>5.3.4 插件</h3><p>MyBatis 插件主要涉及三个关键接口</p>
<ul>
<li><p><code>Interceptor</code>，拦截器接口，定义了 MyBatis 插件的基本功能，包括插件的初始化、插件的拦截方法以及插件的销毁方法</p>
</li>
<li><p><code>Invocation</code>，调用接口，表示 MyBatis 在执行 SQL 语句时的状态，包括 SQL 语句、参数、返回值等信息</p>
</li>
<li><p><code>Plugin</code>，插件接口，MyBatis 在执行 SQL 语句时，会将所有注册的插件封装成<code>Plugin</code>对象，通过<code>Plugin</code>对象实现对 SQL 语句的拦截和修改</p>
</li>
</ul>
<p>插件的运行流程如下</p>
<ul>
<li><p>当 MyBatis 运行时，会将所有实现了<code>Interceptor</code>接口的插件进行初始化</p>
</li>
<li><p>将所有插件和原始的<code>Executor</code>对象封装成一个<code>InvocationChain</code>对象（责任链模式）</p>
</li>
<li><p>每次执行 SQL 语句时，MyBatis 都会通过<code>InvocationChain</code>对象依次调用所有插件的<code>intercept</code>方法，实现对 SQL 语句的拦截和修改，从而实现查询缓存、分页、分库分表等各种功能</p>
</li>
</ul>
<p>常见的 MyBatis 插件如用于分页的 PageHelper</p>
<h3 id="5-3-5-MyBatis-Plus"><a href="#5-3-5-MyBatis-Plus" class="headerlink" title="5.3.5 MyBatis-Plus"></a>5.3.5 MyBatis-Plus</h3><p>MyBatis-Plus 是增强版的 MyBatis</p>
<ul>
<li><p>提供了通用 Mapper 接口来快速进行增删改查，无需手写 SQL 语句</p>
</li>
<li><p>提供了一种简单易用高性能的物理分页插件，可以根据传入的分页参数自动计算出分页信息，无需手动编写分页 SQL 语句</p>
</li>
<li><p>可以根据数据库表自动生成实体类、Mapper 接口、Mapper XML 映射文件等代码，但某些情况下可能不够可靠，需要手动进行调整</p>
</li>
<li><p>可以使用 Lambda 表达式来构造查询条件和更新操作，代码更加简洁易读</p>
</li>
<li><p>提供了自定义的 SQL 注入功能，可以自由扩展 MyBatis 的 SQL 语句，实现更加灵活的 SQL 操作</p>
</li>
</ul>
<h3 id="5-3-6-分页机制"><a href="#5-3-6-分页机制" class="headerlink" title="5.3.6 分页机制"></a>5.3.6 分页机制</h3><p>MyBatis 提供基本物理的分页和基于逻辑的分页，物理分页指的是在最终执行的 SQL 中进行分页，可以通过 PageHelper 和 MyBatis-Plus 来实现；逻辑分页指的是在 SQL 中照常查全部结果不分页，在结果集中再进行分页，可以使用 RowBounds 来实现。</p>
<p>PageHelper 会将设置的分页参数存储到<code>ThreadLocal</code>中，在执行器执行 SQL 之前，从<code>ThreadLocal</code>中获取分页参数信息，然后修改 SQL 语句，限定查询的数据范围，实现物理分页的效果，并且在查询结束后再清除<code>ThreadLocal</code>中的分页参数。</p>
<p>RowBounds 是一个用于分页查询的 POJO 类，包含<code>offset</code>和<code>limit</code>这两个属性，使用 RowBounds 时无需在 SQL 语句中指定分页参数，在实际查询时会先将所有符合条件的记录返回，然后再在内存中进行分页，即抛弃掉不需要的数据再返回。</p>
<p>当数据量较小时，直接使用逻辑分页更简单，但当数据量比较大时，一定要使用物理分页，避免慢查询以及内存撑爆。</p>
<h2 id="5-4-JPA"><a href="#5-4-JPA" class="headerlink" title="5.4 JPA"></a>5.4 JPA</h2><p>Java 持久化 API（JPA，Java Persistence API）是一系列规范化接口，通过注解或 XML 描述 ORM，并将运行期的实体对象持久化到数据库中，让用户不通过任何配置即可完成数据库的操作。无论是哪种持久化存储方式，数据访问对象（Data Access Objects, DAO）都会提供对对象的增加、删除、修改、查询、排序以及分页等方法。</p>
<ul>
<li><p><code>@Entity</code></p>
<ul>
<li>用于声明数据库持久化实体类。</li>
</ul>
</li>
<li><p><code>@Table</code></p>
<ul>
<li><p>用于声明表名，一般与<code>@Entity</code>注解一起使用；</p>
</li>
<li><p>如果表名和实体类名相同，那么<code>＠Table</code>可以省略。</p>
</li>
</ul>
</li>
<li><p><code>@Id</code></p>
<ul>
<li>用于指定主键属性。</li>
</ul>
</li>
<li><p><code>@Transient</code></p>
<ul>
<li><p>表示该属性并非一个数据库表的字段的映射， ORM 框架将忽略该属性；</p>
</li>
<li><p>代表不持久的虚拟字段。</p>
</li>
</ul>
</li>
<li><p><code>@Column</code></p>
<ul>
<li>指定持久的字段属性，如果字段名与列名相同， 则可以省赂。</li>
</ul>
</li>
<li><p><code>@Basic</code></p>
<ul>
<li><p>指定实体属性的加载方式，实现关联数据的选择性加载；</p>
</li>
<li><p>有<code>LAZY</code>和<code>EAGER</code>两种，如<code>＠Basic(fetch=FetchType.LAZY)</code>；</p>
</li>
<li><p>懒加载是在属性被引用时才生成查询语句，抽取相关联数据；</p>
</li>
<li><p>实时加载则是执行完主查询后，不管是否被引用，都会马上执府后续的关联数据查询；</p>
</li>
<li><p>使用懒加载来调用关联数据，必须要保证主查询的Session （数据库连接会话）的生<br>命周期没有结束，否则是无法抽取到数据的。</p>
</li>
</ul>
</li>
<li><p><code>@Repository</code> ：用于标注和数据库操作有关的接口。</p>
</li>
<li><p><code>@Query</code>：用于指定接口方法的sql语句。</p>
</li>
<li><p><code>@Param</code>：用于指定方法参数名称。</p>
</li>
</ul>
<h2 id="5-5-JDBC"><a href="#5-5-JDBC" class="headerlink" title="5.5 JDBC"></a>5.5 JDBC</h2><p>JDBC（Java Data Base Connectivity）由一组用Java编写的类和接口组成</p>
<ul>
<li>是Java用于连接数据库的规范，为大部分关系型数据库提供访问接口，即用于执行数据库SQL语句的 Java API，是比较底层的高效的 API，在精通后适合用于性能调优</li>
<li>JDBC没有指定某种特定数据库，可以为多种数据库提供统一访问的接口，这也更符合程序设计的模式</li>
</ul>
<p>JDBC需要每次进行数据库连接，然后处理SQL语句、传值、关闭数据库。这些步骤繁琐易出错，为了减少这种可能的错误，减少开发人员的工作量，<code>JDBCTemplate</code>就被设计出来了。<code>JDBCTemplate</code>是对JDBC 的封装，更便于程序实现，替开发人员完成所有的JDBC 底层工作。此时，对于数据库的操作不再需要每次都进行连接、打开、关闭了。<code>JDBCtemplate</code>操作简单易学，但使用时依旧不够简洁。</p>
<h1 id="6、Event"><a href="#6、Event" class="headerlink" title="6、Event"></a>6、Event</h1><h2 id="6-1-问题与解决"><a href="#6-1-问题与解决" class="headerlink" title="6.1 问题与解决"></a>6.1 问题与解决</h2><p>Spring Event 是 Spring 中的一种事件机制，建立在观察者模式的基础上，允许不同组件之间通过事件的方式进行通信，允许应用程序中的组件注册监听器来监听特定类型的事件，并在事件发生时执行相应的操作，可以很好地实现代码解耦，令职责划分更加清晰，尤其是一对多、多对多的复杂的事件驱动场景。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AaaService</span> &#123;</span><br><span class="line">  <span class="meta">@Autowired</span></span><br><span class="line">  <span class="keyword">private</span> ApplicationContext applicationContext;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">public</span> AaaResponse <span class="title function_">fun</span><span class="params">(AaaInfo aaaInfo)</span> &#123;</span><br><span class="line">    <span class="comment">// 业务逻辑</span></span><br><span class="line">    ...</span><br><span class="line">    <span class="comment">// 定义一个事件</span></span><br><span class="line">    <span class="type">ApplicationEvent</span> <span class="variable">aaaEvent</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AaaEvent</span>(aaaInfo);</span><br><span class="line">    <span class="comment">// 广播该事件</span></span><br><span class="line">    applicationContext.pulishEvent(aaaEvent);</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AaaEvent</span> <span class="keyword">extends</span> <span class="title class_">ApplicationEvent</span> &#123;</span><br><span class="line">  <span class="keyword">public</span> <span class="title function_">AaaEvent</span><span class="params">(AaaInfo aaaInfo)</span> &#123;</span><br><span class="line">    <span class="built_in">super</span>(aaaInfo);</span><br><span class="line">    ...</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Componet</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AaaEventListener</span> &#123;</span><br><span class="line">  <span class="meta">@EventListener(AaaEvent.class)</span></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onApplicationEvent</span><span class="params">(AaaEvent event)</span> &#123;</span><br><span class="line">    <span class="type">AaaInfo</span> <span class="variable">aaaInfo</span> <span class="operator">=</span> (AaaInfo) event.getSource();</span><br><span class="line">    <span class="comment">// 事件所驱动的业务逻辑</span></span><br><span class="line">    ...</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="6-2-使用注意"><a href="#6-2-使用注意" class="headerlink" title="6.2 使用注意"></a>6.2 使用注意</h2><ul>
<li><p>如果需要在事务中发送和处理事件，则需要给<code>AaaService.fun()</code>加上<code>@Transactional</code>注解，并将<code>@EventListener</code>改成<code>TransactionalEventListener</code>，<code>TransactionalEventListener</code>的<code>phase</code>属性用于指定 事件监听器的触发时机</p>
<ul>
<li>BEFORE_COMMIT，在事务提交前触发，如果监听器抛出异常将导致事务回滚，常用于在事务即将提交前执行某些额外的逻辑</li>
<li>AFTER_COMMIT，在事务成功提交后触发，这意味着它不会影响事务回滚，是默认的触发时机，常用于日志记录等不应影响事务回滚的操作</li>
<li>AFTER_ROLLBACK，在事务回滚后触发，常用于清理或记录与事务回滚相关的操作</li>
<li>AFTER_COMPLETION，在事务完成（不论是提交还是回滚）后触发，常用于执行一些与事务状态无关的清理工作</li>
</ul>
</li>
<li><p>默认情况下，Spring Event 的调用是同步的，可以通过<code>@Async</code>注解标注监听器来实现异步调用，<code>@Async</code>默认会使用<code>SimpleAsyncTaskExecutor</code>线程池，<code>SimpleAsyncTaskExecutor</code>并不是真正的线程池，不会重用线程，每次调用都会创建一个新的线程，也没有最大线程数设置，因此应该为<code>@Async</code>自定义一个线程池</p>
</li>
<li><p><code>ApplicationReadyEvent</code>事件表示应用程序已经准备好接受请求，即应用上下文已启动且上下文已刷新，监听<code>ApplicationReadyEvent.class</code>可以监听应用启动事件，从而做一些类似缓存预热之类的应用初始化，此外<code>CommandLineRunner</code>、<code>ApplicationRunner</code>、<code>InitializingBean</code>以及<code>@PostConstruct</code>也可以实现相同的功能</p>
</li>
</ul>
<h1 id="7、参考资料"><a href="#7、参考资料" class="headerlink" title="7、参考资料"></a>7、参考资料</h1><ul>
<li>《Spring In Action，Third Edition》</li>
<li><a href="https://docs.spring.io/spring-framework/docs/5.3.21/reference/html/">https://docs.spring.io/spring-framework/docs/5.3.21/reference/html/</a></li>
<li><a href="https://www.liaoxuefeng.com/wiki/1252599548343744/1266263217140032">https://www.liaoxuefeng.com/wiki/1252599548343744/1266263217140032</a></li>
<li><a href="https://snailclimb.gitee.io/javaguide/#/?id=springspringboot-%e5%bf%85%e7%9c%8b-1">https://snailclimb.gitee.io/javaguide/#/?id=springspringboot-%e5%bf%85%e7%9c%8b-1</a></li>
<li><a href="https://www.cnblogs.com/zrtqsk/p/3735273.html">https://www.cnblogs.com/zrtqsk/p/3735273.html</a></li>
</ul>
]]></content>
  </entry>
  <entry>
    <title>Linux &amp; Shell Scripting</title>
    <url>/2023/10/14/shell-script/</url>
    <content><![CDATA[<h1 id="1、概述"><a href="#1、概述" class="headerlink" title="1、概述"></a>1、概述</h1><h2 id="1-1-Linux-概述"><a href="#1-1-Linux-概述" class="headerlink" title="1.1 Linux 概述"></a>1.1 Linux 概述</h2><p>Linux 操作系统分为四个部分</p>
<ul>
<li>内核<ul>
<li>控制计算机系统的所有硬件和软件，在必要时分配硬件，根据需要执行软件，管理系统内存、软件程序、硬件设备以及文件系统</li>
<li>较流行的选择是使用 systemd 作为初始化和进程管理系统，流行的原因在于 systemd 将事件与单元文件（定义了特定事件发生时要启动的程序）链接起来，从而根据不同的事件启动相应的进程</li>
<li>systemd 将单元文件按照 target 进行划分，target 定义了 Linux 系统的特定运行状态（比如<code>default.target</code>定义了系统启动的所有单元文件，<code>graphical.target</code>定义了多用户图形环境运行时要启动的单元文件），可以使用<code>systemctl</code>命令来启动、停止和列出系统中当前运行的单元文件</li>
<li>Linux 系统允许在无需重新编译内核的情况下将设备驱动程序插入运行中的内核，系统中安装的第一块硬盘为根驱动器，系统将硬件设备视为一种特殊文件，称为设备文件，并为每个设备文件创建一种称为“节点”的特殊文件，然后通过设备节点文件来与设备文件进行通信</li>
<li>设备文件分为三类：1）字符设备文件，对应每次只能处理一个字符的设备，比如调制解调器；2）块设备文件，对应每次以块形式处理数据的设备，比如硬件驱动器；3）网络设备文件，对应采用数据包发送和接收数据的设备</li>
<li>Linux 内核支持通过不同类型的文件系统读写硬盘数据，还能够读写其他操作系统的文件系统，但内核必须在编译时就加入所有要用到的文件系统的支持，并要求硬件驱动器必须采用 Linux 所支持的文件系统进行格式化</li>
<li>Linux 内核采用虚拟文件系统（VFS）作为和各种其他类型文件系统交互的接口，当文件系统被挂载和使用时，VFS 会在内存中缓存相关信息，从而将计算机中所有存储设备的文件路径都纳入在名为虚拟目录的单个目录结构</li>
<li>根驱动器包含了虚拟目录的核心，其他目录都是从这里开始构建的，Linux 虚拟目录结构只包含一个称为 root 目录的基础目录（不同于 Windows 为每个物理磁盘分区分配一个盘符，每个分区都有自己的目录结构），Linux 文件的绝对路径总是以<code>/</code>作为起始，<code>/</code>就是指 root 目录</li>
<li>系统文件通常存储在根驱动器中，用户文件则存储在其他驱动器中，Linux 会使用根驱动器上一些特别的目录作为挂载点，并分配给额外存储设备的目录</li>
</ul>
</li>
<li>GNU 工具<ul>
<li>供 Linux 使用的核心 GNU 工具软件包由三部分构成：1）文件实用工具；2）文本实用工具；3）进程实用工具</li>
<li>GUN 核心工具集提供了 shell 这一特殊的交互式工具，从而为用户提供了启动程序、管理文件系统中的文件、管理运行在 Linux 系统中的进程的途径</li>
<li>Linux 系统中有很多种类的 shell，分别有不同的特性，有些适用于创建脚本，有些则适用于管理进程，默认的 shell 是 bash shell</li>
</ul>
</li>
<li>图形化桌面窗口<ul>
<li>Linux 有多种图形化桌面可供选择，图形化桌面包括图形化显示以及建立在图形化显示之上的桌面环境</li>
<li>图形化显示软件是直接和 PC 显卡以及显示器打交道的底层程序，控制着 Linux 应用程序如何在计算机上呈现窗口和图形</li>
<li>桌面环境运行用户在桌面的特定区域放置应用程序图标和文件图标，如今的桌面环境需要可观的系统资源才能正常运行</li>
</ul>
</li>
<li>应用软件</li>
</ul>
<p>完整的 Linux 系统包称为发行版，发行版通常分为完整的核心 Linux 发行版（内核、一个或多个图形化桌面环境以及预编译好的大部分可用的 Linux 应用程序）和基于核心发行版但仅包含特定部分的用于特定用途的 Linux 发行版。Linux 发行版采用 ISO 镜像文件形式发布，ISO 镜像是一个包含了完整的 DVD 镜像的文件，然后只需从 DVD 引导计算机即可安装 Linux。</p>
<h2 id="1-2-shell-概述"><a href="#1-2-shell-概述" class="headerlink" title="1.2 shell 概述"></a>1.2 shell 概述</h2><p>shell 是一种复杂的交互式程序，其核心是命令行提示符，允许用户输入文本命令，然后解释命令并在内核中执行，或者将文本命令放入文件（称为 shell 脚本）中，构成一组命令在内核中执行（命令行最大字符数 255）。</p>
<p>用户输入的命令可以分为外部命令和内建命令，外部命令（也称文件系统命令，比如<code>ps</code>）并不属于 shell 程序，通常位于<code>/bin</code>、<code>usr/bin</code>、<code>/sbin</code>或<code>/usr/sbin</code>目录中，内建命令（比如<code>cd</code>、<code>exit</code>）则作为 shell 程序的组成部分存在，已经和 shell 编译成一体，无需借助外部程序文件来执行。</p>
<p>默认的系统 shell（<code>/usr/bin/sh</code>）是用于那些需要在系统启动时运行的系统 shell 脚本，而默认的交互式 shell（也称登录 shell）是在用户登录终端时启动的，为用户提供和系统间交互（对于 bash shell 脚本来说，默认的交互式 shell 和默认的系统 shell 这两种 shell 可能会导致问题）。</p>
<p>默认的交互式 shell 类型取决于<code>/etc/passwd</code>文件中用户账号的配置。大多数 Linux 系统中的<code>/etc/shells</code>文件中列出了各种已安装的 shell，这些 shell 中任意一个都可以被配置为用户的默认交互式 shell，通常被配置为是<code>/usr/bin/bash</code>，即 GUN bash shell（后续默认以 bash shell 为例介绍命令行和脚本）。</p>
<p>shell 提供命令行界面（CLI）来与 Unix 系统交互，在图形化桌面出现之前，CLI 是和 Unix 系统交互的唯一方式。</p>
<p>Linux 虚拟控制台就是一个简单的 shell CLI，是跟 Linux 系统交互的直接接口，也是唯一可以向 Linux 系统输入命令的地方。Linux 系统启动时会自动创建多个虚拟控制台，虚拟控制台是运行在 Linux 系统内存中的终端会话，在大多数 Linux 发行版中可以通过 Ctrl+Alt+功能键（F1~F7）来访问某个 Linux 虚拟控制台。Linux 虚拟控制台中是无法运行任何图形化程序的，因此输入密码时什么都不会显示，为了在访问 CLI 的同时也运行图形化程序，就需要使用终端仿真软件包，终端仿真软件包会在桌面图形化窗口中模拟控制台终端，这是在 GUI 中访问 shell CLI 的一种流行方式。</p>
<p>shell 程序启动后是否会自动出现 CLI 取决于用户所使用的登录方式，如果采用虚拟控制台终端登录，那么 CLI 提示符会自动出现；如果通过图形化桌面环境登录 Linux 系统，则需要启动图形化终端仿真器来访问 CLI。获得 CLI 提示符后，bash shell 会话会从用户主目录开始（在创建用户账户时系统为其分配的特有目录）。</p>
<h1 id="2、shell-命令"><a href="#2、shell-命令" class="headerlink" title="2、shell 命令"></a>2、shell 命令</h1><h2 id="2-1-环境变量"><a href="#2-1-环境变量" class="headerlink" title="2.1 环境变量"></a>2.1 环境变量</h2><p>环境变量允许在内存中存储数据，以便 shell 中运行的程序或脚本能够访问到这些数据，在 shell 命令行和 shell 脚本中，可通过 Linux 环境变量来查看系统信息，存储临时数据和配置信息。</p>
<p>bash shell 中有全局变量和局部变量这两种环境变量，局部环境变量只对创建它的 shell 可见，全局环境变量则对于 shell 会话和其所有生成的子 shell 都是可见的，在子 shell 中改变全局环境变量值或者删除全局环境变量并不会影响父 shell 中的该变量，即这种改变仅在子 shell 中有效。</p>
<h3 id="2-1-1-系统变量"><a href="#2-1-1-系统变量" class="headerlink" title="2.1.1 系统变量"></a>2.1.1 系统变量</h3><p>Linux 系统在启动 bash 会话时就设置好了一些默认的全局系统环境变量（基本上会使用全大写字母命名，以区别于使用小写字母命名的用户自定义的环境变量），一些应当记住的全局系统环境变量如下</p>
<table>
<thead>
<tr>
<th align="center"></th>
<th></th>
</tr>
</thead>
<tbody><tr>
<td align="center">环境变量</td>
<td>作用</td>
</tr>
<tr>
<td align="center"><code>$0</code></td>
<td>在 shell 命令行中为当前 shell 的名称，在 shell 脚本中为脚本的名称</td>
</tr>
<tr>
<td align="center"><code>$SHELL</code></td>
<td>bash shell 的完整路径名</td>
</tr>
<tr>
<td align="center"><code>$HOME</code></td>
<td>当前用户的主目录</td>
</tr>
<tr>
<td align="center"><code>$PWD</code></td>
<td>当前工作目录</td>
</tr>
<tr>
<td align="center"><code>$TMPDIR</code></td>
<td>保存 bash shell 创建的临时文件的目录名</td>
</tr>
<tr>
<td align="center"><code>$PATH</code></td>
<td>shell 查找命令时使用的目录列表（以冒号分割），当用户在 CLI 中输入一个外部命令时，shell 就会从这些目录中找到对应的外部命令程序，应当确保<code>PATH</code>包含所有存放应用程序的目录</td>
</tr>
<tr>
<td align="center"><code>$BASH_SUBSHELL</code></td>
<td>当前子 shell 环境的嵌套级别，初始值为 0 则表明当前没有子 shell，值为 1 则表明当前为子 shell，值为 2 则表明当前为子 shell 的子 shell…</td>
</tr>
<tr>
<td align="center"><code>$BASH_ENV</code></td>
<td>定义 bash 脚本运行前需要运行的启动文件</td>
</tr>
<tr>
<td align="center"><code>$IFS</code></td>
<td>定义了 bash shell 用作字段分隔符的一系列字符，默认会将空格、制表符以及换行符视为字段分隔符</td>
</tr>
<tr>
<td align="center"><code>$$</code></td>
<td>shell 会将其设为当前 PID</td>
</tr>
<tr>
<td align="center"><code>$?</code></td>
<td>最后执行的命令的退出状态码</td>
</tr>
</tbody></table>
<h3 id="2-1-2-基本操作"><a href="#2-1-2-基本操作" class="headerlink" title="2.1.2 基本操作"></a>2.1.2 基本操作</h3><ul>
<li><p>通过<code>printenv</code>或<code>env</code>命令可以查看全局变量</p>
</li>
<li><p>通过<code>printenv variable_name</code>或<code>echo $variable_name</code>即可查看特定环境变量<code>variable_name</code>的值（在变量名前加上<code>$</code>是为了引用变量或是让变量作为命令的参数）</p>
</li>
<li><p>通过<code>set</code>命令可以显示特定进程的所有环境变量，既包含局部变量、全局变量，也包含系统变量、用户自定义变量，还有局部 shell 函数</p>
</li>
<li><p>通过<code>variable_name=variable_value</code>语句即可创建用户自定义的局部变量<code>variable_name</code>，在变量名、等号以及变量值之间不能有空格，如果字符串<code>variable_value</code>中含有空格，则需要通过单引号或者双引号来界定该字符串的起止</p>
</li>
<li><p>通过<code>variable_name=(v1 v2 v3)</code>语句即可创建为环境变量<code>variable_name</code>设置多个值，<code>variable_name</code>可以作为数组使用，接着可以通过<code>$variable_name[index]</code>来访问索引<code>index</code>处的数组值，通过<code>$variable_name[*]</code>来访问整个数组</p>
</li>
<li><p>通过<code>export variable_name</code>即可将创建好的用户自定义的局部变量导出为全局变量，通过<code>export variable_name=variable_value</code>即可直接创建一个用户自定义的全局变量</p>
</li>
<li><p>通过<code>unset variable_name</code>命令即可删除已有的环境变量<code>variable_name</code></p>
</li>
</ul>
<h3 id="2-1-3-启动文件"><a href="#2-1-3-启动文件" class="headerlink" title="2.1.3 启动文件"></a>2.1.3 启动文件</h3><p>bash shell 在启动时会在启动文件（也称做环境文件）中查找命令及环境变量，因此可以通过配置启动文件中的内容，来实现环境变量的持久化定义，bash shell 进程所运行的启动文件取决于启动 bash shell 的方式</p>
<ul>
<li><p><strong>用户登录时作为默认交互式 shell 启动</strong>，此时启动文件分别是<code>/etc/profile</code>这一主启动文件以及<code>HOME</code>目录下的的<code>.bash_profile</code>、<code>.bashrc</code>、<code>.bash_login</code>以及<code>.profile</code>文件，用户可以对<code>HOME</code>目录下的这些启动文件进行编辑并添加自己的环境变量，其中的环境变量会在每次启动 bash shell 会话时生效</p>
</li>
<li><p><strong>生成子 shell 时作为交互式 shell 启动</strong>，此时启动文件是<code>HOME</code>目录下的<code>.bashrc</code>文件</p>
</li>
<li><p><strong>脚本运行时作为非交互式 shell 启动</strong>，此时启动文件由环境变量<code>BASH_ENV</code>定义，即 shell 启动一个非交互式 shell 进程时，会检查<code>BASH_ENV</code>以查看需要执行的启动文件名，并执行该启动文件中的命令，这通常包括 shell 脚本变量设置</p>
</li>
</ul>
<h2 id="2-2-文件管理"><a href="#2-2-文件管理" class="headerlink" title="2.2 文件管理"></a>2.2 文件管理</h2><h3 id="2-2-1-基本操作"><a href="#2-2-1-基本操作" class="headerlink" title="2.2.1 基本操作"></a>2.2.1 基本操作</h3><p>如果需要在系统中维护同一文件的多个副本，可以使用单个物理副本加多个虚拟副本（链接）的方法代替创建多个物理副本，链接是目录中指向文件真实位置的占位符，只能对事先已存在的原始文件创建链接，Linux 中有符号链接（也称软链接）和硬链接两种</p>
<ul>
<li>符号链接是一个真实存在的文件，该文件指向存放在虚拟目录结构中某个地方的另一个文件，因此这两个以符号方式链接在一起的文件彼此的 inode 号和文件内容并不相同，符号链接可以跨越不同的文件系统</li>
<li>硬链接是一个独立的虚拟文件，包含了原始文件的信息以及位置，但彼此其实就是同一个文件，即 inode 号和文件内容完全一致，硬链接不能跨文件系统，只能对处于同一存储设备的文件创建硬链接</li>
</ul>
<p>在 Linux 中，重命名文件也称为移动，此时 inode 号和时间戳都保持不变；删除文件也称为移除，shell 没有回收站或者垃圾箱，文件一旦被删除就是彻底删除；删除目录时只能先删除目录中的文件，再删除空目录，不能直接删除非空目录；显示文件内容时，在显示之前应该先了解文件类型，否则可能会出现各种乱码甚至将终端仿真器挂起。</p>
<p>Linux 包含多种文件压缩工具，gzip 是 Linux 中最流行的压缩工具，用于处理文件扩展名为<code>.gz</code>的压缩文件；Linux 中将输出写入文件以归档数据所得到的文件就是<code>.tar</code>归档文件（又称为 tarball），即便是目录也可以归档为单个<code>.tar</code>文件，因此可以很方便地在系统之间传递数据，这是在 Linux 中分发开源程序源代码文件所采用的普遍方法；经 gzip 压缩后的<code>.tar</code>文件就成为<code>.tgz</code>文件，这就是开源软件包的文件格式。</p>
<p>大多数 Linux 发行版能自动挂载特定类型的可移动存储设备（DVD、U 盘等），如果不支持，则需要以 root 用户身份登录或以 root 用户身份运行 sudo 来手动挂载，设备挂载到虚拟目录后，root 用户就拥有了对该设备的所有访问权限，而其他用户的访问则会被限制，移除可移动设备时，应该先确保没有进程在访问该设备，再卸载设备，最后将设备拔除。</p>
<p>一些应当记住的常用命令如下（写命令时可使用 Tab 键自动补全文件名或目录名，文件名或目录名也可以使用通配符来进行多选）</p>
<table>
<thead>
<tr>
<th></th>
<th></th>
<th></th>
<th></th>
</tr>
</thead>
<tbody><tr>
<td><code>ls -F</code></td>
<td>区分是目录还是文件，并用<code>*</code>标识可执行文件</td>
<td><code>ls -R</code></td>
<td>递归显示子目录中的内容</td>
</tr>
<tr>
<td><code>ls -a</code></td>
<td>显示隐藏文件</td>
<td><code>ls -l</code></td>
<td>以长列表格式显示关于每个文件的更多详细信息</td>
</tr>
<tr>
<td><code>ls keyword</code></td>
<td>以关键字作为过滤器显示符合的文件信息</td>
<td><code>ls -i</code></td>
<td>查看文件或目录的 inode 号</td>
</tr>
<tr>
<td><code>touch xxx</code></td>
<td>创建空文件<code>xxx</code>，若文件已存在则无影响</td>
<td><code>cp s d</code></td>
<td>复制<code>s</code>文件，并以<code>d</code>命名</td>
</tr>
<tr>
<td><code>cp s d/</code></td>
<td>复制<code>s</code>文件到<code>d</code>目录下，文件名不变</td>
<td><code>cp s .</code></td>
<td>复制<code>s</code>到当前工作目录下，文件名不变</td>
</tr>
<tr>
<td><code>cp -i s d</code></td>
<td>复制时强制询问是否覆盖已存在的<code>d</code>文件</td>
<td><code>cp -R s/ d/</code></td>
<td>创建目录<code>d</code>，并递归复制目录<code>s</code>中的内容到目录<code>d</code>中</td>
</tr>
<tr>
<td><code>ln -s s slink</code></td>
<td>为已存在的文件<code>s</code>创建符号链接<code>slink</code></td>
<td><code>ln s slink</code></td>
<td>为已存在的文件<code>s</code>创建硬链接<code>slink</code></td>
</tr>
<tr>
<td><code>mv a b</code></td>
<td>将文件<code>a</code>移动到/重命名为文件<code>b</code></td>
<td><code>mv -i a b</code></td>
<td>移动/重命名时强制询问是否覆盖已存在的<code>b</code>文件</td>
</tr>
<tr>
<td><code>rm xx</code></td>
<td>删除/移除文件<code>xx</code></td>
<td><code>rm -i xx</code></td>
<td>强制询问是否真的要删除/移除文件<code>xx</code></td>
</tr>
<tr>
<td><code>mkdir xxx</code></td>
<td>创建空目录<code>xxx</code></td>
<td><code>mkdir -p xxx/xx</code></td>
<td>“批量”创建目录<code>xxx</code>和子目录<code>xx</code></td>
</tr>
<tr>
<td><code>rmdir xxx</code></td>
<td>删除空目录<code>xxx</code></td>
<td><code>rm -r xxx</code></td>
<td>删除<code>xxx</code>目录中的所有的文件并删除目录本身</td>
</tr>
<tr>
<td><code>file xx</code></td>
<td>区分<code>xx</code>是目录还是文件，若为则探测文件的内部，判断文件类型，以及<code>xx</code>链接到哪个文件</td>
<td></td>
<td></td>
</tr>
<tr>
<td><code>cat xx</code></td>
<td>载入整个文件后显示文本文件<code>xx</code>中所有数据，如果是大文件内容则会一闪而过</td>
<td><code>tac xx</code></td>
<td>载入整个文件后倒序显示文本文件<code>xx</code>中所有数据，如果是大文件内容则会一闪而过</td>
</tr>
<tr>
<td><code>cat -n xx</code></td>
<td>显示时给所有行加上行号，包括空行</td>
<td><code>cat -b xx</code></td>
<td>给非空行加上行号显示</td>
</tr>
<tr>
<td><code>more xx</code></td>
<td>载入整个文件后分页显示文本文件<code>xx</code>中所有数据，并在每页暂停，可利用分页工具进行翻页</td>
<td><code>less xx</code></td>
<td>和<code>more</code>基本一样，但支持更多高级命令选项，比如可以在完成整个文件读取之前显示文件的内容</td>
</tr>
<tr>
<td><code>tail xx</code></td>
<td>显示文件<code>xx</code>最后几行的内容，默认是最后10行</td>
<td><code>tail -n 2 xx</code></td>
<td>显示文件<code>xx</code>最后两行的内容</td>
</tr>
<tr>
<td><code>tail -f xx</code></td>
<td>在其他进程修改文件<code>xx</code>时实时持续显示文件内容（就得到一个实时监测系统日志）</td>
<td><code>head xx</code></td>
<td>显示文件<code>xx</code>开头几行的内容，默认是前10行，也支持<code>-n</code>选项来指定显示行数</td>
</tr>
<tr>
<td><code>sort xx</code></td>
<td>将文件<code>xx</code>中的数据排序，默认以字符标准排序</td>
<td><code>grep pattern xx</code></td>
<td>显示文件<code>xx</code>中能够匹配 pattern 的行</td>
</tr>
<tr>
<td><code>gzip xx</code></td>
<td>压缩指定的文件<code>xx</code></td>
<td><code>tar -cvf xx.tar d1/ d2/</code></td>
<td>创建了一个名为<code>xx.tar</code>的归档文件，包含目录<code>d1</code>和<code>d2</code>的内容</td>
</tr>
<tr>
<td><code>tar -tf xx.tar</code></td>
<td>列出（但不提取）文件<code>xx.tar</code>中的内容</td>
<td><code>tar -xvf xx.tar</code></td>
<td>提取文件<code>xx.tar</code>中的内容（包括重建目录结构）</td>
</tr>
<tr>
<td><code>tar -zxvf xx.tgz</code></td>
<td>提取文件<code>xx.tgz</code>中的内容</td>
<td><code>mount -t xx d1 d2</code></td>
<td>将采用<code>xx</code>文件系统类型格式化的移动存储设备<code>d1</code>挂载到目录<code>d2</code>（<code>umount</code>卸载设备）</td>
</tr>
<tr>
<td><code>df</code></td>
<td>查看所有已挂载磁盘的使用情况，默认以磁盘块为单位，<code>-h</code>选项会以更加易读的形式显示磁盘空间</td>
<td><code>du</code></td>
<td>显示某个特定目录（默认当前目录）的磁盘使用情况，默认以磁盘块为单位，<code>-h</code>选项会以更加易读的形式显示磁盘空间</td>
</tr>
<tr>
<td><code>date +%y%m%d</code></td>
<td><code>+%y%m%d</code>格式会告诉<code>date</code>命令以这种格式显示当前日期</td>
<td><code>date -d &quot;$date1&quot; +%s</code></td>
<td><code>+%s</code>会将任意格式的日期变量<code>date1</code>以纪元时间（1970 年 1 月 1日午夜后的整数秒）显示</td>
</tr>
</tbody></table>
<h3 id="2-2-2-文件权限"><a href="#2-2-2-文件权限" class="headerlink" title="2.2.2 文件权限"></a>2.2.2 文件权限</h3><p>Linux 为每个访问系统的用户分配一个唯一的用户账户 UID，多个用户还可以组成一个具备唯一 GID 的组，并在<code>/etc/passwd</code>文件中记录了所有用户的用户登录名、用户密码（在这里被设置为<code>x</code>，真正的密码保存在<code>etc/shadow</code>文件中，只有 root 用户和特定程序才能访问）、用户账户的 UID 、用户账户的 GID、备注字段、<code>HOME</code>变量、默认交互式 shell，用户对系统重各种对象的访问权限就取决于用户登录所使用的 UID 以及 GID。</p>
<p>Linux 文件权限表示示意图如下</p>
<img src="文件权限.jpg" alt="文件权限" style="zoom:80%;" />

<table>
<thead>
<tr>
<th align="center"></th>
<th align="center"></th>
<th align="center"></th>
<th align="center"></th>
</tr>
</thead>
<tbody><tr>
<td align="center">权限</td>
<td align="center">二进制</td>
<td align="center">八进制</td>
<td align="center">描述</td>
</tr>
<tr>
<td align="center">—</td>
<td align="center">000</td>
<td align="center">0</td>
<td align="center">没有任何权限</td>
</tr>
<tr>
<td align="center">–x</td>
<td align="center">001</td>
<td align="center">1</td>
<td align="center">只有执行权限</td>
</tr>
<tr>
<td align="center">-w-</td>
<td align="center">010</td>
<td align="center">2</td>
<td align="center">只有写权限</td>
</tr>
<tr>
<td align="center">-wx</td>
<td align="center">011</td>
<td align="center">3</td>
<td align="center">有写入和执行权限</td>
</tr>
<tr>
<td align="center">r–</td>
<td align="center">100</td>
<td align="center">4</td>
<td align="center">只有读权限</td>
</tr>
<tr>
<td align="center">r-x</td>
<td align="center">101</td>
<td align="center">5</td>
<td align="center">有读取和执行权限</td>
</tr>
<tr>
<td align="center">rw-</td>
<td align="center">110</td>
<td align="center">6</td>
<td align="center">有读取和写入权限</td>
</tr>
<tr>
<td align="center">rwx</td>
<td align="center">111</td>
<td align="center">7</td>
<td align="center">有全部权限</td>
</tr>
</tbody></table>
<p>文件的全权限值是 666（属主、属组和其他用户都有读取和写入权限），目录的全权限值是 777（属主、属组和其他用户都有读取、写入和执行权限）。启动文件<code>/etc/profile</code>中会设置一个八进制<code>umask</code>值，用于屏蔽不想授予该安全级别的权限，比如<code>umask</code>被设为 022，那么接下来新建的文件和目录的默认全权限值就变为 644（666 减去 022）和 755（777 减去 022）。</p>
<ul>
<li><p>通过<code>chomd 760 xx</code>可以将文件/目录<code>xx</code>的权限修改为 760，<code>-R</code>选项可以递归地修改子目录和文件的权限</p>
</li>
<li><p>通过<code>chomd o+r xx</code>可以给文件/目录<code>xx</code>的其他用户加上读取权限，其中<code>o</code>代表其他用户（<code>u</code>代表用户，<code>g</code>代表组，<code>a</code>代表所有），<code>+</code>代表增加权限（<code>-</code>代表移除权限，<code>=</code>代表设置）</p>
</li>
<li><p>通过<code>chown new_user.new_group xx</code>可以将修改文件<code>xx</code>的属主修改为<code>new_user</code>，属组修改为<code>new_group</code>，<code>-R</code>选项可以递归地修改子目录和文件的所属关系，只有 root 用户能够修改属主，只有同时是原属组和新属组的成员的用户可以修改属组</p>
</li>
<li><p>通过<code>chgrp</code>可以修改文件/目录的默认属组</p>
</li>
</ul>
<h3 id="2-2-3-文件系统"><a href="#2-2-3-文件系统" class="headerlink" title="2.2.3 文件系统"></a>2.2.3 文件系统</h3><p>从一个或多个磁盘或磁盘分区创建的存储池提供了生成虚拟磁盘（又称卷）的能力，分区的范围可以是整个硬盘，也可以是部分硬盘以包含虚拟目录的一部分。对存储设备创建好分区后，需要使用某种文件系统来对分区进行格式化，以便 Linux 能够使用分区，接着将分区挂载到 Linux 虚拟目录中的某个挂载点，以便在新分区中存储数据。</p>
<p>直接在存储设备分区上创建文件系统的局限在于无法轻易改变文件系统的大小，但 Linux 支持逻辑卷管理，Linux 的逻辑卷管理器（LVM）可以在无须重建整个文件系统的情况下，将另一块硬盘上的分区加入已有的文件系统，动态的管理磁盘存储空间</p>
<ul>
<li><p>物理卷（PV），指一个未使用的磁盘分区（或整个磁盘驱动器）</p>
</li>
<li><p>卷组（VG），由多个 PV 组成的存储池，每个 PV 只能属于单个 VG</p>
</li>
<li><p>逻辑卷（LV），由单个 VG 的存储空间块组成（LV 不能跨 VG，但多个 LV 可以共享单个 VG），可以使用文件系统来格式化 LV，然后将其挂载，就像普通的磁盘分区那样使用，不同之处在于 LV 的容量可以动态调整，这赋予数据存储管理极大的灵活性</p>
</li>
</ul>
<h3 id="2-2-4-数据重定向"><a href="#2-2-4-数据重定向" class="headerlink" title="2.2.4 数据重定向"></a>2.2.4 数据重定向</h3><p>输出重定向<code>command &gt; outputfile</code>会创建文件<code>outputfile</code>（使用默认的 umask 设置），并将<code>command</code>命令的输出重定向/保存至该文件而不只是在屏幕中显示如果输出文件已经存在，则会用新数据覆盖已有的文件数据，<code>&gt;&gt;</code>则是将输出追加到已有文件中而不覆盖，<code>&amp;&gt;</code>用于将输出重定向至<code>/dev/null</code>（有去无回的黑洞），从而令命令输出变得简洁，也可以通过<code>cat /dev/null &gt; outputfile</code>来快速清除文件<code>outputfile</code>中的现有数据，无须先删除文件再重新创建。</p>
<p>输入重定向<code>command &lt; inputfile</code>会将文件<code>inputfile</code>中的内容重定向至命令<code>command</code>（比如<code>wc &lt; file</code>会统计文件<code>file</code>中的文本，默认会统计输出文本的行数、单词数以及字节数），<code>command &lt;&lt; text</code>是一种内联输入重定向的方式，会将接下来通过命令行次提示所输入的数据重定向到<code>command</code>命令，这个过程中，次提示符会持续显示以获取用户输入，直到输入了作为文本标记的<code>text</code>字符串，<code>text</code>一般设为 EOF，bash shell 提供了 Ctrl+D 组合键来生成 EOF 字符，从而终止输入过程。</p>
<p>管道连接<code>command1 | command2</code>可以直接将命令<code>command1</code>的输出作为命令<code>command2</code>的输入，数据传输不会用到任何中间文件或缓冲区，管道可以串联的命令数量没有限制，可以持续地将命令输出通过管道传给其他命令。</p>
<p>Linux 系统使用特殊目录<code>/tmp</code>来存放那些不需要永久保留的临时文件，系统中的任何用户都有权限读写<code>/tmp</code>目录中的文件，大多数 Linux 系统在启动时会自动删除<code>/tmp</code>目录中的所有文件。命令<code>mktemp</code>会在本地目录中创建唯一的临时文件，命令的返回值就是该临时文件名（所创建的临时文件不使用默认的<code>umask</code>值），<code>-t</code>选项会强制在<code>/tmp</code>目录中创建临时文件，此时命令会返回临时文件的完整路径名；<code>-d</code>选项会创建一个临时目录。</p>
<h3 id="2-2-5-文件描述符"><a href="#2-2-5-文件描述符" class="headerlink" title="2.2.5 文件描述符"></a>2.2.5 文件描述符</h3><p>Linux 会将每个对象（包括输入和输出）当做文件来处理，并用文件描述符（非负整数）来标识会话中打开的文件对象，bash shell 保留了前 3 个特殊的文件描述符用来处理脚本的输入和输出。</p>
<ul>
<li><p>标准输入</p>
<ul>
<li><p>文件描述符为 0，缩写为<code>STDIN</code></p>
</li>
<li><p>对于终端界面来说，标准输入指向键盘，shell 会从<code>STDIN</code>对应的键盘获得输入并进行处理</p>
</li>
<li><p>当使用输入重定向符<code>&lt;</code>时，标准输入改为指向指定的文件，shell 就会从文件中获得输入数据</p>
</li>
<li><p><code>exec 0&lt; file</code>允许在脚本中指定脚本所使用的<code>STDIN</code>指向文件<code>file</code></p>
</li>
</ul>
</li>
<li><p>标准输出</p>
<ul>
<li><p>文件描述符为 1，缩写为<code>STDOUT</code></p>
</li>
<li><p>对于终端界面来说，标准输出指向终端显示器，shell 的会将运行的程序的输出送往显示器</p>
</li>
<li><p>当使用输出重定向符<code>&gt;</code>时，标准输出改为指向指定的文件，shell 会将输出重定向到文件</p>
</li>
<li><p><code>exec 1&gt; file</code>允许在脚本中指定脚本所使用的<code>STDOUT</code>指向文件<code>file</code></p>
</li>
</ul>
</li>
<li><p>标准错误</p>
<ul>
<li><p>文件描述符为 2，缩写为<code>STDERR</code>，shell 对于错误消息的处理跟普通输出是分开的</p>
</li>
<li><p>默认情况下，<code>STDOUT</code>和<code>STDERR</code>都指向终端显示器，当使用输出重定向符<code>&gt;</code>或<code>1&gt;</code>时，<code>STDERR</code>并不会改变，当使用<code>2&gt;</code>时，标准错误才会改为指定的错误日志文件</p>
</li>
<li><p>可以使用特殊的重定向符<code>&amp;&lt;</code>来同时将<code>STDOUT</code>和<code>STDERR</code>指向同一个文件，此时 bash shell 自动赋予<code>STDERR</code>更高的优先级，因此错误消息会比正常输出消息在文件中显示的更靠前</p>
</li>
<li><p><code>exec 2&gt; file</code>允许在脚本中指定脚本所使用的<code>STDERR</code>指向文件<code>file</code></p>
</li>
</ul>
</li>
</ul>
<p>文件描述符 3~8（后面的文件描述符可能会与 shell 内部使用的文件描述符发生冲突，故不推荐用户使用）一方面可以临时存储 0~2 的值（<code>exec 3&gt;&amp;1</code>），从而在修改 0~2 之后恢复其原始值（<code>exec 1&gt;&amp;3</code>）；另一个方面可以作为替代性文件描述符分配给文件，从而用在脚本中的输入或输出重定向。这些替代性文件描述符一旦分配后就会一直有效，直至重新分配或关闭（<code>exec 3&gt;&amp;-</code>），一旦关闭了文件描述符，就不能在脚本中向其输入或输出，否则 shell 会报错。</p>
<p><code>lsof</code>命令会列出整个 Linux 系统打开的所有文件描述符，这包括所有后台进程以及登录用户打开的文件，<code>-p</code>选项允许指定 PID，<code>-d</code>选项允许指定要显示的文件描述符编号（多个编号之间以逗号分隔），<code>-a</code>选项允许对<code>-p</code>和<code>-d</code>选项的结果执行<code>AND</code>运算。</p>
<p><code>tee</code>命令就像是连接管道的 T 型接头，能将来自<code>STDIN</code>的数据同时送往<code>STDOUT</code>和指定的文件，默认情况下会将覆盖指定文件中的原本数据，<code>-a</code>选项允许将新数据追加到指定文件中。</p>
<h2 id="2-3-进程管理"><a href="#2-3-进程管理" class="headerlink" title="2.3 进程管理"></a>2.3 进程管理</h2><h3 id="2-3-1-基本操作"><a href="#2-3-1-基本操作" class="headerlink" title="2.3.1 基本操作"></a>2.3.1 基本操作</h3><p><code>ps</code>命令用于检测某个特定时间点的进程信息，不带选项的<code>ps</code>命令默认只显示运行在当前终端中属于当前用户的那些进程信息，其中 S 指进程的状态，PID 指进程 ID，UID 指启动该进程的用户 ID，PPID 指父进程的 PID，NI 指进程调度优先级，C 指进程生命周期中的 CPU 利用率，STIME 指进程启动时的系统时间，TTY 指进程是从哪个终端设备启动，TIME 指运行进程的累计 CPU 时间，CMD 指启动的程序名称。</p>
<p><code>jobs</code>命令用于显示后台作业信息，即当前运行在后台模式中属于用户的所有进程信息，包括作业号、作业当前状态、对应的命令/作业内容这些默认信息，且最近启动的作业会标识出来，加上<code>-l</code>选项还可以显示作业的 PID。</p>
<p><code>top</code>命令用于实时显示进程信息，包括当前时间、系统的运行时长、登录的用户数、系统的平均负载（值越大则系统的负载越高）、进程概况（处于运行、休眠、停止以及僵化状态的进程数）、CPU 概况、内存概况（物理内存使用情况，交换空间状态）、以及当前处于运行状态的进程的详细列表，很适用于观察那些被频繁换入和换出内存的进程，帮助找出占用系统大量资源的进程。</p>
<p><code>kill</code>命令和<code>pkill</code>命令用于向进程发出进程信号（在 Linux 中进程通过信号来通信，进程的信号是预定义好的一个消息，进程能识别该消息并决定忽略还是做出反应），并通过<code>-s</code>选项支持指定信号类型（用信号名或信号值），<code>kill</code>命令通过 PID 向进程发送信号，默认情况下发送 <code>TERM</code>信号，<code>pkill</code>命令可以使用程序名代替 PID 来终止。</p>
<p><code>TERM</code>信号是通知应用进程要安全、干净地退出，但这个退出过程中可能遇到一些问题无法成功退出，那么进程可以选择忽略该信号。</p>
<table>
<thead>
<tr>
<th align="center"></th>
<th align="center"></th>
<th align="center"></th>
</tr>
</thead>
<tbody><tr>
<td align="center">信号值</td>
<td align="center">信号名</td>
<td align="center">描述</td>
</tr>
<tr>
<td align="center">1</td>
<td align="center">HUP</td>
<td align="center">挂起</td>
</tr>
<tr>
<td align="center">2</td>
<td align="center">INT</td>
<td align="center">中断</td>
</tr>
<tr>
<td align="center">3</td>
<td align="center">QUIT</td>
<td align="center">结束运行</td>
</tr>
<tr>
<td align="center">9</td>
<td align="center">KILL</td>
<td align="center">无条件终止</td>
</tr>
<tr>
<td align="center">11</td>
<td align="center">SEGV</td>
<td align="center">段错误</td>
</tr>
<tr>
<td align="center">15</td>
<td align="center">TERM</td>
<td align="center">尽可能终止</td>
</tr>
<tr>
<td align="center">17</td>
<td align="center">STOP</td>
<td align="center">无条件停止运行，但不终止</td>
</tr>
<tr>
<td align="center">18</td>
<td align="center">TSTP</td>
<td align="center">停止或暂停，但继续在后台运行</td>
</tr>
<tr>
<td align="center">19</td>
<td align="center">CONT</td>
<td align="center">在 STOP 或 TSTP 之后恢复执行</td>
</tr>
</tbody></table>
<h3 id="2-3-2-父子-shell"><a href="#2-3-2-父子-shell" class="headerlink" title="2.3.2 父子 shell"></a>2.3.2 父子 shell</h3><p>用户登录后所启动的默认的交互式 shell 是一个父 shell，在父 shell 中可以通过<code>bash</code>命令（或其他任意一种已安装的 shell 名称）来创建新的子 shell，接着可以通过<code>exit</code>命令来退出子 shell 并注销当前的虚拟控制台终端或终端仿真器软件，从容退出子 shell CLI。这个过程中屏幕不会显示任何相关信息，可以在生成子 shell 前后通过<code>ps -f</code>来了解相关进程信息，父 shell 中导出的全局环境变量会被复制到子 shell。创建子 shell 的成本不菲，会明显拖慢任务进度，在 shell 命令行中，子 shell 的高效用法是后台模式；而在 shell 脚本中，子 shell 则经常用于多进程处理。</p>
<ul>
<li><p>CLI 在后台模式中运行命令（在输入命令后加一个<code>&amp;</code>）等同于创建一个子 shell 来执行该命令，此时父 shell 依旧可以继续以供他用，但终端和子 shell 与的 I/O 绑定在了一起，如果退出终端会话那么后台子 shell 也会随之退出，这并非真正的多进程处理</p>
</li>
<li><p>如果将进程列表以后台模式运行（<code>(command1 ; command2)&amp;</code>或者<code>coproc job_name &#123; command1; command2 &#125;</code>）则可以在子 shell 中进行大量的多进程处理，此时终端不再和子 shell 的 I/O 绑定在一起</p>
</li>
<li><p>此外，每当执行外部命令时，就会创建一个拥有全新环境的子进程，这种操作称为衍生（forking），需要耗费时间和资源来设置新子进程的环境，因此外部命令的系统开销较高；而使用内建命令时，不需要衍生子进程，因此内建命令的系统开销较低，速度更快，效率更高</p>
</li>
</ul>
<p>在 Linux 系统中，由 shell 启动的所有进程的调度优先级默认都是相同的，调度优先级是一个整数值，取值范围从 -20（最高优先级）到 +19（最低优先级），bash shell 以优先级 0 来启动所有进程。</p>
<ul>
<li><p><code>nice</code>命令允许在启动命令时设置其调度优先级，<code>-n</code>选项用于指定新的优先级，普通用户可以降低优先级，但只有 root 用户或特权用户才能提高优先级</p>
</li>
<li><p><code>renice</code>命令允许对已运行的命令重置其调度优先级，普通用户只能对属主为自己的进程使用<code>renice</code>且只能降低优先级，root 用户和特权用户可以使用<code>renice</code>对任意进程的优先级做任意调整</p>
</li>
</ul>
<h3 id="2-3-3-信号控制"><a href="#2-3-3-信号控制" class="headerlink" title="2.3.3 信号控制"></a>2.3.3 信号控制</h3><p>bash shell 会话会处理收到的所有挂起信号（信号值为 1）和中断信号（信号值为 2）。</p>
<ul>
<li><p>收到挂起信号时，bash shell 会退出，并在退出之前将挂起信号传给所有由该 shell 启动的进程，包括正在运行的 shell 脚本，如果 shell 会话中有已停止的进程作业，那么在退出 shell 时，bash 会发出提醒（但如果是以后台模式运行的进程，则不一定会有此提醒）</p>
</li>
<li><p>收到中断信号时（Ctrl+C 组合键会生成中断信号），bash shell 会被中断，Linux 不再为 shell 分配 CPU 时间片，shell 会将中断信号传给所有由该 shell 启动的进程</p>
</li>
<li><p>收到停止信号时（Ctrl+Z 组合键会生成停止信号），bash shell 会通知进程已经被停止了，但会让程序继续驻留在内存中（作业还能从上次停止的位置继续运行）</p>
</li>
<li><p><code>bg</code>命令会以后台模式重启被停止的作业，<code>fg</code>命令会以前台模式重启被停止的作业</p>
</li>
</ul>
<p>shell 脚本的默认行为是忽略这些信号，完全由 bash shell 会话进行处理，但是可以在 shell 脚本中加入识别信号及处理的代码，当指定信号出现时，脚本会捕获该信号，此时无须 shell 会话处理该信号，而是由本地脚本自行处理（即执行指定命令）</p>
<ul>
<li><p>在脚本中通过<code>trap commands signals</code>命令可以在信号<code>signals</code>（多个信号之间以空格分隔）出现时将其捕获并执行指定的<code>commands</code>命令</p>
</li>
<li><p>针对已设置的信号捕获，可以继续用<code>trap -- signals</code>来移除已设置好的信号捕获</p>
</li>
<li><p>在交互式 shell 会话中使用<code>trap -p</code>可以查看被捕获的信号，如果无显示，则说明没有捕获信号，shell 会话会按照默认方式处理信号，shell 脚本会按照默认行为忽略信号</p>
</li>
</ul>
<p>通过<code>./xxx.sh &amp;</code>命令以后台模式运行的<code>xxx.sh</code>子 shell 不和终端父 shell 会话的<code>STDIN</code>、<code>STDOUT</code>以及<code>STDERR</code>关联，但子 shell 的输出仍然会使用终端显示器来显示<code>STDOUT</code>和<code>STDERR</code>消息（最好是将后台脚本的<code>STDOUT</code>和<code>STDERR</code>进行重定向），如果终端收到挂起信号退出那么后台子 shell 也会随之退出</p>
<ul>
<li><p><code>nohup ./xxx.sh &amp;</code>命令能够阻断发给特定进程（以后台模式运行的<code>xxx.sh</code>脚本）的挂起信号，那么当退出终端 shell 时，该特定进程并不会收到挂起信号，不会退出</p>
</li>
<li><p>由于<code>nohup</code>会解除终端父 shell 和子 shell 进程之间的关联，子 shell 的输出不再使用终端显示器来显示<code>STDOUT</code>和<code>STDERR</code>消息，而是将<code>STDOUT</code>和<code>STDERR</code>重定向到一个名为<code>nohup.out</code>的文件（位于当前目录或者<code>HOME</code>目录）中</p>
</li>
</ul>
<h3 id="2-3-4-定时调度"><a href="#2-3-4-定时调度" class="headerlink" title="2.3.4 定时调度"></a>2.3.4 定时调度</h3><p><code>at</code>命令会将作业提交到队列中，并指定 shell 何时运行该作业，<code>-f</code>选项可以指定使用哪个脚本文件，<code>-q</code>选项可以指定作业的优先级队列，<code>-M</code>选项可以禁止作业产生输出信息</p>
<ul>
<li><p>针对不同优先级，有 52 种作业队列（用<code>a~z</code>和<code>A~Z</code>来指代），默认情况下作业会被放入<code>a</code>队列</p>
</li>
<li><p>Linux 会将提交该作业的用户 email 地址作为<code>STDOUT</code>和<code>STDERR</code>，任何送往<code>STDOUT</code>和<code>STDERR</code>的输出都会通过邮件系统传给该用户，如果系统没有安装<code>sendmail</code>，那就无法获得任何输出，因此最好对<code>STDOUT</code>和<code>STDERR</code>进行重定向</p>
</li>
<li><p><code>at</code>的守护进程<code>atd</code>在后台运行，<code>atd</code>默认情况下每隔 60 秒会检查一次系统的特殊目录<code>/var/spool/at</code>或<code>/var/spool/cron/atjobs</code>，从中获取<code>at</code>命令提交的作业，查看作业的运行时间，如果时间和当前时间一致则运行此作业，如果时间已经过去则在第二天的同一时间运行此作业</p>
</li>
<li><p><code>atq</code>命令可以查看系统中有哪些作业在等待，<code>atrm</code>命令可以删除等待中的作业</p>
</li>
</ul>
<p>Linux 系统使用 cron 程序调度需要定期反复执行的作业（前提是 Linux 系统是不间断运行的），cron 在后台运行，会检查一个特殊的表（cron 时间表），从中获知已安排执行的作业，cron 不会运行已经过时的错过的作业。</p>
<p>anacron 程序同样用于调度需要定期反复执行的作业，但如果判断出某个作业错过了预设的运行时间，则会尽快运行该作业，那么即使 Linux 有过关闭重启，也能确保作业一定能运行。</p>
<h1 id="3、shell-脚本"><a href="#3、shell-脚本" class="headerlink" title="3、shell 脚本"></a>3、shell 脚本</h1><h2 id="3-1-基本操作"><a href="#3-1-基本操作" class="headerlink" title="3.1 基本操作"></a>3.1 基本操作</h2><h3 id="3-1-1-脚本构建"><a href="#3-1-1-脚本构建" class="headerlink" title="3.1.1 脚本构建"></a>3.1.1 脚本构建</h3><p>在创建 shell 脚本时，必须在文件的第一行指定要使用的 shell 类型，比如<code>#!/bin/bash</code>指定要使用的 bash shell（除了<code>#!</code>开头的第一行以外，shell 不会解释以<code>#</code>开头的注释行），写在同一行的命令需要用分号隔开，写在独立行的命令可以不加分号，此外，由于 umash 变量设置可能会导致新文件的默认权限不包含执行权限，那么可以通过<code>chomd </code>命令进行授权，然后通过<code>./filename</code>来执行脚本。</p>
<ul>
<li><p>用户自定义变量的名称可以是任何由字母、数字或下划线组成的字符串，长度不能超过 20 个字符，区分大小写</p>
</li>
<li><p>使用等号为变量赋值，在变量、等号和值之间不能出现空格，或者在双括号<code>(( statement ))</code>中进行赋值（此时可以出现空格）</p>
</li>
<li><p>对变量赋值时不加<code>$</code>，引用变量时要加<code>$</code>，脚本中只要使用<code>$x</code>，就会被替换为变量<code>x</code>的值，如果需要显示<code>$x</code>文本，则应该使用<code>\$x</code></p>
</li>
<li><p>shell 脚本会以字符串的形式存储所有的变量值，脚本中定义的变量在脚本的整个生命周期里会一直保存，在脚本结束时会被删除</p>
</li>
<li><p>命令替换通过反引号 `` 或者 $() 来将命令输出赋给变量，这一过程会创建出一个独立的子 shell 来运行指定命令，在这个子 shell 中运行的命令无法使用脚本中的变量</p>
</li>
</ul>
<h3 id="3-1-2-数学运算"><a href="#3-1-2-数学运算" class="headerlink" title="3.1.2 数学运算"></a>3.1.2 数学运算</h3><p>bash shell 使用<code>expr operation</code>或<code>$[operation]</code>来进行整数数学运算（<code>$&#123;variable&#125;</code>用于引用名为<code>variable</code>的变量），通过内建的 bash 计算器 bc 来进行浮点数运算。在命令行中可以通过<code>bc</code>命令进入 bc 计算器（<code>bc -q</code>则不显示冗长的欢迎信息），通过内建变量<code>scale</code>来控制保留小数位数，通过<code>quit</code>命令退出。在 shell 脚本中，最好是使用命令替换配合内联输入重定向，将计算输出赋给一个变量。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">variable=$(bc &lt;&lt; <span class="string">EOF</span></span><br><span class="line"><span class="string">scale=4</span></span><br><span class="line"><span class="string">var1=1</span></span><br><span class="line"><span class="string">var2=2</span></span><br><span class="line"><span class="string">$var1 / $var2</span></span><br><span class="line"><span class="string">EOF</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure>

<h3 id="3-1-3-脚本退出"><a href="#3-1-3-脚本退出" class="headerlink" title="3.1.3 脚本退出"></a>3.1.3 脚本退出</h3><p>Linux 提供了专门的变量<code>?</code>来保存最后一个已执行命令的退出状态码，也可以通过将<code>exit num</code>作为脚本结束命令从而将退出状态码设置为<code>num</code>（介于 0~255）。</p>
<table>
<thead>
<tr>
<th align="center"></th>
<th align="center"></th>
<th align="center"></th>
<th align="center"></th>
</tr>
</thead>
<tbody><tr>
<td align="center">退出状态码</td>
<td align="center">描述</td>
<td align="center">退出状态码</td>
<td align="center">描述</td>
</tr>
<tr>
<td align="center">0</td>
<td align="center">命令成功结束</td>
<td align="center">128</td>
<td align="center">无效的退出参数</td>
</tr>
<tr>
<td align="center">1</td>
<td align="center">一般性未知错误</td>
<td align="center">128+x</td>
<td align="center">与 Linux 信号<code>x</code>相关的严重错误</td>
</tr>
<tr>
<td align="center">2</td>
<td align="center">不适合的 shell 命令</td>
<td align="center">130</td>
<td align="center">通过 Ctrl+C 终止的命令</td>
</tr>
<tr>
<td align="center">126</td>
<td align="center">用户没有权限，命令无法执行</td>
<td align="center">255</td>
<td align="center">正常范围之外的退出状态码</td>
</tr>
<tr>
<td align="center">127</td>
<td align="center">没找到命令</td>
<td align="center"></td>
<td align="center"></td>
</tr>
</tbody></table>
<h3 id="3-1-4-脚本函数"><a href="#3-1-4-脚本函数" class="headerlink" title="3.1.4 脚本函数"></a>3.1.4 脚本函数</h3><p>函数是一个脚本代码块，可以为其命名并在脚本中的任何位置调用它</p>
<ul>
<li><p>需要保证函数名是唯一的，在函数调用之前定义好函数，以及在调用函数时参数和函数名放在同一行</p>
</li>
<li><p>在函数内部，<code>$0</code>对应函数名，函数参数依次保存在<code>$1</code>、<code>$2</code>…等变量中，<code>$#</code>对应函数参数的个数</p>
</li>
<li><p>默认情况下，在脚本中定义的变量是全局变量，在脚本内任何地方（包括函数内部）都有效，函数内对全局变量的修改在函数外也是生效的（这个行为很危险），如果在函数中定义了全局变量，那么在函数外也可以访问</p>
</li>
<li><p>函数内部应当避免使用全局变量，在函数中定义的变量应当用<code>local</code>关键字声明，这样的变量是局部变量，即便在函数外有同名变量时 shell 也会保持变量间互不干扰，对脚本的其他部分而言，在函数中定义的局部变量是无效的</p>
</li>
<li><p>函数运行结束时会返回一个退出状态码（可以使用<code>$?</code>来查看），默认情况下为函数中最后一个命令返回的退出状态码，也可以在函数的最后通过<code>return</code>命令来返回一个指定的退出状态码</p>
</li>
<li><p>函数的最后通过<code>echo $variable</code>来返回变量值（区分<code>return</code>返回的是退出状态码）</p>
</li>
<li><p>bash shell 允许创建函数库文件，然后在多个脚本中通过点号操作符<code>. ./funcs</code>引用当前目录下的库文件<code>funcs</code>，shell 并不运行库文件，但会使这些函数在运行该脚本的 shell 中生效</p>
</li>
</ul>
<p>在 shell 命令行中也可以定义函数，接着就可以在整个系统的任意目录以及子 shell 中使用该函数，无须担心该函数是否位于<code>PATH</code>环境变量中，但应确保函数名不会和已有命令相同，否则新定义的函数会覆盖已有命令。一旦退出 shell，所定义的函数也会消失，因此，可以在<code>HOME</code>目录下的<code>.bashrc</code>启动文件中定义函数，那么每次启动交互式 shell 时都可以使用这些函数。</p>
<h2 id="3-2-条件判断"><a href="#3-2-条件判断" class="headerlink" title="3.2 条件判断"></a>3.2 条件判断</h2><p>bash shell 的<code>if</code>语句会运行<code>if</code>之后的命令，如果该命令的退出状态码为 0 则执行<code>then</code>之后的命令，非 0 则执行<code>else</code>或<code>elfi</code>之后的命令，<code>fi</code>标志<code>if-then</code>语句到此结束。</p>
<h3 id="3-2-1-单方括号"><a href="#3-2-1-单方括号" class="headerlink" title="3.2.1 单方括号"></a>3.2.1 单方括号</h3><p><code>if</code>语句无法进行状态码之外的条件测试，因此可以使用<code>test condition</code>或<code>[ condition ]</code>（以及<code>[ condition1 ] &amp;&amp; [ condition2 ]</code>、<code>[ condition1 ] || [ condition2 ]</code>）命令来测试某个条件，当条件满足时返回状态码 0，不满足时返回非 0。一些常用的简单<code>condition</code>如下所示</p>
<table>
<thead>
<tr>
<th align="center"></th>
<th align="center"></th>
<th align="center"></th>
<th align="center"></th>
</tr>
</thead>
<tbody><tr>
<td align="center"><strong>数值比较</strong></td>
<td align="center"></td>
<td align="center"></td>
<td align="center"></td>
</tr>
<tr>
<td align="center"><code>n1 -eq n2</code></td>
<td align="center">检查<code>n1</code>是否等于<code>n2</code></td>
<td align="center"><code>n1 -ne n2</code></td>
<td align="center">检查<code>n1</code>是否不等于<code>n2</code></td>
</tr>
<tr>
<td align="center"><code>n1 -gt n2</code></td>
<td align="center">检查<code>n1</code>是否大于<code>n2</code></td>
<td align="center"><code>n1 -ge n2</code></td>
<td align="center">检查<code>n1</code>是否大于或等于<code>n2</code></td>
</tr>
<tr>
<td align="center"><code>n1 -lt n2</code></td>
<td align="center">检查<code>n1</code>是否小于<code>n2</code></td>
<td align="center"><code>n1 -le n2</code></td>
<td align="center">检查<code>n1</code>是否小于或等于<code>n2</code></td>
</tr>
<tr>
<td align="center"><strong>字符串比较</strong></td>
<td align="center"></td>
<td align="center"></td>
<td align="center">（使用字符的 Unicode 编码值进行大小比较）</td>
</tr>
<tr>
<td align="center"><code>str1 = str2</code></td>
<td align="center">检查<code>str1</code>是否和<code>str2</code>相同</td>
<td align="center"><code>str1 != str2</code></td>
<td align="center">检查<code>str1</code>是否和<code>str2</code>不同</td>
</tr>
<tr>
<td align="center"><code>str1 \&lt; str2</code></td>
<td align="center">检查<code>str1</code>是否小于<code>str2</code></td>
<td align="center"><code>str1 \&gt; str2</code></td>
<td align="center">检查<code>str1</code>是否大于<code>str2</code></td>
</tr>
<tr>
<td align="center"><code>-n str1</code></td>
<td align="center">检查<code>str1</code>长度是否不为 0</td>
<td align="center"><code>-z str1</code></td>
<td align="center">检查<code>str1</code>长度是否为 0</td>
</tr>
<tr>
<td align="center"><strong>文件比较</strong></td>
<td align="center"></td>
<td align="center"></td>
<td align="center"></td>
</tr>
<tr>
<td align="center"><code>-e file</code></td>
<td align="center">检查<code>file</code>是否存在</td>
<td align="center"><code>-s file</code></td>
<td align="center">检查<code>file</code>是否存在且非空</td>
</tr>
<tr>
<td align="center"><code>-f file</code></td>
<td align="center">检查<code>file</code>是否存在且为文件</td>
<td align="center"><code>-d file</code></td>
<td align="center">检查<code>file</code>是否存在且为目录</td>
</tr>
<tr>
<td align="center"><code>-r file</code></td>
<td align="center">检查<code>file</code>是否存在且可读</td>
<td align="center"><code>-w file</code></td>
<td align="center">检查<code>file</code>是否存在且可写</td>
</tr>
<tr>
<td align="center"><code>-x file</code></td>
<td align="center">检查<code>file</code>是否存在且可执行</td>
<td align="center"></td>
<td align="center"></td>
</tr>
<tr>
<td align="center"><code>-O file</code></td>
<td align="center">检查<code>file</code>是否存在且属当前用户所有</td>
<td align="center"><code>-G file</code></td>
<td align="center">检查<code>file</code>是否存在且默认组与当前用户相同</td>
</tr>
<tr>
<td align="center"><code>file1 -nt file2</code></td>
<td align="center">检查<code>file1</code>是否比<code>file2</code>新</td>
<td align="center"><code>file1 -ot file2</code></td>
<td align="center">检查<code>file1</code>是否比<code>file2</code>旧</td>
</tr>
</tbody></table>
<h3 id="3-2-2-单括号"><a href="#3-2-2-单括号" class="headerlink" title="3.2.2 单括号"></a>3.2.2 单括号</h3><p>使用单括号<code>(command)</code>作为<code>if</code>之后的命令，会使用子 shell 来执行<code>command</code>命令，子 shell 的退出码取决于单括号中最后一个命令的退出码。</p>
<h3 id="3-2-3-双括号"><a href="#3-2-3-双括号" class="headerlink" title="3.2.3 双括号"></a>3.2.3 双括号</h3><p>使用双括号命令<code>(( expression ))</code>作为<code>if</code>之后的命令，在比较过程中进行一些高级数学表达式运算，双括号中的表达式无需使用<code>\</code>转义（双括号命令也可以在脚本中的普通命令里用来赋值）。</p>
<table>
<thead>
<tr>
<th align="center"></th>
<th align="center"></th>
<th align="center"></th>
<th align="center"></th>
</tr>
</thead>
<tbody><tr>
<td align="center">符号</td>
<td align="center">描述</td>
<td align="center">符号</td>
<td align="center">描述</td>
</tr>
<tr>
<td align="center"><code>val++</code></td>
<td align="center">后增</td>
<td align="center"><code>val--</code></td>
<td align="center">后减</td>
</tr>
<tr>
<td align="center"><code>++val</code></td>
<td align="center">先增</td>
<td align="center"><code>--val</code></td>
<td align="center">先减</td>
</tr>
<tr>
<td align="center"><code>!</code></td>
<td align="center">逻辑求反</td>
<td align="center"><code>~</code></td>
<td align="center">位求反</td>
</tr>
<tr>
<td align="center"><code>**</code></td>
<td align="center">幂运算</td>
<td align="center"></td>
<td align="center"></td>
</tr>
<tr>
<td align="center"><code>&lt;&lt;</code></td>
<td align="center">左位移</td>
<td align="center"><code>&gt;&gt;</code></td>
<td align="center">右位移</td>
</tr>
<tr>
<td align="center"><code>&amp;</code></td>
<td align="center">位布尔<code>AND</code></td>
<td align="center"><code>|</code></td>
<td align="center">位布尔<code>OR</code></td>
</tr>
<tr>
<td align="center"><code>&amp;&amp;</code></td>
<td align="center">逻辑<code>AND</code></td>
<td align="center"><code>||</code></td>
<td align="center">逻辑<code>OR</code></td>
</tr>
</tbody></table>
<h3 id="3-2-4-双方括号"><a href="#3-2-4-双方括号" class="headerlink" title="3.2.4 双方括号"></a>3.2.4 双方括号</h3><p>使用双方括号命令<code>[[ expression ]]</code>作为<code>if</code>之后的命令，除了可以进行一些基本条件判断以外，还可以对字符串进行模式匹配（不是所有的 shell 都支持双方括号）。</p>
<h2 id="3-3-用户输入"><a href="#3-3-用户输入" class="headerlink" title="3.3 用户输入"></a>3.3 用户输入</h2><p>bash shell 提供了一些方法从用户处获取数据来作为脚本运行时变量。</p>
<h3 id="3-3-1-命令行参数"><a href="#3-3-1-命令行参数" class="headerlink" title="3.3.1 命令行参数"></a>3.3.1 命令行参数</h3><ul>
<li><p>命令行参数是在命令/脚本之后出现的各个单词，bash shell 会将所有的命令行参数都指派给称作位置参数的特殊变量</p>
</li>
<li><p>位置参数是用于保存命令行参数的变量，位置参数的名称都是标准数字，<code>$0</code>对应脚本路径名（可以通过<code>basename $0</code>获取不包含路径的脚本名），<code>$1</code>对应第一个命令行参数…</p>
</li>
<li><p><code>$#</code>对应命令行参数的个数，<code>$&#123;!#&#125;</code>对应最后一个参数，<code>$*</code>和<code>$@</code>都包含了所有命令行参数，区别在于<code>&quot;$*&quot;</code>会被扩展为<code>&quot;$1c$2...&quot;</code>（其中<code>c</code>为<code>IFS</code>变量值的第一个字符分隔），<code>&quot;$@&quot;</code>会被扩展为`”$1””$2”…``</p>
</li>
<li><p><code>shift</code>命令会将除了<code>$0</code>以外的每个命令行参数都向左移动一个位置，即<code>$1</code>的值会被删除，<code>$2</code>的值会移入<code>$1</code>，<code>$3</code>的值会移入<code>$2</code>…，可以通过给<code>shift</code>命令提供参数来指定要移动的步数</p>
</li>
</ul>
<h3 id="3-3-2-命令行选项"><a href="#3-3-2-命令行选项" class="headerlink" title="3.3.2 命令行选项"></a>3.3.2 命令行选项</h3><ul>
<li><p>选项是在连字符之后出现的单个字母，长选项是在双连字符之后紧跟着的一个字符串，选项可以理解为一种以<code>-</code>或<code>--</code>起始的特殊形式的命令行参数</p>
</li>
<li><p>当命令行参数和选项混合使用时，Linux 通过<code>--</code>这一特殊字符来将两者分开，<code>--</code>表明命令行选项部分结束，后面是普通命令行参数</p>
</li>
<li><p>当多个选项被合并使用时，可以通过<code>getopt</code>命令进行解析，并通过<code>set</code>命令将原始命令行参数替换为解析后的格式化的命令行参数，最后就可以用常规的方式来解析非合并使用的命令行选项</p>
</li>
<li><p><code>getopt</code>和<code>set</code>命令配合使用方式为<code>set -- $(getopt -q optstring &quot;$@&quot;)</code>，其中<code>optstring</code>定义了有效的命令行选项字母以及哪些选项需要参数值，<code>-q</code>选项用于在<code>optstring</code>定义不完整（缺乏用户实际输入的选项）时忽略错误消息显示</p>
</li>
<li><p><code>getopts</code>命令可以直接在循环中依次解析单个命令行选项，无须像<code>getopt</code>这样先格式化再解析，也可以解析<code>getopt</code>解析不了的带引号和空格的参数</p>
</li>
<li><p><code>getopts</code>命令使用方式为<code>while getopts :optstring opt</code>（<code>:</code>是为了忽略错误消息显示），对于每个正在被解析的选项变量<code>opt</code>，环境变量<code>OPTAGR</code>会保存该选项的参数值，<code>OPTIND</code>会保存该选项在整个参数列表中所处的索引位置</p>
</li>
<li><p>命令行选项解析完成后，变量<code>OPTIND</code>配合<code>shift</code>命令（<code>shift $[ $OPTIND - 1 ]</code>）即可解析剩下的命令行参数</p>
</li>
</ul>
<p>常用的标准化选项含义如下</p>
<table>
<thead>
<tr>
<th align="center"></th>
<th align="center"></th>
<th align="center"></th>
<th align="center"></th>
</tr>
</thead>
<tbody><tr>
<td align="center">选项</td>
<td align="center">描述</td>
<td align="center">选项</td>
<td align="center">描述</td>
</tr>
<tr>
<td align="center"><code>-a</code></td>
<td align="center">显示所有对象</td>
<td align="center"><code>-c</code></td>
<td align="center">生成计数</td>
</tr>
<tr>
<td align="center"><code>-d</code></td>
<td align="center">指定目录</td>
<td align="center"><code>-e</code></td>
<td align="center">扩展对象</td>
</tr>
<tr>
<td align="center"><code>-f</code></td>
<td align="center">指定读入数据的文件</td>
<td align="center"><code>-h</code></td>
<td align="center">显示命令的帮助信息</td>
</tr>
<tr>
<td align="center"><code>-i</code></td>
<td align="center">忽略文本大小写</td>
<td align="center"><code>-l</code></td>
<td align="center">产生长格式输出</td>
</tr>
<tr>
<td align="center"><code>-n</code></td>
<td align="center">使用非交互模式（批处理）</td>
<td align="center"><code>-o</code></td>
<td align="center">将所有输出重定向至指定的文件</td>
</tr>
<tr>
<td align="center"><code>-q</code></td>
<td align="center">以静默模式运行</td>
<td align="center"><code>-r</code></td>
<td align="center">递归处理目录和文件</td>
</tr>
<tr>
<td align="center"><code>-s</code></td>
<td align="center">以静默模式运行</td>
<td align="center"><code>-v</code></td>
<td align="center">生成详细输出</td>
</tr>
<tr>
<td align="center"><code>-x</code></td>
<td align="center">排除某个对象</td>
<td align="center"><code>-y</code></td>
<td align="center">对所有问题回答 yes</td>
</tr>
</tbody></table>
<h3 id="3-3-3-运行时输入"><a href="#3-3-3-运行时输入" class="headerlink" title="3.3.3 运行时输入"></a>3.3.3 运行时输入</h3><ul>
<li><p>bash shell 提供<code>read</code>命令来在脚本运行时询问用户并等待用户回答</p>
</li>
<li><p><code>read</code>命令会将提示符后输入的所有数据分配给所指定的单个变量，如果不指定变量则会将接收到的所有数据都放进特殊环境变量<code>REPLY</code>中</p>
</li>
<li><p><code>-p</code>选项可以用来指定多个变量，此时输入的每个数据值都会分配给指定的变量列表中的下一个变量，如果变量数据不够，那么剩下的数据就全部分配给最后一个变量</p>
</li>
<li><p><code>-t</code>选项可以用来指定等待用户输入的秒数，一旦超时<code>read</code>命令会返回非 0 退出状态码</p>
</li>
<li><p><code>-n</code>选项可以用来指定等待用户输入的字符个数，只要用户输入达到指定字符数<code>read</code>命令就会将其传给变量，无需按 Enter 键</p>
</li>
<li><p><code>-s</code>选项可以避免在<code>read</code>命令中输入的数据出现在屏幕上（其实是将文本颜色设成了跟背景色一样）</p>
</li>
<li><p>通过<code>cat</code>和管道可以将文件数据作为<code>read</code>命令的输入（<code>cat file | while read line</code>）</p>
</li>
</ul>
<h1 id="4、文本处理"><a href="#4、文本处理" class="headerlink" title="4、文本处理"></a>4、文本处理</h1><h2 id="4-1-正则表达式"><a href="#4-1-正则表达式" class="headerlink" title="4.1 正则表达式"></a>4.1 正则表达式</h2><p>正则表达式是一种可供 Linux 工具对数据进行模式匹配从而过滤文本的自定义模板，正则表达式使用元字符来描述数据流中的一个或多个具体内容不确定的字符数据，然后通过正则表达式引擎（一种底层软件）来负责解释正则表达式并用这些模式进行文本匹配。在 Linux 中，不同的应用程序可能使用不同类型的正则表达式引擎，最常用是 POSIX 基础正则表达式（BRE）引擎和 POSIX 扩展正则表达式（ERE）引擎，大多数 Linux 工具至少符合 BRE 引擎规范。</p>
<ul>
<li><p>正则表达式区分大小写，能识别的特殊字符为<code>.*[]^$&#123;&#125;\+?|()</code>，如果需要将某个特殊字符以及<code>/</code>视为普通字符，则必须使用<code>\</code>进行转义</p>
</li>
<li><p>默认情况下正则表达式可以匹配数据流中的任何地方，位于正则表达式开头的脱字符<code>^</code>可以指定位于数据流中文本行行首的模式匹配，即如果模式出现在非行首的位置是无法匹配的，如果<code>^</code>放到正则表达式开头之外的位置，那么就是没有特殊含义的普通字符</p>
</li>
<li><p>脱字符<code>^</code>用于锚定行首时，无需<code>\</code>转义，<code>^</code>作为普通字符进行匹配且后面没有其他文本时，无需<code>\</code>转义，<code>^</code>做普通字符且和后面的文本一起进行匹配时，需要<code>\</code>转义</p>
</li>
<li><p>位于正则表达式末尾的<code>$</code>指定位于数据流文本行行尾的模式匹配，即如果模式出现在非行尾的位置是无法匹配的，直接将行首锚点和行尾锚点组合在一起可以过滤出空白行</p>
</li>
<li><p>点号字符<code>.</code>可以匹配除换行符之外的任意单个字符，但必须匹配一个字符，如果该位置没有可匹配的字符则模式不匹配</p>
</li>
<li><p><code>[]</code>用于定义限定匹配范围的字符组，在<code>[]</code>中可以使用<code>0-3</code>来代替<code>0123</code>，使用<code>0-35-7</code>来代替<code>0123567</code>，<code>[^]</code>用于定义限定匹配范围以外的字符组，除了这些自定义字符组，还有一些特殊字符组</p>
<table>
<thead>
<tr>
<th align="center"></th>
<th align="center"></th>
<th align="center"></th>
<th align="center"></th>
</tr>
</thead>
<tbody><tr>
<td align="center">字符组</td>
<td align="center">描述</td>
<td align="center">字符组</td>
<td align="center">描述</td>
</tr>
<tr>
<td align="center"><code>[[:alpha:]]</code></td>
<td align="center">匹配任意字母字符，不区分大小写</td>
<td align="center"><code>[[:print:]]</code></td>
<td align="center">匹配任意可打印字符</td>
</tr>
<tr>
<td align="center"><code>[[:alnum:]]</code></td>
<td align="center">匹配任意字母数字字符，不区分大小写</td>
<td align="center"><code>[[:punct:]]</code></td>
<td align="center">匹配标点符号</td>
</tr>
<tr>
<td align="center"><code>[[:blank:]]</code></td>
<td align="center">匹配空格或制表符</td>
<td align="center"><code>[[:space:]]</code></td>
<td align="center">匹配任意空白字符：空格、制表符、换行符、分页符、垂直制表符和回车符</td>
</tr>
<tr>
<td align="center"><code>[[:digit:]]</code></td>
<td align="center">匹配 0~9 中的数字，等价于<code>[0-9]</code></td>
<td align="center"><code>[[:upper:]]</code></td>
<td align="center">匹配任意大写字母字符</td>
</tr>
<tr>
<td align="center"><code>[[:lower:]]</code></td>
<td align="center">匹配任意小写字母字符</td>
<td align="center"></td>
<td align="center"></td>
</tr>
</tbody></table>
</li>
<li><p>星号<code>*</code>表明前面的字符必须出现 0 次或多次，问号<code>?</code>表明前面的字符可以出现 0 次或 1 次，<code>+</code>表明前面的字符必须出现 1 次或多次</p>
</li>
<li><p>花括号<code>&#123;&#125;</code>允许为前面的字符指定可重复出现次数，<code>&#123;1&#125;</code>代表出现 1 次，<code>&#123;2,3&#125;</code>代表至少出现 2 次，至多出现 3 次</p>
</li>
<li><p>竖线<code>|</code>允许以逻辑<code>OR</code>方式指定正则表达式引擎要使用的两个或多个模式，正则表达式和<code>|</code>之间不能有空格</p>
</li>
<li><p>圆括号<code>()</code>可以对正则表达式分组，每一组会被视为一个整体（可以将其看作是一个字符），然后对该组应用特殊字符</p>
</li>
</ul>
<h2 id="4-2-vim-编辑器"><a href="#4-2-vim-编辑器" class="headerlink" title="4.2 vim 编辑器"></a>4.2 vim 编辑器</h2><p>vi 编辑器使用控制台图形模式来模拟文本编辑窗口，复杂但功能强大，开源后被改进为 vim，通过<code>vim</code>命令和要编辑的文件名就可以启动 vim 编辑器。vim 使用全屏模式来将整个控制台窗口作为编辑器区域，在内存缓冲区中处理数据，如果在启动 vim 时未指定文件名或者指定文件不存在，则会开辟一段新的缓冲区进行编辑，如果指定的是已有文件的名称，则会将文件的整个内容都读入缓冲区以备编辑。</p>
<p>刚打开要编辑的文件或新建文件时，vim 编辑器会进入命令模式（又称普通模式）</p>
<ul>
<li>命令模式下按下 i 键后进入插入模式，vim 会将当前光标位置输入的字符、数字或符号都放入缓冲区，按下 Esc 键退出插入模式并返回命令模式</li>
<li>命令模式下按下 : 键后进入 Ex 模式（提供了交互式命令行），此时光标会移动到屏幕底部的消息行处，出现冒号，接着可以输入命令来控制 vim 的操作</li>
<li>命令模式下按下 v 键，进入可视模式，接下来可以移动光标来覆盖想要复制的文本，vim 会高亮显示复制区域的文本，按下 y 键完成复制，并回到命令模式</li>
<li>命令模式下按下 / 键，光标会去到屏幕底部的消息行，并显示出一个正斜线，接着就可以输入需要查找的文本内容，按下 Enter 键，光标会定位到正确位置或者输出没有找到的错误信息，若需要继续查找则按 / 键，再按 Enter 键或 n 键</li>
</ul>
<table>
<thead>
<tr>
<th></th>
<th></th>
<th></th>
</tr>
</thead>
<tbody><tr>
<td>命令模式</td>
<td>命令模式</td>
<td>Ex 模式</td>
</tr>
<tr>
<td><code>h</code>：光标左移一个字符</td>
<td>PageDn/Ctrl+F：下翻一屏</td>
<td><code>q</code>：如果未修改缓冲区数据则退出</td>
</tr>
<tr>
<td><code>j</code>：光标下移一个行</td>
<td>PageUp/Ctrl+B：上翻一屏</td>
<td><code>q!</code>：放弃对缓冲区数据的所有修改并退出</td>
</tr>
<tr>
<td><code>k</code>：光标上移一行</td>
<td><code>G</code>：移到缓冲区的最后一行</td>
<td><code>w filename</code>：将文件另存为其他名称</td>
</tr>
<tr>
<td><code>l</code>/Backspace：光标右移一个字符</td>
<td><code>num G</code>：移到缓冲区的第<code>num</code>行</td>
<td><code>wq</code>：将缓冲区数据保存到文件中并退出</td>
</tr>
<tr>
<td>方向键：在文本区域移动光标</td>
<td><code>gg</code>：移到缓冲区的第一行</td>
<td><code>:s/old/new/g</code>：替换当前行内出现的所有<code>old</code></td>
</tr>
<tr>
<td><code>x</code>/delete：删除光标当前所在位置的字符</td>
<td><code>u</code>：撤销上一个编辑命令</td>
<td><code>:n, ms/old/new/g</code>：替换第<code>n</code>行和第<code>m</code>之间出现的所有<code>old</code></td>
</tr>
<tr>
<td><code>dd</code>：删除光标当前所在行</td>
<td><code>a</code>：在光标当前位置后追加数据</td>
<td><code>:%s/old/new/g</code>：替换整个文件中出现的所有<code>old</code></td>
</tr>
<tr>
<td><code>dw</code>：删除光标当前所在位置的单词</td>
<td><code>A</code>：在光标当前位置所在行结尾追加数据</td>
<td><code>:%s/old/new/gc</code>：替换整个文件中出现的所有<code>old</code>，并在每次替换时提示</td>
</tr>
<tr>
<td><code>d$</code>：删除光标当前所在位置至行尾的内容</td>
<td><code>r char</code>：用<code>char</code>替换光标当前所在位置的单个字符</td>
<td></td>
</tr>
<tr>
<td><code>J</code>：删除光标当前所在行结尾的换行符（合并行）</td>
<td><code>R text</code>：用<code>text</code>覆盖光标当前所在位置的内容</td>
<td></td>
</tr>
<tr>
<td><code>yw</code>：复制一个单词</td>
<td><code>p</code>：粘贴上一次被删除/复制的文本，可以与任何删除/复制文本的命令搭配使用</td>
<td></td>
</tr>
<tr>
<td><code>y$</code>：复制到行尾</td>
<td></td>
<td></td>
</tr>
</tbody></table>
<h2 id="4-3-sed-编辑器"><a href="#4-3-sed-编辑器" class="headerlink" title="4.3 sed 编辑器"></a>4.3 sed 编辑器</h2><h3 id="4-3-1-sed-概述"><a href="#4-3-1-sed-概述" class="headerlink" title="4.3.1 sed 概述"></a>4.3.1 sed 概述</h3><p>不同于 vim 这样通过命令或鼠标单击来处理文本的交互式编辑器，有时候需要一种可以自动格式化、插入、修改或删除文本元素的命令行编辑器。sed 编辑器被称作流编辑器，可以根据命令行中输入的或脚本中预先定义好的一组规则编辑数据流，支持 POSIX BRE 正则表达式引擎</p>
<ul>
<li><p>默认情况下，sed 编辑器会将指定的命令（用单引号<code>&#39;&#39;</code>定义）应用于<code>STDIN</code>输入流或者指定数据文件中的数据流（比如<code>sed &#39;s/a/b/&#39;</code>使用了替换命令<code>s</code>，代表使用<code>b</code>替换文本中的<code>a</code>）</p>
</li>
<li><p>如果需要应用多个命令，则要么使用<code>-e</code>选项在命令行中指定并用分号分隔（比如<code>sed -e &#39;s/a/b/; s/c/d/&#39; xx.text</code>对<code>xx.text</code>文件中的数据使用了两次替换命令），要么使用<code>-f</code>选项在单独的sed 脚本文件中指定</p>
</li>
<li><p>这种 sed 脚本文件区别于 bash shell 脚本文件，一般使用<code>.sed</code>作为 sed 脚本文件的扩展名</p>
</li>
<li><p>每当匹配一行数据并针对该行执行所有命令之后，就会继续读取下一行数据并重复这个过程直到处理完数据流中的所有行</p>
</li>
<li><p>sed 编辑其并不会修改原始数据，而是将修改后的新数据输出到<code>STDOUT</code>，使用<code>-n</code>选项则不产生命令输出</p>
</li>
<li><p><code>-s</code>选项可以告知 sed 将指定目录内的各个文件作为单独的流，这样就可以分别处理目录中的每个文件，可以配合<code>1F</code>命令一起使用，<code>F</code>命令用于打印当前正在处理的文件名（不受<code>-n</code>选项的影响），<code>F</code>前的<code>1</code>代表只需显示一次文件名，否则所处理的每个文件的每一行都会显示一次文件名</p>
</li>
</ul>
<h3 id="4-3-2-行寻址"><a href="#4-3-2-行寻址" class="headerlink" title="4.3.2 行寻址"></a>4.3.2 行寻址</h3><p>默认情况下，sed 命令会应用于所有的文本行，可以通过行寻址来将命令只应用于特定的某一行或某些行</p>
<ul>
<li><p>基于行号的行寻址可以用行号来引用文本流中的特定行，比如<code>sed &#39;2s/a/b/&#39;</code>只对第 2 行的文本进行替换，<code>sed &#39;2,4s/a/b/&#39;</code>只对第 2~4 行的文本进行替换，<code>sed &#39;2$s/a/b/&#39;</code>只对第 2 行开始到结尾的文本进行替换</p>
</li>
<li><p>基本文本模式匹配的行寻址通过正则表达式来指定需要匹配的行，且必须将匹配放入正斜线内，比如<code>sed &#39;/pattern/s/a/b/&#39;</code>只对能够匹配<code>pattern</code>的行进行替换</p>
</li>
<li><p>如果需要对单行执行多条命令，可以用花括号将其组合在一起，每种行寻址都可以对应一个花括号组合到一起的命令块</p>
</li>
<li><p>命令之前加上<code>!</code>就成为排除命令，旨在指示命令不应用于行寻址所指定的行，而是应用于行寻址以外的所有行</p>
</li>
<li><p>在行寻址后加上<code>b</code>和<code>label</code>参数就可以定义指定行需要跳转执行的<code>label</code>处的指定命令，如果不指定<code>label</code>，那么指定行就无须指定命令脚本</p>
</li>
</ul>
<h3 id="4-3-3-sed-命令"><a href="#4-3-3-sed-命令" class="headerlink" title="4.3.3  sed 命令"></a>4.3.3  sed 命令</h3><p>替换命令<code>s</code>默认情况下只替换每行中出现的第一处匹配文本，可以通过设置替换标志<code>flags</code>（<code>s/pattern/replacement/flags</code>）来进一步指定替换方式</p>
<ul>
<li><p><code>flag</code>为数字时，指明新文本将替换行中的第几处匹配</p>
</li>
<li><p><code>flag</code>为<code>g</code>时，指明新文本将替换行中所有的匹配</p>
</li>
<li><p><code>flag</code>为<code>p</code>时，指明打印出替换后的行，一般与<code>-n</code>选项配合使用，此时只输出修改后的行</p>
</li>
<li><p><code>flag</code>为<code>w file</code>时，指明将替换的结果写入文件，同样与<code>-n</code>选项配合使用，此时只在文件中保存修改后的行</p>
</li>
</ul>
<p>删除命令<code>d</code>用于删除文本行</p>
<ul>
<li><p>使用行寻址时只删除指定的所有行，没有使用行寻址时会删除所有文本行</p>
</li>
<li><p>可以使用两个基于文本模式的行寻址来删除某个区间内的行（包括被指定的行）</p>
</li>
<li><p>由于 sed 编辑其并不会修改原始数据，被删除的行仅仅只是从输出中消失了</p>
</li>
</ul>
<p>插入命令<code>i</code>会在指定行前增加一行，附件命令<code>a</code>会在指定行后增加一行</p>
<ul>
<li><p>必须使用行寻址指定数据被插入/附加在什么位置，</p>
</li>
<li><p>只能指定一个行地址（基本行号或文本模式匹配都可），不能使用行区间</p>
</li>
<li><p>必须在要插入/附加的每行新文本末尾使用反斜线</p>
</li>
</ul>
<p>修改命令<code>c</code>允许修改整行文本的内容</p>
<ul>
<li><p>必须使用行寻址指定要修改的数据行</p>
</li>
<li><p>可以指定行区间，但此时会将区间内的多行修改为指定的一行文本数据</p>
</li>
</ul>
<p>转换命令<code>y</code>是唯一可以处理单个字符的 sed 编辑器命令，会对指定的<code>inchars</code>和<code>outchars</code>进行一对一的映射和替换</p>
<ul>
<li><p><code>inchars</code>中的第 n 个字符会被<code>outchars</code>中的第 n 个字符替换</p>
</li>
<li><p>这个映射替换过程会一直持续到处理<code>inchars</code>中存在的所有字符</p>
</li>
<li><p><code>inchars</code>和<code>outchars</code>的长度必须相同，否则 sed 编辑器会产生错误消息</p>
</li>
</ul>
<p>打印命令<code>p</code>用于打印 sed 编辑器输出中的文本行，打印命令<code>=</code>用于打印行号，列出命令<code>l</code>用于列出行</p>
<ul>
<li><p>和<code>-n</code>选项（抑制其他行的输出）配合使用就能只打印指定的行</p>
</li>
<li><p>可以在替换或修改命令做出改动之前先用打印命令查看相应的行</p>
</li>
<li><p>列出命令可以打印数据流中的文本和不可打印字符（比如<code>\t</code>表示制表符，<code>$</code>表示换行）</p>
</li>
</ul>
<p>写入命令<code>w</code>用来向数据文件写入行</p>
<ul>
<li><p>写入命令要求运行 sed 编辑器的用户拥有该文件的写权限</p>
</li>
<li><p>可以行寻址指定单个行或者行区间</p>
</li>
</ul>
<p>读取命令<code>r</code>允许将一条独立文件中的数据插入数据流</p>
<ul>
<li><p>一般与插入/附加/修改命令配合使用，将一条独立文件中的数据插入/附加/修改到数据流</p>
</li>
<li><p>读取命令中无法使用行区间，只能通过行寻址指定确定的行，并将数据文件的所有内容都插入数据流的指定地址之后</p>
</li>
</ul>
<h3 id="4-3-4-多行命令"><a href="#4-3-4-多行命令" class="headerlink" title="4.3.4 多行命令"></a>4.3.4 多行命令</h3><p>上一节介绍的 sed 命令都是单行版本命令，有时候需要对跨多行的数据执行特定的操作，sed 编辑器提供了三个可用于处理多行文本的特殊命令。</p>
<p><code>N</code>命令</p>
<ul>
<li><p>通常 sed 编辑器只有每次在当前行中执行完所有定义好的命令之后会自动的移动到数据流中的下一行并再次重头开始执行命令</p>
</li>
<li><p>单行<code>n</code>命令会将数据流中的下一行移入 sed 编辑器的模式空间（上一行已经被移出模式空间），而多行<code>N</code>命令则是将下一行添加到模式空间中已有文本之后，文本行之间仍然用换行符分隔，将换行符分隔的两行当做一行放入模式空间中合并处理</p>
</li>
<li><p>单行<code>n</code>命令和多行<code>N</code>命令都是位于命令列表中的定义好的令编辑器移动到下一行的 sed 命令，都不会不影响 sed 编辑器每次执行完命令列表后再继续自动换行的一系列行为</p>
</li>
<li><p>如果 sed 编辑器在处理最后一行时（此时没有下一行），那么在执行<code>N</code>命令时就会叫停 sed 编辑器，即命令列表中位于<code>N</code>命令后面的命令就不会再执行了</p>
</li>
</ul>
<p><code>D</code>命令</p>
<ul>
<li><p><code>N</code>命令使得 sed 编辑器将换行符分隔的当前行和下一行当做一行来一起合并处理，此时单行<code>d</code>命令会删除整个合并行（换行符分隔的两行）</p>
</li>
<li><p>多行<code>D</code>命令只删除合并行中的第一行（换行符及其之前的所有字符），合并行中的第二行虽然被<code>N</code>命令加入模式空间，但仍然完好</p>
</li>
<li><p>每当执行完<code>D</code>命令后，会强制 sed 编辑器在不读取数据流下一行的情况返回到命令脚本的顶部，重新开始执行命令列表</p>
</li>
</ul>
<p><code>P</code>命令</p>
<ul>
<li><p><code>N</code>命令使得 sed 编辑器将换行符分隔的当前行和下一行当做一行来一起合并处理，此时单行<code>p</code>命令会打印整个合并行（换行符分隔的两行）</p>
</li>
<li><p>多行<code>P</code>命令只打印合并行中的第一行（换行符及其之前的所有字符）</p>
</li>
</ul>
<p>模式空间时一块活跃的缓冲区，在 sed 编辑器执行命令时保存着待检查的文本，此外，sed 编辑器还有另一块称为保留空间的缓冲区，可以将模式空间复制（<code>h</code>）/附加（<code>H</code>）到保留空间，以便清空模式空间，载入其他要处理的字符串，最后再将保留空间复制（<code>g</code>）/附加（<code>G</code>）模式空间，或者交换（<code>x</code>）两者的内容，从而将保存的字符串移回模式空间。这种机制可以很灵活地来回移动文本行。</p>
<h2 id="4-4-gawk-编辑器"><a href="#4-4-gawk-编辑器" class="headerlink" title="4.4 gawk 编辑器"></a>4.4 gawk 编辑器</h2><p>gawk 是比 sed 更加强大的命令行编辑器，提供了一种编程语言，而不仅仅是编辑器命令，可以定义变量来保存数据、使用算术和字符串运算符来处理数据、使用结构化编程概念（比如<code>if-then</code>语句和循环）为数据处理添加处理逻辑、提取文件中的数据将其重新排列组合，最后生成格式化可读性报告，最完美的应用案例是格式化日志文件。</p>
<ul>
<li><p>默认情况下，gawk 编辑器同样会将指定的命令（用单引号和花括号<code>&#39;&#123;&#125;&#39;</code>定义）应用于<code>STDIN</code>输入流或者指定数据文件中的数据流（比如<code>gawk &#39;&#123;print &quot;hello&quot;&#125;&#39;</code>使用了打印命令<code>print</code>，代表将<code>hello</code>输出到<code>STDOUT</code>打印出来）</p>
</li>
<li><p>如果需要应用多个命令，则要么直接在命令行<code>&#39;&#123;&#125;&#39;</code>中指定并用分号分隔，要么使用<code>-f</code>选项在单独的 gawk 脚本文件中指定</p>
</li>
<li><p>gawk 命令默认可以使用<code>$0</code>代表当前整个文本行，<code>$1</code>代表文本行中的第一个数据字段，…，<code>$n</code>代表文本行中的第 n 个数据字段，<code>-F</code>选项指定了行中划分数据字段的字段分隔符，默认情况下是任意的空白字符（比如空格或制表符）</p>
</li>
<li><p>gawk 脚本文件中可以定义变量来保存数据，引用 gawk 脚本自定义的变量的值时无须像 bash shell 脚本那样使用<code>$</code>符号，gawk 脚本文件中可以通过特殊变量<code>FS</code>来定义字段分隔符，此时就无须设置<code>-F</code>选项</p>
</li>
<li><p>gawk 允许通过关键字<code>BEGIN</code>和<code>END</code>来定义在处理数据流开始之前和结束之后要执行的命令，即先执行<code>BEGIN</code>定义的命令，再依次匹配数据并处理数据，最后再执行<code>END</code>定义的命令，这就是生成格式化可读性报告的关键</p>
</li>
<li><p>可以在 gawk 脚本文件中依次定义<code>BEGIN</code>命令块，数据处理命令块以及<code>END</code>命令块</p>
</li>
<li><p>gawk 支持 POSIX ERE 正则表达式引擎，并且能够提供一些 sed 所不具备的额外过滤功能，因此处理数据时往往比较慢</p>
</li>
<li><p>gawk 默认情况下不识别正则表达式的<code>&#123;&#125;</code>，需要指定 gawk 的命令行选项<code>--re-interval</code>才能识别</p>
</li>
</ul>
<h1 id="5、参考资料"><a href="#5、参考资料" class="headerlink" title="5、参考资料"></a>5、参考资料</h1><ul>
<li>《Linux Command Line and Shell Scripting Bible, 4th Edition》（看到 488 页，就此告一段落吧……）</li>
</ul>
]]></content>
  </entry>
  <entry>
    <title>2022.10.31 - 2022.11.4</title>
    <url>/2022/11/10/week-10/</url>
    <content><![CDATA[<div class="hbe hbe-container" id="hexo-blog-encrypt" data-wpm="Oh, this is an invalid password. Check and try again, please." data-whm="OOPS, these decrypted content may changed, but you can still have a look.">
  <script id="hbeData" type="hbeData" data-hmacdigest="fe758c2bfded2a50e02512518b1816c484ba616218d07298b0c86a0185df32b4">a99f2d1cd7f89812758242c57c62a59fe859e32cc19116fcceb1abacce500da0960986acd07eddb3568f524414b51fee17e4d6bd35088912fa4af175c2bf91d707d28626ce04406e2d0a9a2d2a331aa48ca9e0a9fa6bdde39334c7ec4cb391ed74829c6091a641e5feb114ecebf69c677e948cb7d6d44fd4e3d796992e2f1541c3bf2f3edd56c934a0733c5123b8a72117bd06a8134d50a8c15f81fd4cf3cc3b15573ab82affe835b64c5721313eba3716b32f0dabaa6ee0709973834a5a4100fbc8170c9665560f9f874c41aa5ca8196608c6bc63bcdd85faed830b01c5b9b4e7f7111671e83427a24057dc0e775439093a03e4f5c6c5d0b655175dcc503fa1546d0c6addbb6f007944ce89e4ac56f1b787855dea01cbf9404c4825dc4a5efad40949c5c780d5f887c4a4c34eae0e55b575d136cb71280ff8b9329ee44c4a76ee344cd106a5aab14b329ef9fb836327c09b1ff2264b7ddfc80947611d39bb9c5eeea25c1c0b9847008a5359a343583bdaa36648f0d7721b7c2df1df178ca0b92cb718100b207a0d4e006cbea7fff012aa2a12c5262c490136100093d707630a20adac5385c59a42beb8052bdea04a1d91cf9bb70c0d620763f1b6a01438e782a8a6a418ae12366f1a231530e624a1b17b25090f5a238adb192259e22b865d4cca7356e02ae355bd6dfbdbb9902e5ee2855a08551916e394e94808fe6aa706746ee2f34fd49958d78cadad4168d2a16d763ffceabf0ce63bbcf2ddabe10cdaf788ff730279c1044b10302c27380a0da4fb950d8655a6ab2971e375b219df4197da452b62598e9fed8c26a0f90811a3c38643e936fd851dc045c3273bf73352b9a75332f3095e93619edac45c1899820a3c0f18890a93407d62852b835eaf7eb7a1f2c3566646ae9f7245c1e886f546bebf75422de71d2976dc4921e3fbac0c71a0896e125ec3df529d90202770f07011468edfff9a906dbe18f60e568ce4615f16cb31980a91ebfacd8634bc8d9718de41e1578ca46f59734e40351ed0991a54f44c0983b480b8e6edb3685da30f9dbd723d3fc9817ce4e71dac1227c369b5252ed19e5b5935280a79835694230cb6ac2ca1d3298fe16e6c033a50458efe1d82f0c1b2b962da4185ef7418cf0a738e9be645eb06584d3d6553f3655022124d9a9359afdf8ac692fc1902ce4ea875bf5f1e6ce5cdb9f99e0feb56233cfb2b25afbfbf00a2a3732efc2f7a0ff3e47c46ddfcbf5593ce79ba9e5b3eca7dc1ba451839561eef0be7e09a86204d6a9036d60f5f1af1330bb2b31a2628c04c7ebae17c6dc39133c5e0edadbfb97fb4d8c1655e41b33537f9bd9193c04e6cef258179208095af5e24807ebe2b968eac83146f8ebe6fc5b1302d094a430a8269a2f35c83b736c4b448ddc0b9b0e00fc5a535bad650ff17ec5fe9c7839b1921ec6c5cf10920f6b421100d598c1424f1319da958cad8ee16370b2e80bebe62659f66560d278aabe6e20e0f0b84348b3229ecdc8fce9b3f9f30658e50c61b5abd1dc392740aef394e0f316a18b2d3d56455a1733988dc112395706262dbd68c53eddd7ac2bd4939cbf849ae48fc6502cc7cc207fcae5ae5ddbbee04a7da42e9cc2af66d6a0666d987b330612afe8ab69643c887fd2771021e7292a640a8fab9e0d4e643b7dbfc97aba0f0229d42ce7910de15369d67d233f924e76b73c481b58f9bd949f9f976f1e7f57c819e8484b03058f5bdbd9e1bb1e034e081542dda022959824f953428fc887e21a4061fdbc04f261749f561852ba29d941c214fb18a3405413695d43407a1a1e911c2357000145002f45160e690ef9c92c233e7fabf679063f0d32c07a5dfe67e40c847df9322aa7374061520082df1764c4c8783db0af34b280ac38a43c61f911e020f36ddb272779a759097de43d89e0dbc29742b78ec9df199970b48a7ec9304ff4047699338f5c9ededeae322e203fce19a5b7794f074ae9eed188c14f67c83476be9a56b6a983ee47222b542d5522011d5d452e4eae0fb9c1a79133777fff04955474488dbf62efd064c79c5905d6b64de94fba34babe3c086a9e5b5f01c2880ce1e7a0d4207f35221</script>
  <div class="hbe hbe-content">
    <div class="hbe hbe-input hbe-input-default">
      <input class="hbe hbe-input-field hbe-input-field-default" type="password" id="hbePass">
      <label class="hbe hbe-input-label hbe-input-label-default" for="hbePass">
        <span class="hbe hbe-input-label-content hbe-input-label-content-default">Hey, password is required here.</span>
      </label>
    </div>
  </div>
</div>
<script data-pjax src="/lib/hbe.js"></script><link href="/css/hbe.style.css" rel="stylesheet" type="text/css">]]></content>
  </entry>
  <entry>
    <title>2022.11.21 - 2022.11.25</title>
    <url>/2022/11/21/week-13/</url>
    <content><![CDATA[<div class="hbe hbe-container" id="hexo-blog-encrypt" data-wpm="Oh, this is an invalid password. Check and try again, please." data-whm="OOPS, these decrypted content may changed, but you can still have a look.">
  <script id="hbeData" type="hbeData" data-hmacdigest="858b85e2f938c8eb755679b0fbc3cef455a1ae52c04f9b286b0b56e9f154c1cc">a99f2d1cd7f89812758242c57c62a59fe859e32cc19116fcceb1abacce500da0960986acd07eddb3568f524414b51fee17e4d6bd35088912fa4af175c2bf91d707d28626ce04406e2d0a9a2d2a331aa4c39db27c3c075975fefa39a71113c797618c8ea383f1bda23878a07c403706ceb9462903da0e0865f946d453925713c4a23db123769da3819035802dfbdfcf645149bc556b8b77dc3b63200f87f8ffaa12a1a733e259fbe95d8a19d01bb1d74cf543e8f8d1cdd8c9b077a08cc187122a70f53652386e3bebd366bd866e201a1876762c8464b1dabd77ef1af2c14220999d6d8331e984cd853154660bb4fa864dae94b2c1fd1f5c629e5afe3fabce00232389f9c86d77e9eed8babcfe88744a2bcb8779ab32a23843e92f732b062eb329499b72cef8a2e56d04a5b3848fb7824b7bf637eb96a043abe24aeba7c789a4dba9cf9e237171bc946ae345f823f8e14b99050c545c6cf892ff28656889ddc5868885708b39b091d5e394cac3b4e710bf77fe4e8a9e6ac56368b7e6ef544c9281ea206d7763d6fcfd0bf61c0e43c8367133078f9dc6c6a8941cd7f38f09d1685af54fda65e917e45793f3eebcccab633e39df9e51448ce41d8814186552841f4d5a0e5c0d4e75ae658b76efaada1d211e44354ff6e8f09b341bebc2a0512440800dd96e946c91b9a82e56567b3b83a0410de99733a2b2a8901367b2dd4e90d7e0a283063bb99af2916020d6a37fb43ad4c6383daa2ee46f07b10ae325299859c7cfea2fae02b7ca7b01be5dad7bbcb28d61120a92528cfc8ea6d5c1e8fe857251039c974e39d0515d9b6376d768f94bde3023bc563ef7208131bf31e85354c968abf4d7b0ba722c113b2333a0963956f5a425586ff9fa3e9a9196f7e02f4ee4d821e3e9ee56ca2ab1988bebd4717c14354a6ab7b8548aaf06bb271cf12c1a95786ffb1ae3171add1c6c99d967103c4e17ee46d4fadaa8daf15aa3a701e660d494d62d1c7d0c3c794d586a96482b397fd3c03055f67e63b1ed86654b6e81f8e33e0685409ace4a017c17fee27bd17d038c1d32fc54135e94eb9dd8c8c624d9b2d27b73d9f64be77e184da3710e31f5b4f1d73c401cddbfe14b98fac0c3564ed437976e20456553a95c40db9208b7f6989069f149c50878577e235bb225e2fb9d5689a16f944fa65c0d41a689852cf254120283b158947abfd809a788a52e226b488fce4f3e1956e996c717da36ffbbf3e3d6e6c3549920da43dbc06e99bc32ecc98c135201d5eb4a88a1eba16e0327fad881a235e2b974351101ad06345b5472a79bd338583b20df4e0c44f1decaa1e70509b25c3dd56fe9f7fbbc745a53c8231c4ea00c94891dd861524cc525ce3ce1e1024b80c175f18b1588b0c6867df62bdb6ccdc528f1cb5f7ae6346d1f02dab0f166a26575d26c15c03916968d8a0c906d3e74ce284251e7aa39c79f6bec18dee456e1862155666648d66aad858ea4cc2fb113da4adebc50c4d13da19ecec63bc1f83b7ed5edf4d0d792956d116aee13e7c091517d48de0040eb1f7850409235cc00a4fb132f85aa95e36c502c7a7bb6398ed0ac9af01f15a5caa9d3b38b6eda93432a25cf17e799be14448220df79197b172a2233ba794e4e2f8b426328c2ef8cce7f63f3a79eb41d6033543088e0a88cc780d5aa32572748e492742df627149e53893d2946b7f4e4357c74d8da84318dc8a459c6a661e21d8bd6e2e7a002ca8ffc0f64fc882d7ab98742aea7c41726f3cb4775fc9279ffcdcd1c66096b9a04c1b014ed1d44246bca13e8685480fdac123abb50b782b81642cb962c2f56423d84ff065902cc188e7ff0416b80b03aeb2a87e55a4981a711d170ef1229d6c0ae06857b07559304be7c3039c8cd724c54fc5692cbaccc70b3942037a3d3ae1a9fa786cb0b740c228809033c34880e1e4f0590acc19f71e9021330b34603abbca93b671f8c30384e68293b8f180c4420ffafe103e8ec242debfacab5bbed7ecbb4f0a9a9a848cf8f5cd65bf750fe3c7a994dcd4696291eeab20db924d665a6613ca93298300a9519a2978764a132f77ca2e6c4227c14aa78458aa0df40eb1e571b2992e25747442233f639536663710da19ccbb38cba2e8dbe0b27bb841b24d0238e942e481fe2bdcca0f9b6e7b6659b28b02bf2fd86ddc30210c57cc666dd0bee94062446b1125994e4199cd645dc17d1847d0c570018627fdc4c61a4b93a0503abd69da60439abafec541d8a58b0ec84b08ef27a8b07218d772e1666d546d72f6ed786d517f468cb939d1a600b14467710bba95099943ec17b390bdbc8f18d1cfba30f0fa8c86f2193832b985e7a8cdb263457733c2e18c2bfbb4ec11cc4b1a3428def4bc7011dee4fd7276d2b53a31dc2098d9e281b2b7c10d6756d6036afff48a3c5f60b98860e6df0193497b04ecc6dc6e90443f6ca3d1907e45c273fb030a7efbc5ffab2f287d5f269a774eadd313d4c9fafd0fbeb1ebdc4fd2a8177f4886ccaa4e8fd4fa7533354ff18a62ef6b0819d593affffe956d3d6142c2708220cf930afc59e4ace2418d6f6e9bdf42901fdfef5e546829b1651ffa5f439e4222292262272abe019c404a381e7283f4f3c65597ecfa849f5a8cbf94091b1f7fb611547567f7a2ae802d66aab98da95231adc25d5e3d56358e759781e8c8e33137b0e492600890bdd33b469be581c001229bd99a7526a6e4113805e37fa3479344d426a4c70b032f14048625224cb289d376f147b3ac792e00c5570ce154a4ee9e445434979376bbc7eef6218980d6471fa566d90379b3e2d1c3514d3efc0a9e779057123b824460ada6a364bd61cfbd8061a3df2fa2d74fa667f51d0fa306a258736b5db8b3c136fdeca804f15a84067a214cde0b9adaded5e19796d0b86854869466d9dbb67bfaff39291bc7c9c90370a59aa21f37653d20f2c8cf8a98f9702bcd92e4bcfbd9d702288685b22dc1c2b915f657566aad9d8995448fa4ad677e92075ef1ebccab5618c9c340794885142498138dae3ddbd5022ec442c69173d2ef6ef1c710e21e2541352bec4832193038d52042cceb6497c299bee05c1bbaba8aad0348d1da44a61a89f12c65da59107d88bd4864e79484188b944fcc831bfa583306b760fb177279aeb9199d751ad4842380c05b0542e4adb56c461d9c9c6472482f2ce851c70d26b1c5f3339b4b81bf5a2dd121773e6965aa9c3b8bf2bdba5e509ca99a4d00bfd12157a62b93868e52792a2a40faebfbbceab266eba1846f32c825e5f23305b8ca0301c850c34ee2c2e5d30ef08cb069a902668a65b44ff817f4ee6c216fcadaa449c50009378a742015f9fbea82a718b5b56e70d88645b5d0a1718044724d1cd59ecd450d1c3c4658cf1440b25820c40af8c265530e2e4283bf47929e6dc81b62dd67ef482071e1136c34dc18374e99cf1f11e3987392aa7f1c744116fae20f966a50c072e73a01609934bcb0ecbeb1779f36054a8af6f5566042d4048cb326f62131bb9972b47d3d42a11cb5a8b3899343179f4a1aad61733a7daeef0777c859bbefcdaf992a82c6921435ccc82fcc6b6c77885f6f7fe58dff814699b57e8785ab97c8b88fa933342794f6879cb1edfec19131735e9ab1ba4081aaf2f8929eff11d251215f4a5712779185a1246f4358880bf577777c97851afbeaca0e392caf9fef24469f0700ff61a53bc2cd7d325410b81601ec93ad1ee6b409fd6f0d8ae79f377d3b085c0fe965e19a33730ba36bb8a8bb2431982f3d41b024f58ff425dcd21265adccc4e0019078a585f6d523c98495764fc037b83c2b34709db497e0f0c30c6fb61dc80e6b608a3e161698c629175076e39cb29464ea91f3dbd29b364d397034af6d5fec5ea75a470cf60c6ab20bf2bef2adc7c5c0b8e3d79cb9c00eba5be6c9d3c2821c57abda2dd81fe4dbd905fd016e86fe854f47d0112b559e8c8583baf6c9da8a4113b2c286cfb0f2eec3256b4ec0e1fb37d79d976feca822a3fae26b2ce47be1b2afa8c28883c12524c81e31664098946c7e290e345f8f8e98aac3c63bbcaee3ddec68a1b44836ab44d7cb9cba9284b6961cff2436d084204ba2146edbc6592b156067ba8095eff257d435c3ca260569171ca841d38746cf1fa7fd4c0ac30b7bf9c2bb1e79e3432b9de11e7bf320ad6d11d0b2a1a9a77632dbcc5100a9ac278fd0971a93daf4a47bbdb94ad42d229da5a92b6d8a8d218dffd4150febbc36f55d2bd9d185c84ee85e7c0a0d77547a26080a0e4d88ae77f6a7fbe4940e2556ae2cc3f34490ca43d002127990c4ff1a89c375fab8cb4ab0c9aba8f912964ac71cb439b2e6a49a3dacd0c039f46c5db817bcbbaf7004dad85061d86077b310974d526487f00b9bec0222d1f338d5569beeeb38fc5dc2de91a11d30086607c53595bf9637fe339a4a9289c741c053c4cc220cc040aa1e33fdd9cdf315f28a2ee3397425ec4ce9246c810ad7632f30ae29d7f1d4b930775bda4649e7e08df6b1ce2f03016443849555fa12010c83d984feaed04fa139da18385d8878c3346c8e8adc93b3b526dbe2e64cd54c559bc5eb1852343c71f3c6fa577b3ec0a79769af5d01ff3582a63830783f236e7f9c10a144adcbc577e44f7a42eacba26bbe1eba0ff1ea76099a86cebdf37f9192e4ff278184613f8ce91d7e616124816985ca142a9aa640d16fc18830ea78237953f175f0ae58effabf53f8aef02183556486640371823a6e68d05faf9a64f7ee52d595792551f4f5eba50c25d8a787eddb5281a94badd9ab99a007f82afa7a9534972112e929052b23dfc9a667342720e1b7590e3e0c7328e15a9580e9a1b4579593c2b5fe89efde05ad2bd092dd1727996819a9b95f4434dac1c41bf8b1eb3f8300d9b187efd40e14afdf4b9fefb978323c57941837e2bca72281410e67cfb31cf7961cf83fa3668b79a59c4cae37fc5b06d2efd3813b2bae3ad80e3dc4e09c033479e4a52c59c9994cc7ed09686b703ca42453206b44d09fc2125a8bcd16f53b11cde99aa5d10e5357ac939c48722e34bc746dac1f01d59e269218eda13b448d1cb8c576dc890e307763bbb42e725a06a57cbb18bd70cfd8d3fd1ecdd8b65adee780b649fabac06426f32961378c885eb4b5573c72c9a19ecdafab6f4c3c2dc440b8d732166b641d4e543f1b2061b3e7b813af458690fb93cce8aff4c985072f5b1b85bf88208398ba1ba221ad2c9b8f2cfda5c4cf3e09f65d176d784e6540fd48cf33ab9a7ed60dac86c3c15003f20eb05822104b5c28193ab834c478cdb18953465b0511dac93efb31f5f6e20defa8b22ece860d404ce59d1421863472bae17f80d067fd7d7dee64efd7cce7c3aa1b5b1941658fea1efd2c02a8d5c82a31e9a534c058f01c10f1eebe14ab084424d0569045d83445009b193c94aebe0f81c9d5c49ff4280451e9f4b9ff6bba0bf2e8acd94947c7dab2a3d861f5a93e076fe3afda35244f0f50638796f5b04432883dbb3abf22fe0ef442aec825273a8ec5b08b48c166590111454ee34f0d406e6abda15614a5712b09663de3dedf9546e45c40420010b968ab9b8d63afc56b7335205164e1be34ecf8f000439bb6174917637ee8c67cc368dcc7f411538fded520ed762bb6b7f454d5e855bdc3679f42a65519eff6f7610689524c2044a5987430ed44337cefe8c0eec40520b9524239526cba2aca360c2b6ffcfb2df42c64e41216763d70eabaa7fa7264e1214386e9916b9f611d9a850c18c1e98403c7be49564538c618817b168b4575d911a3134f8d43e7ba248109c0617157f7563e7f718a166df63575457f89613b4ba292ee91fa98530da83967b673e3620890aec14a84808e1bdc7bb66b2db14132e9b612fdbd2ae30c8bf62b8197bf52d80600a7db5fda4919166de3fb6e5b5a221227dc916c9c5705bdda274366ea52bfb754c15c57c3feaa7c52c7f0799719ac777e8fcfd9dd46933d56bffdbaeb2d34de93322ba4282e77bd79358333d9ebb55884ee4f4b188db57aea4d7722889935912f8ed9cf7ed93d58afbbcaac38e5e041687f7191ed372f7c5a689d8382111d6f5466dc55a948cc691287b2433e5a48b8d67ea178611a41285f769a3c19592d07086f44db0d1f87691b29e388cbd32d85cf4f78aa320f37ffe4a465ee089ab28a8edd38a6703a2b8de82272b7491922034ff4cbcae1bb9a87987a88bd074a3da7d35011f92206da49517849a2ebabcf1e37d202912f13433e7502759fe47d7e5b8856136b75318090f44f20dcf573c1fcfdadc5c1e44252b93841379141ef611bed34beb6eb8bdc5428b515f538309dae9e4d4c6a032758bf749cb91506877a5b09d175261233e1b6254a95703f78a7d720ac3cd20a349dc851985b550cecd413233fef6167d9606a394cb541b405726a28ca400f40388a8fb5fefb3c8fbf3f6bde74eb9454cf2ed59c895f061e86190da3400547275d7995d2d3d608b17c21d7998201cf41c5fdd4ebbf79b6b2872d467816391a6ebef0719fea66f921fba8f38948717a622256e0e2bf263bf14a0b4dd01a4520eb725f748ad59d5458b7ee48d3a37afd066417858ef96acb2e658e78a03df69c37cd4a7cbfaa7551bc86ffe8e22baaee689d342020fb0c9322e02b4331b15488ebe114927e50b3b4b06d01248bed7e0bf78be16249cd7e40055f37de1810a1a910c60a860069b10992de2a2d753403615e77b6aa5cddfcfca0c6ba75c6a4d7be319e38300b7e7d36638b5fd3f27dc2854c44c2a13be23788e40549cbe6c3e024c4fe15b3e78f8997548fab9e9081d81567986c3b9196025bc64f2ef16bcb0bab8b6b37263097b6902e8a375f169c3c6a7c0e59064d7aa7c7198184bfda1a329e84f18c599c73750f1060ae5a2d0ff10218964af05c825bbfde7655729cd4de56b0e4565ed15881ac969694f093813690c3ce6247ab9d53850d5ca2adaeb3126b58ffc2c3c7398108d47f64f917882dd9e856040e77f6874dc7c9786c0f3d289712eead8d18b70f45c8ca96dcf1df44b9042176c5691239522f0555a38e011ad6d627800473f06af0e00cebd66f7c51b58c31632ec7ace4682938cfcab5488b6f87a64278cbbb6113195576e250b2b111c001fd79e7b09904ee90290bdf55a3504d036b7e2aab2594377bc06df582a5cdb6e02f202eee814a0fae51781453ed50471cdad0862f63704bfd6d47325bc72a5ae1f0c97eca7951ee88872acb8df1247d87d702c0222f4002cdb2b49496db3345b008616b03f1752e287553a0fd7bbeb2a9539519b0133b585b068c5f86f0be4b0e503444c0892b4302fee1045864d959c0c189efdd8c2c60906e8926a0e7d7a8c329e8b9a37e1774e0254390794b719e789fc449666eaa84b5f88da86d908ec3820b3988bc2093cd54f6e9e336cddbe25bb9b5648ad0849a156f40cdabb64e677cd74b234f22a2e618ed94060c4ed56b550f11af900ec920873b115a5604abd08f710932228bd81d75d66cb0d733e93deaaf1f5da4ff7c5e711ca79b20b1433dc556d2a4439216f2639b1fef664ecb10ac114296bb6dfa807ea3180bee954e05300484598bc683b413861c06d06b76423fa55b45fb1680eb04a6acca49013a0038832b96361d052c0964327eae4fa49cf13d2edefaef35e9f697d95aa167fa6d63c76a7b6ce59e4694d857ea95a1639abd1f2cc35c360a427b5db5c8a59733ece219964608136b8d8093f1f8c65ca456f9be75b50e35171129ae2a111c0d6b66c0eb683db7bbf44b0d57f76847d3c018d17279e6550eec9c48bc34e5d409123cef6849e0f7b6b9bbf0ce991d293f3a97cb638bd77117832ca1e679132acd51921ced06640764dea0bd00df467af39e335d3d578cd18c9fc3ec0e2f3afb7e8aabc5480c05fdc799491a4dc614c0205f87f1e34d71976b25b4d36878ce23b44acbd6e82278639b5758ee03e46490c2f390e8a8e5a639ba540cadd57a88f1cdade0b41fd836399f54b5808f23ced5086ead5c51c1a6a69b6581f3caadc68880a19839d048dc5b72de7b9ff14ccf80b10cab71526d8adb1b96312dfb73c0353a32c3a9606cbcd90911cd72a733c9ccb576cae87dfff9e255f31f9a533f643d6531ed3c395d6e458b8050c0a0c5b6157ad6c183d17cd03f6251c2d1d7a3cf3348311a740ebcb9c7b2282d25ab55f976c5e70d96857e4c9cc38596611e1fb3db35a0f2f20a47954dd2fdd73c9b16f13f46221746243edcb4641c406cf8c63848520b76c3dc5d4e0210cbd63881e59de225215ed3a6635b8c4578f3fcffcb3605abfec52962bde3af27b809cf111196964310e82107633d6104da3d395b697eff1555c2af0d4f28b166176ad29e11c8d4dbbd38c4aee132f8245f6b371663d4426c6096bb98ff071ade71a2739e0eee4890a8f8d1109a27ef0f4bcb8138b4c6f3f7730c30b6a33dcc1692519a1f7a3566e74aae814d93be543be6b68133b7616f7c22176833097a40270f3f383e0db7c739905ba02a7732183357c173e1dccfac2017d693359e1d3268f1e9a4f2c61b8848288e9134bd4a983882b18b04676ccbb9d12a5512d9c66781df926797e912b308a2359769047c4e10d1f49ee28c7502cad06bfcb4d93d758be4fe4fd0fbfd9ba5c2e82db73a419eb3ee071add71d1123286dc09b901c542de928464a4753e897f31472f79cc164d41bab7cd65b259fb8c142d202a3da1526c0e94bd824c886bc007964f2658ee654ae0190da19208a81178deb2dae86137c64e79778a603e116b0cadd1713af92c736c1cd5b5c3cc0c7fe63fbad5e11794210157776cb5f2b780725b5ae3f75b67dd133b79d9fff0e56a0e80161f1b25bbed1617e7586ff7c0d220b7fb50bc2229d259d5595cfd88ffba4f8860811295f28a1b1cac4f96da86500fbc6df323809300e99533a38fefb57a694d98011d05c044f94143a5fbe8a420a41d34d99504c3faec14321d85bcea009772318e0630a77492639be3dfbd52126d0f0438d379df19b583bdbe0271fa6fd7ae400747f9f7836fdd60774bbf9ecbb372c9d07383181f5d082f8a522f64ce63e33c7b07a166913480367b7aa5162e0a0d2d175c8f21c50b9398aa2525b8aa17896b47cacba7fa04876688917bcdd67c805154f195fc907a97c59dd3aa9ca295c7849fd5d511f3487af3d95b58195e77a719347546dd4f9ef9f1dc94ee08049778da8a6154f20209f57040582fd7461b205b26090540036b1b3390d6a1399242c174fdc99b8829570052743c934563f6b5e1b4dba5e1c08902f144a4fd7aff252d6f0ad33e19934c7d03c22cd898e78f29db7a990a82895dc128477840dff3eb6b0c77d8d9cd931999b56c16a3e11bb630cf267421e944d313d815fba766a18fc51970afb70c746b61f2647df86e947894f8751662436bed92719ebc41c43b1899700d9eb5e6b400102f404ab73e9329cf45106ba2a80c011e98635d3867f70916c06645eaecd5e77ba75473a79600533a9a4105d3bc527e30781b11feeb1ce7788f96efc25cdc964d176e42aa30498eb52a083305b2b8813d03f1e9aeada3f8a101ec5b7f7368b7016e210a593947b350758c7d063f666f9c029153e2e0aa13d5b4533ec4a0b973f74bc9812262907e54ab6025bb857912aee7272d5766ee6b079e54120f7f9ab021adcaa5b5c0ccf41eadb33098a3fd40de1bba4481d77b485ed8bd9270dace82870d2af34b50a9e90a3117315dd4a567c22b7eb824bda3123fcbcd6e7e5e27924d6f5602a0c3bf1c73c30ebc2e32d91dda9756593c82ca8e7d549297237b7cc8b2d16a6033996a302e2c96324edaa2a71b2a8b5d08211fb2138cea4c45f49eca4b37fa2c188be312bf179f5ed37f85c80001364f965b02e341fb45ce87522356a9eac6910510ea0fda5089051ab9baab253b143b08afed3d33974d79c1d7fe9546293c69ccb90a30de9ca21bcdd7dd254570ca4dced37732ff11a3c5b7b176d5782028a24b9c820700dbd23fff242fb5e8556f1651a7471e6c3defee06b88982813dff0afc3ae54a0863ac13fbe4a5561536820183e0d44ed5337222002e53989fe528091c30e2862b4303148702752f4a1d59cb65b60c00d0a23b19341d932c13c0f31c5cf756bff4a1b005d52af4639cdce0ecbc2feaf86a0b80fb2a1b21ede7cffee8f499e077292cd2984e2dd27ac050a3ca942f674919e424e731810b35b409f9a425b1093f38718efd6f66145bbce20ab14f0b0cf5d147eb82e57e1d4e6df5bce59df78796eb259c8c0947fa200ad5e74054a08154c5d27cff42a7ddc14016b72646182fddb904f11df3819344c67381b95506bc80d084f39ded914ebfaa4345c57c7aa29ae7cd52ddfbcb6acd994f909d948df92d127633e9ab40031265d25a21221cfd43eb83ea6bb6580abd31d4043f030b735ea459bb1c3a2011a3773ffe633fcf2a27740fe48626e064b9f72f8fb1d2b85a921d248fa44ca4b278a4b425f11c92c6f40dc63b2618fee2a60c17b163988a9d7c4ac1dba8c0fb14eff4c0d96e9b058714f38e9c0104b89c3d26cabc2c30eddbc19aabede9dd33fbb885adf3e2bbc9830315b779ab2e7f5e388075d5fc15c8f25391b3a8fee86a9cf67f3baea8f11540beed510bb936943d6790840c278e65efd4b577ddeb22fe1384d5768e6f70ca72534ce806137714251650997e1554d12608ea4b9da0c0c7e3310069d3c7d4175266ad4045b42770e6173c086006309f1ec1beb9fb66d610410028ec7b109c6ce9c2e85c1fd8f9dfd75935afc17281014824772479c1ca66c9d1ad6a2f04ebfb3421ceb879361f2319dde94a6a53984839f71d4135e7b7d0fb97c89ac0533ffc56a1c72616e0a8268ef9036eec4056907a1dedfee6242757c10d6e8f155f59ea9638c604c18ab13eb0030052dba4cb9da527117877aff57700c8f33e8d8065103001ea6454c5e1d6f08602f4cec91eb925c740fd751df1849c604a95110709efd1a9244040987239d31081f76c45252c4d5cafc8defeb7f2ead8e4bd83c4fe8c60966a37e44a3cf211373e6c0a8ec5b430dbce35a548efd2a905899b695ca82a65c7af22e2248f368dd8fd0471725a0b7b441299a1613019e5b9f35cd8c3cf9b8230f8fb1d1c4b58954b2118553d49fe6db2c795434057267398f8dd5236e2ec2526d935c603787a6835e19a0e26b4584c4500e0025787131e71897778a5bf06a95da8b1e20e92a25000a3efdd0061041d554df54a9469a29fb05e65bc189126de7ac5d651b71959ba4891c7b22b2de7d382bf18a3afa4d856cad26f649bb742eceedaa7fca4aeab623d73d97ffca4fe4b95218c2fd81d9768e398455e2cd0c8020fbe51cd83c0fc292d079263dc8886177a0df9e7bc7d73519ac022145aedd5f415b1c7068364ec7d2e1615854895a5577d7f9da46b98feb2aee9d7a64f8db9cbe64f9b0faa3f2021cb636c6d7a0b4029a035a94c0678466587abb1ddf6254ba0c52732c9dd7f02a0801856b6991dfeaa816a82dc2518f9dbcb62e70443c3065d2eceb6c38f1d853023e8d70e40e866f8bbe32bcae8e6739dd4f1b24864be3c5b553e16af8a6c302e6412f3a145038250647befd4a9f6e5b07e9e8f789bc48fc9495928d7ccebc1750b8a0c045a47ce333b4daed05013249d37bcec4c28afcc49080fc6119337802ad9a2a75cf5a18cd0ed861ff50125e8709fc59a873b1cf58380eb8834c67f564d482428525876dc0dd2327f045a5bd1dffbf9351347934458c767ac859470c5e359a0594b29c4f392cf9bf35be9ab58f583a6e53a985a85f64d8205cadec8509f446f3742e3232edcafe10b98d2e18ff56bfd93b24301a2a6665bcc87ff050217eb1928c72100f4c5a13b8ba4aa83a7b0699d2f6a2eed56a6e9121a37e9d7801ec143d3b6f009f6bd483533d24e3f6863c82d73d3029cdeb47b2d3f2524efa2b66a76ba90f98bf7a13c9b005c00221e99a25ad6e4b67dbe32af0b3dce8024d3d803a208b41b08dd7b11bec8f4d20cd3bf93786d81e7c2b502f19b2a62bee2de458a1126ae969b1c613aaa227a3e1287ad3a14b9857a75ef07f5b880801677808442c0cdf11f1b2e2c6e34a4fd875c574d606495442dfb300e830246b48a8a7f84963bc1d6c47b54017cbc90af04e220b22fe1bb627dd5cd89b8aecbecce288ede8a41c8278bb2f4cb82402e27275f728fa28130ba3b84718854ea08c5bb768c2a1b0dd76592e2a06b13a78b90cbb4ca4b958a8976e4585122b95513a053c31587cf6817a35a24f0eebc9f06a96e55e96eb9f135d1a1a1e565f3423ae3c22b48b0da16ef690a43ec25424beb901c7bf96b78b47ed05bd75b7d8388cb9c52fd465bcb5aee5c288eb3c4a74dfba5374f3fb84e30cf1e7b55207030a18b319bc1216c076ce49bbcd050b09ebf2e452e2fa318faaf7907130149640bec78e4beb98b3cc21fc36b2a7526687be5b0e4d876c2d0f7946183fd5c7e60ef58af10049ea3867ca997a72ab8e37baddc90b3192d696e6e9b569333ace709eb017885b912d16ef7783c63edfde51e96ca70521cfde3e35278d52047458b93c40fe81285d71292c692d8f2cb185e8a65716e3c12b7f067a87633406a940f37904e66a86a26c279e442d227a92aea5ea8bcee0e5f22a4c95d14c8491c689ad8baae550ea863ce01104b13c19348169569b8c956acda6eac45d3b1d6a40a08511e11b1c4f64f701054737e13996dd69eb85e4635beb508a6dbe0452467aa9a22c96c446fd5ceda4177949db09a009eb9bbf07b6be0901579b674ca8daa497a987b55e52ff6592c8990d2b6ad8b4ea7335ae9563e447eefa03c3426553800b35faef3139eb7df0315d0c561d47062e6ac6c4940a6b3d1291680bdb825a2b768ddce48bdcbf49357272c02dd9100d249faca8875ddb58241924cbe1cc491c267f1a1c21fc91059469caca3c463ac39b3e90e2968ff4357a34e2d2471e321f243de1388863605131464efb0b454d0c89170f28d8cdf9cc46d02bcb2559f8944d69cf2a14f42e25447f8b2cc00b7c086c3471b56f791c6f618a3426a999424073f22e400afa7eda407d85dbd3eac2d9da4da2beaa7a60090af536671fe4f5a54f80c4c19afbc34ad0902707d645b4d0778d195f7de1b2ea10c9911cad3bbcf956724d3644b9b5cda6bd29017e453946383eb1311f8619b635386ca1fd7f1cab694032291a940806db09ee30d9607d8986e84e1ab45be47272d82652605fef4d157240504c367bfa0dce60ef4f80a5d91c1d0ea3a25bb39ac45f89f15ba859941683b440b4dc5a57758fec89602762a069982968ff45c4db263a53a520df535900155f4727946f19645c3b99290eb8ce3e8abba655a8c5e124ac4127856dbc21519164d02f45c0bbcce78670c0f38d6d067e339b3ae37b43e4d2b988bd573fa39399e7f9244c2f60262d4707fc69a8939d0256020bba75e147752963fd645d8f37f9756aac6436b8737c54ca906bcc4ee386be052fcb3f808ec351d90ec896c8841a1d695a0810680850ea1868fd0dda41367277bea184ca910a48ea2b374d9f4e93d8de0d92f892146efdf85ae47759228e1ba7568a3d2e2a82c23c9e0321301f2d9287d714553c266930182611436324b5b63d16de03c197880702385ecff2e176433e2bde93029e45a5e694f8556054bda27936543e31f48f9963d42a06bc62e21ef7f339312e8d33b2e0561cd5a16cc792ad627c849e17b6eac5232f842d2b522ee3fe38f419233ef54ff663e210b3c9239e77bfbbd5ec700f8b16d19aebc5394406fd753505f5d7e3e9eea79bf0460cab2c86ae8dee8e550b2ecdefdff67383c80e67bce915b0d1632c185b4974afe33e2c5ec23243f85ff353a0f10a41826e0d67d1a78aa59e1cbcaf773db1b5085268949b01a15d087f0322d99fc58c846f999e0f9bd488f6580cc95639fbfbdf74a60574a1cc6ce4a8c9faa581c3804bff7084bcbe817ae8a5155129c85c26066a1cfd9408c2e3838181f8e20bb9743398a1df4165714f2e14041069adbcb9d55ed3d89f003a41bfb43102b4e0c1725f215b43a3413ed3d085692f60ccc03ee2a6c1a3de2f31e5dcbf8204430339a7029759149aafc313ab7765b2d449a0d58a272c9cf37676f2c36a23092a725bd87d7cee5668ba954f39cdfc99a7297c4c901fe5ea59e2991124b7f424699fd92d06813f04473db861f0d4fa0a65745390dfaac389f80336c308630bd0c89de7bbc12044b64171ea37908fe7680c34e4b823c224a93f3f9a9ae1499cd24fa67a22498ec0bb9423ebe58c682547b0e74b8b0bf7a8c32aa759db278d90085d19f4f2239e3226c88af5f4628e3d2aeb7cbedcdd0b83fa982d83ddac0d76c8be581309d279e917855fbe2015104315864a5bdd0bb288cbec960957c099014090714cc86ebd2c1ea9790cebff6e63da538d5637c7ead53d1a7a59b87a11ae43b609b64d55e2ef47041860966b4345b993fb80eea418b20b87b8a19a5ca78c707746feabe32e04bb017aba814791213e9eaf80cdd446922a348bd66290e5e08899c70ca792e547e781ecd842e394df3af40fc13e69c1884ed7e064818d5d93b00f84e15c2db1c2ceb6ce51713f25135167003efaf56a7085c4b8eb4860ddeec58f7764f3afd966b15f1aa099509a0405659602db596965f445aba02c05f3222729bc7db3c7c0f628215c40c5ed28a671b0397acf06d94aa39c35281850e70af7293a89003f74b520d2e76364dd105c0d0078516c336c1f4cae4319960e7defbd8170e6533bf48af42b586601d793a00052d55f2d92794843d6835982a7451a7f8e51750b02428fa0f170ebceb0193566859c77f29d41bfc936540c57ce5e5004a2e1ab97e3e5be4e24a1b7aab3957189952eb6c68b2508eece3402d33613540221b93b9e28d9f175f250db6fc572cd725af55dab621870a0f238b682a553c916a883e0f34594796ccc01c22a04320388dd40913b3168e1afc493356d95464f5008f99d3ea4fd89229cc8c6124a155a6f66f866bf408ede94767c1f8658bcaaf3fd3acba01a6d8b20eb6ed585061a6f0f39cb642ef13aa2837ca0d925d578658e99f13665720432eced7e405ba4c1cc62431c57e013d28d45ff926b0a24eec335bd012708b61e696cce9a58a6eec7215360a6135ee10ba6efb2c696199f74da92c03a5b1354876f8ad9847fe6d878ea6263976acb109a2bc18956ef9523a544d9587d86d1c2d0f87099bb01a986f61318bb97855f52076c04c0db763d3fca111fd9ff130c41affd9d67c9a13a573a96f72fa1fa2072c6ab3339ac3b569a8ccdc57a3f3be4e07dac89c35425cd09c7f52d83862ae9fc4a8728ae93bd794dc284c33e21fed24a533176765d2412bb1b8becf393c2ca93362cd5576cc8c61e6e6ec57a54bca791be8bc20320da55fde2987324f31be143df168bb76960ef6acff6972853da6f4f70e267195b9f697529c32c5b3ca39cef290651bc03fd1cedbd843d4b526da7e5ca7ad8f18d40e4f142b8372d032a61b717ae72f4a19aa9fd0005916c5de4971f78701cafea9086447cf54b4ce026bd7e4a2cd01a16c2365de88fdd0c07c19fc8a60e671efbc4d88fcf714c73b237d62c842a7547d28cf873a8f9a043199d25cadf357857ff081b745d190224f0901733561c7c4eda17f76f142dec0a66c01390588e028f81ec137569cb670470d196cd576e79a5d5409f77b8abfd4f87be0a99254720279525b11f38bb3ebb825926087cbd8d49fbb705be60d77a290bad50143dc4b1a619e9898bedbb12395fdebe9da337801f33eb7c08d30084b532d9d0731f71bb9153a4a7488084cb80377607ceda11f4e8dc5475238ef7b51d96eb74c4baf0a0a1c976252e045d306f7ff17eeba13ce365c806975145c058aac495c8629041c10644800068334d5ed7afb21a45d11d5e3033b795428225d5bbfa106db8bda2e828f996a5bd93d3d3526d15a85938d61ae543e879d7d6ca0760da3c3914408264a545f4ed266be1bd58b7a15bf56447661510f89118d31d53872d0dac893af1bae7e1f757f5fd05bc154e7a5c8a7ad53db8c4be50dba2875c89837bdea2fdc9cc649e80be77c03ff6ec720a00723a883a830f1915259cc8106fef973fbb68bbb1962870547ea81aa7c28b4475771c92f58b982380b040a3b316dc1ff2fa029b56b80aabc03c917c2d876b825d04b9b9abfba60ceef2fb802e6c488436a57273904ff4b94a632e888cad10d87a4f5614c651dbce588d1abece2ee2535d18eb765ac0914527874a88eae7ad2efcf4725bc819c379205d1ae06e77a2510d6f33c14d9e27f9afb995a5649e2e53491faac05192539b3518df411aec9dffe29e697c885da3e4b5128b03847046886e4edaa300b10b4d510f904eca11277bfd7a359d6734516f48935aad7c0816341362fd35c9c84e057b79d395d6e9af06f98f28ca55f1eac720e23488d1ead621a42cd5e9e41fa7d1236dac55d5033a42db579afd902d8178f2e1f7db7a35b27753bebbb3def83481c7df93437397c8fae7b0c773f2e83da19fe3ea1f19952c23163bd897f1f1b6d6164291a5229acc8a4e07c418093cc38f6a0c4de3b1e8fedda4a051aa7250a137f0024fe9aab0811a256cdc29810d7d3baf1c063433e928dd16792a1d22d908d3c8b125a710550eb7a5365db1b0378cda609c18ccc85a9ff43acfd85f981bf4adfb6bf1075eb8952d759dacde02cb5f6d0fcbef7280debe6a542481864bb12831bf47a2355a291ecc2127dff4efdeabbdc9b920d569f204fec1c2927d5ad6cd3300d56ebf76223da5ba0996a653b99f62592cc65e1396ac0108810d024cc00bb9856225090a33548e23cd5ce184cc68ac0bfea72b1ce1952d0f8c548cc40dbfe30a1afac92c4c24fa19a29ffeefc22325f9fc3d4711d55ed336d8644127a3202d4362604c05b53243eb23269ea4e49174c74edcfe3e4a495fc58ad6e62c982db6b65a8c3ba5d16e244170f552f649c355fd0268354d8bbce421eec0cda11a71bcccccda36aebc9b4cd0c0f5d7668dfd268d4864f3d9b0eb1e0eac0a3ac3302bd67892ca749870dd6d0a40103c3adf2b40fa0b4d3fc1e186f669eef00d0e8a0376744cd5d140622775fc5b2378670e7269981dae9b64ae31018812f2f806b115ee7e31f3688120a89f6afa9034f9516c15de23dc697636177fae6e29c000550a9bd9a6261f157b1e43ee6d6e1e639e8c5c02e45cb5bf38aa3f46a6277c4d8f2c7ebed4697f6efedebf375fc572c5393914d1cb9f8ec89ac17e9cb722b621ba9be72819fe83bf89ad187443864a9d4b8474e18f5d8754435a2db236d52ecf4c84ae6bbb5c8903da4f450d07be405105b01bcb0174be6f3e0272b562d21dc489cdc23266d00ff1b7a119c755c17934c53c715c37daf0fcbe0ad3a497717ea45c1db753f914d33d61bd4c996826e029ab3a7d0483e8e683af855e2dab1f98b5b68588e5739acd96c496c68188601a77aea46b72e2b1d143f5c81a4bf16256959011c82e4c9a74c6ea12d7986008b19bfd62b98e9a8653dd5a6a062b1c40128482c95f0d6b42668c22033f100df6c66c9e7f4d7bfba87952025180d6f8f72ca99f0d80e126db311302495428fcf6956a3d092483c631cdd1b4772981aaa901f6e39a9b4da9859b89e90da4879059b6e48453f11680d72b945b0dfb403ae3672e10362a56e237304c937d2b046e7419a48bb9beaf038e065f2a880de76e402f13b7258cb25d25f06648054450922af98aee212fb65c17000305b54689730cd7eaf7f88564a460de9d826cb95899624d7bd6662fd91e85ead6f6d50f0248680929ce3f19df75c7c7a57c5a76886612e213c17295aada697079ccba36519c86a9a77c809f2130ff88bb99bd9bc63b36e34fefabba4371717f7915df46b6e1c9a52598d59f717c1119583f15bf7e2b7e11d832250066efa04ed5d7d6b90bd3a438a563bd398195282406756ffd607f3dc62934e24ef09155c5a6d361fb587da6bc48c6c85d334b182c703b850b0df971ba0d3e955bbc12917c9cdc511cf8a0f568d3347830d4dcf6a509d5f6929faf8053bbc3fdcf0cc16651aeeb7ec214ed44f53c336467ac0faa160dcb986a814a478c3deb1c421989fe27d5cd106d3fcbc5a8df05a1edb52eefc6379f00c373c68ff3877d05be1106869875a78112b5ba48992f8b956f4f265803a612472937ed9ea978962a4cdccb7b6315114c63880e51b1908feda654a031fdc40390209271a63f48a0423ef788c713cc306c6a2c201b907c558786740fd109697b</script>
  <div class="hbe hbe-content">
    <div class="hbe hbe-input hbe-input-default">
      <input class="hbe hbe-input-field hbe-input-field-default" type="password" id="hbePass">
      <label class="hbe hbe-input-label hbe-input-label-default" for="hbePass">
        <span class="hbe hbe-input-label-content hbe-input-label-content-default">Hey, password is required here.</span>
      </label>
    </div>
  </div>
</div>
<script data-pjax src="/lib/hbe.js"></script><link href="/css/hbe.style.css" rel="stylesheet" type="text/css">]]></content>
  </entry>
  <entry>
    <title>2022.11.28 - 2022.12.2</title>
    <url>/2022/12/04/week-14/</url>
    <content><![CDATA[<div class="hbe hbe-container" id="hexo-blog-encrypt" data-wpm="Oh, this is an invalid password. Check and try again, please." data-whm="OOPS, these decrypted content may changed, but you can still have a look.">
  <script id="hbeData" type="hbeData" data-hmacdigest="748b378dc28a70d895e130534829cb08a2cb1bb5e8e5862d667d61cd378e147b">a99f2d1cd7f89812758242c57c62a59fe859e32cc19116fcceb1abacce500da0960986acd07eddb3568f524414b51feed3332575568d42f2bbfe4dcf99bfddd5773c87d1cc59ce3f2f4d7a276666dfa8cc76af005aa1f53441d36c4a758caa8686abd05978c3e186ba89546ed87783e91e2619fcaed1dbdf76785229c00007d70b810c0bb2483e54ebf43a50d21031694e6f13f2d7fe286d0884b9f8b71a160f2d834061f905d64b773ef89b71b919cb6033bca1c3815c9844c083e92f9f7004341dbc1980bf521cfdf66393efc03e050c3801ba3b6f9785042f7257c8511d5e2a73917bed8fa8de815b69ec7fbb570bb134b05633f6bd0f64566aa9e6870785783774edf87268f541e4e9efec31270427256d11d8a2028aae27cdee06263d04f3b9f0883c72650576913497085f1bd8431e3432294aa18b9bd9e7361e8de4a404d5d501f3d3f2e2697e47442f8cdfbb2eb66054aef8a02f478a36d6572da3e988115ca818fbf5520996687abdb34a089f11f1a6fc94e5bae9fc2503d270cbe2666f3c829436bfd615a27c25af717f2b06fffca226418e38e1eec1d8e342b189ca59873eda18fb0158cfcf3793e7ff2f31a0a0e99df4e23f6128fca8321420844960d96f57035bb1d141e51210fcca885589bb15b959532e27b29a04d5d248fee6c84ef2218a7b19635f91d29b62918b4f27fbccf0f30d6cf033c4df8589b44adf20897956c9324cd8898a47d238bfcb436ea79de39da47baee6c4fd4c470105e5d1aabe7d958c8e3fc84dba7996570afad97fba38774bbb6b131c33aac3500e2f094ccc055d27a7712752eb60a2e498fd3b35522e797527d820423b251881b53d9b6043042314478d49cd37985d6841e9cf8be66b5bfca18d8700f7c537172b1495c72954995fcb34221e492e66e2171026db4a599933e1c4a3cfea23e8d58fbb261b14540610eaa2ae092f102fe9b2c3e26b96e9b088b2aca8b04328e9cf6dc6779294a9ab9d29d1a2a522caa2789467ba3c66b60afbed2b536a23b93e5f4faf45af7e2a242dccf9bc2567b921033c102acee832e28e30ed673f76caae0c50796abd3795ec9fc4387aec3acc25a687df1fc60dd63ea9164c72d8e057f9107786018a262953dce6620115f4770038c30b1f16ab3c3479a263278e33da801d4036b2776a0f6ab114992a97c4aa2b8e52accf5107bac075a4f155742d18522d57cbb829a96d2281a9117bc1852979185128d84a486cabaa22c30bcb0ee0e9734a24b2f02216e5b21513025059fbf4a66ea96d9868b6f785f7784e937c7f55f2effe624b6b6ff957046c6e1ca142113c21a223651a79b6dd81911d0e0a2b05624d8e74f30614e381b6cdfdf38222490f0ebaa5f755ea29afa177c2500be7f66bee26820b64b27a17f649a59c2c0b526070191f698a4914524b2375cd9ae0b4623edf5d86f46cd6ebd2b66033e736a1b43aded3e535413e497c9e27e1981744788bbdc1366841745c48a6cfab419440902bc2c299ec1d554ca4d7cde4dbad1b7b1ef1501e30eedd285e44e0236db16356e8b6df975b4c65c0657af1706bd7553ce5f3590c9a824983961a7640f9fcb1dd6c7e41cc4627c067ace70cc54b5f2a5289d1056f5af3aadebc6a2baafa8537a0a03dc912437ae0bb329f6432b61af8e5c182fb5f2634cfc233f7ccc9adf6dc642a5686e7b3fe0cfc69db17f91dc66de2ea691ccbcaca8f9ffe665875f1053bc2ebad93b60464f38dee7390bc05eff1fb7ae1e97e1495110caee4e49cbbb0ed35f81442226a1e9f0f3606d84b9a6713aba085d068a26f2d81e538422f87fe578d66</script>
  <div class="hbe hbe-content">
    <div class="hbe hbe-input hbe-input-default">
      <input class="hbe hbe-input-field hbe-input-field-default" type="password" id="hbePass">
      <label class="hbe hbe-input-label hbe-input-label-default" for="hbePass">
        <span class="hbe hbe-input-label-content hbe-input-label-content-default">Hey, password is required here.</span>
      </label>
    </div>
  </div>
</div>
<script data-pjax src="/lib/hbe.js"></script><link href="/css/hbe.style.css" rel="stylesheet" type="text/css">]]></content>
  </entry>
  <entry>
    <title>Spring Boot</title>
    <url>/2022/05/22/spring-boot/</url>
    <content><![CDATA[<h1 id="1、总概"><a href="#1、总概" class="headerlink" title="1、总概"></a>1、总概</h1><p>Spring 是以<strong>简化 Java EE 应用程序的开发</strong>为目标而创建的</p>
<ul>
<li>Spring 2.5 引入了基于注解的组件扫描，这消除了大量针对应用程序自身组件的显式 XML 配置；</li>
<li>Spring 3.0 引入了基于 Java 的配置，这是一种比 XML 更加安全的配置方式；</li>
<li>但在使用 Spring 的过程中，依旧无法避免基于 XML 的配置方式。</li>
</ul>
<p>Spring Boot是以<strong>简化 Spring 的配置</strong>为目标而创建的</p>
<ul>
<li>Spring Boot 是约定优先于配置理念下的产物，通过约定来降低开发人员的配置工作，会默认读取一些配置文件来进行属性配置</li>
<li>Spring Boot 会通过自动配置自动生成一些 JavaBean 并加载到 Spring 的应用上下文中，可以极大地简化 Spring 配置</li>
<li>Spring Boot 还内嵌了常见的 Web 服务器，可以帮助轻松创建可运行的独立应用程序，实现开箱即用，快速开发</li>
</ul>
<h1 id="2、使用介绍"><a href="#2、使用介绍" class="headerlink" title="2、使用介绍"></a>2、使用介绍</h1><h2 id="2-1-启动类"><a href="#2-1-启动类" class="headerlink" title="2.1 启动类"></a>2.1 启动类</h2><p>Spring Boot 要求<code>main()</code>方法所在的启动类：</p>
<ul>
<li><p>必须放到根 package 下；</p>
</li>
<li><p>命名不做要求，但一般是以 Application 为后缀命名；</p>
</li>
<li><p>使用<code>@SpringBootApplication</code>注解标注；</p>
</li>
<li><p>可以通过<code>@SpringBootApplication(exclude = &#123;...&#125;)</code>或者<code>@EnableAutoConfiguration(exclude = &#123;...&#125;)</code>来指定禁用的自动配置。</p>
</li>
</ul>
<p><code>@SpringBootApplication</code>等同于以下三个注解的集合：</p>
<ul>
<li><p><code>@SpringBootConfiguration</code>：支持在上下文中注册额外的 Bean 或导入额外的配置类，是 Spring 的标准的<code>@Configuration</code>的替代，有助于在集成测试中进行配置检测；</p>
</li>
<li><p><code>@EnableAutoConfiguration</code>：启用 SpringBoot 的自动装配机制（自动扫描+条件装配），详细介绍见3.1节；</p>
</li>
<li><p><code>@ComponentScan</code>：扫描被声明为 JavaBean 的类。</p>
</li>
</ul>
<h2 id="2-2-默认约定"><a href="#2-2-默认约定" class="headerlink" title="2.2 默认约定"></a>2.2 默认约定</h2><p>1）Spring Boot 默认约定采用 Maven 的目录结构。</p>
<p>2）Spring Boot 默认内置了嵌入式的 Web 容器，支持四种嵌入式 Web 容器：Tomcat、Jetty、Undertow、Reactor。</p>
<p>3）Spring Boot 默认约定的配置文件是<code>application.yml</code>：</p>
<ul>
<li><p>Spring Boot 几乎所有的配置项都可以在这个文件中配置，如果不配置，则使用默认项；</p>
</li>
<li><p>文件位于<code>src/main/resources</code>目录下；</p>
</li>
<li><p>文件名必须是<code>application</code>而不是其他名称;</p>
</li>
<li><p>文件后缀采用<code>.yml</code>（<a href="https://yaml.org/">YAML</a>）或者<code>.properties</code>，后者的优先级更高；</p>
</li>
<li><p>层级格式的<code>.yml</code>文件比<code>key=value</code>格式的<code>.properties</code>文件更易读；</p>
</li>
<li><p>使用<code>.yml</code>时：</p>
<ul>
<li><p>属性名的值和冒号中间必须是空格；</p>
</li>
<li><p>大小写敏感；</p>
</li>
<li><p>使用空格缩进表示层级关系；</p>
</li>
<li><p>缩进时不能使用 tab，只能空格；</p>
</li>
<li><p>缩进的空格数目不重要，只要相同层级的元素左侧对齐即可；</p>
</li>
<li><p><code>#</code>表示注释，从这个字符一直到行尾，都会被解析器忽略。</p>
</li>
</ul>
</li>
<li><p>在配置文件中配置<code>server.shutdown=graceful</code>可以使得应用优雅停机</p>
<ul>
<li><p>即不再接受新的请求，并等待正在进行的请求处理完成；</p>
</li>
<li><p>等待时间默认是 30 秒，可以通过<code>spring.lifecycle.timeout-per-shutdown-phase=2m</code>来自定义为 2 分钟。</p>
</li>
</ul>
</li>
</ul>
<h2 id="2-3-优先级配置"><a href="#2-3-优先级配置" class="headerlink" title="2.3 优先级配置"></a>2.3 优先级配置</h2><p>Spring Boot 提供了一种优先级配置的机制，优先级高的配置会覆盖优先级低的配置。</p>
<ul>
<li><p>优先级最高的是命令行参数配置；</p>
<ul>
<li><p>命令行参数的优先级之所以被设置为最高，是因为可以方便我们在测试或生产环境中快速地修改配置参数值，而不需要重新打包和部署应用；</p>
</li>
<li><p>以<code>--</code>开头的命令行参数会被转化成应用中可以使用的配置参数，如<code>--name = Alex</code> 会设置配置参数<code>name</code> 的值为<code>Alex</code>；</p>
</li>
</ul>
</li>
<li><p>不同位置的配置文件的优先级从高到低依次为：</p>
<ul>
<li><p>项目目录的<code>/config</code>子目录；</p>
</li>
<li><p>项目目录；</p>
</li>
<li><p><code>src/main/resources/config</code>子目录；</p>
</li>
<li><p><code>src/main/resources</code>子目录（默认配置）；</p>
</li>
</ul>
</li>
<li><p>配置文件的优先级高于应用Java配置类：</p>
<ul>
<li><p>任何<code>@Component</code>或<code>@Configuration</code>都能注解<code>@Profile</code>，从而限制加载它的环境；</p>
</li>
<li><p>通常的应用部署会包含开发、测试、预发和生产等若干个环境。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@Profile(&quot;production&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ProductionConfiguration</span> &#123;...&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ul>
<h2 id="2-4-读取配置信息"><a href="#2-4-读取配置信息" class="headerlink" title="2.4 读取配置信息"></a>2.4 读取配置信息</h2><p>Spring Boot 可以通过以下方式来读取配置信息：</p>
<ul>
<li><p><code>@Value(&quot;$&#123;property&#125;&quot;)</code>：适用于只需获取某单一配置项的值的场景；</p>
</li>
<li><p><code>@ConfigurationProperties(prefix = &quot;xxx&quot;)</code>：使用该注解来定义一个<code>XXXProperties </code>类或者<code>getXXXProperties</code>方法，读取以 key 以<code>xxx</code>为前缀的信息，适用于需要批量获取多个配置项的场景；</p>
<ul>
<li><p>配合<code>@Validated</code>注解可以对参数实现校验功能。</p>
</li>
<li><p><code>XXXProperties </code>类配合<code>@Component</code>注解或者<code>getXXXProperties</code>方法配合<code>@Bean </code>注解就能像使用普通 JavaBean 一样，将<code>XXXProperties </code>类注入到其他类中使用；</p>
</li>
<li><p>如果不使用<code>@Component</code>或则<code>@Bean </code>注解将其声明为 Bean，那么需要在启动类或者被加载的配置类上标注<code>@EnableConfigurationProperties(XXXProperties.class)</code>注解来注册<code>XXXProperties </code>。</p>
</li>
</ul>
</li>
<li><p><code>@PropertySource(&quot;classpath:xxx.properties&quot;)</code>：使用该注解来定义一个类，读取指定的<code>.properties</code> 文件中的信息（<code>.yml</code>文件不行），同样可以将该类声明为一个 JavaBean。</p>
</li>
</ul>
<h2 id="2-5-过滤配置类"><a href="#2-5-过滤配置类" class="headerlink" title="2.5 过滤配置类"></a>2.5 过滤配置类</h2><p>可以通过<code>@Conditional</code>及其派生注解来判断是否过滤候选的配置类，被过滤的配置类不会被 SpringBoot 的自动装配机制加载，详细介绍见3.1节</p>
<table>
<thead>
<tr>
<th align="center"><code>@Conditional</code>派生注解</th>
<th align="center">判断条件</th>
</tr>
</thead>
<tbody><tr>
<td align="center"><code>@ConditionalOnJava</code></td>
<td align="center">系统的java版本是否符合要求</td>
</tr>
<tr>
<td align="center"><code>@ConditionalOnBean</code></td>
<td align="center">容器中存在指定Bean</td>
</tr>
<tr>
<td align="center"><code>@ConditionalOnMissingBean</code></td>
<td align="center">容器中不存在指定Bean</td>
</tr>
<tr>
<td align="center"><code>@ConditionalOnExpression</code></td>
<td align="center">满足SpEL表达式指定</td>
</tr>
<tr>
<td align="center"><code>@ConditionalOnClass</code></td>
<td align="center">系统中有指定的类</td>
</tr>
<tr>
<td align="center"><code>@ConditionalOnMissingClass</code></td>
<td align="center">系统中没有指定的类</td>
</tr>
<tr>
<td align="center"><code>@ConditionalOnSingleCandidate</code></td>
<td align="center">容器中只有一个指定的Bean，或者这个Bean是首选Bean</td>
</tr>
<tr>
<td align="center"><code>@ConditionalOnProperty</code></td>
<td align="center">系统中指定的属性是否有指定的值</td>
</tr>
<tr>
<td align="center"><code>@ConditionalOnResource</code></td>
<td align="center">类路径下是否存在指定资源文件</td>
</tr>
<tr>
<td align="center"><code>@ConditionalOnWebApplication</code></td>
<td align="center">当前是web环境</td>
</tr>
<tr>
<td align="center"><code>@ConditionalOnNotWebApplication</code></td>
<td align="center">当前不是web环境</td>
</tr>
<tr>
<td align="center"><code>@ConditionalOnJndi</code></td>
<td align="center">JNDI存在指定项</td>
</tr>
<tr>
<td align="center"><code>@Conditional(xxxCondition.class)</code></td>
<td align="center"><code>xxxCondition</code>类是<code>Condition</code>接口的实现类，需要实现<code>matches</code>方法</td>
</tr>
</tbody></table>
<h1 id="3、源码学习"><a href="#3、源码学习" class="headerlink" title="3、源码学习"></a>3、源码学习</h1><p>SpringBoot 具有以下子 modules：</p>
<ul>
<li>spring-boot：核心工程。</li>
<li>spring-boot-starters：启动服务工程，可减少第三方 jar 的依赖。</li>
<li>spring-boot-autoconfigure：实现自动配置的核心工程。</li>
<li>spring-boot-actuator：外围支撑性功能。</li>
<li>spring-boot-tools：开发者的常用工具集。</li>
<li>spring-boot-cli：命令行交互工具。</li>
<li>spring-boot-devtools：为开发者服务，其中最重要的功能就是热部署。</li>
</ul>
<h2 id="3-1-启动"><a href="#3-1-启动" class="headerlink" title="3.1 启动"></a>3.1 启动</h2><p>生成一个 Spring Boot 项目时，会有一个以 Application 为后缀命名的启动类，启动类的<code>main</code>方法中会调用<code>SpringApplication</code>类的静态<code>run</code>方法。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">HelloWorldApplication</span> &#123;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">      SpringApplication.run(HelloWorldApplication.class, args);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在spring-boot模块中，<code>SpringApplication</code>类的静态<code>run</code>方法是一个可以通过默认设置和用户约定来从具体 source 运行 Spring 项目的静态帮助器。</p>
<p>1）在<code>SpringApplication</code>类的静态<code>run</code>方法中，依次调用了<code>SpringApplication</code>类的构造方法和对象的<code>run</code>方法，完整代码如下</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> ConfigurableApplicationContext <span class="title function_">run</span><span class="params">(Class&lt;?&gt; primarySource, String... args)</span> &#123;</span><br><span class="line">   <span class="keyword">return</span> run(<span class="keyword">new</span> <span class="title class_">Class</span>&lt;?&gt;[] &#123; primarySource &#125;, args);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> ConfigurableApplicationContext <span class="title function_">run</span><span class="params">(Class&lt;?&gt;[] primarySources, String[] args)</span> &#123;</span><br><span class="line">   <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">SpringApplication</span>(primarySources).run(args);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>2）在<code>SpringApplication</code>类的构造方法中，完整代码如下</p>
<ul>
<li><p>以下代码的第8行，将不为空的<code>primarySources</code>加入到一个<code>LinkedHashSet</code>中；</p>
</li>
<li><p>以下代码的第9行，调用<code>deduceFromClasspath</code>方法得到Web环境类型（<code>NONE</code>、<code>SERVLET</code>、<code>REACTIVE</code>），当在 JUnit 测试中使用<code>SpringApplication</code>时，通常需要将环境类型设为<code>NONE</code>来使得测试类启动时只会初始化 Spring 上下文，不再启动 Tomcat 容器，从而达到加速的目的；</p>
</li>
<li><p>以下代码的第10、11、12行，调用<code>getSpringFactoriesInstances</code>方法，从而设置<code>BootstrapRegistryInitializer</code>列表、<code>ApplicationContextInitializer</code>列表以及<code>ApplicationListener</code>列表；</p>
</li>
<li><p>以下代码的第13行，调用<code>deduceMainApplicationClass</code>方法获取当前方法调用栈，找到<code>main</code>函数所在的类；</p>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="title function_">SpringApplication</span><span class="params">(Class&lt;?&gt;... primarySources)</span> &#123;</span><br><span class="line">   <span class="built_in">this</span>(<span class="literal">null</span>, primarySources);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="title function_">SpringApplication</span><span class="params">(ResourceLoader resourceLoader, Class&lt;?&gt;... primarySources)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.resourceLoader = resourceLoader;</span><br><span class="line">    Assert.notNull(primarySources, <span class="string">&quot;PrimarySources must not be null&quot;</span>);</span><br><span class="line">    <span class="built_in">this</span>.primarySources = <span class="keyword">new</span> <span class="title class_">LinkedHashSet</span>&lt;&gt;(Arrays.asList(primarySources));</span><br><span class="line">    <span class="built_in">this</span>.webApplicationType = WebApplicationType.deduceFromClasspath();</span><br><span class="line">    <span class="built_in">this</span>.bootstrapRegistryInitializers = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;( getSpringFactoriesInstances(BootstrapRegistryInitializer.class));</span><br><span class="line">    setInitializers((Collection) getSpringFactoriesInstances(ApplicationContextInitializer.class));</span><br><span class="line">    setListeners((Collection) getSpringFactoriesInstances(ApplicationListener.class));</span><br><span class="line">    <span class="built_in">this</span>.mainApplicationClass = deduceMainApplicationClass();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>3）在<code>getSpringFactoriesInstances</code>方法中，完整代码如下</p>
<ul>
<li><p>以下代码的第8行，调用<code>SpringFactoriesLoader</code>类的<code>loadFactoryNames</code>方法来获取传入<code>type</code>所对应的实例名称，并放入到一个<code>LinkedHashSet</code>中去重；</p>
</li>
<li><p>以下代码的第9行，调用<code>createSpringFactoriesInstances</code>方法进行初始化；</p>
</li>
<li><p>以下代码的第10行，调用<code>AnnotationAwareOrderComparator</code>类的<code>sort</code>方法，根据Order对实例进行排序（@Order注解或者Order接口）；</p>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> &lt;T&gt; Collection&lt;T&gt; <span class="title function_">getSpringFactoriesInstances</span><span class="params">(Class&lt;T&gt; type)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> getSpringFactoriesInstances(type, <span class="keyword">new</span> <span class="title class_">Class</span>&lt;?&gt;[] &#123;&#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> &lt;T&gt; Collection&lt;T&gt; <span class="title function_">getSpringFactoriesInstances</span><span class="params">(Class&lt;T&gt; type, Class&lt;?&gt;[] parameterTypes, Object... args)</span> &#123;</span><br><span class="line">   <span class="type">ClassLoader</span> <span class="variable">classLoader</span> <span class="operator">=</span> getClassLoader();</span><br><span class="line">   <span class="comment">// Use names and ensure unique to protect against duplicates</span></span><br><span class="line">   Set&lt;String&gt; names = <span class="keyword">new</span> <span class="title class_">LinkedHashSet</span>&lt;&gt;(SpringFactoriesLoader.loadFactoryNames(type, classLoader));</span><br><span class="line">   List&lt;T&gt; instances = createSpringFactoriesInstances(type, parameterTypes, classLoader, args, names);</span><br><span class="line">   AnnotationAwareOrderComparator.sort(instances);</span><br><span class="line">   <span class="keyword">return</span> instances;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>4）在<code>SpringFactoriesLoader</code>类的<code>loadFactoryNames</code>方法中，完整代码如下</p>
<ul>
<li><p>以下代码第6行，调用<code>Class</code>的<code>getName</code>方法获取之前传入的<code>factoryType</code>所对应的类名；</p>
</li>
<li><p>以下代码的第7行，调用<code>loadSpringFactories</code>方法来读取所有jar包中的<code>META-INF/spring.factories</code>文件中的配置项的value值（key为上一级方法调用入参，value是一些类名）；</p>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> List&lt;String&gt; <span class="title function_">loadFactoryNames</span><span class="params">(Class&lt;?&gt; factoryType, <span class="meta">@Nullable</span> ClassLoader classLoader)</span> &#123;</span><br><span class="line">   <span class="type">ClassLoader</span> <span class="variable">classLoaderToUse</span> <span class="operator">=</span> classLoader;</span><br><span class="line">   <span class="keyword">if</span> (classLoaderToUse == <span class="literal">null</span>) &#123;</span><br><span class="line">      classLoaderToUse = SpringFactoriesLoader.class.getClassLoader();</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="type">String</span> <span class="variable">factoryTypeName</span> <span class="operator">=</span> factoryType.getName();</span><br><span class="line">   <span class="keyword">return</span> loadSpringFactories(classLoaderToUse).getOrDefault(factoryTypeName, Collections.emptyList());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>5）在<code>SpringApplication</code>类的<code>createSpringFactoriesInstances</code>方法中，完整代码如下</p>
<ul>
<li><p>以下代码的第4行，遍历刚刚加载得到的类名；</p>
</li>
<li><p>以下代码的第6行，根据类名获取到类对象；</p>
</li>
<li><p>以下代码的第7行，检测获取的类对象类型是否与需要的一致；</p>
</li>
<li><p>以下代码的第8行，获取默认的无参构造方法（传入的<code>parameterTypes</code>为空）；</p>
</li>
<li><p>以下代码的第9行，通过反射调用类的构造方法来实例化对象；</p>
</li>
<li><p>以下代码的第10行，将对象放入<code>List</code>结果集；</p>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> &lt;T&gt; List&lt;T&gt; <span class="title function_">createSpringFactoriesInstances</span><span class="params">(Class&lt;T&gt; type, Class&lt;?&gt;[] parameterTypes,</span></span><br><span class="line"><span class="params">      ClassLoader classLoader, Object[] args, Set&lt;String&gt; names)</span> &#123;</span><br><span class="line">   List&lt;T&gt; instances = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;(names.size());</span><br><span class="line">   <span class="keyword">for</span> (String name : names) &#123;</span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">         Class&lt;?&gt; instanceClass = ClassUtils.forName(name, classLoader);</span><br><span class="line">         Assert.isAssignable(type, instanceClass);</span><br><span class="line">         Constructor&lt;?&gt; constructor = instanceClass.getDeclaredConstructor(parameterTypes);</span><br><span class="line">         <span class="type">T</span> <span class="variable">instance</span> <span class="operator">=</span> (T) BeanUtils.instantiateClass(constructor, args);</span><br><span class="line">         instances.add(instance);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">catch</span> (Throwable ex) &#123;</span><br><span class="line">         <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>(<span class="string">&quot;Cannot instantiate &quot;</span> + type + <span class="string">&quot; : &quot;</span> + name, ex);</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">return</span> instances;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>6）在<code>SpringApplication</code>类对象的<code>run</code>方法中，完整代码如下</p>
<ul>
<li><p>以下代码的第5行，调用<code>configureHeadlessProperty</code>方法，将JVM系统属性中的<code>java.awt.headless</code>属性设置为<code>true</code>，表示运行在服务器端；</p>
</li>
<li><p>以下代码的第6行，依次调用了<code>getRunListeners</code>方法 –&gt; <code>getSpringFactoriesInstances</code>方法 –&gt; <code>SpringFactoriesLoader</code>类的<code>loadFactoryNames</code>方法 –&gt; 读取<code>META-INF/spring.factories</code>文件中的配置项的value值，从而设置<code>SpringApplicationRunListener</code>列表，这里列表中只有一个value值（<code>EventPublishingRunListener</code>）；</p>
</li>
<li><p>以下代码的第7行，依次调用了<code>SpringApplicationRunListeners</code>类的<code>starting</code>方法 –&gt; <code>EventPublishingRunListener</code>类的<code>starting</code>方法 –&gt; <code>SimpleApplicationEventMulticaster</code>类的<code>multicastEvent</code>方法 –&gt; <code>invokeListener</code>方法 –&gt; <code>doInvokeListener</code>方法 –&gt; <code>ApplicationListener</code>接口的<code>onApplicationEvent</code>方法，广播了<code>ApplicationStartingEvent</code>类型的事件并启动了对此感兴趣的监听器；</p>
</li>
<li><p>以下代码的第9行，依次调用了<code>DefaultApplicationArguments</code>的构造方法 –&gt; <code>Source</code>的构造方法 –&gt; <code>SimpleCommandLinePropertySource</code>的构造方法和<code>parse</code>方法 –&gt; <code>CommandLinePropertySource</code>的构造方法 –&gt; <code>EnumerablePropertySource</code>的构造方法 –&gt; <code>PropertySource</code>的构造方法，封装了 <code>main</code> 方法的参数，从而更方便的解析和获取参数中的值；</p>
</li>
<li><p>以下代码的第10行，调用了<code>prepareEnvironment</code>方法，从中逐步</p>
<ul>
<li><p>通过<code>getOrCreateEnvironment</code>方法获取或创建了<code>ConfigurableEnvironment</code>；</p>
</li>
<li><p>通过<code>configureEnvironment</code>方法依次配置了<code>PropertySources</code>和<code>Profile</code>属性；</p>
</li>
<li><p>通过<code>ConfigurationPropertySources</code>类的<code>attach</code>方法将<code>application.properties</code>或者<code>application.yml</code>作为一个<code>PropertySource</code>加到<code>PropertySources</code>中；</p>
</li>
<li><p>通过<code>SpringApplicationRunListeners</code>类的<code>environmentPrepared</code>方法广播事件，通知所有的观察者环境已经准备好了，可以进行后续操作；</p>
</li>
</ul>
</li>
<li><p>以下代码的第12行，调用了<code>printBanner</code>方法，打印<code>banner</code>，即每次启动输出的SpringBoot的图标；</p>
</li>
<li><p>以下代码的第13行，调用了<code>createApplicationContext</code>方法，根据当前环境类型（在<code>SpringApplication</code>类的构造方法中确定）来创建对应类型的上下文；</p>
</li>
<li><p>以下代码的第15行，依次调用了<code>prepareContext</code>方法 –&gt; <code>ApplicationContextInitializer</code>列表的<code>initialize</code>方法和<code>SpringApplicationRunListeners</code>类的<code>contextPrepared</code>方法和<code>contextLoaded</code>方法；</p>
</li>
<li><p>以下代码的第16行，调用了<code>refreshContext</code>方法，从中逐步</p>
<ul>
<li><p>通过<code>SpringApplicationShutdownHook</code>类的<code>registerApplicationContext</code>方法来注册一个名为”SpringApplicationShutdownHook”的新线程，如果 JVM 意外终止了，这个线程会把当前的上下文关闭；</p>
</li>
<li><p>通过<code>refresh</code>方法来调用<code>AbstractApplicationContext</code>类的<code>refresh</code>方法，<strong>实现 IoC 容器的初始化及 Bean 的生命周期中的部分过程，具体可参见 <a href="../../10/spring/">Spring Framework</a>  的 2.4 节</strong>，如果是 web 应用还会创建嵌入式的 Tomcat/Jetty/Undertow，默认是 Tomcat；</p>
</li>
</ul>
</li>
<li><p>以下代码的第17行，调用了一个空的<code>afterRefresh</code>的方法，用于之后可能要增加的操作；</p>
</li>
<li><p>以下代码的第20行，打印日志，显示启动当前应用所花的时间；</p>
</li>
<li><p>以下代码的第22行，调用<code>SpringApplicationRunListeners</code>类的<code>started</code>方法来广播<code>ApplicationStartedEvent</code>类型的事件；</p>
</li>
<li><p>以下代码的第23行，依次调用了<code>callRunners</code>方法 –&gt; 所有<code>ApplicationRunner</code>和<code>CommandLineRunner</code>对象的<code>run</code>方法（同步调用，并非开启新线程）；</p>
</li>
<li><p>以下代码的26、27、34、35行，调用了<code>handleRunFailure</code>方法来处理异常并抛出<code>IllegalStateException</code>异常，在<code>handleRunFailure</code>方法中会继续调用<code>SpringApplicationRunListeners</code>类的<code>failed</code>方法；</p>
</li>
<li><p>以下代码的31行，调用<code>SpringApplicationRunListeners</code>类的<code>ready</code>方法来广播<code>ApplicationReadyEvent </code>类型的事件，至此整个<code>run</code>方法执行完毕，程序启动完成。</p>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> ConfigurableApplicationContext <span class="title function_">run</span><span class="params">(String... args)</span> &#123;</span><br><span class="line">   <span class="type">long</span> <span class="variable">startTime</span> <span class="operator">=</span> System.nanoTime();</span><br><span class="line">   <span class="type">DefaultBootstrapContext</span> <span class="variable">bootstrapContext</span> <span class="operator">=</span> createBootstrapContext();</span><br><span class="line">   <span class="type">ConfigurableApplicationContext</span> <span class="variable">context</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">   configureHeadlessProperty();</span><br><span class="line">   <span class="type">SpringApplicationRunListeners</span> <span class="variable">listeners</span> <span class="operator">=</span> getRunListeners(args);</span><br><span class="line">   listeners.starting(bootstrapContext, <span class="built_in">this</span>.mainApplicationClass);</span><br><span class="line">   <span class="keyword">try</span> &#123;</span><br><span class="line">      <span class="type">ApplicationArguments</span> <span class="variable">applicationArguments</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DefaultApplicationArguments</span>(args);</span><br><span class="line">      <span class="type">ConfigurableEnvironment</span> <span class="variable">environment</span> <span class="operator">=</span> prepareEnvironment(listeners, bootstrapContext, applicationArguments);</span><br><span class="line">      configureIgnoreBeanInfo(environment);</span><br><span class="line">      <span class="type">Banner</span> <span class="variable">printedBanner</span> <span class="operator">=</span> printBanner(environment);</span><br><span class="line">      context = createApplicationContext();</span><br><span class="line">      context.setApplicationStartup(<span class="built_in">this</span>.applicationStartup);</span><br><span class="line">      prepareContext(bootstrapContext, context, environment, listeners, applicationArguments, printedBanner);</span><br><span class="line">      refreshContext(context);</span><br><span class="line">      afterRefresh(context, applicationArguments);</span><br><span class="line">      <span class="type">Duration</span> <span class="variable">timeTakenToStartup</span> <span class="operator">=</span> Duration.ofNanos(System.nanoTime() - startTime);</span><br><span class="line">      <span class="keyword">if</span> (<span class="built_in">this</span>.logStartupInfo) &#123;</span><br><span class="line">         <span class="keyword">new</span> <span class="title class_">StartupInfoLogger</span>(<span class="built_in">this</span>.mainApplicationClass).logStarted(getApplicationLog(), timeTakenToStartup);</span><br><span class="line">      &#125;</span><br><span class="line">      listeners.started(context, timeTakenToStartup);</span><br><span class="line">      callRunners(context, applicationArguments);</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">catch</span> (Throwable ex) &#123;</span><br><span class="line">      handleRunFailure(context, ex, listeners);</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalStateException</span>(ex);</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">try</span> &#123;</span><br><span class="line">      <span class="type">Duration</span> <span class="variable">timeTakenToReady</span> <span class="operator">=</span> Duration.ofNanos(System.nanoTime() - startTime);</span><br><span class="line">      listeners.ready(context, timeTakenToReady);</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">catch</span> (Throwable ex) &#123;</span><br><span class="line">      handleRunFailure(context, ex, <span class="literal">null</span>);</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalStateException</span>(ex);</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">return</span> context;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="3-2-事件监听器"><a href="#3-2-事件监听器" class="headerlink" title="3.2 事件监听器"></a>3.2 事件监听器</h2><p>在3.1节中学习到了Spring Boot启动过程中会发布一系列事件并启动事件监听器，本节对此进行详细介绍。</p>
<p>1）在<code>SpringApplication</code>类的构造方法中</p>
<ul>
<li><p>会调用<code>setListeners</code>方法和<code>getSpringFactoriesInstances</code>方法，来读取到<code>META-INF/spring.factories</code>文件中key为<code>ApplicationListener</code>的全限定名的配置项的value值，从而获取并注册监听器；</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">setListeners((Collection) getSpringFactoriesInstances(ApplicationListener.class));</span><br></pre></td></tr></table></figure></li>
<li><p>在spring-boot模块中，<code>META-INF/spring.factories</code>文件中存在以下配置项</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"># Application Listeners</span><br><span class="line">org.springframework.context.ApplicationListener=\</span><br><span class="line">org.springframework.boot.ClearCachesApplicationListener,\</span><br><span class="line">org.springframework.boot.builder.ParentContextCloserApplicationListener,\</span><br><span class="line">org.springframework.boot.context.FileEncodingApplicationListener,\</span><br><span class="line">org.springframework.boot.context.config.AnsiOutputApplicationListener,\</span><br><span class="line">org.springframework.boot.context.config.DelegatingApplicationListener,\</span><br><span class="line">org.springframework.boot.context.logging.LoggingApplicationListener,\</span><br><span class="line">org.springframework.boot.env.EnvironmentPostProcessorApplicationListener</span><br></pre></td></tr></table></figure></li>
</ul>
<p>2）在<code>SpringApplication</code>类对象的<code>run</code>方法中，会调用<code>getRunListeners</code>方法，完整代码如下</p>
<ul>
<li><p>以下代码的第3、4行，调用了<code>SpringApplicationRunListeners</code>类的构造方法和<code>getSpringFactoriesInstances</code>方法，最终会读取到<code>META-INF/spring.factories</code>文件中key为<code>SpringApplicationRunListener</code>的全限定名的配置项的value值，从而设置<code>SpringApplicationRunListener</code>列表；</p>
</li>
<li><p>由于spring-boot模块中的<code>META-INF/spring.factories</code>文件中存在以下配置项，因此<code>SpringApplicationRunListener</code>列表中只有<code>EventPublishingRunListener</code>这一个值；</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"># Run Listeners</span><br><span class="line">org.springframework.boot.SpringApplicationRunListener=\</span><br><span class="line">org.springframework.boot.context.event.EventPublishingRunListener</span><br></pre></td></tr></table></figure></li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> SpringApplicationRunListeners <span class="title function_">getRunListeners</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">   Class&lt;?&gt;[] types = <span class="keyword">new</span> <span class="title class_">Class</span>&lt;?&gt;[] &#123; SpringApplication.class, String[].class &#125;;</span><br><span class="line">   <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">SpringApplicationRunListeners</span>(logger,</span><br><span class="line">         getSpringFactoriesInstances(SpringApplicationRunListener.class, types, <span class="built_in">this</span>, args),</span><br><span class="line">         <span class="built_in">this</span>.applicationStartup);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>3）在<code>SpringApplication</code>类对象的<code>run</code>方法中，会调用<code>SpringApplicationRunListeners</code>类的<code>starting</code>方法，进而调用列表中每一个<code>SpringApplicationRunListener</code>的<code>starting</code>方法，即<code>EventPublishingRunListener</code>类的<code>starting</code>方法，完整代码如下</p>
<ul>
<li><p>以下代码的第3行，<code>this.initialMulticaster</code>是一个<code>SimpleApplicationEventMulticaster</code>类型的对象；</p>
</li>
<li><p>以下代码的第4行，调用了<code>SimpleApplicationEventMulticaster</code>类的<code>multicastEvent</code>方法，方法入参是<code>ApplicationStartingEvent</code>类型的事件；</p>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">starting</span><span class="params">(ConfigurableBootstrapContext bootstrapContext)</span> &#123;</span><br><span class="line">   <span class="built_in">this</span>.initialMulticaster</span><br><span class="line">         .multicastEvent(<span class="keyword">new</span> <span class="title class_">ApplicationStartingEvent</span>(bootstrapContext, <span class="built_in">this</span>.application, <span class="built_in">this</span>.args));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>4）在<code>SimpleApplicationEventMulticaster</code>类的<code>multicastEvent</code>方法中，完整代码如下</p>
<ul>
<li><p>依次调用了<code>resolveDefaultEventType</code>方法 –&gt; <code>ResolvableType</code>类的<code>forInstance</code>方法来获取事件的类型；</p>
</li>
<li><p>继续调用入参中包含事件类型的<code>multicastEvent</code>方法；</p>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">multicastEvent</span><span class="params">(ApplicationEvent event)</span> &#123;</span><br><span class="line">   multicastEvent(event, resolveDefaultEventType(event));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> ResolvableType <span class="title function_">resolveDefaultEventType</span><span class="params">(ApplicationEvent event)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> ResolvableType.forInstance(event);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>5）在<code>ResolvableType</code>类的<code>forInstance</code>方法中，完整代码如下</p>
<ul>
<li><p>以下代码的第3、4行，判断事件<code>instance</code>是否实现了<code>ResolvableTypeProvider</code>接口（该接口表示事件可以被解析），是的话则强转成<code>ResolvableTypeProvider</code>类型，然后获取并返回事件类型；</p>
</li>
<li><p>以下代码9行，将传入的<code>instance</code>包装成<code>ResolvableType</code>，并返回一个默认类型；</p>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> ResolvableType <span class="title function_">forInstance</span><span class="params">(Object instance)</span> &#123;</span><br><span class="line">   Assert.notNull(instance, <span class="string">&quot;Instance must not be null&quot;</span>);</span><br><span class="line">   <span class="keyword">if</span> (instance <span class="keyword">instanceof</span> ResolvableTypeProvider) &#123;</span><br><span class="line">      <span class="type">ResolvableType</span> <span class="variable">type</span> <span class="operator">=</span> ((ResolvableTypeProvider) instance).getResolvableType();</span><br><span class="line">      <span class="keyword">if</span> (type != <span class="literal">null</span>) &#123;</span><br><span class="line">         <span class="keyword">return</span> type;</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">return</span> ResolvableType.forClass(instance.getClass());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>6）在<code>SimpleApplicationEventMulticaster</code>类的<code>multicastEvent</code>方法中，完整代码如下</p>
<ul>
<li><p>以下代码的第5行，调用了<code>AbstractApplicationEventMulticaster</code>类的<code>getApplicationListeners</code>方法来获取对当前事件感兴趣的监听器；</p>
</li>
<li><p>以下代码的第10行，依次调用了<code>invokeListener</code>方法 –&gt; <code>doInvokeListener</code>方法 –&gt; <code>ApplicationListener</code>接口的<code>onApplicationEvent</code>方法来广播事件并启动监听器；</p>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">multicastEvent</span><span class="params">(<span class="keyword">final</span> ApplicationEvent event, <span class="meta">@Nullable</span> ResolvableType eventType)</span> &#123;</span><br><span class="line">   <span class="type">ResolvableType</span> <span class="variable">type</span> <span class="operator">=</span> (eventType != <span class="literal">null</span> ? eventType : resolveDefaultEventType(event));</span><br><span class="line">   <span class="type">Executor</span> <span class="variable">executor</span> <span class="operator">=</span> getTaskExecutor();</span><br><span class="line">   <span class="keyword">for</span> (ApplicationListener&lt;?&gt; listener : getApplicationListeners(event, type)) &#123;</span><br><span class="line">      <span class="keyword">if</span> (executor != <span class="literal">null</span>) &#123;</span><br><span class="line">         executor.execute(() -&gt; invokeListener(listener, event));</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">else</span> &#123;</span><br><span class="line">         invokeListener(listener, event);</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>7）在<code>AbstractApplicationEventMulticaster</code>类的<code>getApplicationListeners</code>方法中，完整代码如下</p>
<ul>
<li><p>以下代码的第12行，尝试直接从缓存中获取监听器，如果<code>getApplicationListeners</code>方法已经执行过，这里就可以直接拿到缓存，如果是第一次执行<code>getApplicationListeners</code>方法，则只能获取到<code>null</code>；</p>
</li>
<li><p>以下代码的第35行，调用了<code>retrieveApplicationListeners</code>方法来获取监听器；</p>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">protected</span> Collection&lt;ApplicationListener&lt;?&gt;&gt; getApplicationListeners(</span><br><span class="line">      ApplicationEvent event, ResolvableType eventType) &#123;</span><br><span class="line"></span><br><span class="line">   <span class="type">Object</span> <span class="variable">source</span> <span class="operator">=</span> event.getSource();</span><br><span class="line">   Class&lt;?&gt; sourceType = (source != <span class="literal">null</span> ? source.getClass() : <span class="literal">null</span>);</span><br><span class="line">   <span class="type">ListenerCacheKey</span> <span class="variable">cacheKey</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ListenerCacheKey</span>(eventType, sourceType);</span><br><span class="line"></span><br><span class="line">   <span class="comment">// Potential new retriever to populate</span></span><br><span class="line">   <span class="type">CachedListenerRetriever</span> <span class="variable">newRetriever</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">   <span class="comment">// Quick check for existing entry on ConcurrentHashMap</span></span><br><span class="line">   <span class="type">CachedListenerRetriever</span> <span class="variable">existingRetriever</span> <span class="operator">=</span> <span class="built_in">this</span>.retrieverCache.get(cacheKey);</span><br><span class="line">   <span class="keyword">if</span> (existingRetriever == <span class="literal">null</span>) &#123;</span><br><span class="line">      <span class="comment">// Caching a new ListenerRetriever if possible</span></span><br><span class="line">      <span class="keyword">if</span> (<span class="built_in">this</span>.beanClassLoader == <span class="literal">null</span> ||</span><br><span class="line">            (ClassUtils.isCacheSafe(event.getClass(), <span class="built_in">this</span>.beanClassLoader) &amp;&amp;</span><br><span class="line">                  (sourceType == <span class="literal">null</span> || ClassUtils.isCacheSafe(sourceType, <span class="built_in">this</span>.beanClassLoader)))) &#123;</span><br><span class="line">         newRetriever = <span class="keyword">new</span> <span class="title class_">CachedListenerRetriever</span>();</span><br><span class="line">         existingRetriever = <span class="built_in">this</span>.retrieverCache.putIfAbsent(cacheKey, newRetriever);</span><br><span class="line">         <span class="keyword">if</span> (existingRetriever != <span class="literal">null</span>) &#123;</span><br><span class="line">            newRetriever = <span class="literal">null</span>;  <span class="comment">// no need to populate it in retrieveApplicationListeners</span></span><br><span class="line">         &#125;</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">if</span> (existingRetriever != <span class="literal">null</span>) &#123;</span><br><span class="line">      Collection&lt;ApplicationListener&lt;?&gt;&gt; result = existingRetriever.getApplicationListeners();</span><br><span class="line">      <span class="keyword">if</span> (result != <span class="literal">null</span>) &#123;</span><br><span class="line">         <span class="keyword">return</span> result;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">// If result is null, the existing retriever is not fully populated yet by another thread.</span></span><br><span class="line">      <span class="comment">// Proceed like caching wasn&#x27;t possible for this current local attempt.</span></span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">return</span> retrieveApplicationListeners(eventType, sourceType, newRetriever);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>8）在<code>retrieveApplicationListeners</code>方法中，截取了部分代码如下</p>
<ul>
<li><p>以下代码的第11、12行，获取了所有的监听器实例及其对应的beanName；</p>
</li>
<li><p>以下代码的第17行，逐个遍历每个监听器实例；</p>
</li>
<li><p>以下代码的第18行，调用了<code>supportsEvent</code>方法来判断监听器是否对当前事件感兴趣；</p>
</li>
<li><p>以下代码的第32行，根据Order接口或者注解对监听器进行排序；</p>
</li>
<li><p>以下代码的第33~42行，对缓存进行一次刷新，把以前的缓存清空，将这次运行的结果进行缓存；</p>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> Collection&lt;ApplicationListener&lt;?&gt;&gt; retrieveApplicationListeners(</span><br><span class="line">      ResolvableType eventType, <span class="meta">@Nullable</span> Class&lt;?&gt; sourceType, <span class="meta">@Nullable</span> CachedListenerRetriever retriever) &#123;</span><br><span class="line"></span><br><span class="line">   List&lt;ApplicationListener&lt;?&gt;&gt; allListeners = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">   Set&lt;ApplicationListener&lt;?&gt;&gt; filteredListeners = (retriever != <span class="literal">null</span> ? <span class="keyword">new</span> <span class="title class_">LinkedHashSet</span>&lt;&gt;() : <span class="literal">null</span>);</span><br><span class="line">   Set&lt;String&gt; filteredListenerBeans = (retriever != <span class="literal">null</span> ? <span class="keyword">new</span> <span class="title class_">LinkedHashSet</span>&lt;&gt;() : <span class="literal">null</span>);</span><br><span class="line"></span><br><span class="line">   Set&lt;ApplicationListener&lt;?&gt;&gt; listeners;</span><br><span class="line">   Set&lt;String&gt; listenerBeans;</span><br><span class="line">   <span class="keyword">synchronized</span> (<span class="built_in">this</span>.defaultRetriever) &#123;</span><br><span class="line">      listeners = <span class="keyword">new</span> <span class="title class_">LinkedHashSet</span>&lt;&gt;(<span class="built_in">this</span>.defaultRetriever.applicationListeners);</span><br><span class="line">      listenerBeans = <span class="keyword">new</span> <span class="title class_">LinkedHashSet</span>&lt;&gt;(<span class="built_in">this</span>.defaultRetriever.applicationListenerBeans);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">// Add programmatically registered listeners, including ones coming</span></span><br><span class="line">   <span class="comment">// from ApplicationListenerDetector (singleton beans and inner beans).</span></span><br><span class="line">   <span class="keyword">for</span> (ApplicationListener&lt;?&gt; listener : listeners) &#123;</span><br><span class="line">      <span class="keyword">if</span> (supportsEvent(listener, eventType, sourceType)) &#123;</span><br><span class="line">         <span class="keyword">if</span> (retriever != <span class="literal">null</span>) &#123;</span><br><span class="line">            filteredListeners.add(listener);</span><br><span class="line">         &#125;</span><br><span class="line">         allListeners.add(listener);</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">// Add listeners by bean name, potentially overlapping with programmatically</span></span><br><span class="line">   <span class="comment">// registered listeners above - but here potentially with additional metadata.</span></span><br><span class="line">   <span class="keyword">if</span> (!listenerBeans.isEmpty()) &#123;</span><br><span class="line">      ...</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   AnnotationAwareOrderComparator.sort(allListeners);</span><br><span class="line">   <span class="keyword">if</span> (retriever != <span class="literal">null</span>) &#123;</span><br><span class="line">      <span class="keyword">if</span> (filteredListenerBeans.isEmpty()) &#123;</span><br><span class="line">         retriever.applicationListeners = <span class="keyword">new</span> <span class="title class_">LinkedHashSet</span>&lt;&gt;(allListeners);</span><br><span class="line">         retriever.applicationListenerBeans = filteredListenerBeans;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">else</span> &#123;</span><br><span class="line">         retriever.applicationListeners = filteredListeners;</span><br><span class="line">         retriever.applicationListenerBeans = filteredListenerBeans;</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">return</span> allListeners;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>9）在<code>supportsEvent</code>方法中，通过<code>GenericApplicationListener</code>类的<code>supportsEventType</code>和<code>supportsSourceType</code>方法，判断了判断监听器是否支持当前事件以及是否对这个事件的发起来类感兴趣，完整代码如下；</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">protected</span> <span class="type">boolean</span> <span class="title function_">supportsEvent</span><span class="params">(</span></span><br><span class="line"><span class="params">      ApplicationListener&lt;?&gt; listener, ResolvableType eventType, <span class="meta">@Nullable</span> Class&lt;?&gt; sourceType)</span> &#123;</span><br><span class="line"></span><br><span class="line">   <span class="type">GenericApplicationListener</span> <span class="variable">smartListener</span> <span class="operator">=</span> (listener <span class="keyword">instanceof</span> GenericApplicationListener ?</span><br><span class="line">         (GenericApplicationListener) listener : <span class="keyword">new</span> <span class="title class_">GenericApplicationListenerAdapter</span>(listener));</span><br><span class="line">   <span class="keyword">return</span> (smartListener.supportsEventType(eventType) &amp;&amp; smartListener.supportsSourceType(sourceType));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>10）至此，完整介绍了<code>ApplicationStartingEvent</code>事件的广播及启动对此感兴趣的监听器的过程，这一逻辑的入口在<code>SpringApplicationRunListeners</code>类的<code>starting</code>方法，该方法是在<code>SpringApplication</code>类对象的<code>run</code>方法中被调用的；</p>
<p>11）在<code>SpringApplication</code>类对象的<code>run</code>方法中</p>
<ul>
<li><p>还会调用<code>SpringApplicationRunListeners</code>类的<code>environmentPrepared</code>、<code>contextPrepared</code>、<code>contextLoaded</code>、<code>started</code>和<code>ready</code>方法，如果抛出异常，还会调用<code>failed</code>方法；</p>
</li>
<li><p>与上述过程同理，这些方法调用分别会实现<code>ApplicationEnvironmentPreparedEvent</code>、<code>ApplicationContextInitializedEvent</code>、<code>ApplicationPreparedEvent</code>、<code>ApplicationStartedEvent</code>、<code>ApplicationReadyEvent</code>以及<code>ApplicationFailedEvent</code>事件的广播，并启动对此感兴趣的监听器。</p>
</li>
</ul>
<h2 id="3-3-自动配置"><a href="#3-3-自动配置" class="headerlink" title="3.3 自动配置"></a>3.3 自动配置</h2><p>启动类使用<code>@SpringBootApplication</code>注解标注，而<code>@SpringBootApplication</code>注解包含了<code>@EnableAutoConfiguration</code>注解。</p>
<p>在spring-boot-autoconfigure模块中，<code>@EnableAutoConfiguration</code>注解会启用 SpringBoot 的自动装配机制（自动扫描+条件装配）。</p>
<p>1）<code>@EnableAutoConfiguration</code>引入了<code>AutoConfigurationImportSelector</code>类，这是用于选择给容器导入哪些组件的选择器，会将符合条件的配置类都加载到IoC容器中，<code>AutoConfigurationImportSelector</code>类提供了<code>selectImports</code>方法的具体实现；</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Import(AutoConfigurationImportSelector.class)</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> EnableAutoConfiguration &#123;...&#125;</span><br></pre></td></tr></table></figure>

<p>2）在<code>AutoConfigurationImportSelector</code>类的<code>selectImports</code>方法中，调用了<code>getAutoConfigurationEntry</code>方法，完整代码如下；</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> String[] selectImports(AnnotationMetadata annotationMetadata) &#123;</span><br><span class="line">    <span class="keyword">if</span> (!isEnabled(annotationMetadata)) &#123;</span><br><span class="line">        <span class="keyword">return</span> NO_IMPORTS;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">AutoConfigurationEntry</span> <span class="variable">autoConfigurationEntry</span> <span class="operator">=</span> getAutoConfigurationEntry(annotationMetadata);</span><br><span class="line">    <span class="keyword">return</span> StringUtils.toStringArray(autoConfigurationEntry.getConfigurations());</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>

<p>3）在<code>AutoConfigurationImportSelector</code>类的<code>getAutoConfigurationEntry</code>方法中，会返回需要被加载的自动配置类，完整代码如下</p>
<ul>
<li><p>以下代码的第5行，会调用<code>getAttributes</code>方法来获取元注解中的属性；</p>
</li>
<li><p>以下代码的第6行，会依次调用<code>getCandidateConfigurations</code>方法 –&gt; <code>SpringFactoriesLoader</code>类的<code>loadFactoryNames</code>方法；</p>
</li>
<li><p>以下代码的第11行，会根据候选配置类上的<code>@ConditionalOnClass</code>注解来判断是否过滤该候选类，被过滤的候选类不会被加载；</p>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">protected</span> AutoConfigurationEntry <span class="title function_">getAutoConfigurationEntry</span><span class="params">(AnnotationMetadata annotationMetadata)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (!isEnabled(annotationMetadata)) &#123;</span><br><span class="line">        <span class="keyword">return</span> EMPTY_ENTRY;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">AnnotationAttributes</span> <span class="variable">attributes</span> <span class="operator">=</span> getAttributes(annotationMetadata);</span><br><span class="line">    List&lt;String&gt; configurations = getCandidateConfigurations(annotationMetadata, attributes);</span><br><span class="line">    configurations = removeDuplicates(configurations);</span><br><span class="line">    Set&lt;String&gt; exclusions = getExclusions(annotationMetadata, attributes);</span><br><span class="line">    checkExcludedClasses(configurations, exclusions);</span><br><span class="line">    configurations.removeAll(exclusions);</span><br><span class="line">    configurations = getConfigurationClassFilter().filter(configurations);</span><br><span class="line">    fireAutoConfigurationImportEvents(configurations, exclusions);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">AutoConfigurationEntry</span>(configurations, exclusions);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>4）在<code>SpringFactoriesLoader</code>类的<code>loadFactoryNames</code>方法中，会读取<code>resources/META-INF/spring.factories</code>文件中 key 为<code>EnableAutoConfiguration</code>的全限定名的value；</p>
<ul>
<li><p><code>EnableAutoConfiguration</code>的全限定名所对应的value有很多（一百多个），每个 value 都是一个配置类的全限定名；</p>
</li>
<li><p>SpringBoot 的自动装配机制并不会加载全部 value 所对应的配置类，而是会根据配置类的<code>@ConditionalOnClass</code>等注解所确定的条件来判断是否加载该配置类；</p>
</li>
</ul>
<p>5）因此，如果需要<code>@EnableAutoConfiguration</code>注解去加载自定义 jar 包中的 Bean，就应该确保：</p>
<ul>
<li><p>该 jar 包的配置类中编写了标注了<code>@Bean</code>的方法来创建并返回该 Bean；</p>
</li>
<li><p>该 jar 包的<code>src/main/resources/META-INF</code>目录下存在<code>spring.factories</code>文件，并在<code>spring.factories</code>文件配置了 key 为<code>EnableAutoConfiguration</code>的全限定名，value 为配置类的全限定名的配置项；</p>
</li>
</ul>
<p>6）总结与注意事项</p>
<ul>
<li><p>Spring Boot 会根据<code>@EnableAutoConfiguration</code>注解来猜测开发者想要如何配置 Spring 并实现自动配置；</p>
</li>
<li><p>自动配置被设计成与 starter 一起工作，但是这两个概念并没有直接联系在一起，开发者可以在启动器之外自由选择 jar 包；</p>
</li>
<li><p>自动配置是非侵入性的，开发者在任何时候都可以开始定义自己的配置来替换自动配置的特定部分；</p>
</li>
<li><p>在 jar 包的<code>src/main/resources/META-INF/spring.factories</code>文件中，开发者还可以添加配置项来指定自动配置类的加载条件，<code>@EnableAutoConfiguration</code>会根据加载条件来判断是否加载某配置类；</p>
</li>
<li><p>这些自动配置类被设置为<code>public</code>只是为了方便禁用它，实际上这些自动配置类是仅供内部使用的，不建议直接使用这些类的实际内容（例如嵌套的配置类或 Bean 方法）；</p>
</li>
<li><p>如果新定义了一个 starter，也要在该 starter 的 jar 包中提供<code>spring.factories</code>文件，并为其配置<code>EnableAutoConfiguration</code>对应的配置类。</p>
</li>
</ul>
<h2 id="3-4-Web-配置"><a href="#3-4-Web-配置" class="headerlink" title="3.4 Web 配置"></a>3.4 Web 配置</h2><p>添加了 Spring -boot-starter-web 依赖项后，Spring Boot 会自动添加 Tomcat 和 Spring MVC，自动配置会假定正在开发一个 web 应用程序，并相应地设置 Spring。</p>
<p>在 3.3 节中学习到了<code>@EnableAutoConfiguration</code>注解会加载<code>spring.factories</code>文件中所配置的 key 为<code>EnableAutoConfiguration</code>的全限定名，value 为配置类的全限定名的配置项。</p>
<p>本节以<code>WebMvcAutoConfiguration</code>这一自动配置类为例，介绍 Spring Boot 的 Web 配置。</p>
<p>1）<code>WebMvcAutoConfiguration</code>是针对Web配置的自动配置类，截取了部分代码如下</p>
<ul>
<li><p>以下代码的1、2、6行，通过<code>@AutoConfigure</code>和<code>@AutoConfigureOrder</code>注解给出了<code>WebMvcAutoConfiguration</code>配置类的加载顺序；</p>
</li>
<li><p>以下代码的3~5行，通过<code>@Conditional</code>及其派生注解给出了<code>WebMvcAutoConfiguration</code>配置类的加载条件；</p>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@AutoConfiguration(after = &#123; DispatcherServletAutoConfiguration.class, TaskExecutionAutoConfiguration.class,</span></span><br><span class="line"><span class="meta">      ValidationAutoConfiguration.class &#125;)</span></span><br><span class="line"><span class="meta">@ConditionalOnWebApplication(type = Type.SERVLET)</span></span><br><span class="line"><span class="meta">@ConditionalOnClass(&#123; Servlet.class, DispatcherServlet.class, WebMvcConfigurer.class &#125;)</span></span><br><span class="line"><span class="meta">@ConditionalOnMissingBean(WebMvcConfigurationSupport.class)</span></span><br><span class="line"><span class="meta">@AutoConfigureOrder(Ordered.HIGHEST_PRECEDENCE + 10)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">WebMvcAutoConfiguration</span> &#123;...&#125;</span><br></pre></td></tr></table></figure>

<p>2）<code>WebMvcAutoConfiguration</code>配置类内部有一些静态内部类</p>
<ul>
<li><p><code>EnableWebMvcConfiguration</code>配置类</p>
<ul>
<li><p>相当于<code>@EnableWebMvc</code>注解的功能；</p>
</li>
<li><p>通过<code>@EnableConfigurationProperties(WebProperties.class)</code>注册了<code>WebProperties</code>，</p>
</li>
<li><p>重写了一些<code>WebMvcConfigurationSupport</code>父类中的方法实现并声明为Bean方法；</p>
</li>
</ul>
</li>
<li><p><code>ResourceChainCustomizerConfiguration</code>配置类</p>
<ul>
<li><p>由<code>OnEnabledResourceChainCondition</code>来判断是否加载；</p>
</li>
<li><p>默认是不进行加载的；</p>
</li>
</ul>
</li>
</ul>
<p>3）<code>WebMvcAutoConfiguration</code>配置类中声明了两个Bean方法，注册条件如下</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="meta">@ConditionalOnMissingBean(HiddenHttpMethodFilter.class)</span></span><br><span class="line"><span class="meta">@ConditionalOnProperty(prefix = &quot;spring.mvc.hiddenmethod.filter&quot;, name = &quot;enabled&quot;)</span></span><br><span class="line"><span class="keyword">public</span> OrderedHiddenHttpMethodFilter <span class="title function_">hiddenHttpMethodFilter</span><span class="params">()</span> &#123;</span><br><span class="line">   <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">OrderedHiddenHttpMethodFilter</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="meta">@ConditionalOnMissingBean(FormContentFilter.class)</span></span><br><span class="line"><span class="meta">@ConditionalOnProperty(prefix = &quot;spring.mvc.formcontent.filter&quot;, name = &quot;enabled&quot;, matchIfMissing = true)</span></span><br><span class="line"><span class="keyword">public</span> OrderedFormContentFilter <span class="title function_">formContentFilter</span><span class="params">()</span> &#123;</span><br><span class="line">   <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">OrderedFormContentFilter</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="4、Spring-WebFlux"><a href="#4、Spring-WebFlux" class="headerlink" title="4、Spring WebFlux"></a>4、Spring WebFlux</h1><p>Spring WebFlux 是一个用于构建响应式 Web 应用程序的非阻塞框架，提供了一种基于异步非阻塞的编程模型</p>
<ul>
<li><p>支持响应式编程，开发者可以使用响应式流处理来处理请求和响应，能够以声明式的方式处理异步操作和数据流，适用于高并发、高吞吐量和实时性要求较高的场景</p>
</li>
<li><p>使用非阻塞 I/O 来处理请求和响应，借助于 Reactor 库的异步特性和事件驱动的方式，相比传统的阻塞模型，非阻塞模型能够更好地利用底层系统资源，提供更好地性能和可伸缩性，允许应用程序能够同事处理多个请求而无需为每个请求分配一个线程</p>
</li>
<li><p>提供一种灵活的路由和处理方式，可以使用注解或函数式编程风格来定义路由和处理函数，从而根据 URL 和其他条件将请求映射到相应的处理器函数，更加简洁，可读性更好</p>
</li>
<li><p>支持异步的数据流处理，能够轻松与其他异步非阻塞的组件进行集成，从而构建完全异步的端到端响应式应用程序</p>
</li>
</ul>
<h1 id="5、Spring-Cloud"><a href="#5、Spring-Cloud" class="headerlink" title="5、Spring Cloud"></a>5、Spring Cloud</h1><p>Spring Cloud 是基于 Spring Boot 和 Spring Framework 的一个完整的分布式系统开发框架</p>
<ul>
<li><p>提供了一系列开箱即用的、针对分布式系统开发的特性和组件</p>
</li>
<li><p>基于 Java 语言实现，同时也支持其他语言的开发，编程模型和通信协议绑定 HTTP</p>
</li>
<li><p>主要目标是解决分布式系统重的常见问题，例如服务发现、负载均衡、配置管理、熔断器、消息总线等</p>
</li>
<li><p>可以帮助开发人员快速构建和管理分布式、微服务和云原生应用程序，能够支持多种云平台</p>
</li>
</ul>
<p>网关就相当于是一个前置的入口，所有的请求都要经他，然后通过它进行服务转发和路由，可以很方便地管理这些服务，比如负载均衡、动态路由、统一鉴权、统一异常处理各种粒度的限流，降级和熔断操作等</p>
<ul>
<li><p>Zuul 是一个开源的网关服务，主要通过配置路由规则将客户端请求路由到相应的微服务实例，用于构建微服务架构中的边缘服务，是 Spring Cloud 生态系统中的一部分</p>
</li>
<li><p>Gateway 也是 Spring Cloud 的一部分，用于构建基于 Spring Boot 的微服务网关，提供了类似 Zuul 的功能，使用 Spring WebFlux 框架和 Reactor 库实现了异步非阻塞的处理模型，Gateway 的推出是要代替 Zuul 的，是微服务网关的首选</p>
</li>
<li><p>Nginx 是一个高性能的开源 Web 服务器和反向代理服务器，是一种服务端负载均衡，即负载均衡逻辑集成到服务提供段，需要单独部署一个 Nginx 服务，在服务端对请求进行转发，支持基于配置的路由和请求过滤功能，可以用于网关，但不像 Zuul 和 Gateway 那样专注于微服务架构</p>
</li>
<li><p>Ribbon 是一种客户端负载均衡，即负载均衡逻辑集成到服务消费端的代码中，消费端代码中引入 Ribbon，在客户端直接选择需要调用的服务提供端，通常与 Spring Cloud 一起在微服务架构中使用</p>
</li>
<li><p>LoadBalancer 是 Spring 推出的 Ribbon 的替代品，其使用与 Ribbon 基本兼容，与 Spring Cloud 其他组件紧密集成，较 Ribbon 更加轻便，性能更好</p>
</li>
</ul>
<p>Feign 是 Spring Cloud 的一个声明式 HTTP 客户端库，用于简化编写基于 HTTP 的服务调用代码，OpenFeign 是 Feign 的功能完整的替代方案，但是在 Spring 6.0 中内置一个 HTTP 客户端<code>@HttpExchange</code>，因此建议使用这个客户端进行 HTTP 调用。</p>
<h1 id="6、参考资料"><a href="#6、参考资料" class="headerlink" title="6、参考资料"></a>6、参考资料</h1><ul>
<li><a href="https://www.jianshu.com/p/f3337a836faf">https://www.jianshu.com/p/f3337a836faf</a></li>
<li><a href="https://snailclimb.gitee.io/springboot-guide/#/">https://snailclimb.gitee.io/springboot-guide/#/</a></li>
<li><a href="https://www.liaoxuefeng.com/wiki/1252599548343744/1266265175882464">https://www.liaoxuefeng.com/wiki/1252599548343744/1266265175882464</a></li>
<li><a href="https://blog.csdn.net/qq_26000415/category_9271293.html">https://blog.csdn.net/qq_26000415/category_9271293.html</a></li>
<li><a href="https://juejin.cn/post/6910458302547623944">https://juejin.cn/post/6910458302547623944</a></li>
<li><a href="https://juejin.cn/post/6844904106843193357">https://juejin.cn/post/6844904106843193357</a></li>
<li><a href="https://juejin.cn/post/6844904106847371271">https://juejin.cn/post/6844904106847371271</a></li>
<li><a href="https://docs.spring.io/spring-boot/docs/2.7.0/reference/html/">https://docs.spring.io/spring-boot/docs/2.7.0/reference/html/</a></li>
<li><a href="https://docs.spring.io/spring-boot/docs/2.7.0/api/">https://docs.spring.io/spring-boot/docs/2.7.0/api/</a></li>
</ul>
]]></content>
  </entry>
  <entry>
    <title>2022.12.12 - 2022.12.16</title>
    <url>/2022/12/15/week-16/</url>
    <content><![CDATA[<div class="hbe hbe-container" id="hexo-blog-encrypt" data-wpm="Oh, this is an invalid password. Check and try again, please." data-whm="OOPS, these decrypted content may changed, but you can still have a look.">
  <script id="hbeData" type="hbeData" data-hmacdigest="b73cd091c7938bf20a8577b5daa76dfcad1e47e0b840285fb7526a7c2320af2a">a99f2d1cd7f89812758242c57c62a59fe859e32cc19116fcceb1abacce500da0960986acd07eddb3568f524414b51fee17e4d6bd35088912fa4af175c2bf91d707d28626ce04406e2d0a9a2d2a331aa4ff2f116d05cb5319f8e755325e2424fd007256612574d640aab91bc6a3f786d7ba40ae7b4cea7277df0c3a40328cf9dc3c674638afdda0671643029c0ead18544db96753a22196f9abe44927d0bc5303255eabe43f7e62f8d2cbc6aa860622049b96d0ffcfda6356fa27439347e7791a294849b9912e091d1b6fc50b65167132cceab9d016d3afeb94e387acd6b8fc316ce965cdc4b92f11d72abf1b9779f3947507a23bae9d6f68e2f74b7c881258e07b71ae2972c3d61f3e8042f13b92ff6e47a40e3f9471a887b3ac9dc671731e2635fb6d59d73ddc916c2d1ac0a34d45cf1f2ffbcee0a93a553587d31e4f6104f89462e44eeac7f8bca6ef3ad9cf4d37280a88712fab32f8b2f311df177736f79663fffd53257e083efacb09fda007b7b871c8e37caf4361f238a5fc6b724a3cd5e7b0b0fb71d2f3bd11a23c99b9db6f3decb3bd68e314b921689eef5ee5a84788e01e66680eee4fd97530c882010bf367631ae927ba7910dcb4aac11c437d9e10c89a5d7f85154f20da355e96440f430a4caffd65241f05682292f6cf86ed3f12091225f640fb6f955b1edf8526b035f4712cf6d0421261c63fd2224f88db766c7939558644edd2aa34496e5b1d24c738fb43b1f0b17d646ab40f18a508715a8687097214e412efa18657e3f965c09ad67d5a9a9c4257a5aacf26373e9c58feff6d84a4e7bb2037cb61c320ec8ac895a93577dfc18b05482de875dc0b1519be27eada94572ec7f416de5289941e400825377c50e271442369d7768977f5336df4d47fb5d0dfceb1f02b941de63360cb92b4fe1f02410b751389a9eb4ea4304432ff8a9ff1aaade12dbc505b2be3b4ef88b75678a269549b3517a3d374a7ad6a29497a8fc31ceff6627b4d480a443a873bb5b1d7d5cbd3c8f5cb2b91a410210d5bbdd083a54c73b9606e349cdbbbd3abc5b759ff4f7c71261969987f33cc0c0d3c4a950eb43e10efe16e24e2e3706af4ec866d7c3c5630445ddc7dcc85b1aecafcac9c8cf9fb90883d03829ae7ce355e7015bff544fc34b389faa2240e6588e91b82a5d47440f48f96527f6029ba048ea780cef49f04fc85051cac3bab4fa610b4ab05e51fbcc62029f51dd747eaaddd77a7516e88ac0b860fa9496d83ad074a4c</script>
  <div class="hbe hbe-content">
    <div class="hbe hbe-input hbe-input-default">
      <input class="hbe hbe-input-field hbe-input-field-default" type="password" id="hbePass">
      <label class="hbe hbe-input-label hbe-input-label-default" for="hbePass">
        <span class="hbe hbe-input-label-content hbe-input-label-content-default">Hey, password is required here.</span>
      </label>
    </div>
  </div>
</div>
<script data-pjax src="/lib/hbe.js"></script><link href="/css/hbe.style.css" rel="stylesheet" type="text/css">]]></content>
  </entry>
  <entry>
    <title>2022.11.7 - 2022.11.11</title>
    <url>/2022/11/10/week-11/</url>
    <content><![CDATA[<div class="hbe hbe-container" id="hexo-blog-encrypt" data-wpm="Oh, this is an invalid password. Check and try again, please." data-whm="OOPS, these decrypted content may changed, but you can still have a look.">
  <script id="hbeData" type="hbeData" data-hmacdigest="076f925be20feb8edb1bae5c44af29329b8c0426c7aa91ec2e9f1c59b69005a9">a99f2d1cd7f89812758242c57c62a59fe859e32cc19116fcceb1abacce500da0960986acd07eddb3568f524414b51fee17e4d6bd35088912fa4af175c2bf91d707d28626ce04406e2d0a9a2d2a331aa454d697d42d153ce1642f1f553c1e835e9adb24937cd76f2494c82dde30e80991c526c68f56ffe5890fe4f6f5f168d0be97ffe3910d07b64b5fa46a81e5239fe1b8256e4cf6eff1014fe1a4787989873555cd0510f95677d0dc56ec2dab84f73c338a10c361d38ddeaa700c10a2771fd43f5f7577e51c73898945b937ab57de98d3bbbe5e82a27d8f96d4ba65c637d28dddac2217e17fceaa0707b997200d2f31154ad9dd21978dccadafa2909c141ebf779617d03dc9337bd62fa6ebbb9be1aae81b58140366ca63379b2a3033329f732318fba8db934d32b651af352a4f9b8d6aef260fec2744683b7728cd69bc7a6b2a8bea52e31e5ca8bf524dce9cd73847a74baf09a1ab8321119ebe5f960973ce24d7f227d164ea9741fc8c2d5c01ff78cb85322e3c699e37f715a860b1d9860c77de8009ee4a8634af55ec64a238c6056c91e95eb2349d8f663c769b32c7f67453ac6b66868c9998889d28d838b38a1fe2f47901e6f8b86b09ceb52f3bc5ce41e72aa1a8b9b239dcb41a54063a98f68f5060343775dda025433e6f60d436baa7991ce3ca8d0cb84be8294fe2dc7916c5baa5d45072c1ef5d1cd2faf70bec6643ea4b7c07c3570049341bbeffd15d2b86f276eac831ffbb677133b3ac6f652d38de99be10f363b8b8da9f3b59ec2ade97059f3808b8e8720ba1b9f82909f9e23a65e63d80f8a541118c43962ab93eb2be34d7bab3a7f9d9d772d304acc1f685ba9c7f0141b8bccc8f8fe41fca9900f69a8677835d228a47b445fb83be946618a32b3e905ab46241b6c08ac78a7bb4b1ef1a3045457a3aacf87aa2d0e6a23d07c6534760ce09b1dcef989ec9cc3522c5eccf15aaf7ee286d430306507a0f6fcb181c464c73a594736202a4cabbf67e6157410e3773e0e8b26a8ff99da173fc04a831183155210ac97d0394b3a17504423363ea5dd7c79ec4853de796e02d9d2479b0d1887e1c878ac42b273891a8c255f8abe996f8b905f42854ead6cc30a93d9aa07754d63a9b58c9c2dea782e84e2b58cfd145ff42a7d326c1bc756f404f0ce37e7ecbdc713ee3fec9e63f746bb49008bc304051109512ddeaf11c43a43873ccc768bb5d4c52143660df443d03f68b1e562ba6075bff08cd79de80aed568c8035713567d4ed282fc9dcee1c934f18919423646f62f529a8e52e6b84b4e2302ece426737092e050acdfd71b66b06f7436ec2e7da14460ac4f89a6ecaea9936a011989de29fd129c845a2a676dc59de858385bc4b33e25783b411e980a0c5809c324cb274f035b38cd55d0546dab451c3177f8f49d330437ed33d33b0ac8b4f3984330b4e5878019c17487c2bd4a1d56866901ef6899853da01127f38ab04937c12f710c1cb74f52bd1c46031041ec60b662a62ee05a721a7b50c83a1ef8bbe9ea56ce65e5e9f35bda3bc1969666d9d5a9213f2401327d6a751c86f6a94c4f1da0019fbb924b644feaa672e03a9df94ead8c6098f9c878321b77268ede895dbdf86bbe22b32a49431c0ca97aff12ffdd78f3cd0407196804b8965fffeec434134cd8cf5910c08ccba0c1d5ba9a5e8ef5157a3403b20e6891e912d2df1cfff4cb3cf4a3e074da154e64946b62bf58f9c7b99810f0af0c1ea7ee17c63f7d6b9d1c28dd9314207e89f41344ab7679e2b5aae60d2b60f266e2daf592522197d05d97a3e139c508158ea87a5f29651bd16139b2ddc2cf135f7046d3b66c47693f66e8c9f48c7ccc4a0e63834613ac0493976e987f3b94a8a6703ea25d27b3c4271e602470d27a31c54139f95ccc091fbe45e6ebb342b8bf599965b888850c15b20ca7e2a56a1f00dca0a7ce175a0cf381e823063d5f70f71c26a6955a84ffb1d56023fb5e7d37447290e4a349ec6ff243643cf18c8698dd8c8f4d3d1cfa7119ae6901b5119d3e9f6024f710308a4581b6f18fddfd967739fe799ed0b9c9bdad1f77a7a1a350a93d462a72026a4ea2d420c96272e1535ba27493ba73de62f1c23b8efa58e903e66d433396596937473aec4e6606b0250bd24b3c4570f5e8367d180aaa1edd792a7ae5c7ee8e9703e71d5f7920869751a0c5ab8db7039d1271b87fc31059866de0e6055996b257c3ee5a0d1b21daa323d8f3b09383fd44197b79ab4ea41575a0d06aef904ea0c6556da85e0c7dab3fd92a8ff2b46584fdc046b7a25e2f140f7e61428e15c12e26dc77f66d8f69b0439e2945c300574fa823972d5ff3d35ec21063bcefb782658e6da05fb2612018b9ea78e60c4982b5a04f8ef1304fc2d2d5ce9c3888dec6dbfe8f1b92adf538142ffeab601e471f19801a19f3cd417a3f6a8b05a434c0b9ef6a4c21c332b55c3e69dec85676820572c3a8a5d4cc8106c9ef8f59f8fc1a96a00c3ee9113f4051f5cb75f511f9accf3ae40f1fa2bee42c70ec72e5a1c8d272c0aa758f9baddfa3ae</script>
  <div class="hbe hbe-content">
    <div class="hbe hbe-input hbe-input-default">
      <input class="hbe hbe-input-field hbe-input-field-default" type="password" id="hbePass">
      <label class="hbe hbe-input-label hbe-input-label-default" for="hbePass">
        <span class="hbe hbe-input-label-content hbe-input-label-content-default">Hey, password is required here.</span>
      </label>
    </div>
  </div>
</div>
<script data-pjax src="/lib/hbe.js"></script><link href="/css/hbe.style.css" rel="stylesheet" type="text/css">]]></content>
  </entry>
  <entry>
    <title>2022.12.19 - 2022.12.23</title>
    <url>/2022/12/19/week-17/</url>
    <content><![CDATA[<div class="hbe hbe-container" id="hexo-blog-encrypt" data-wpm="Oh, this is an invalid password. Check and try again, please." data-whm="OOPS, these decrypted content may changed, but you can still have a look.">
  <script id="hbeData" type="hbeData" data-hmacdigest="1300251b4c05ef0f830baf34bad1b24d9a57aec54a58fba9d0cb6f3473e3c0bf">a99f2d1cd7f89812758242c57c62a59fe859e32cc19116fcceb1abacce500da0960986acd07eddb3568f524414b51fee17e4d6bd35088912fa4af175c2bf91d707d28626ce04406e2d0a9a2d2a331aa4fcb428215b39bd5d256061970375b5d865374d82a251cfaf4e227485c39446d9ad70287c14a41ab3a6c29f9cb6a5915c501293e04bdab614ec7b2293b3abecfe02f7c02778b40a4d805e71fc8719ea9e1855d216d597ab9b5d7aa4d03f8bdbc54cfe095b1e6a96aebb9cda33a0b9a7f5525a7c60208cab4f485236b8d4ef17bebff87c7e37a23ccebe73e48632f4dba7cab42e94cc2bddbef3948edc1a9dc9fcbd794be58fedb0cce288d89d86b38cabee9176a4bbd81398e235e7e74fe55000ce5255f661219cb2f525f6922616da797e7e9581ec59d3ff440b815347803447bf0d3ceade2e7f2d9d3bec4a4a6d7b06ee677dac5cd79baf5af4db4b5bd1ca245fd65de3bc9ee7c89f8bb557202983676487f5381aeb1642c702df8806d83e0474034864e3d582f07c562fa4b6515d8408685330c16ea5870f21c6db75b3cf2272acd51f4d3f35dcb6b45038734b4f7a45a3202d54a87f31efea298503daa90405ecd686b7667b4a263dbc3767378fd4b63faaa24201510e9cfb801114fc54dfda0c80a8206444c94a085e369a3c0f9f78e80bf3334d764c62340acf9cefad6a047a9d1845d6faae3aaa9834b76c1b42ccd42762bd3942dd4b623556d9c742486f82e636bd06abb00bdc88d2828b0e2d24bee553f718e9e1083277f62e0bfe3e95feac0ee149910c4e823d1da6263f8cee688af3993d8c8026070d4aac223baa63bfb0cc856272acf3218a5fe0f1fa62e4f3d55df9e464124509d9ce77bc4b658cc8fef806cd6b72504e4ccfb21d39163f6d1b38f46c2e9b8ea39922260e81fd400d6ec42292cf00a87296dfa49b900101ceaf707c32727be083fdc4de7fad0e6f7c49acb3b62f32daa17d75795fd4160275f0d1c5722610575cd714676d5d41222dad796df70f95e2990f1642a4e7f4e7a662c24231dfef518796696ff5275f45fec7187ae5acb4c673eb39d3afcb349d1f5032384668e0c6df51f21d9ff114ab822e74ec7b4f1eb237220761f6d24b3377017d0863ea85258cb05d3dde096276bcd870ae015e0c1e2b24c2bcb1ff353cba991b5275cb8b546efa112bda2a7836753827915a81da18af4e9574a0ffef2099632f624d5792d8ea3d5050388a8a08f8065f9b7e6f5e43d559ecf59b9c5962606f6e75369d88fb77672850056af90a0ceaf870913dbc00aaf8cb6cba5afcd67743f877f4043fe5c3443c41da050aff452bfc51f1194ceb45aa18f9a57bef66c9a9f1330450dc36a870c4078cac542d0e7d28b7171e2e7738a466bd3c4203a88fbd96b06cae46cfa84651f7f9a2f86a0f70ab4942ddbc809f192b76a747732933c466afa0c19d89aed01a4a49be2cf92b3f529c45d994ae259c0a2ba22b5948cf0db2713218b4519fc5dc7f76cf07f81d5d00a2af2dda458731b362b466344eb28a828afd2079f0ef0905a8933f4fc5466a12bf29405b3904232a9fac4c9b0dee04f9826a9e831f2da7447356384c1106b09682ffbd647780aa921dc8931fe3fea83cb65078a66f9b4b82373bb88f475baed015aa333c9d590e100342a802c79b70f1a92806f0dc22bbe9cd4593adfa129639dcb0039f67ad9579dbca3503aa1861b51ea083aeb4d85272f712869773992c46b3ad4b5663097eceb431f95fda534c0b0741d1c0fd314ae1ecbacf5166b21690e9327779925e1b67073934716465e01bbdc9197f9ce840c45dfba436eabd3cb8d42bcac4d40c6057ef79fe5cd6f4dc022abc9b59333d48e719387949db17489f0127d885d832d5d48063912d5c506949f4a6763741f870960d7a0540f4526c4b9b0c746cd6d6f14c8c20c1041bcc6bff6908db3246f2ff7c63ff7c8829c6d7ebcd00df2513034b720346bc788e5ebe04d7abe95e91ad460e475b769ee0e3b7d36fc6b7029b11b723a638e6bfcf5f135642e79a11790e85e6e23ce5eae59428c1a20161de09ab060344f783bfc28f9ae994cc6916041df9e29e00dd247f7856eac42d3d209dc9e3464d5357b922d6e4837031a62ffc33f58bae07a2c6b077e5bb3d3d04210028e3b01b901ceacc528d565380ffc1faa5c284f3990ab8ff337cf7f298c2dd7438c049eae46f9e060a92b316dc5f3a5dc4177c85721d449cc177d15f45a44bf06fc915d1682f4c60bfabbdb2bfad37f4460e45e59b593c4fffd37fe68afe75e73aabd1cee0cd48d9ff0d6c9aeae85ecf82877e4cf7f5a0361804bafb7fdbb1d94914c2f53343626f68e3ba1d313ccced71a369b9d16f2a27f986e516673a99b66a9a86c928a58e02545f475b71e1db62fee75a684e66cdbb0e45cbacbba437e07f685e4b48a371855883fdc1e1720062dda753d8722cce8ab46867d69ef864627d0a68f5fd0e727e123ccbfbeb0d984e7a1c8586ad1f0f0ca2eb66121529629fae7d92959774a6328ed8336832ebabe851b6d8c4b3723047716a679fdeed2f698402998feabc9159eb22f76add08d1ffa6d34ff1b1c2841a3485e7459554498609c635cab24ac22ac39e6603114dd17288425a0dd1b5b2760011c6b9395785a3b755da6fc2b39e4647c0ff9768b27327602c0d337c3888fcdcd0ba52d0bfbbe159d789a52c97806ace9f52a9fbf75431ba228703b4b0a851f263542053abf9c8cfa68f4e2086bf0ba5b35cdcfa29777b4efb87f1304be6e2980ff3fe9813bac66efcfb0bae19592cf393acf943b420873ca5fd2b3f0901eca245f141de2cc4dbe2a01d60096fc3d5fd7041b9f9cb5b4473d39a9fb021a3bf35ce1675396590335e64f1a3a230e5b96d6c5dfeb95b24b8cda30da92cd0c0ece5e1fe324f7abddcabaaba4dd2da18c25ea2f5cbcdb2b39dbbcf6004354fa015c021e99c7f73bb21e21f4c34459e4be63be6d1f56d317e11a06ebdb47f8203d872f9a9a1a70e411d54a2e24d8eae5f8005f7c674d5665e643c0174df1b8b3d8a7754895b0462ae5924c89bd355bb48454ff291a9f28221fa8a3120337090afdac7e4ec4eb17cc33328bcb11a0c0e811c412b3fd574cd9becfddd627152c8bdf3cd022ce81ec120ec91e21f107a6321f06b29179d72fdefaae0a0e5c081e1ee3d9df5a023c79dff30baf047b98b843a52f3c94c88c67dd7e29a38d26af4b9d9e309ae091b5125df24c0313edfd305e7c7c4691b1e3a28ab0aa7c345615842c33e2249b5926ea40d5b851c5d17c3f4aa110316345b647834f6d35139ecde13cdd7afcc390af5ee78e3544c2bc6e769da6c8cc87eb3e86e821120e46b48edc9d389c4ab7292c15cbb5f49595fb68b5280c47536bf5f54f8e05d8544da574247128048e3351455e2b9055828d5a7015e1d809a8fac4418d7f5c6af389d3bab03196629270c1d977db8bf1199ab7096df36b174860cf4dd7aaea34d79469758b69b1aee5c45a2072bdf0b8edab0e760e01f82469430631a8ce3f6d0ac4950d078328ab3b6eed277747510031169beb554816190e3f03edb159de85cddcf76170c4658d941183354d42af5ed84b04d9c2205ace7da7d392d4ca10bf0506c9158d98238e0c10ef9fa85b9c4b16650b3b4a5c5b59c8ea6282c5f633a3b9fafc659c137e30d43373956aabcf9ae424d792e66baabafa3c761177b2ff223664590a357c1057bcf6b695662c2f34e8033462adea5c09cb32f8cf791bd273ea43c56e2fdf2243f545030a2e7a2c63eac7ef7ea2fb4114a9fdca8bd8484a8a37020896c2893c5f7b08b63bef623c1a12d57aff5716f0855fd4f4340585a92f7fd66a5f0c074e80f7690aa976efdcd781dee8a6ae973d9f7223a5bdac6a169593bf2434452d1bc4f1d14ac1bf104859db249c634bb05830b1d7854ef912d1d9620074754875e07c5bba8a8752dd53b6ab198b0e9ad66254c7d39d6b9f68c6f5afc551fea3abe726f7655ee2746a25ae0484c111c66655c915235b12a6b779b26d72ebf73114e365b6c76218f01989d577134e5641533b165438a869d5031c282f7cc80b42270625c90985770c811621204a28d26044e0cc48d5e80c5bf127a8ece8c65bfab70b998bd8077e9164d324f84da9bad27bdfc95d86a0f85a4018c0104db1021f652906891adf0968ce837941e69436b3eeb1926acbb14fabe9406c83d1fc82daeb264b0c583ba200d552ecec28d685471a47eb27bce9d6de7dc33e3bce22672aa14d11aea5ba2c34143bf8e442b7908847676873b9b9ce68317ce5cbeb1813e223fdad4d20b62f1d986c1605d47f447af697fc673946595e213fd1f9dceb1387f33247b1f9ba4b04422db31e48211fa066dc9ca242ccb276d30bb03c6ba7e73deadec0f801dec26bd87eaafbc1feb1a6031b83b1da056656eb963a12d1600c05591cfb5b73da86d0db428d8edc826495867af4276febe6b696c463d035830c9ec651b6a535806570af1662011553d9a8147dcd433892e785928ab0dd727215b395ad4f4cffea4e9c56e33099e7305242fe5f0025c6904a8636a72daab8fd353bc517ddab974c7fa48ecc8413bcd9b2ee38bebcf1e9741d895697f69184a257fe0c6fd20a8b8828462c1014878f6e00be70174c5ab5388740856fd6a123facb9990177f5a319e4d0c93d5aa3a829cd6d8b86a013e471dc9232826f6ba72a1b3101e8fe4a4161cca79f3f554d6013e98ee0458ab4df886a78afdf5640100a74cd3ff95cf3cb0df9167b6485841a267961b4ecb94fecc73eecf1f47192107727b77949cac3155ff0358f1ba113eeb4adad2fed1db94648317a7af5cb90799f1569f7a94eb63d9596ebe6c3d361c45afca4c39023c463e03f047d72df3f8882233b7456c4d185f6175c8dfb93b4ac37f69aab97dfd938cf9cafcb5e06d1cb00f27ab30384e291a81e42f889912f8a483d410fc548551d880f71ea3f2daaedd107b1e7ed3dc0acd8faaa340ddc200af817a044e25ba81aaee7b9aa108db5554849cc74f15575e1fda1a25f16d3e5569d882c758184e3e70a5834c7f4343e61fb137d5d82020a717e0cfc483b716cc4f180a3ef7db0244c64481a9065b78c2220535ea174f7945ab62d50028b5c94f31bb48e4951bf58b1cddbbb0d8bf966ad6923673844d9675ae0d7d526be116e33dc832a06a23876d5b0e19f4042af62b6cb35f7e3bfb6f6fcdf77e04e76cccea62427de7a338868327441cd43b597617219685793f3aedb4cdcf34f4e2308baa95c228c92742646a676d31fe1f55c8860da3d2d8a26b4f8b07dc3b8a27260f003e90fb4cfaf2abe9f79bea0c03da5fb751f4d0a35e0995a600e71e445b846ba64cf703ea30c04d770083f04c567d4076414fd1482551c45b65a8713cb61eea52a5459f321aa31724a4cbfd7d1d582548b14ef28087c485415fbfe3238ad499cfa808d572542d552299769501f2e7a5983c31a1f80d4aa97721901a9ff5347c9887203c1262d733eaaaeef491a425dec3a7f544f486fdabf37153c84ddda86992ad2fd9077c3f45c0e1ee80818b68719227aff1eaf03c2ff8c914c94a5ed20b74d380a5e90d1b46347744e8b33c966f0739985ef5b3b7cf3152699bf565fc5852c27bb2b02dcd221485e529931c14403e6d42ae2fcf9fdeed9e361f8755f2c8c1300efb965921cbd2dbe29eb14e2e09ba4945a62658d5f245af77f0afa624183b6f2166da4237ea5ec3b57d8e78d9dbeea00c044433d264bee98ff5a1daee2f4e66c20af0ee01443c69589731a04244f5f0a48fd7d754db67a667afe18251241e85cc0583a53bc6db1d8a72464001cb4d2fbfac968314efd0cdec6c54b18595ba53f742dd759bdb34eea2513714c91f483a5c1d10e7eb1450aae03ead73aff1ed40092714c0e582afc44b4e0cf6c98f2a92e804242ba47b80dcdc1ea22a8a210518edf0902309885038a406a9c93995296a6c98b4c36db7766e94ad8369499459771e4239ff24488d206fe997eadd525c01794942ac3f422e15108a061f8e0a608a90aa5dd06a38f3dbdbb04ffb9d21674d7d5e5ecfd9760de6bf0ff487336d7de4174746f321402c22393f74faabaa27e9b0c0a27977dca447c337d515be4daf18c0aefd5b635796925b7c320c6813cdde02b80413b7bfff0571ed8313f20053c95637e7e00f6a6af7a6639b722b9e1802de3fcf65e539163253b8d6ce0b81c445e05d6696053403917c502e2924c2d177a8c115780dfbd913eeecae0ad90b7bffe72cfeac97f5b542314d18dbabfcf99dc8c7d7780ba631f65d3f012ed3e4d580e236aa522459660e1872e7353449718b7c1b059d741b5491de58b17895a35ad00af5082623b946068019ab9c00c8e1001bdd32dcb3b37007f1eb9b3fa355bd9b225e598b57d085c38ea5573e1d6437674a2c25fd57cd3ea3ed2d42a13e5093146e4381bc6daa584eee70ade332e2b5c65a89bce0e18e9d7ab7f3ff1a998af53df46f64634e86efe4966bd74a3aaa7c32adf8d662ba64273683505aef40a0251d6eadf9392902d07373b9a8bcbebf20f5e52a4d59802e4976ac47e7c7b8300094d334e23a6de317d9c6452af75b56a4745aa5ed00a88b9d8d4c092200566f961073e1923fa4252b9ceaa5656eee2fe0b144528e2fe614f9f445fc6d5ee0bfaab4e0e3f5bb339a8fc282248e96dec93897600efa57723619379d6039e2f92a2e89eb6a600d85388293441304b0839bb77ba45cb329f69650e93983a640212f4b0a0787ae4090d54891e2ad9b91bc135df13ab262e403b5689844fc13275ff2c23e74a11f96a2a14e9df8308d81b664eeccc4bf85b9ba510515232f241191e0f81a9b74812f7b6554c8f21677ee1a730705be30cdb02ff93eb677f8e0e3cdee25ef11948f851f7d032f0de202566debf38df7a1045b1ec32b25b57ed22b547ae8abbe79716e6df442f16b5910c9921cabdac4067d01152bf2f4039c05e84ca0c5cf53ad01cab89e7009273c713b4a64f5f82a3c667aeec746afd6d7f2f8cdfd464ebf0befb4153accdd69ceac12900c9155249eda4c7f8cb8a7264a0b5c0cfb9ad4bdce9522388baef28295b1b045ee0646c3c60fdf3003152723cc5ce8165c80e0a7437f44a29f987d7c4266602da557e13b39508252481463818e176bc61639d35f3fb326b9d4d2466ff8c23181f38b6e392874f44da1cfd32b9262a95d3bcc563e05e46a70fff69abe3194a7e5f8c89ffe7e17851fb4658fa87b545a7cc4f8f09b158664c41d0da7a57f9481b781f789f6c33c90dc9484bfdb670f059d341046f9c7a69cf8013db7d50593d8cc004fdcf9bb48b6f3cfcb9b85dd704300e25a59b4807c23af01091e17c6e70dc90d945cbff1f47d90bf193f4eaedcfc80c451aa7985ddcc6f6381ca1c7693867b9cf69620e1f06b813ddec7c58459a49e4d0458ae865c21e87cb6b053ce3a073ae186f7ecae5be9cb052ab27ba2e990504ecf29088edc26e5806e1353973f0c6635c984176eafc76d876e08ae0c3906544040187cef47e4a9996f579f972821ccbce3d16663b04f041a23df2fb74187af7df9862e70d60f3d730b4f99f161900b9e5b238056f3b07f291f67625e940123ed61fcb06882a501249658496676dd3bd757777851a79a1b8333502aa501dcfec36a0cf53ab5889afe11e667a26c38eafa3671c53a4e315bfdf25275751c39a3490dd95eeb8332d91f19ad2f00bbfc3e4dad2c6f3241471dfa10ae4f6ad4f32e0ccaa74c1366a7bef2e87e5ecc853a671d571e6509fcc797d93447f9344b9146fa6baaa4b72aeda05c216718b5e5e89b1a4d31ff7c42f63af8fcf00bcbacfaacfaaa338d8549847b262504b509cdd0820523aad86e9b682ccc9efe8625f9b445c07286c76dccb82c9de1669ba208838945550d22ad968c95aa56cc2f595309807ab6f5af23290f77707af51166c361245e1d58409d169e5ed3148a8dacfef19f150024b884616f59d7f672ab0e3d2ced99c0131de333a6b01929c60dd7209f062caa5fd0277c09e08795f01727e6ffa9dbd4d29db424a8e1389b528547780c735ff6cde653821a6281e012326bbc48b4776746e7d1a5de247938ea58d30b67c59195c7617e0c5766fd18e5c325c038836556e19040f6936e0aabcfca5b7955d39fb24550efc61ec4ba3f923867166cf88c7e704f0963f6aba812e0c024efbe992ebe41919ebb7074f6f6d009826b9d73e794ff794195d33d959a0357408e867958fbd6d1261d5f4769178a36a3ca0a7b2e574b7f1b162a5049927a7cc84c01c195bc4a82bb190e0bef4b0a06da5d2e8064346a06a152ad5248d8a221d489ec79371f7a184785ce49343aa7ad22c2800cf90be7975427f67186c28f953cb019d84ad396668b0e028e87a377251bccacdc33876375e242e5e4bab251feb177040dcfe151596cc215aa00f7659b4c21161b2d8655bb99bc5a8af13b308d4211ddb21bcc0d09f3cfc540f5c10419dcfd433b20363a28262e586d36e3646e5add09ccf496316a39b0eac1103f0d2058e8b90de8347b55f65ccdb1854bcae32a046241395a5d2b05920c55b44124dd4e1b52505fef36b150fbb3b7a0cac530820da5d0bc5ecc2fdec20f7239d3ac955d4abbfbdca4a5302cc7eb871dde2e9494b482fa0781c3842eb906477c6de735cca42ce26464834f533021f8de17365ff89d5948d4997bcb32549031c8e8523446b28479cce8d2fff3a4de5a62d418571d1949cccedd63c256cf4c35fcfc2c53d758a371c9e72a286799499a8c76baf48042f0f359dbfa1f5d0ed3f536b31608d6d4bce8bbe43a1b46b4e1d98d8890a2f658859cc21c406596cf80c3d85d2f2f79d12a800df8f8b439c23ad4460b85d1b64f3710754dc80ef1cda1145557f5423369e9bd9e5360543a1e29bee58530b1ef8541fc3aff1f890a7ba37760ebc8beb0526fd6a6b543ef4b829231ef6b35484972e607f72a9268a34d020388c2eef61e765b76a24771ee61ee20904dbe7cdb60147bdf224d9e4a87a0c3c604724a3e5475ba99f4f20003f72a523c0f7d3b2ba7f4576bea0ba79f456c36d174d2f24e6e786267c60805c1809d97c1f758f58b18c41daf8820a9f1f035e05c23321c8a73de7bcb2c740a9a57e2e53fa3fb8bd33aef0c5844f122208157b44a3f1b6ee1d7c6f9463dfb273b681ff8884ec9863b498178837299562e716f683ab9250de3e18fdeaf98131ab04f9c057a0c9219651307502949568fa08461c26f8b2450c025961e22aa66789c37c94ee287c8b717ac867918e1cd4f00cfd7869cfc4cf20c621d3c68722b3c3c26421409d8591020d3a8f436bc5b925c3e3dc8b6db999c72476b202d1f3147f4718bebe7c120b8791dd2e0a8556a728feeae24750d5561534472574ac44934b17f760c83bc003495f4a9d963619e8c5369dcd4ca6ba86b617fdf810d8ca4d851c17ba80afa71ccd18e1504db78dfdeacde08033de2373aa3a1fa4ef9fb0145c75903a6b7fc7834d73d6831f4d9dfed318d00d1f57731649f7eaef12de4cafe1bbb4b2eab6b5e3e4baf6249afef5b0d059c717554f888c576d5c354f3ec90b006623116a5b482433e8c3745ce7f2ae402d1c37ac85a023d417782bf632d5b3ac44c371dc8e17e68bca9a49d481a1fe6f1a21e40f26c9fe88558ff1916ab41c355bbfefd655774af73a5a0431a3aba876e6ccc782f0d7ebadd0b0dceb10fd39fe92d44f92719fc574065ed09b4ee9bc44e22063ff962de16a44e12e3f0b4c48f65500b8814fc76b07ca9226d232f246d05c3b9c6b470e6132e901caa1688db587c6a44742921deadf919ab8ad008edb59d2d47c232913051b05af162519e31d16e6c460ccc6b6246fcd0083bc0fb42fa809435673c70a025b5902659bdd105f2f0eea521871bb146e7eb7536b98d9af483bca9c05dcb57025fe9ac963e6d50420e617a2fe70fd89a1ae8165925a7860ef595924ce2aafbc61f42de77783dff30b149c8ca88f7880406cbeccf43fcd5ca0bf3805839008fa8eb4e08fbe550831d44494f54c204492a60ffe9e4f32bfcfa8e32051853c67163e054dae6a86206efe951496c7e64c973cfe456f414462e664139fd26d23b60491b42943618e69659adbbd11e874a4ae865be36d624a4a0166ca399c9376baf850f57a8b1b92c3e845d083d2213ff0320a936f22a6170d4f3a6649e71a4bc0bb5c3e3c169ea34c9df650e0d61518bac8b538fd8e2b1999f3a6db2daa95613592c605ddecf252b02d160975a3b716820a979a9b95f78bcf7e3e987174a1472f2d7031cf0d017e13ac415780d7341ca298b4bc6052d5aab49ae1ec7f139c4dfb076dafb10200468fec2d1d76f452e439de5a3dddac36b481d679c1506bcceb2e5fed0515d4ed22a3ada4dbff8b68c6f7808fd0071f58f4b6099d85068fe279fe3d2cd523e3ee135b8e41d6dc2e3d6ed625cad0c4e30630d655aa8bb2971f9bb31cd91bd396eb4d6b7031b52c059224f4e4d31187bfa735fe9f9c98d74a1216fa83a8a847c5650d9bc921dcfbe3c772cdf4f48b454eedad5eddebfe58f55933ada99bdaa68d1cf4e41e53df155cf80f7af59136bf1e770eba17f4d9beb833a9fb297f7d08e67d1f123d9cde1d27ef3042f5120aaa3be7ecae971a162773407d8c90cd9941836c59f48c7010bce39b9981d6b14c9825dfe23c21e67371f35b161fa775985d9dd1dcb045aba2be9363272219d900711aa4eeaa6c73159bbd01eff1ff4fed469d76f19ce47d926969be29089fdc268fe7a06cbf99b162c4e186db913f091ccd04b012b743d6cd17c3cc6a1c9fd6ef4b429c1be488e5376cfa1f2f81199ba91d6af6a67751390b81bbd5f59da3dd71f9e04c168ffa9af8e971fb2a40743eb7ebe110365dc23f0b946ef643ac32bcb1398150354ad537196f0f3507eba4b7bd065c82b9df67e02afb3e9cfe91a8781614d2de21867502f0f588328212be1c5fb2087beec0b6414e05152ac781cef34955541cef162778dfdd63e423d64a1ee29af80e6ef91ffa9aff09082b836a55c4f50b6f49828cc6e64c8e1542e40b3c09196454d2fc71fc105620c24ea959ded2cd80fdcf9a98bdd575ece980ae9d87daf480e04ec49f33ccb67353c0c8d09af08285448b17683ebff7070db08c994291316cec077ba40fe722032a447587e2944390d00321834f4729ebfcfe302fb97b259197f269990bd59c395a4d18ab40ffd0d5249f5ddbbc67479d22b1ba271ae62f5e524ce92426ae311da0dba3ed008732145965142b46daec741c8fa92a89e359e6f98ec64420deb49b7f1fd31f5f0cb9ae5342c1dcd86fc14aa4</script>
  <div class="hbe hbe-content">
    <div class="hbe hbe-input hbe-input-default">
      <input class="hbe hbe-input-field hbe-input-field-default" type="password" id="hbePass">
      <label class="hbe hbe-input-label hbe-input-label-default" for="hbePass">
        <span class="hbe hbe-input-label-content hbe-input-label-content-default">Hey, password is required here.</span>
      </label>
    </div>
  </div>
</div>
<script data-pjax src="/lib/hbe.js"></script><link href="/css/hbe.style.css" rel="stylesheet" type="text/css">]]></content>
  </entry>
  <entry>
    <title>2022.9.5 - 2022.9.9</title>
    <url>/2022/09/06/week-2/</url>
    <content><![CDATA[<div class="hbe hbe-container" id="hexo-blog-encrypt" data-wpm="Oh, this is an invalid password. Check and try again, please." data-whm="OOPS, these decrypted content may changed, but you can still have a look.">
  <script id="hbeData" type="hbeData" data-hmacdigest="43e02f65fa8d2efe5b9a12777132cd9ab9a0dd665b9340c7fcdc55d24a23a694">a99f2d1cd7f89812758242c57c62a59fe859e32cc19116fcceb1abacce500da0960986acd07eddb3568f524414b51feed7a27390ead2b4e38ef97ca6a69051deef0c8d68f492f6b9b6875056e2cf998a309de192cc9c0f30f9457c3e1e91a6cb8c8793ad2ca89033023e9d07b13b4b4ae820d9675bf09c18ad85d43e5c37898a5c99c922f50032cc27b3f10e59f83c897b5e28a46e4a61b9ce2cb5e80457dafe20d38d417c572b86745a4d2da416509a5bd9854e92d2424b6a30671f4dc0ee5800d5e3e97f6ebef125e71c637ab61e66226af31def0e0339a31cbb19950aa058c6223325193b5621cae82397a71c725219602bad34cd387ef92cfa6fa6064e26a1de862abe453a9565ffa6805a957dbf8650d31eafa511661d65bedec10740e9128ccdb06fa472ec4efae59baf4a34ea4e14b10e96d1ab31db71eb2fdecd52a1d075b96125cb8ed031d1b0fe568ede1d07510c5505dcd4c4cdf1daad7eec5a2a51fcfc2afb41aae47ebd0794dde6cd02e654f49ecf75ced8bd37f26d464ef744862766fadbfd44abb7f2777fb906d3128a222f416dbbcaa8e3222cdfdaf99fea9d69aebafb1b4e0f9ddc41ea8e82307081596859ec85116507202afe88979503ecb9a51d38d5fb38ec86991c27160e08e4d5dda505d2422d19998b08e70f5f2cc5f62b663c84f0c42465140e5c00d59e39206ce6cb3610257f5992dd277350b90b49c7e525e5aa50f3dc834cadf0dea62a9b2ac3acdfd1022663176f680f99d8068470ca586f7f8d9de0af83c543c0eb701cf6e36dc171234f61c66ccbc64fad93f0b1c236c781359bcbb17655c106f50dc88c8b354e824d4dd884d38a4eb23d18a74ec23ef121a0cc3ec2510aaa7fe90725dd3632ee1366203fb0a04e546263de645440019a82ee8167f12ae39cb6411de62491674482a6cce9522d6cc9a8dde3f7f605326498485456a67eda8dc5d29dc0eeaff8c20b43102ac34ecd6546b22bd5375d567c8b9d26858029aec94d1874979798be2bcc6b2b15996d8ddb21163eb5f1c90dcbc2e1de0ded08889f9f126c097a3d3a555ee55babf52db1399ae32fdc3a969e86c8fa75af9af56d728961e8090cb751e5aa0d81e7807df75932afd5472f378d9873c4fc5ce493a7db1623e86cfbdf3d6fd572302225202705825ce704cb114b98d63c6803373d44ecaa1af4aae1f2ab4d84a03ddb8dc13a4a95ad3e19ee2d60511f612c596533f5a1d749049129908b5b6a3d619bb646263c89c4c5b04ad86429b54b90a9be46d862aee34ee90b6385b712d4890613ccdb0492044e6c0aa67cf66796d9e2feccab1de969b948d3093f1c9eca033018a1faa3cad1fe2860673074cd9154dc9e12db6e9b9b2556650051efe1613201ac5430c58fdda74cdd3a68e46c060a76b8fe8a7379695643d2a881e1e395ce0dbdac63faf26d6b732e02c74e68da4a0ee012fcbebc6a251294bdf972f6633226afdec2cd28d9871407ac380c17e530c0bbdfe6e95ce9d3849dff88039ff1d7b50db6d9930a8ddaf5d29b364c7ce1d65122e7eef4021f698d502c0d68afbf6cc93e5b3dbf2057ff6d4f3089ac49da044d5a01de79c2a9adb678c2ed318e81bf33f39e8225708d74fbd2390576ae14e7c84cbf63c7818cdf6fecf3f22859778159da6998f3837f10e07e20006bb07248f8904a58e874e4da3f827593bd691695c3073f0a3d951044e33ace7056dc8e120231f31a9cdedecc1e778575535aa66711b9287d5062fd17691bc3cfeff1241ffbdcbcf6689a0df3c28845332b05b3f0e8af523fd950b658488c4cf25d057d4c314652719c64528509533d7be85d995da3e860371cd0de35f5ae64d2c5a37a93479117a2edfbb76b025b6660cd7e4d495bf717d141a1e6d94b643d29314f2ab525b4e22eb56fd10db5ea19999b662033319ae1b9cac858187417f084816d32573482c2d0f63cf05159f5677ca5d3404be908ebab85217603d3f3a4348c23bc8462e171ff3ce030454762018797a516d845e1ba9de3f669bf8237662536cd15c28598ef585f5b8c5cee735b1518c31536cb050ac17b0c54ac505200a4c32535334155d340d638514aca3bbc209f7ef6391b7f30e1d76b1e2141fdd52656a1d0ff4299af47b1afd6ded9f3cb9571317018b787fa673171530dd63ea987518cf5c68d2f5243043045ada261d87190d49f7c43ce4bfd28e956f1092d64431160800e33ff1f61561371384e324786364008bc0d3a126934c5cf0c5e82bd76b0e5520d0feaea5331aad71eaa7538d57e9b78944366897f5e8a602fc0a1dda96a2b8aadf8587248879972b0781e2f5444b7719c44c1e4d90ca1b87245f904efcd4b08ea7976069d2cbc20b84923f847071af0fbc51561827da6891be42fdfff84f02a938086c69515f782edb3aadd46fa1e0fc2335d4f5bf75c71d64229a3fa66d1c2765465b34dd2503a10691fe1d60f0c6f359bd593d8473e3dd02e450668c8f69041775d811387f01c6a4044830fc5f9f2c5d2b8c49a717a9ad1ad185c7f3f2d6c8632adb249cd46418d3963b6830d06a488a626866ba20142d69db72ec36dc819746e5ff7df3bac3c284b3587cdf31f530f9db98a31f4a526917f33b2e601bc30c9de29d5840eb21d569cac96dfa6cb6d0de46f484dc75c6b7621962b9fed63b6a3d0571331bc7e5e97322fcae7a103a9edc6f56c0ebf7711c5f55a0ae770bbf4ebf892fe6d4585fd423a93d4002923664c42a0e1a487933534fc2ab23fa78f6d2417e1d680d02b0e78ceac4e8b54c5ce606d20a2de4caf9949537ff79aa03669d565ab0314627dbeb182490430efd9aa3b32c2861984047faba731da9bdb8cf8bb77bc5d1984f18ad11c61e6a75fe385941e2b59b3ba963169280f6172bfa87f62f2c74114617871a9b2dc6228a04921414a192bfa22a5ea1aa7949fedaf431edc08a6e5512cacc220f12f5759a256cb2528f67d4643bc2abccaff1589d166a5673e6754aa7cd1cb00db34473473642b8a44df0a61d2152120e056e075ba52f8f37b26d1ba80b0804006ab373171fcbe2417c76799ec5e922bd13f79e92f1cf04c1712c15a80eecd585a36c0807857b53a3cf97f2a726db9ab195acb8209e84b8efd418e184b04ef01657c68faaf8e6c864e1409b58e785a1b679599b83071a1de4f7fcd6a0815e09a8d7f5057d0002474d80db48562895dae1dbbcae34c0d2825f33dad9c158f8571a4eebb14bc93620709ede2fcd85e32931ec99d61dd46e859a7759d16501d1ad2f121f17cfaac7f626c7b90df9909f04360a8400209494bb7859242b872fb8d28593a22f309269d65526c8b02b020b294f708f2d0f35c22bf73b01567e55b6c9f7414d39b3e38785e6f2b0976d7b7a09fb003025ebcbe718d90f54eff7702d9244b018769f6258eac5c58cfa0b58f298cdb1910adad94acfa4f4331d759ac88ece4fffff4fbe3c71e00cb145182a6645792e98f232a4e08f2223f41c9802cdb82c924c68f27c9667a9218d690493d1767e663020a31d8a60bc138bbefc3a3f65c0e479940eecabf95a839049702dcde5bcbe9a151379f72224a65b02339c10cde848d8714c2092b4d06e6fcce7dfd047e1ba89116498ee874d19244af7ef03780fbfdd06b56787b33a4fe8fd19730fcc60fed0cf28aa31aa41884d1ed4527aa93a63f5412c7e60dfee2380276f0893d5ed5f6772c9c9eccf1dc8d47042e70b49891a8ccf7213ecde0909646a6917cdea595e1d035c1c43e2a84947bc9ed37a8b1777d0e3b30fb7f10752c2c7e0d66b1e29b95544a19e302a12b4f7c0fbda57336a0aa201b06a6db7dd57f864409835e40ad1d15d66c42a2f38f75897b357d2d01c94cd7cda9d2122efa63c6424720ff117b07bea46cb6ce048d86f54cf43a45bf78563abfaa48372e881e62ed525911cbb21be690d94ff63e79c6711e617d4fb5f18d4171ee12e117a7bbf28f385dadf6db44c7a263b3a262e3b354755e4b41b84279854803060bcc724f92bc86c97c3d27c3ea0de64fed6c9118b4581feabfeff9826f308a8e8463541a0b92b8490423e891655f3928e2c5f8215466283062eff9720d15eea38feb37a74a9ea890b0b0955d8bea9725e6ed1e3ac9a88b49399af32fd62a9aa323317144190399f7b46535ecc4fa581f0a2f8cb365fd34f80c2b5dd30ea2c8014e2e6f267dfdbbd8f8f90d2b99cc75fc71a82a0912ab72c005bd8d3e4fca619c0a3e3ce0e51d4d3a304a599e978f7e676e91351027b69051908a7476e59805069322faace8c366a51d1882cabf1d3690c36b56647699438c46982a0ba7536fc45f4c4cecba26590c3acc516a183e3b916e095245c3c967fe6c5a9a193d033d2abfc7bbaaec8ad37b2bdcf6476649cd6cd12219b81cd717252160674b634a75f285accb3b89b37a6be630f9dabea8edd90722a7a23678b1e88ac51425fab6e806174fbf1413b8a4f5197bd8953659b054dafd766a57e4f8a5d8835492f8d2d04ad5b2f0250dd25cc2cd5314ae1133a5c658ae0adb37404517ae7d67be31f38bb0816811a404e49fe59a3fc77b1c0e773cd01934c03128f9a76e3b054bd81535a015ca72be423bebe11f75cc61f41916b17388c8077e1b5ed6ebcb8b552f730757ec47a043b8e767e4f8a19b5dca644e8d9b93fd2c2a9a58e77fefc71c958ce9eba7c1f8318f0a9a6dd4a3dd5077f7a020dbc8a10d3d41cb263b47f40379acdb1e5e49c735c224811113a5382fd6de484406cbc4f0d1ebde0cc7520e1555ef3c4d6bcc053928f8f3574a54e50114e53ed838f2827687f29289f5fa729078d4280bc340ca17795f17e60cd116ad400edb056cfec99f65c327897123129222f2774bec179fbeee04704813f4149316facdc6394d26936f80daecf30dde1bff50eba84b37f432461e31eeb0607c421961d5d4a941c035d91c0648db783d2dff1668bd22a4fe5787aa4fae7d81f0f4da61c7e98f95f641f6f4997554e313cd3cfcdf2f57adeb0cafbca4fcea44b902c0a3c60382734a44b83a83b26045056476962d8a2d1eff2524ed75797686ecc0754b628ce60e6be533012b4d05da698f56cb426dd0f6189cb8ca0a8bdcfcdeaac1141a7c449adb7c81540e8d160868b35f394ddb5933f50792be2258fe2939ff6b0c568d87e23bc17ac2b58a61fad3e1e30515129f54624980a0464ff8f9ac9d795fc704e2989949900f42299d95f3b4e9f9623e38ab0dabf32007963b65e30189a34d1870bad75fccdb1481b4e2572355c108cb03d641bf6114dcd1d3e6aea8e8cd47c9ddafc7df461a0dfbe193dffd81925eca5348089c29bdfca818cec15211b3cd1cbc517cb3a5ecb293e65d97b37bb2246dad867f9b65d0b6bf7db6b8fbfe02b202d587c228b644b572873444a855a2ef88a34979048fcc7d4d9896d26fffa1b1edb0c060f59db547faf34bbd9cc9d98c8c0920b9023bfa59a0954b1ce401c3bfba6f2447a3af134119f7770cb5e928e9926edab55d763a4ed0e4914efc618b1572eac70c6c635c10e318d2a727a972c47a1260cd5cbf19644d85bda37d3ebac2716168bb7fdea00efea24ef9cd02721ca6eb55c1e800b8e999d950ab2395b8234407bd90ab0e104719bbf7b63685e484ac91697dbbbc70aa7e6ef21cc9679930a8ef61caeefb668e1ef7b0cdabb850647d28c341045d0dca0281202f8a53d92312c94cb67dffb6929c08ca2ca131a92150015d7f14e496801e2710327c38e68f81575b48bd6eb4fcf66fa66a2ab5be1d952298e2d98ad064fc07ec9d630b64ec7a57b5f67a8d46396327e328230365c5c690c46c53b571ec4c7bff0c23edc8fd40eb465137a217508b25162a31d85d20114e40c6be5417bba0d6205d458a5c8ebee916ed3ec5d5c3bcdc28ccb8d18346ff244c11b9d4c302d8e1d2495db6757a33aa8c2ea92b969eebd0b579819b13b2d208e5d8dc688551cfcca2d517eb99aeaa64082b79b7bc299595158fc76f7d510b2647df3b1a1d83a2160fde1e4f9f3c4bf42fa02aa6eadd141a5f38a3b8dca43dbe87740b075e1a83d4a66adf60060f9adf228c6804d5cc7fe24da2399a52fd0796ebcc75ca74b2a0ba4009eae7e8abdc17dc6791e0beee10d1d83f9e8343fcd44457a40fdd48908ab7c99d5ae0e9397a7e78f61021faed1428c0aa27fec64020107bd20312f5ced51bcb8c98e33bebb9354c188a151a2ff493977f74a70dd8b0c72836c37c639b17063d665ac772cc98d2f658548c96129c7e863b8f2340fb61ed87b3484ce31c8b36c5f47312743409e0534413483ec570a2c716f6ccfbb7589a2e9b7b58a5efab25ab2f490e33da7194ba159db3de9ec1c0f8954b20255e212d1765fda20a67ffac96c72efbba5c77c3d8d6827eb1941cba80702fcf0464fd20401dda9db38188c06fe6f1d084861ea311068c4c4a71637d7402f652ddabeeeeab0fd287aa321c4e6999aba265a77cc8aeb80c36f7f72c299d2557233d70257cdc4ebca99f39ea8cfd3312a6ebc8a0813103acefd733f8c0fd80b0b3c3c5b04ced49f87b1dc38d468279cbf39315e6db54190ef2f4780286bcbbc54d5caffc1f7abd7bc954a2db11b415d44fd293a78754dba5fcb86af488d8fb34cb02962550f22000ffa0d157107038294f67427baff7d1023df6673b98b2c2d72f12e5c212360fc9f6d2e16818b77e9365d971c7e20cfef2df04b3d9fdb077e67248c280f3e4fc940a45935ae82a31379f941e13af8294859eabf779171c6f1b364f742b069f8742a2f6250751eb6892a3694068360440150e14f021dce36d796ad5952025e38c972fa3f58fb3f47792d1bdae9981d379bc12d68cf416216c55d68ca5c39f949b193b12ac45840f996571918a33505b02d3437c2f145620555141824204571f09d98916a63cd9e12b2cb0e46413842657eeabbe2ff15d86f4ec0b9db2bac3f8664052fab6292df4b6dbd9ce356c2fb319d9e16423394e2a77714200c4b2eb287b75c54e58fea6b3a1ee258200efa92dc751e3a2b04afc6ffdab4a02ddfabb1bad6c3fe53cdbc3cd78471a2e79141569652855b31a956c17865746b2e055f94eb0a1a0818c1393bd6fa6f2c96638ef21b3a5efe82c0ddb35f67663871b0b77e63169fb1786aa106289d2c25cd954ea3c8b14b31fa4135d26aee8e30507f50ba5b79f5b5bf19b1360f65bfe026bd8bdf4074198f87c3e056abf7636f4dbb48a790885ef10f04e7d6e288f2f81d3c5d05e7c13e5a56a81cd3c60a36788fd81a7c6d39e41a6aa13b2e7a090d30cb8e8f4612303e372f3d5a427a4de3159800df787d83c33afbb9cd886a134366bd5df19a669d75294bddecee29d2d5d898e25261af8482a70b35031b5f7e2f3d0001c174938198d65a116cdf09bf67ff77fa76c5314561b48ea79e7d639220a88c3ebd5db5355a98193f89ef439197fdbfa7e3f6ec9bb5e291e1767e91eea5b7001cbe07d0aef787f3e526ed0befaf688527a138b27c8efaa752d26d526d545d230cea2254e18743fa6458253882efc8202f42d95baffaba2352000374939970182ee35de98f98c7170ef3e0f05577b00e842f2e65de89ad0829f54c8938ea4968509fec6a20e52781137fceb0ae594b13fb4e7722f9140e6051ece50eee64be2af4eff456ff8de3a18079275a8f3d0c6a5f04ab9cd8cd3abd5099b0694ec5600a059148f2ad53b63d859d5504caf52eba278f82c4163ed71d3b27b6b12a4cc3935ece3596b91a59468d9e1120b604899a447b02ea350b61d820da0335821976da7dd874e2174d182ec06a9108643b0d605648c43700ac01678e049a6b452bab194769b7d29f562fedb04742dc6c56689be799f445aa4e3f648fa6c4e9da809eb8c6eb642a54123a07085ff83b1b6a23cde9ae9ff627be4c9d1a1fac74dc51004843fb7f5062ac677aa40a690dd0972314d8e182ed0dce1511c60fb2729db0fee92bbbfd870b26cd4483c3dd0c5c421194a19ccda021f373c8ae38cb69e9d8e9cf9e574a154d434dfe60cecee1f93fdaeba8ad09338d34561c2a6b6e27b8fe3eb46406a4ab47146a49dd0fb430538c4d864f257379660c8172310e39aa6a973e0db2e3a2297841f183acf908d3ac95f5f61c89de8e10a5a7ee09c942287c747ea09ade8f8db2b2b4b14c47c8a460286064fc0ccf3d17cb6caf86078e1091fda35d501e24c93a552175dacc25a29a0d4e7add365cd843cf88af16bd37a9cf6fd55f331f2075231eaae9fc1e3cc72ad711c98ddc24f3d59ac275127626708eec4fb38b7e6abf416710a65651a26c221b63077c2a962328004d2e8071d5d1b51fad716e7aaada8c2e6b224528b544933758a450a6fd137dc45b552d8a5e2a54202f2f069620e3981748792d2b8ab188f8bc2f3c8256127839ef8f7440292e9bddabeace20dfc7561d1f67cccac38bbadff4fd3c8e4183d62a16f60790bc74d704f95ccfc7b33883d61853421b8fcafc86f5772d934d1a43c0fedef6ace004fa0dae9a7999f38ca5a1d64ba155b1fb836acabedd0b7d78c171575ed9d956810c2d845638b3d84eab890442e1ca45e8319551bbbd1e28b746dacb2b65486725efe4238db3e4cf369b5a2dc14091eb360dbb8b7e16f09e3d7ddbdab65814c1cd20f23fc7ab13aef9602b4f69c5da7ee7057b1c83caf193003b4bcf23558c37d4f5caa4b8127ae8ab251501dc757b87de3f713e01ef3d7fe02a3b7b0a235742933a137c1bf99f04f45f9de3b4bbd790372145603156ee1b23357d6e1edb6d683d93695bca8c9ad971fd0bef5423b222bd79f638fc980eb55d8bb4a87a9dc36b67e11597d1b82739b960e06a2d031071b034891328b662fa9251f1e72b6422627f7e45415453cc1fe98b004b65268f5ee702247a8766267aefea34c0cc6e7e38b1bb40c095ea677fc8505155f8373baf16edbfc22364b47c134e2d7e655449587fa990ae0c1e78145c66eea32f552b434a8e937df9e121472da9c6b89d0967f7739be825d5a6ce55ef1ddfca8387b2bec17f7f65517d1d67f2b02c4e9052c7957d5d6a326b53621f55f4048293684e5941b5a00c99dd2c1295f40f95ecc162f43aae24d2435445d1ba43f1e66bbe0f85703def1d304d9d5ba102920a7c70a57b5fb347825e9967345774aa66100de0a70e73f8f700e0d13f56dd671a2f491442c545c825c6ee6ed57cbdeef61bde239ffa2de62375d0d850ba6b62dc8aaeebebb535a018480ef42d8245fc9f76349e9493b11c69d01beab8490f50070c8a09953c96e4045a70906c02098dcf2d17045d2e7012c34768d5e6d9b40135aaeefac7d689125b6cc6fc317fd2622ae259ea48e1404e46772c5e7150ba09801b1af5572d03e01c9ccb7edb2c2494bc79c43c4e62534b2183eb207ffd25958e2d89984eb63f0fa8d3a5f674b753472691dfd1d3fc58e6832d7b7cdb0d8f83bde3abf4800097bbdf43d84435a94ec73bdbabd218ef1b87d45cdd95c3842936149c1ebde12b65db349a51087fb8bac4ec73384f4f7f365bfee31c65fc86490a1e33b655b71022b71784d890bee8345e33efdbed072cfdd7e2f37f45eb42b948eac888ed1e2716a5da2e6ede7fdd08d41080792edfd09363a1936cd1bc193880df4020fa9bc852f2eb5c6b8d69d9adb59e9746dfdace0cb89add3c9f41152167998ffa76b872a45c5c5f2a56d179a03b3b546b78f</script>
  <div class="hbe hbe-content">
    <div class="hbe hbe-input hbe-input-default">
      <input class="hbe hbe-input-field hbe-input-field-default" type="password" id="hbePass">
      <label class="hbe hbe-input-label hbe-input-label-default" for="hbePass">
        <span class="hbe hbe-input-label-content hbe-input-label-content-default">Hey, password is required here.</span>
      </label>
    </div>
  </div>
</div>
<script data-pjax src="/lib/hbe.js"></script><link href="/css/hbe.style.css" rel="stylesheet" type="text/css">]]></content>
  </entry>
  <entry>
    <title>2023.2.6 - 2023.2.10</title>
    <url>/2023/02/11/week-24/</url>
    <content><![CDATA[<div class="hbe hbe-container" id="hexo-blog-encrypt" data-wpm="Oh, this is an invalid password. Check and try again, please." data-whm="OOPS, these decrypted content may changed, but you can still have a look.">
  <script id="hbeData" type="hbeData" data-hmacdigest="8b1363690e3702fcf60cdabe0c6d34fec27cbf75422374390b5b269bb7c9c61c">a99f2d1cd7f89812758242c57c62a59fe859e32cc19116fcceb1abacce500da0960986acd07eddb3568f524414b51feef9f1d18fdd5c7fa1a88fb1d267230aff2d6a07a74dd62da36d2fc46f5b1cac6a6710a20d3f40ec6d2af3f9d01494e35b9657fc3d97e9cecfad4ea60c83fd0a1853edda3041c007acb495bd6aa9761ce78ee6a4e48d4b520a3617074a462d30dbcc54709cefb5f745850deac780ccfafb6eced86774c653a51cd83f49d3f3c09ef1a2a406efc8475dec08e0a650dd90719cc57d88b70fd59989f192dbdd1b7be3819bf410c984b68686c753f75dfb0b110cdbfd2ce74a21763e89cb9ae16236426bc69649b4587c8286b34fec05025d3aef2c6f9588d947863988e525a86c292590d2dc4eec6352d916a8570c18a79f647665404106b55913e4c613bb040f90675d98a41f4ed51642ec4726b505600a3958214b2264056bc92be0e148b1c6b0767fe42e451117e029b6fb693ceafae1879dc0c912a645d5c14997d047649750a3f096a3f6b059ccee1bca0866d810c103a6a97447539863087548702a8b581284cc3a4291b7bc4f69c3812d37ae55ff4fb7eb73bb45b44ec42bf497ad0c2e7a728353c42f06c6dd44ab5093231d430f0bf58b072262460ed9f8462acc9a3331165b9291229393ebead7d11c87211b1447cb0b3a8d914d483d30d9f7523ea26d7860cc4c592ede22fbf9f2b02abe6d0106b2117007a681097cd9be2a5f0312214972b8cd8f763c224c4d079cf8f8fb0fd504c845180fe5d5a42444d28bfe13a2d2f2211f57d5f5d37119cef452f8e307ab685de17211e358edd1b3313ef79c217ee8998744d9cf85958965f6ce74b012c4418ce9d825edc0c3b27c65b66d858eee2463e97a78a7334641b52d72e47217193cad4af816219342bc572e208c15ca7c57f2e6cb4c0f4b9e265e69e4cc2759434dc0bbeac1805c6f30acaee6cb243f1e8785490b7f61af2425b88b8a4dd9ce76f554f97a838a85a6b401e9b7b74b9766e98bf531ad482e34bfd707884f3f4f4a8882058d72661a8b1e9e159fee5c2f854dec6492edaaa8953bfd3118b06b7b6b594f2aae62771d9a2adcb7d9d7f8f7394ae1cd7e52cb752deef4a75bacddab0044011a7ad8b9b372392e70019cd2bc70a75957c3d0766438efcbebe15a277d91fc94913694141326116e7600acc5b790a0330837635776c4a9866366564d7c6a552c6f71cd6eacfb19a6cdebaad3ace8c5680318a393b1bc405f03c793c2238b4220dc309eab75e70896a228a762f0ecf068a7fec7b3e20dda48c4d21246e33ebfee88b4293ea5c0c7ead7041502e5e7174b10c64904424f2a6fb69466a5f06298414120dcde62134e1ecd4b5b0775fa2fc8a852d5226ec6c01a186daaed53b884ae0d06b400a2a1a22221f70c3d3f1fb090ebe931dadb78f5efd4b22a74ef20682ec3c17527a6b49d122598683c56899c076d80cbefee9d891f08d1b731f548f204205c49f6b4798e33beb9db8d5ed6029e72991ac69df88d055315d3a4805084c2990f7fb5c187e5f13b69f7c05f5300f4473e1f91bc71b9fbcf3af65ea08d466e50647a3239af1a24e1eb8d52a057bdc5432507a08e4474077ebea49eb90863c89afbae82e8c28d6da2912767f912f37c05a385a09cf1f8b98b87b9f7de83b66c032a448eeadf71dc8d72c4416ebefedfed022e4fe201ad8966398be0f5186dd696dcc4fc9ca6588820c8d7846879b9a54cb071ecaa2ae88e857d10e8f6964e3dcbf6f6ef2b0fdb5a72ac51366bae5a78e093c615ab9cbb849ab3edb69f57fb5d2c9c5c6a9930327b0ba4186100d4446019c69180547c9d5e292f0aa9d62637dee5b9a389b5449557be39f2e2ca61dbf4d0cfd217c065bb95b4a26b12a74664e22b4771dd8faa104fa2a57b7138a74a0dcd98a06894ebbd67e42ffe2b8b6b7e07940647eeedb8730764c214225464249800f1ac50a398f42eef17818d570f72efd3ec55d5750f401d61faed8b89ddaa5fb6129f408b6ff44e6f1c5c0bc573c6d1946017c9f817134930db69c0a82eae7c4567510d10008f981f2a8f9136141e0d679c4043a81179fe3163fec3c81dcc6e6b9c50c49d0e58a59faca7fb4fea63915371dc3b1dd222a4ba8164ae15e00d329a7b360ff509adacae2ae30364746c66b202560a97eb9e5249648d1f7a5d7e35b971bb32aaaaba44ab4fe794f4fce14d54be0fb2c4e44a64f34e8d084116268a34b8cd4b8744475fdeeaa7cc77053507a2f1934b327f308df6e1931373b29cb0119d51ba37d1f98b8645bbddea530554531c1f63efd7760a68e31bb77700d5b427323fdcb24ef84b52fb1391fe31a848d857f8ee23231209f2a546f8ca204e586fce0d8263a546c7a161f480e9bad9417711ddcae3521a1cc04d1560db4b010e5e75a97a4974f9d536922c8f209417445624d3b255302a68a607cb4016f249325948e99e735c50dd01d0231380b1fa49b022f6620dfc94ad9a5efc0a63db9553e146a08d15140e588f05786a7185d29c1394edddc50009c5aa7c2e5ed709e44dd12a5a23846f0f8dd09c76d689b0661405f450f9a13af27d5d7996025c34db58d4780da322c2d862196a3e1862e633a594fe8769bb42871fe19b09cbae419a9848e4c6ab0e89cd4d5e39a634af446c7f484fe2dac234cea4c3b0ca48aa9f032885f9f0517ae567f7ffa91f5b7b2cda1d3ea1c0c37002741fcda45176563ee5c95e15a507bffd4f3f0282d2ef53fe7a2fdb77b007644eafa4d90dd657c7d2434227a6d5e5984c2426279cc4746c6a8fc3423178365c98add51fa6b44c73429e9440ca2841f81e52cae69e9b9a977295f351f7165c66afae5a4dc38c4271b3e0326e4cd5c4f8afe268805bf421eb5aa7eb1a79d14488e0774860d28b5bd1c5300bf8e049590ebe2b080e22121f47275a1d509c6ac01a650f69db75780a6715f583a8d7ed87225de805c1e6194a3160041164883398fb9328cd8d794bd148cf547379b2030d310416a0b61e597fdea14ebb5ca33debb5c358c7102f7972110787c4af848855e07756a391a904c90b90d10f0095697ee0ffe8847ce6f6f6f2d3e9cffe498c76bf2f595cfac41be3bf0e2023c1e29611a55ed412555c5facff62e4b82c5b7a910b409c7dcff52e5eb8bd7f2aa1e0fd1db8a7424537beb23c38593978ebf0f401e2d95ad4adc7a253061bb71cf861d4070225920681a2d3c4866bc25d1710380bbfd32eeb2b5753fb3060b23b334778ed5a2c4669a71a01c895b1c4f109825897ad81b806793d75f1c405dc8e4063cc28545f5e71978e75c5f008b4e730cf1df1592f5799f33dc4592afd51916de96ddc127c9bd58067d3b80044f89c643dd71cc435152a696c8902afa68a8a43e5b32cf906ab69f826bfd3eff3bb8532d149744866bd5bd5afa34fe190db5316ec57304c53020b23d66802582488d5a169d82231a292252b1dd81e87681793ffceb51b6e19435bc2451cec162cf1ecae6a36b2c7f75b8950f49bfbc91df5eaa3e5fafb29717e0a8a540df1fd14ed2673192b1a4b7eb876c960bc86ea6bc66f7f0dff98bc38056b8255e419fd66b24422fdb77ea206f600c45433f16594963d547aa63422cb47cbb21fce614f074bf2192d72d4371ecd5c69315de6e041559ce7d206ef36f59b4e1712012fe42818464914ec710a702f476b0b02a40942bca1aff5b76b9ceb7e8ee1c775e7b55a4f71cd6d9a631a3a80fe077e3fc5c43ac2ca956addfb2786a55ba9cf83f69720ed16ec7969974c19fa9ff8203d6d74f354184f8bc924546ca3af62ac6b06a67fed1f79f4298955863b923f09a40bc9e3d87e786e8f05e3a27e921953f4a3cb4c342d0190e8001d5cc6a0b3c17e74b669daa7cf5f87726b028f40de163d16a1a183161545b9b1ab8f77ea761febb517906dd4e855b1a85ccf9534a34c6048eb2c0129128ba17d172214cee83ceed93047d246c26466449c633e745b49d0aeba4009b2b5a52ae3ad13df0be90d5d8ee3116d104ea63d7cc538902cb1c44e2be4c69a47e1e6102f6a349626fac26184e6c01e7369bbba62cb472a7032b9a277835e580f9004cd86879c1e06168c5640b9549c1d8e1beb2054972834b7a8df500b2f29b2847af1b9ff3f9dc0df0e48977fed94bd94f009b685748a06a154dc60879b2dee04400dd1c89b5868e2ce807888e450dd7f0c0e55ec5ce2a1978f4f7fb9e31fa02bcef370eb452942e3f89075363ee370f80e162806abdbd0cab9b67d00f239e9c49ca7dee48a31f9e58909f7f2a42511216c3a36d742320383b38c612989a4baf64dc6047e21bc6b2975ef80a5bfe63f20dea591a8d19a781945dd64122c040df5c687c16450f0e477ea9ae7a8338cf4b8973b1485fef408b8c888bc60ebdc52660621109e946b2b7271b7b95aa47c5094965b9ae6eec3a8e4d71e4e95a3d7686e73fa217db9d0fc5ae3e1c6aee72a05d58032397d621e34ff96548a52bc54e935f2f27abdd98421903d9e39b6b0ab9f58d3e452042a61def7724c445c1c984cf166c98cb8ce4087c1700a3a7a121b4e886e10ab8fb31adb2511752c0ce45a474abe37d0ef88d2ebaff1476e1edd645b09a75fa17ff11da034f1222fc1caf4e5400e47367bec166478ec9945418d2e1788f3698a70f63809c1e3f3a86dbc6f629b1c73f6e079b9f602a1742910c1d10115959144b16cb72485e4f3abc021cc80e73ffd8a3d27babab216600f53699124af74f69cc59f6a9fdf84e6e0364c17c2455df09942a14a4b0a05069d6884b0424eaf9d4dbdc5606406b54db1ccb4e274ed1a1c9098128b7217c866bcd5ea7fdf59310a0b957ec69adc9f5524a6131b97f15340ffb0c964c3790752aac6b38a85a465b157e82276c13ec8e23d7e2a0fd513e6c09afdd0eb3e8f1870f18ac86b976ae16a3e2a5888b6220a3fcc7f047e190d189026b4f53a7757aa5e7edd2df2ad55e7f96f7466e9395f48e7ae9f6e286120cdaeaf5d0740e64ca399ff62fa90c86d9ca4141df8a82d861c382d59b08d8fc54a47951eee3618f03127773f3973d022f136681f2912e0bc51c49030a87de0749764e3f9a325efb1d9ff46a6c96155b280c715b6eca13bd0723c6cb969feb5c3fd404388212974532bddfc1b4083248c2c82a79365ddc5729b85f60ad20ea8c6d1b7b338639b781be530f5ccea987680cafc0a991676dc85378e6aa9bfa184365d41226702b9ae54f7f1b9aeb4b4c9c9da9ab8f068f3dc5dec6e71599629dfba4a8822a17a4a61c0e6fc75857fa6e7453525fcd0d053df19fc5941d40af8ee4a62170916308463a0eba159382098131dba27ce309b2fb678e11655c3ab833d4c0d38ef3fee3bbc8d946ff456e4955eab3d4ed5bbd89397a01725afe50aca9ca660970d763dd6ce10f53568b0e8f5676154f6337aa846583f2f5ff3f4dd4afeba6e98fe0e961bcd1bf52a54a48806e39828165bcaef9af1a5c4913e82d3a762680b7b3588fe128f06cd5ced092eeed445643ea053c5687552fdc31766235b0ffe25570d32e79203e13c22d5dca8ae9019dcc3819994b450b392029e375fbcc36762e0858d6fc87e06d69581466a0f884ed31c9367c7a7bc9002a39c2189c18b3da2bc465573260d1601b860bc60dbe11ff24165258c26bbf891b35712b384ef43e703e7a8a40ca9e5e7eecf8052788cce96d06a0e21107c11697237a7bf3edde39d5f92e65dab8d0dac3a28185fa311bdd7943ee43a75c93b9da9dd1ab3818e3adac797a5f340f4dc071dc64e62c49725adb97186b2aa297a6def68607d48391fa09ba7d96103aa922544ba684cbdbf3358da891bfc710d6e8f63d04e38578a5713ac67587d2c0cae144b9ac389edfb6ebd0618c717e772a705fd862b3b8a64c68be98a4b79c8e5d2fa8d586d1b14244020444aded4c72e5be120701d57eb043a6d03a124be7c4d6d78ac26115a2d2672c6ad6009422701e66a09a73ba3b26b31f6216db429eab324ec9efe2da5712ebd8939331692a8731048d43c81a2997e82d7c56224e59b4378cabd48f563</script>
  <div class="hbe hbe-content">
    <div class="hbe hbe-input hbe-input-default">
      <input class="hbe hbe-input-field hbe-input-field-default" type="password" id="hbePass">
      <label class="hbe hbe-input-label hbe-input-label-default" for="hbePass">
        <span class="hbe hbe-input-label-content hbe-input-label-content-default">Hey, password is required here.</span>
      </label>
    </div>
  </div>
</div>
<script data-pjax src="/lib/hbe.js"></script><link href="/css/hbe.style.css" rel="stylesheet" type="text/css">]]></content>
  </entry>
  <entry>
    <title>2023.2.20 - 2023.2.24</title>
    <url>/2023/02/25/week-26/</url>
    <content><![CDATA[<div class="hbe hbe-container" id="hexo-blog-encrypt" data-wpm="Oh, this is an invalid password. Check and try again, please." data-whm="OOPS, these decrypted content may changed, but you can still have a look.">
  <script id="hbeData" type="hbeData" data-hmacdigest="de73663f61db0a7389774e5f03e3db20c59f29a660396749bd93cc2fb0e523f9">a99f2d1cd7f89812758242c57c62a59fe859e32cc19116fcceb1abacce500da0960986acd07eddb3568f524414b51fee4eae1f2d89babe34509d3fa1df95b4360f98d3e58a47b57ffd9a7c04397bb31980d93396ea4a562b24930ce907b9d3939a8f62d7fe4a9d0105b366272ed3d9c110aee11c6832d90bc97c4ea5c6a8229143447011b364756a6223334074ab2f9c7ebb53b4f16bfc353076d88fb2497623e00d996748cc570052038797cf857ad2636ca73a438ad661e4d9f292c3c915d21331b542491860b6d9bea34187a6d6dcc1d3dae94126b44d8bacb5224efc8e86e4db4958a3fdd7baa548e34243e25ce53bafc8506489b82ac16b823709be5c4d4ee899e31b3424d6f5156de86d4a1afb6f0c2ea5c727af17bff1dce47d8099eb61a1d928aaf3601e026d39dd0ff13aeccb0d613536b7f5f613e234bcf3b42076158f959cd7a78642209494351b16fd0174e9ba170bd94675fb6881f285e0387080bc9746b82feea1071074ea3cdd53b943f8fe4158a659bf3c63ef88087ebccef2fab344ea3062be20aa4b258c696fcf3bc725c3451ffaab7ecee0e63e09d439b3890896f7dccbf0cbeeca2b79634b94b8467ec180c1f9168fed7d1112eabbb095f27b4a49a45c9cc84ee0a88a27bf82537269723cc8e218be3b6903112ebcebd132618e7016ad8db73b33525a5a1696f01eeb1f68d6d94373d150ec2cb1df81c7e1e8be95e7ae3c500e302ccb0bdaa75f342ad11ccd64115e78980754965a79c1ff042469af9395befa025fbe4a2c1cfcafc3865da0be86f8310a934bbaf3c8e31faceab013d8ed08425125bacc027b6f810502b5e7d8f62be30dffe0d0d752784f9b189fc91dc99079718d268c8a5cf341879131d95dd18960c2d28cb981d3d0551d8ceb1817edd62c3598ae4d09fca8d7fc3074fcc4178901ce35e6a9338f8deb50351a6e54162834edd3a4ad25b48912f4e5a2584525ecf19ac68703d0880dc45bd33a94e89b7e2ad63b5f76c1d17d303b1ca77ecf93353342827b2e6ad4d5be85d7e41fb84dae62e43b5d1ea27197205cdcd45c38e45caf9c0a4b1ae9529a4699633ca4c89881ed446242a333d46d7aab8b58476fe9281f6d58493d6512375eb65917453a41dc709f2ed577692a850f1c69434fff0b7d1e6a11cbc56d146ebaf6d95beba6e083a17d517dd3a5e7b29c2e4e2901880be40c660827a8f6d8e985050c54980f362f05912cccd406c644c7c6cc130f0b687a7c76c5819590f6ef4bbf4882089c318dbb0a27bf942c00b5d565d05484ac07f90bf72710f097680fa4d6df49a93851aef97e866df5d2a0b0541020ad020726f47a128143930bcda60e8f0dfc035bad83f2779be16c352db5e463ac22ea91b618c421bc6fda7ae590237bec6c9809bf0764d094a1479ec424fa1b13ed65166d0d3820ef4f4105c7f3c1f03efd2df1690d8e1ecad8d7c60c1e8280af04b8409457d5bb83e8ee13835a237885d7bcbfd6733c8ab3bb687bd08528670ca5c901de1851223eea6f72b2186bb1560b2fc42b63dccf0633c63f3f0ad649a4e6b394e81528bc19f69f79b2139b4e3a24047af8ca85f8be9818309b5c88f9c859590b7590bc6ca597446178c0aa9d5b5371d042684373c2fdf70103c8db4507077f18c402bedc190907542e6bf5d8872d34751653e875469da30868ecbcb474ec6eca9e6fcf1719b4d37c2db3cd73d284ad6b782e2cec0ec5012ee371980435aed6cd054f2d3916ef78e072e7a441fe971446853efcf109cafb73e485ccd3ea50a76c127ee102a6676636e0cfbd9352cc9118ce25a1f0e33a124ec1a2c1e5793956244425b647635de64e629a0e12176bb37ed04ef39b19f3253e9cb3f87adaeb8a9eed003b3587ae7a7358c2be8e5451a6e3ef05576234988953f75dc63e91065310473febf908f7e9bf1598d9df83071c718b5ff458eee90a94846459df52fc92ee339b9817855fd85a32ed1153bb1419fad9f7df35d9c26746f4ccaef8f35fe5f09538673af8b9f4fb3e69ba9420a724522c5d6996fc558dcc4649d331998610ff32fb31d56d597b62addf71e09c598a604f295651d170b549b76a752ed6911cbd9fda63d7bf6e5358fdf831c1056586751799edb322d1068e8dc42a9facec83cc711f990536c736ba5333614ee7cca1f40b9dea405fef76c825aa09c735034131b0c6baabf3189a25ede21605c67e2bed495686df1cddd1441ec231a148fbe46f9f163a47b38fc3b18fd7955afc8c74d394bd76eda39335cf6ae02989e3689def0fc2e7b2473d81670173416d42059d069d58bfe7102854ce350b5c6ddb1a8b5cf1a9c9bc879899f0f076a8d481ce2eaf169af78f7eb8c32c5074bb9fccf5f548a6dba41a824134712f2e5a214f34711496add8da3ec51049b5426b965b5d8cfc2b32c553bbc94bad289f4ffc7e68118446cf7ab46a851315949746860f6b65ef99199e09d5cf07430153b3f27933f479ea1b2f9946dc8700c66e1b441be0bbc572afbc0f6f288a774c6a844139f942077583c849cc6af5c91fa8c7b7c8799204f0b57c6977c6c01b7e5e2dca97c2ac5c0020c12c2ceb5d6e73ae6a8f3fe14eed50a3aab3f1a1570135f3850e1fa88cd92af17545ce51678cf12b96ca162dfdf37250d1ea926e40880a9739bb78944f58e1030cf057b0ef5f850eedfe0fac725ddcda30177b92415a184e16878d8659eff0dce1fe0149c385f8d2d96017e615a795aef16fe3645af4ae8a7138106574ac54898198dc027487f84b6658d3bb1f11b69f0a165f21670b24e192862d7c4f1ca36d8dd8dc7b74d87a73cd80960dc353c99d3f1f4129fa91f1d031859a5fff4d1cc4d2e7db890de28a94418685aa4849c461d2e82c9a3e6e25131aa7e090df7ba0d48b0d41765532a86e6a4d85ee8db76b5bae03bd305407aa781d532a26cf579f5482ff9520117400b89b69496ae7bd88f8aae75950b65889717db5cbe1926cc6e4f98b7aa43cc9efde4e30b679f4c67a0e28ed8d8b39aaca1689d49fa86e13b847e0a02e5e77ee1f0a012e18399824c86bf6ebe01d4e6a7d8db8f5704084085ff7ad4d1f7d9d0b958bcc7ed28b88babebfcbc1a71687d12dbcecbaed9fca32d791f102f4196a841e34fa34f0e2b087981f96788037dd3a1fec68353f256be97bbddb3568f68701e8cff18c125c9d0a2327feb2220b8f0aabc2c4d0ebc2bf18c4b67176ae96560c03f83231003b84508982135c78959b6d36a3cd28a150188c7bf05d28fae523f146cbe2ede68d8c2f5bba32da91bdd154fb8bb938576f039194fa8fcc45a2e3e69824e813d59add5552b39ad5b6220d66b85c04df6f6b0383cac60a4ee0140551818ef82e6589e300fefe25cc8e870d6e809c50ec6ca93b13920b17e501099f9d78bf73785fb034d8e2cfdaada846c6f960467c621b7151dbfa4d6e375cc2fac5a733b15ea3463475eb6508ff295c2a19b1e64aa6741e56916bcbd9d4696fbf74a8c870346cdb1bdd384efa3395cd96f27c3b842730f80a8fc82a68c6700c0463f0805b9ab5009035079267cfcc480f93d4b202caee73e651283c03307d249df96df19b54cda90b55ff858f2c474ea5e7eb683721dcd9e32fafc3e9bc24326ca739f403b76cc2aa097d55952f007131b4db5ab9ed89502467c3ce1e9d741b55ed35068f9b187d04ae2936e37fb7c87628656710ddac2e79dfa565412eab1f96a39a54b0a18af5771fe50c2079aa125da3e03337fbce921441f6d99c42395d8a0c1ff936e73b500c77583864d32d101424f626b0e7f50c73737d6ba0ff56e112428afe5e8c62cde32acf6a27a9fd83ee682eed474817be57eea8656018a2a54cb4444e7336d952a9e7ee1331dec1785f8d370042904e3d4f89cd5562fd89cef59a87d550fed7558697432092e651f5f412af3a9ee4319c4ebd175fea5a35b45e52f07a41d9201cd2b300ebb8f1792c478ad2b2fbb35a09ed47649ff9c097df4e2dd3e96c409b69afa9c4f1f6faae5d2f2089f42367f60808f76c93f05a9035f22bc3af3539c4b813d6fc6ad8f9362a104ce5f39fbd8737effc5db3776ed7274d610d47cfc00c4845a05a91b8c51bd8eb4766f2f0349f8dce606468e2d7f3afc26afbd8cfca7414bda067ceb06197cb39ed3438e329ce8efcc482ab9f2bbd7d7564b7c51fae9e110f0e6f464d6537d796848c3dafb2a089064faec512d24c565121246921ce24da2de53441fdc3004ea962540cb0342e32b9f7a6b4fee967015463139d49cb63d4a83663a3b4902286a456f557e67af5dcf8006505c158441a163def98f355ca440001a5420991b1d61748e9e83f6f31ab50071c81c9403723d2c84f05423db957ec3212f6e667fbb2bd2c34b4d50df6fa0ad9a8b751a3773aac1f755dc6d18ad92c56eb04a518c7a461e9949c2ec7fb958e85d1211c8f9ea162e33df4607b91620f4e4116e88f4da41df1484af2acdb9cf812c12f3b46c3cc7f05901ad9fd9a107fa441593cb36d4e0a49a53c3bfbfd89f8d1c3581f574ba6b56b790183ed06a61a3febafac938d10dfe3fe3e1b9fa92d5fcb22463f1cad5866abc3e842c7c4cfed11051362d8ad5c791ff4c55eabcda47e348a0493a2b0b377af946df26c8109034bf9a4dd7915bb639855b13cceb5505dce822af1a7ad9f0949d7ebd21643a8e32a5728deedb80e6050a8f9eba1433b8e8ef4d580b10754bb515932c9ae73fd4478fdf1753809a7c69c4a8e00634a2bcbf3ce371dc23066a02763a8355a77d89625b94b5e6896da8d493ec0977eb7393b86b4363565d04ad21e99319a28ac211eb67512fec6be5f9d28fe65c4d6f099293e11e73039ad8704344fbbea01d877dfc9a72044490011deca25c4192ed2f645ebaf51f5ee35d64962cda411cdadb5c8ff3f70af4a09db249612a6ce0e1783aecdba4d89d8fb1a98a4d4a8a35dc3306063c5b68461f33ec0d9f7fecb2b1ec8eeaaddd19d11a98ebac21f2e5dae284fc9d90ae4a9707ba5d6c92b259424a36512abfb784e4eddb195e4e27d22f7763188e1d2ee3e7ce6d10680d9b79aae9e35062366b71492eabad3354bc58e0d0370a2893d767fbb6ebd673a25e921c164536c55def77040cbaf4757dfabf9125260a45d8a1292259a3051efe9a147c82128d006f780a5fef9d43ef1092247560159db7659327a001d8d146ad2c7167dacb0ae7b9212d4c43a42696f11b021b56498bf55f4563598f9d8c8db18d98a188e30f16152d455c4f4e5009ac283ef0e0ee514963ffd81d3dbfdd824979be6c77aef1c6a37c5a18381c36dac940aea49c108b373c71871fd2bef764fa09827b3fa9bbf15901211c3b3a20b0b50e6e03e36433ed0fea8537b3cfba5fa9f168c1fd9bcf008eab5dbeb919fc6e028d1bb2324e936b16d138d36d4c5f8dda5bcdccaebb3b839d73d7b83df3dcaf15cf934ecc419715767897012e843e15e27c8fafbeeb5aab2459ace1f60981152097a69aafdb682771353ce2a51fba387fcd115577e213f2fc48b655106fff9e3e72a942c0c6d1c34651e6683fb248dc960e82e4b833b85e6f664514d84a8ba813283fca95a21417bdd9824aa8435db34d90102a88e5e3e38ddda2c878f25bba90ec9c365ec16a72777b63e61b9fa3d6db819bdb5d0d5ee471db3633efd74150fe7</script>
  <div class="hbe hbe-content">
    <div class="hbe hbe-input hbe-input-default">
      <input class="hbe hbe-input-field hbe-input-field-default" type="password" id="hbePass">
      <label class="hbe hbe-input-label hbe-input-label-default" for="hbePass">
        <span class="hbe hbe-input-label-content hbe-input-label-content-default">Hey, password is required here.</span>
      </label>
    </div>
  </div>
</div>
<script data-pjax src="/lib/hbe.js"></script><link href="/css/hbe.style.css" rel="stylesheet" type="text/css">]]></content>
  </entry>
  <entry>
    <title>2022.12.5 - 2022.12.9</title>
    <url>/2022/12/05/week-15/</url>
    <content><![CDATA[<div class="hbe hbe-container" id="hexo-blog-encrypt" data-wpm="Oh, this is an invalid password. Check and try again, please." data-whm="OOPS, these decrypted content may changed, but you can still have a look.">
  <script id="hbeData" type="hbeData" data-hmacdigest="731cf93e8827e0b1f4d17dc3be5a77ccacbca2d7dfd8055ebfcf3417897dc5d6">a99f2d1cd7f89812758242c57c62a59fe859e32cc19116fcceb1abacce500da0960986acd07eddb3568f524414b51fee76889343eaee1490a5c7fbfbcd5cdf71420d30fa8eb402cd558d15476ad005072953676415a08e448c0a4bdf8d8ecb6cb3a921f1d78c15fb6633878a13ba5ed2a8e3016f40d456f2fe63b8751adaea5217b215f873df800dbf8ceea2c8c3002045a07d2e40660a0c691b7bfa24713ddb1ff1a8c6fc1b7dbbea969fddc6cfef74174618e5a03265cc8626459f7763e18a3fd2655d11884591b66922d78e40f97d165ca265eb3cbc58d899eb84869d60477d4a48ce9bd674e17419a70d85bcd8dc0c0badc281a322d441a890e44e94b0b6b26d74c8163910639d7f169a3879a4ac0070881304cd0ae324010f517612b176666e7c9b89de79a22e55873f7bf633c69ebccf840d31960aa3acd8a62c0e47d77a7e7b004471b96865e608bf0f1013aef5060942c83d4be4d089befdfb26ec8598e7264b42c5af3a5de1ab5d424f153167c72da3174be269f5a26b7ac0e2e3c3dcee34e405d4b98abdfea06cb51d45f2bf82aa4f3d76a6624f76c92b1a877897edb7dca1ed86ec26da4276a08b58cf60ee62a96a9184b6e6acb2a7c52aac5668559e5741d0a16b45b13f33d2285d6fc34907eecb7e77a1b04cb4677683ade1a3f8cd681cdf538a444f6666dc0a38700c3a5685011d62b6216e9c42345e7bbe8eec15a56b9c9026d2e6638101ba20df7ebea881b85f9936dff0d66134e840151f4025f437abb64a60551b7da040839a6f8da0144e0750e6e8d65590cd79da2d10495aa24af62781e0a1f1296ea314aa51198349b44a99b72fb15e01de628be0533bcf2a5fe05440b13865ced1451cbb9b1d87a6bfafab613969a9a3d2a89e70a1c21f737cc31cc254a054344f31f7717335f13e82e7bcd570125560f74d3fb13d9b1d73172f641ea6d73c45ba4450eab229692e7da4d0da6d50bc3bc1bb6103a8b54f9019c7728d38f75259b0729dddee50a7ac6b57fb09fb3c85183aca0a3ed5bbbe0a1d9234119bd988f03d4d6ecc1e532fbb252b469c4c69739ad518bef5f807c91610dce9ef7b439eb77a5bcba66ca418fdcc378178a618edec671c4e8b1f78b01dbb7cccf01921107f4a0024f66018e61d13e85f3007d8f98aae4dd48ab6601ac46d3a4ba93fa028cf9c3e56c66151e7b2c3702e2bac06a25725f671107ccd9f64a948c2c222712cc26ca758b46a80922b8c6b4572a49b82e7d4f56611bb3749a94ec8cb55694c1fdf9e31dcdbcd35e818b8bf02fe60a4e5b3261859561194ebc01c0679c361d0950b172b1d760f9a12e59b06f38570357d185aaf50145e77bae0e7868c53c3016eee8f95555cd59c2fa62570e554485a4b01f566b2580f67cdcd65c31c62514aa1299d62c2d80f3668f4fb9bb6751b4aa09441a70da635c72ae26ae4b7b464f2024c4619ef0fd016097b98a691346dbcff1043a38c49fddcf60382aceffcd6391beef5fa5f9270b1cbaae377e8a9c7effc824a793721c3ab71915e7b79a11dd219f66f0398849f548f429a3e7e57762472396a9d77aeaec60952b4f5303544ed1121aa8db293de051ca3ef78508b1d909d8f8caa72652e6bc68f380c4d77ed848e888e2d57182e4276b59e2df88c72902f1910bc6cf3bc6996b2e4f5f63f0f4afbe1cf85f16c400deba732f281559ff3cf010093a13e5fb453414dddc047d37599c93ad0d5b673611e35c1049b18cc8dc9ee64c6573ff2d141506a54bea5e1b46df0be886c29ebc01390c550f4836e145ab93f104629c9b88fcdacbb2f14520894884b0086ce2c5a90daa229d101e2a9a66c030f744d3abf6984150cc1bc66fe710d5ccbf9c85070f5e5f522ff0f2fc11a011662bd078720a048ee9d3194eecf8b403433fb92a64213592c336250f3d38c9869cc948d9026a82b3983c3fe2acb2e766e062833f084c97d68acfdddeb6746b6d5a4bb38976bbe3caab3ed2c217ec135c912d70233a348f6dd14142ac5bf533586f17ca889154155249acfe869d12ce60039c6057bfd25a5701b5bde91f01ad0181672f01543ee74d02810734e8a0d275e502942c9168210aa105449d7844c9382d5a947148df8d06dcf9a81f0269ff91b5947e32dbd0d71289b040ea5432fb3ca5b8d224186c8f0e2a0753eec02194c27ed36735832858beff37e529062756b7afbda877709f8979ec0daf4d54c16f064487a1df6518e5da96ef071fcccae87e405007795e3a12197220468438e6b0adc9a737dc7c1cd3902e2fbb6c46ca72a7ef7564c3c2874519f2c85f3c59de7097c6ac166e002f4d6e9b730a2486c234ecbe68123470673678553721abfac750017db05a7ce043a4ae547c80cdbc216809f675e0eac07959e8fe4665baea909473bfe1f2f9c9c8d5381130e6f853f277ca2b94c292f13b27dc30fec6c4482074413932f69f7950f2eed399c74a44a005457498651f6c0527b6769594f2b644b83896903445c9d3885b552388d147706cac4f6cbbd5c6f5cd6d718390d8ecb29bc7f22b9ebfa9dfb611b29de2e96782aa2ed46fd9b846cf67d03c312b5f4163c0fd71727e46a27e944da80b588bbd295bd1ead84ac8687e74c4ca7451597114bec5d2414121f5bb601b54f185abd74762be0cc0ccbc1b22a3809e29b4e87e52a44abb4f2a52ec558a63961b4a8da3cf36c5eb244391f7a6aaf1ac3c7377e669c0e465d2aea3e6020c65d00bee2e892a1fafff1d5b9ee398e18221aa7f985b0c85c8e9f711a37cd74fab4a0b3f11668f1d409501455c6fea5adceee137b22ec1b731d3609f0e6bfe0b1c909a89bd2d9ac4e5e62aa24cc84434dbb6254e305ba8e456f593236f957448678dbd06e450f4fd76501e1265e6f2ad558e3de7d8137566ccb40b760804c1bcdfc7cf8f215cb130b2e24aaad7ad4a5068e496e8c17dbbf1ed359cba5c56c6014621c0ad60d0ef8155fd82773d1a0e6ca6bb18d8f6d366fe203985b1238cd72cf24a471d20d2b4d356f0a5d7719105362785462c51d11b3c3aa398f3a2b3b34edc3a61fa5f75e9d24f412f79aea1da03c81a5a078be1c4aab80c4e7e3216681a2db390ebfdabfb9b039024649828a1e4ea066c1565ae276bf4a1c56ee720265527a417e7d4e13b10e96c2010bcff51e9c22fb444b47c1275fea83b865ca771800476233afab19a3a4a85ebb200c3774afc437ae6492b51342af6d8f6605a15a40b6d7020d5f774a19f4ad094ac7690f4a5400b6605d8ab2064a7628bf7752aac633f9f1c7fc8f419943ba9529c9cb31d7b41543936df69970e05c58431a2bf6d8e342ef4fab4c19e0bcc6d226be5554da78826592afad1d9a193fccd49c0c9a8743721a1b503cd741012aa98f857c7bfc03b5dc28839ec55453fcb82c840a00a7e202364dd11e64793bbfe5ea505fa10658246f8bcb217b7277beefe2ec342ea33804d2e937a900246e5681b6be77b5f41107ccfae1c2d1a2c54a643eb650b543972dae0daad86ea6321748732e</script>
  <div class="hbe hbe-content">
    <div class="hbe hbe-input hbe-input-default">
      <input class="hbe hbe-input-field hbe-input-field-default" type="password" id="hbePass">
      <label class="hbe hbe-input-label hbe-input-label-default" for="hbePass">
        <span class="hbe hbe-input-label-content hbe-input-label-content-default">Hey, password is required here.</span>
      </label>
    </div>
  </div>
</div>
<script data-pjax src="/lib/hbe.js"></script><link href="/css/hbe.style.css" rel="stylesheet" type="text/css">]]></content>
  </entry>
  <entry>
    <title>2023.1.30 - 2023.2.3</title>
    <url>/2023/02/04/week-23/</url>
    <content><![CDATA[<div class="hbe hbe-container" id="hexo-blog-encrypt" data-wpm="Oh, this is an invalid password. Check and try again, please." data-whm="OOPS, these decrypted content may changed, but you can still have a look.">
  <script id="hbeData" type="hbeData" data-hmacdigest="ed484eb2ef10a3afa857c738eaa602a17eb3ce01c145c240db2c0b644fe6d564">a99f2d1cd7f89812758242c57c62a59fe859e32cc19116fcceb1abacce500da0960986acd07eddb3568f524414b51fee2e002030fcdd5e43ea5341f278feb6a82f73078379c20b78dcf02e598501a2af1e57cc1d2da2b404323a1120f0daff38ff48dd3fe3e5c9330b51f26abb933a0841309374af74b7b3953e83436d75d56a95b3837177440bc0ac8f8f7c0ebe3f4c2f6fa3a0b7c1a49473900b464bc5c392fc02a82752db8f1e857f233976264b4b0e7e838621bdcb39724bdf393d88189153402944c99b4d5e546be71fe17354db620c16343d80db6e4842247c4d713c46e772c275e75d780bc8a248bf6b3210cc6410bbb527d7fb7b243f1725d11d8fb2a31dd9c3546806a5ab2ee79b17a163b02b951794c36df8c9a2041cb4cbd68ef1e2d5cf5d4a3e14f0cdcc3ecc794576c43f5cc39785c3898865787cc62f6b8ac9d2afa68fe6313e6d2a7ebc2d908359221c3cf853a8f49f41415e44bf344e8216688cdee18dae6566de9ccd35d9670af736c180f041bc905d8119eb3a4f89bb2f7948855e9b0c046a79f271ac6b38f1bd9ea6cff89335803a3acf9e6764bdf090cd3488a9485ebc0a777d7b488aa86f398a066f8c9ff85122b95515d4dfe2f5e349d9046d33702e6870888d920d5d9411d03a5eb7b61757ee96195037c58c1d57ff89eabf284a691632e1c7d64b4d1435a5f4cece89b40fcb9c2b97b9ce5929b65e4f0116b03a39eadf19d7b166b2e5bd6e3ce2b1382a3e16f84aea7d1ea1c1b5d48484eab4d0ec8f508f9d1a270afbfb7a9e9fce8155fe35ace59bfa2f5e5cfe3cd1162692cce4e60da52dc8c6775a3df17bf21a438b58d59d95ce454b3a679060c6eea1236cc77eea9fabd0fd72aa560d23943a9b362f21a4d0c14742cde30bb32a0288dac032d558f9d1f657512ab7c70f6e1ad109d07aa988af24b0dd14450625205911848523cf1c1c8b9afe733fdb0653c1910af8d72cacffbf3231ce41a569aca2da4d0138c42c1156699ffef592b5e3423a59650a71b65dc389e3d5edb1ecff552666dd17f0a66b906d4cde5a11a44c38b55eeff2b99ad446e9ccc49d513f6867491e99817d2fa0fb144a656c8d089ed769e7a11234525b52b8f2d621f2bd641be2692bd2fd441a18e8275d24721ab1480150e8706796a8dcfe11866d19b73df84587d4512882a7415c471f0ffc34cf24aab362a838331256e0835433039c271270864e4b1a5fc433ee101f202e504a9ce0a5a17a9e71fd9515a1ecff6a9a2fa7582fa910ea7a874baf2659069987847fb6e6d04997dbe7eacf0f48d36954215abbe0db529fe1e2874a1a385c8d144d24d12a703351d37dba329ccf7700e704f20af70721a6bb6a1bf8574ff00beb73880544111e0223fc8d0d2058b38272754b5fe22cd9d0efd9c3ac6e935e7ad020e42fb4c247b8b05fc9c8a899b6b8c7418b2bc509dda886d0bfab3792d3bee7b613c0836d5f48183a888aeffa869a6389b25df4d4b880c4ccc76baa8e81281aa4a666df02dc37456b9df2235640f790ad0c707539d226c81fe5022845abdbeda863b954de9977891b87ae4bf764c30d971dbd41554c949ba5edb1ed97d5f57fe3916a24b89f60b2c96af775129a9c4c7c1fa1c097dc8e2fcf77e7ed811923425516fe6dcfb78a039bb9146ee80f706d49ca649e8e3fb33ec3a044c3df68fad3a3c14f80bdf6c595041f89c49653859234226a11f60d64e97e7e09a5bcf7935b4e57d0031a8d952b765ed08ff9ee9170e324121fbab991934f174ebe3066c836425086480d79975abb6c2b65f5ce2d7d25cf2db51d5a9a0c6ae3ec172cafa8b67d8f9962aee975bbf4ea52a360c2196892f7e6b1ce6655c02bc8956281629d7df0c573a23bfc94c43174ec44a136da11e1029f233d5e5fb0717186c5bc955ac527d60573ac638335450fc92c2bbc63e88f57d21ad57f4a14590cd39e056c19801ad7fb6610579d55ef1a797563594f2572f1dfca8b2c4c8e32e91107c4d6e507c82c1e20606a3ff08d8208029832332427f715608c647fff0650d5f88ed9098c20d3348dddb1b6c443045ad6e34a8051cf613081b34f6a3c931a55941f6acbe64e6d19602b15b639902c0444ebd26c04afc400ddec40a425cd6cdce737f41ec5132aa20dcab0f6c0e0e8f86ccc89ab09765cfbad48a33fa8a4cfd34959fc8eb9f0abe4e0842f27ee4402cf6f76ed2ef42b33699be68e08c314463f582e7d5bc3ebc03be0e0f1e9983cd1aa179c0fad5caec5ca6466cd83041e7c558d16cdb2b7440c28bc41eae0ef7c31dfbfad2e8e22653350501c2cb50f46783d1d0baeb53a48c7db5647c153799352b5c71794186d562a4e44eb418e82b5c0d97500670ff0abededc4656b112e8c4ce5c13ff2fd2fbbf20f8bdd5c92a6f680d8e74b50076134f5e74e5ae8fdd3aefa9d9baa88177c27a44909d9f5ee594741dbc2469171dd8d4fed37e9473a21bf471c5e6a5a8db153eedecc94ca21a637eeed20ac0c3f99e25f70610a09f30d6552f4816bc2f980022b3068131fbab606f2d7b3c5459caa9a9d6ac125371f64befda14824eefb34ef62f7c95860029c93c50b8be53c783ad16b308847c7457224ae5291250670966fa696b98b891f1a1d6973ea9c5f9e63b198d7cf695c32e1b0116e7b39a1764ceed86686c033c9a9ae04f0fc7a35a5de78b11bc89ecbb58cc0e4f7f82d7e45a0e75d6f1e7853516d4bb49ec76d56c528bca69724f97ed6b7f23aa5ecca195c23396c79cdf3f66f5b2a856d250b6e730e76fa1873131462caadc7507ae16479f699c4112f62e33e5f8803d36909debba16a6d4b5b9a384b869f836c1f2a2cbea8bef3a60e9057004c90032f3844a8b74b35e78541c6d486fc09d61e73650b1477feab40871911d4728e335525261fae4e479f5436100cb1fef15dd4036f3644d4db13b2c0376f0c07186248e468a15cd2594d43c753496c895dc8bcc139fa3f59c02ff6c5155fe49447f5eaf79e89fa76a968f2c26d7f329804a7f124103b61e0da015fa2ac901e152644e5ee906e8856c9b543f8da2bfb8fafd1875c0ce0220ecf716bf7cf02d03b6a63a9a237ef20805c36628f99d6ceec385b82860fb0b6ac293fd5f3ce992a1905eb1e15e343d3e7af1c1362d57dbeeade80d7dc32473f5c0b06e8b5ac67dc549a284ec68319cd335d4fc694ec3b3c920585dc9b33a9631af2f23ffdda8b37c4e21a03bc40458392af69c01a691105d8f8100ae1fedbca343ffe3bec4a58bd2963a217dfb317</script>
  <div class="hbe hbe-content">
    <div class="hbe hbe-input hbe-input-default">
      <input class="hbe hbe-input-field hbe-input-field-default" type="password" id="hbePass">
      <label class="hbe hbe-input-label hbe-input-label-default" for="hbePass">
        <span class="hbe hbe-input-label-content hbe-input-label-content-default">Hey, password is required here.</span>
      </label>
    </div>
  </div>
</div>
<script data-pjax src="/lib/hbe.js"></script><link href="/css/hbe.style.css" rel="stylesheet" type="text/css">]]></content>
  </entry>
  <entry>
    <title>2023.3.6 - 2023.3.10</title>
    <url>/2023/03/11/week-28/</url>
    <content><![CDATA[<div class="hbe hbe-container" id="hexo-blog-encrypt" data-wpm="Oh, this is an invalid password. Check and try again, please." data-whm="OOPS, these decrypted content may changed, but you can still have a look.">
  <script id="hbeData" type="hbeData" data-hmacdigest="06398e60d748474ab065b635ddc36c712f08d9f325d1133896af220990697bdd">a99f2d1cd7f89812758242c57c62a59fe859e32cc19116fcceb1abacce500da0960986acd07eddb3568f524414b51feea94ed3a8842a2a7cb58681a02b461bf770f84ee1401d0da18103907eac52ca77090548360f53fc4e66e5c391b7dfb9ae86849e4fba5e66d69fcd759aa75fdfe0e4095724125680b303c8ac98c2eb7269b1ee5a431a362eafbb5c906d984f20edbb9001670312d1bebacb48225d176e880686f711e03057c4ed063d0a12935d87a03fb90657982ab92b8925afd5f157760d83cf59ab399042e81a8503e2eafbf0c4cfbc6610ba5eee2b2064bb01bc7642c39a1614a9c00a2be693fa885f33077e27f503100fc426770560d13dc872edbea1ef66abb17864defe567c92ca06bc3649f6a2726645eb88db1d600ef801eeb3699d2e3c5656f13a79106af830f3d464e55af753d4e7d3c37bf40c4a1a6ed2adf0babecc95426e92adbc0e5736fb3a3690cd6db193da5874e831d5e635ac0b37e66e7e3617f8a5fffc05859161f189be9182607db8b6267f9495cb333a5d512cd0941e6e3a04009844c8b668255a2a90232f2a76f946c16378a31bdaa2fccee3188cef110e0af4c958d00e2010acb67e2a3ae15570ae83048014923a8d7f2480775a9c339c9aa1229772e9e9c4337358ab4924e535cc12a621b14bf804d490939611d52e8c294da05d3c409ce92af3e7699ded18b1a054b4507bb9244d23546e330acbbf8ea44f88fe25e0766239bc74306a0fc073b30de796a9597588415d4d467adc5a86e2981cd8f6fe0f339d8277afcbfb81e88547aff1d2f2bec82eb32bd80f62abbfe9a87519b0c034fceedeefefe319071516ab5df5513b8a0a09c28d4723a214763e43dbcb097607b0779330e78964b34fdfeddba1c88cf742a34da1720f0a223973d5f39d55b267324fbb3b622271f289fc79280c00aaedd8c8f405bb4ece186e427ff3b5a32227a366790155aeacfb135652389b58734375ed074627775b38b0542e058e3a4f28f2289c6e025cac2c0b09b65db0d2334ff3fb707854820c9fab389c7e9cff46f2a99402ff0a163b11035d4b117062f6375210751252ffb67d01210011115bf8c8223d8938c5f45beca0021e115661d6bee8fd63dce1963d0ee1238ec9dc7606b3f421703464b8f0a97f8fe612e8f1a5f37a164325abdc38150ca3ffe0ccc1326291a0f4e6027423efdd694855caf05a42459d6b983508966790c34097e521ddd1ef2e59b6abd33e27d2f643f0dd95f3bfede692b95b57b672b166d4ab7494e85582b949c31a77e06f7bdebc656604a509afdfca3ea6c386cd16627cafada8afd2cb870de7f25cb81030b6a6579832ea1e2c65692412894c6b1d70cf188626a1c678e44ca7b6517c2f6c3b580d34583893dfad9d6018fa5897857fd6d7ccf30ac03db6365798fd52655f0ffe85025b3213229b38bd175d5f610ed1f4f459a7eb76b4b75cf27cc18e7e301050e3770bc5e4e4af1b2c96bb9e9a86d5b8cb53e14213ef788110e5940737cbbfb4b412a9233f1feca0baf07d6d5f32c62c76c5ee8765a1b6d2a79154f30462d8cdb867e4bf71de81db769e510f7c2ee2d3cad19046c26deae2acf0f5b39f3b72b02c22039d0c8f9e0101fdc785feee7168f8dc2b9acbc1bcde7ab1440b74d420385a1d0f2b8e90bcc2625831b6b8b5eee6b5a91578f81ebba3896b0c779d24e0277e2952cd06b69993022278b5129c36a1c1ae4f0fc559ec0d09eae143456427b097edb5f64e0227e61396de6c4c02ab73dbd3e0bceb6d3328d6e07ee0106422dfcc6c20d13929b64cfd06b2b3af088eb34fe12aa518acd75fe90dc51d63c6dd6022e0d368d02a0f9b5908295c93cdec278be6aa0943f1e50ce790c02a986d162329c6d7fa5b270cb0ca63bb01129c7b71a715c2103113c9d5f1d87fec2da18e34fffeaeb14b92cd44e62e1ccd561d21f0d148bc641421a42d1d8377df8700e0fa9cc4af7e4aeef98059c3fbc00e2d134a853d9550e682f5a6394d402b8057c3e0b30339aaf902d5d417136687db4f2fb873d959a2c4a9874712e790a459443a52ae214f75f22c73efc7e3e7ced24f3a469853b207fd82c1ff8f7ded28506a83366bec40d565a51580a4e893910ee2e16a5bd4cbc2a8c97ff67d555cea04fff052aa2d5c07c875da1b41685207b2246c9117e9bb53db9c4e2f3c9b899518ff28cea8248c308e53e3f082148bcab0afb4a630645bf38312fa76dd7bb675424a3a904c9864e81cd8b6c0ee3bf9ec4d0b2a542941ad14f7927d0332c54a96433c174dd24ddc2508aadffb294919dc8924fc966cb96222b14af1fb09ff460b230bd2bdbae4f2bf22d2739c6e3312c57db984b502ccda8d31ff0fddf812afb94d8f3ab15aee443ddac223b79f762be5583ba8cb5f4bab6eb71f6fa47d8f33f504a9b8b44f8d7e45d4a6429ab5ce7e05feb2e9a5d81daa97f10ce7f682e26957400285eb92558159213ca055667492b6cf8aa6f40f91dba582b8c167e52aa7ceb7e10b34ee16d04567654753a6b1d673d2f2b4cb0c29f2fb33347c80373ae767c1a785948c42e548032ea03b645537416bd0b75a7ecfbb2dca2c2113f88d8d23620beb2dde79b21e8a3c4ad9a88964925d7ab2ae95df7eb45e506c1cca37aac13a29a4ba04ce32127124be0b3ae0c2b744ccaea5c86db294b67336d740fae5b9cf1237ddf478c3accef51b081c0218e7a321bbc9bd66c03974b1c2cf9b087afb95ee0a40229f1eb9bfba4c6ff48e1908be28d2347d0fdee7751fa10f73cfcaaa97313b6ddc0652c591292de50f8874c63b2f628a2d8fcfeda8200754ca4fd19d8d6c6924bbfccef6152287df2039f2ddecf78c8a2eb953cf0b4f2b70ec1e03d59436934ae8a61829e9d74f932e210c9034225af1d6d5b2f2a2e2f5be22e75be5acdc2fa7affdf74d24e1352ee226f7cdc395f80f73f79c9190853a2969dbc36ccbf1c069d2b9fe0c5d17b7aec94a86dcc6b3c505183618eca56a6c6a80223c4b6edfbea48b81fb1fb761090328edc37440e788a83f06144442d25816355c46a6853fa0335bfaa20c01241e81cc17ea8b7299b6546ce0b6459ba94c6215eb1bf6421643e3a72439af365d0d0802c48c3e53acff0b182c1e6f7e7137ee534b0f8f34bf214452cb8981ca33980ff9100aa5b20fa923c1e74d3c91dc94acd3ec65c34829217ff42b97777e7ae5fa412c6b88000cbcbc74e5d58c27aa42ef28b8d1c730752ef9d30ec947d55bbc3c47915ad8c53f828568ac5b855019c8df789a6f3f552d916018af18f6641c0f801531b4b200297c677ad83a6637d9bb8fb0d4856098039a379d3095aeed792b6ab1fce0ffc94000488850b0597b9c12c22b94b497691bb370b3d61c6f8978bbd07b7fb87b541544c8ca1bcc834094b5dbbde0078b13823af64e270b82636b72fefd4be138061fb468febc7d18c4d793e51710b8c2e93c635970901f0b4e0f821efaab535246123b28273d025539d41ca452cd0bf3e59f026721e08847193480b0739b7a4b63313649fa23434878724f81c36e3a7343fb08f6f2976f4ebab5c1f1340a51dc3cfbb0f09ab704e46af9069b1e896c84a11bcb67f12c78a7743057398cbb390796d6b0ad1e661e0f6e47d79082ab151a8670e22bb793eb0efba030a22fc75ff016c71d56e384b37d48bff42e7c34422e478e4a45b6e731c207eda2ced73b4f8fca3123b6f06a4ed1c8efc7f6ca132e886a2b9664d1925bb63c471d9f19b10135b9bb9da236d1cef381ee0c23fb7cb486d133f4005f3ab902a49d1100601507812a3f2d60bb474f610b5e74ecc1ab38a544d77e7365b19427aa8603a11df15255d4d82ba61c0934d96071db9c2c0b1b77b609f9a846f267f9e9f3f8962ec34df73d58f3060dc26d4b998a729ec97244103a2814f2a503e7584c9271245a07c913f61ec12445cd8072e4864f0234c1da8576d8a8966f3a11735d58e157948edf3d344f2e95a293a6e30baab77abb6177ab4c4f8d3079dc9f21bc88cbfe81392c9d7080a6196c088cf35e221b0504a13db199fa7cb693e7f81ab27eaae3131fd100978fe18ce7f56e17de37dd339dea22f186cc7749c936bf328c50b5512951e0a3260a458d951461a8c3feace5a2eaf651fd60b15024a8e3fc71383c507b7387bfbd7d187fa83048569e400077579cd19d698cf70fbba48f40c58ebf9a2e73792c40a33799aea572b125d5721899ee625fdde6422a69ca4a748b3f31da6dad3fd43e527aed5df11552b4600422eff67ba76b83da9f522cf82642375e970bda526d6e3c9b5cb29f30400d689ca4fae1602140a54f4cfa0125c810b5ee60e4ff14ac00078f72a3e8007d9c8b5abae2c28f51eaf65aa44ef574024db61044a1638c8a291db7db06ecc7e55162cabb82aab98a22e3aa4d81c20d44f9198bd06a126b2722f81c95d2b75c35a5c8ffa2f97fb8c3f66e9763558304b69b5454fcae9b0f7f2a254dae86b7cc876ca44ccf84c097e69e031f912804974181860db054d4a6d9cb553448a7bc8f93f5974d527fb9ab2604cba70e702dc56cb87031aff6ffa3e1b36fe5218b9ba36041bdefd14a80f2cc96d1f579e4d0f4d3f4541d75990af3f9d1f1df15cc712c610b8f2185ce472d84b07cf3451e7a8b77f02574c81caf36eb390770935dcb461b3608f4e67c4353294a0c6a6542acf8ae7ac8fb9c2cccc9b932c73140a96e75da76581809822472cb5b28d41c28f3a92ec0285665046d1ea393a54bd9b0a99c70818022d80f235c23dbb97415196efdc7c81da69c3d36dc02bb1eda6478e4dad3fd536bab2925b2f15e13a9c7fcb1f430520301930944fe3c97df4f00f6226f7cfe505cdc87287d4fa4916e1ed800a1757f290e12fbee2aecf8b912c017cad10dd77fe547c694882695ceef6c25016bb2967ae7a0698ed3f50b7855325e55a639c6d1081497fc638e9d57a3856d555267bb02e72a792c251ddfa1e9e967c5beeee8f876f361fbe7dc2824f1b7eacb010de4abf4428b6d5b5127ffc34a3e3e17a57109895499cfee9a31367c27e7772812f8774f6de563af578c575cfd4d09dad397920d511112fe4fbda5b19b4c7dc09b39d477fdbe8802dc5e0d8249a24251325de291e62305fb616eab70146cd421dec7071feab99974da1f1fbcb6e9f7cfe7b4fca5424ca09453d3bc7756cb5e38cb54888ea5cfff84f536156f51a57d81f17fc47e49267102f9e006f7852e215b2e1f8fb81cbe1985895d928811f2ab9747b919e5ee18dfefe63afbf089bc051653634651310964b8d6830094166b0f14b2ff4d50f3be57060cea89d3ad4cb5426eee9a6ae429816ae69c64cbe0d5964fbcc1d1fc8a66fae1e5d6a127555f6b2e39be7409262b58ffdf022d3af720218097b6d7553de1a22d220527b02d1d35e507922b33acb89157f8f6bf1ae3a13d8b36b97b4523a92a6e8ff3081742b470bb6fb2ea448ddc817a0cb3cfda3f9c7968c25531d83fcae726901880b4ced956ff78e58cea47ee1c64872a5d9aef6d58cfdbf6e7ec4a68d07c1566e879bfa6c7ca5fb02d69801baaaa96db038c1e3bb453acadc05cc1fe0557cdcd4cd59e07085e56f717a8efd85b8923a8565155782b9ac4a6c461697ee53a51a5cb70abdd3b6c2d5fdd4d95892ffc9d6b5e93ed823b3f929fb2f01fb538aaedc968d899374425bb6ce1691ee6e73bcf516d9c67b9bceb69580cc8b24fed76cf6bf7787a321f594072593cddb0ca545bb237ada8c8b1f0c174177642d7944dd21b3ad0015150de6c91515a07af6be0f9aef621640f0fd0311bf6e35e6b1a0f666fe9634af376d2a0bea908a4163cf1728f32749c6a14076b5cbfb1901ad43b0e052814d9e73b0224033848e64b2a38981adda674c665396fba04b7fbc61fc3cc4613bcce52b9ecb34dea64fb7c78d64d757ffbffc4e5940a70081d296899329e46195af09b15300cce989b9e85639224dd3e2ffbbf2dd82003b47f13e05bf9acc70e199a7679e968b58a4d34776d30a139f5eb2f2c1bbba39647bb3e3d1312e995aa11e25787046a15ef7be529fc7e2500fea40650e11e16e28af279ddd028f1687256cd336990a24e1f97d1ea7c50ab9f29b8a45692f41e7dd9142d58f4dfe3334931fb236c819ed5b8aef8387bcfe8d4dfdb4852b0eeba5527fa745b369b60b1637525df0baefd9c929c9f117d5e41d4e1433356b9fae2c308bc9991e1e00c74cb64bed291520c4bfb983b67bfda5f853967146af2572827e157fde9737fe187c50ef57bd1aea9f31e898e8597db26f9a4656699753f7d3f110bc663e404db8874d55a62aa30912d0f9438cf42ebbeb8aac4321a6a1254860a57a8b00e858ae29e52daed731c8bfecef7a16ea87b41475a80f0e815fca9b1877efbf1c6dfc81f6bfc2e2ecbae097b574e060cca11a9adedbc1c1f330d9f2e6c501a7564277a0c623244b92f23baaa444a760b2bfa258081c43855273864caa05e66ba0639a94031269ff1147fe2637f2bd772a17cf87c77d39557783ed2750912a400338e7877fd9a6def7519c14e969c8e4605d45f2c25a1c99cf8bc4c5a02fd91574f55fb0cf36f6930a5d641a3b34f3aed7df68351e44478811893d3ec8565f777bf98b9e459d558ce2a3d4128e473bcab7e5120e33c9bfae1f094c5ec0dbe43d4ef0a6c072d379dd62459185209af17f7fc7beac619687cae886e89b13f0bf5263a91e916b854f056a1c853ba0b4c8da5ae6f155f5b2b5cc572656d70f5e1fb7fc2f29dd1b7b6ad510285ddd38102ccdda41dc652bd82b014c2e8170597ad814c7b2806045361275b52f301543a1bc876f650c52ba5b0f75b86f11d03e8220432df398d26d8780c791dc9808d0de1b5e9dc06f840739c18b28b37b915c2f9b6258685f4d703dadf18a99f746db0c4e0bbc7bf5b4994cd1ac3fd606cebad52c1ba38666245e6a189bdf1c9e59c57b44f2043484374671a3cc0e8fbe990e0de2d6d296f661715085db426df04008a553a9ee3fd92c58d74c4079148e4c4cafd0e029d727e5b3cd7f85e2fbb3917c7988f479110d241563f059931c707ff6be9a1177748374351e5fb1d67dc3ebd4eb8ba6a8f27a004164469da35b54921d158f9603617976fc29947d1381b0c049df40ceeeb90a2f005cc206cbfa571787f55c2540c2db576e34b241ac14e613b05bbe49b317122eedadc9ed81693a2542f8e5e2567649a123627bde5911ea6d062bd39e99f6bf010efa7de19774b63d57ab2916bf3c89f7f498d14218a59bd28afd4d103f06081bf86eaf9bc2fff6a7377ca5934bcc2a090d53487356baf9f977f9e5305c4c14a413d974485638910fe740e7aee8c09793f4cbaf167f8e2436e93c557ed4fc10d848fb9f34bad8d87f16081aba37814733fc0421925798c14e254cf5bd17d2d9ad4285fbc08b06de29228e7b1325ab0f3b58a182527126b0d4e920f5cee7875d487f5a8847fdc44b8b528223931660c08caa1d8cd64dc375bcb4a1250c665e818a4b08e05da787d45f9d38305ebeac5410dfe2b0ddee05999eaea433aed5056fc0068d75fb39ff66aff52cd72131a6421f324794c20186c17b979c96a006ac731a5280cbb8f366a26f9c80b8e538d18b05789b4d9c221fe6acfbdafe29abb3629a1ebbf3b9374795edc487d64232b56b1e0ff07e9c1e9a20ec050b7e5a6094680eafa57cff0d5fca23505fb26b8035614740a3955304a378d673e647e12826091ffa39d5fc701dfb7562ee998950c3613ccb94fab64c26fd4d8f90569c3efcae7651ca8d023aecbcca1412be77b725a22dc0d533be9abb111505ca81c9a7b8687e833c2d2f0ab4f5d06e92e1a05fa7df8ebbcf394bd851a801170f2376d8a0478249a4ef2cec9c3c685000ad050d72ca4a5aba16f2e6e6cc645eedd08774d13d6036635335e9e54e8b66450e5f409ed21123d181cc2c354b7d085f7e4ca14349893dc89a04ea39a703f500034a922055ea9683e7f4c51305092d3c2662d90cb44489fc8175b6414524869b109656e512928884a106f9b9af504e828413a1204aa235da748341a25ce9a4772709f965aa5708a640c489131ecd353abf0cfff0328fdee59fb73525a4f28a02a86dd0c3a1aaa5197afb15a271310cb5e8208849c8447d4b56cebe95dc056a6230df851eb3568dbba6acda48f851d15e1cdc30f6b0a3b3436e03a0af7be501ae9fc11c795e8e61ea34401af92c9ef7eda5c11c30e398e07fc393cb278265f159dbecde7ef1ccae0dd4f26f51a47286bcb50d14fa08cd53f80900714a9a6b170919636d32857c84879d454fc6581914885cdd6bc6d47e3469026e2da828211a7792e8c94cae359a5bef37d06566091b170ccd983d3fa5d46fa0c0e38b7c100296e9dde6607022599ad32eb2d9c1d5011d6d58bef6ab2df2622dbe208cfe38e7a021c1025f93e6248d1f295012e1be40f21eb1d396d34ce22358229a6123a0a3ed198d6b3e590fda24487fb2cf45a16a77020fcf34fbb99f44bdb39f79968b1cf49cd702d25bcb96122d7ef66f570a085f4f6c57c6c2557f555ccb5331ecc45ce91de89362dad08ee246b2d48daaf057775a6ebbee96cd84cc55d439ca6bdd07dfdce173f18ed973555826f2309c18b95e996b0f3518eebfa14ae929a8025e5eee610280774a4fddc05c8eef19657da31b37f96125c3b4d85559c13ca3ea5c1cae6dba8098f3d7a4d9dfe8613d0f1790f31ce3231122fa126a065538cc12c52bf6df82ae9c237a2a1f71482bf72da436381024a1d4910bd909a709956770dc7d376f1f010a825cbe0b4cab3d9bb1d0e845e6629be78af7deffd58cf68ba728acb714f8ad2a70a16cbf5e6a823e9a781b285ded2f62bba57cbf0827ba802482c46b8ba05a5dd97c297a56cc8a6fca35dd8f7d90764917052b6c62feaf1093f0b11f4c82e08a918bc6808905390f5dd97235ac694664d8d83a35cee79d94a97de61d06e29de21c103f40bc362b4db3ac8f791160852323249a3396ac236297a5aafd964b9f2d5ef0272a75a711803e4187200de89b7c858a6298b1eaa5e603fdc7ca4a2469f5cdf3aaa3f79a0fa1c61a0d3339878a087d7d20ecc8a7d644f72a08471348b9d9baa71e3cc64095d5df215eed2973a85684d8213cebf4720f0aa1fe1ecca3c9122e443e898b32ff8bdbea660f7a8b58fc170a73d43e4d3eb0cb0495d3462831867c55426115e302898d95cccc6442f45b849598ed57eeb41e71c2a851067f425ee7a806467c3659d653dcfa29d3dc82f76471a023c1b1dd1216f98385266ca1d7da4394d386099bf8628026a0984e2ba2c55e923f33149ea349da3e80b2dbfc76e227f1e792c4de97f2969104db014f5fcfe308a1d94707f2a06dae009120fd8e9385ea68b8b54db75cda31093e2ff9b996fe4fe9f60c6257e03b2701210b69c25655c709b43ad94f94e02ff6866cdd084e90850873efdcaedbcb4056fdce68f0849abce507e281b94594a08a9727a49422566d7d02b88c7ea280053fc677dde34abf6ac372ff2dbe40dcca1630afdd78c12c36267ca3f238f0fa68219238d92e53e6a4b0768c530254a7cc101dc35c3dfe15b91f1f40f8a765b01c385a3b7f86ad44706ec9ff951ff17f79b0dc857edc2aaee46050961d013e0c1d21695ff9aebd9e00f1f5cbf80104623496d44e82fc6aad505b24fa6c85027ed5436d3b0f587c21799d993b68b6877511f4b2539656d494dc7306fc6a9e1d6e5020d34e142a5d7f99428df5248ceb14e88ebe5986e23feaa0972d759c5816196fda53e1dc08116651471e4e01334f3b21e83109b1c045aea259d02f1f050526b8032868a98fbbe4c27a10a409bda4ec9e92c14d54c9d9e747921ab458669fc0309bf476adac00c97c5067c49e4666ae28fdb49dda36902d22d460a232fd4848f5c99ba0ad0eee7bd9bdf1c438ac26249caf7ccb4f61517d0fbb730b4c3d2afeee54eef18ed112031bc72ad81eff8ea148e9d3fa4dd28abe27f9042f74ee72e09766335f8bdb8aa244d18c6e13f6890e18eaba2f430dd749d28d81df67e900894d0f817f3586df97a96a810b9e3a50a9491bd8d518a5248ff4fbae6229631bfaeec71103671cac2e3689a12e198c3e92cb8da4c5745fa5709ec417478e4428378d8cec8da10af91ab35ec5243b8ecc20b20b4761cd92612d37a668135dc28354f5bc0c1c6ff1302e31eefe18a204c5402c1909c775a831e31f1c7e68ce9bb958a37a7ee89d2ba5fee1f92baefcf5647b5e4ce1bace25e0e2c573d184390a79e696600910b126b4a4f9f66b5547caa11c5b2b3abd663e4c3fc51c425adf7b18c20560f73d202a2af31749df36c039ed3ea4d1cee4505dc198f3ec0bf77e3762ba1f405f46450838cb89a9d74affb73eecfbbb6c1609403a30391ef72a3f8034b4933d0f859c4fa6111fedadf54e0ec4272b2ba4643258a29be63a1cf84438f6fd125d623d16d399aedafeaf6795d6f368f2ffa5327d9fc8eb7ea496f73679a7993e4b39d87e0e9adf5aa5bf2a61bda8000646752d05a68d86e62ce473f51bb4acd58b2bb9176e3ed53b313c6feeb818ec8c23a159b28b4d774229f8649552db64b02033352ded7c1c8c144967f08711ee7d4e6d3765ab6771f45df978660e4b134cdc14815614a5e942876e42bf132659c21e79dcbe6385a5f79eaa91d974b39c4b0f75b219f3028745e6f8152c52a88b0aa24416094a051bab6c4a6265de8220fe6eee03b199711472a71f9ab87fc15ed63d9a37f671140df8b9854eec4d504b4672b65c73b6ab6b2b2f6c6bc1086a1e0522cae6f51fc490158dbb3375106132e4f77a0c11cc6f2adacfa2ba726bf6f8e12bde0d982e678f9f41ccf37b8cae0bfed3c219908c68dee39cc56f9126a5edd668817558d02fcd66e9f20832034074642c24556203f38c8feb398de6a5b26ff1f5c29efc26065f56cb50882da02069733ab25a72aef984ddf4b2bc0c9d4ef8441e44eee7ee0593534a21da727c5d1807de661254e8a192091f1ba19d28e2a3f03ac2a40d44cd2e8301fba9a636566f97a31a2bfbd48240b59e1225d3de28fdcc94f847bbf11a436a8b98494864a80ac96ac46d8c3b93fd8bd54be4500ce99d96e3bb3df2596f273ae49aae6328e541c9eda9034473b3faec6e4b9e1fc8065fec6fe097d9d88e3993d5a62d1133d51428a2690cc3206a6bafc1ff287ce80c7330d075f31dcd8d70f7324e8cef000150b264e4350b50784109687f8bf52c623527fe6a62f91c403598babb22b1a4484754a95e74372ff2589b9ec84e2dc7bdc7f532f650a8cfdd792b112054cfe61b46dd1b9de70f0329745f4e11ceca110dbf783797b02af263fa736649d5aece7201e761f54e0a952d5ccfade64bc7c3253b7b98c757aa7ce3cdcb10da98237d55cda74b34ede4dc734a1c562e0129fb521751a859e405146c954ea847a415ab443337e3edc2ec7ed9a3fb52bc82da4cccd1770945fc4ac90fe723261d287fb08a258fac422af51132d6c3abe8dfd47d112f810bd24d61397b52012186cfcf563004007978b6070c4f57c067727734c5277f37d219e2e062f38a4eba034da376a19c1e744dc632e13c2ec82f1cf6b66c9f8367f063dae15547c2610275a271171372f5ecb447e9b962fa1365dcc20643cac28b43a14b0d76e012c756f3bc36a5ca23433f12a2ab875ec8890345c579f559a300bb5328dd06eaf5b3d12a125b1595aa3d97ef112b11bbe326c5169cbffea04ed26c1a46ead38d6a15368543a4bebbc701c6e91467ee43bb57f71a5d93ac8aecfe051f40cc4abb92452e800579b645cafe428366ee2b3cde0f7d474598e77968ada52182bf85747c4a5054a12d45b524538b44907ff669cafc08ce6372a00e4d3c518567a48f83491e83842325601787c5b8291429cf27206d5e7b7d6ac5543393a8b226c8cfc90e3ad5e71cfe0bc7ae7ab398e9bdd6faf66e5111ad6009e7cd108e46cd4a162f62ba3c37f08b998e885aa5ab871f28ac7b2b73f59161d60ba2f7358029c782dd61543b2f8fbba372ba94c1cbbf33d1e44fefb7b35565fa2cc84b58c4bdd367a53be76f74c7d722ea6e7fd0c98ebb21e1335769a6925f3e90fc5c064d259aee1442050a43ad67a8c989c0746ca0fe2d558182d2f4ff10140bed66d87ec2b16b16fc68fcee25889fa1ab5d574c36a3b8e654bfb7dcec13bd17b5e69da354454214de96657e8cdf562ed5f73cd3ac0e6924e141a972b72f0f741bf95f4fe34f3a687d26fbaeb33d121c8fa94feb2b573d24ee5a492d8bff9bcdc7fbf61338128ca15fe3728e9a5c9077ed9515936cecc51e1af174c8cf912483bfff3a7b16129dcf92deba29c7a33d13bc0b006bb3e8118fbebd5506a7b45df6a8068b175fbd7e76b602077ee96c9e745333d7f50cb0727d1e6c76fb141fdefe888b9eaf2db1dfa485a13c428ca5d3cdc9922583fc7c695442a244b043542745fed7cdd3ca54a3d793d4d1eb6b172fb491ab1e1d215c77cc8757609a6aa60f6ba77d8b196e77eada6314ac2bbf339cc4272e93d0c8af13d123b3dba0b35b430f6775890d77bbb3da7da76fcd60d0bce9da6936470f757a66b3856d2c8d256cd600bf98f48d449a97038f3b9afa69ed173cac1fc2337829b3edcf8f612fbbc4c677bef8627965eef0806956b8bcae5cd97592f8a988be720f8565960b69a9926539a2e9932b3fd947a7052d649eff55e92837cb6bc101c49cbed3020e9832d0d85b77fbe1a393075a9bf1d582e950f55cc3f126a5f0a7094a587418b29ed5f0f62dda1fdd319679dccf311b1dc50a8530c35248f61867154261c610b62c63d614aa87c8f33ce5d0229e3148187a9a1a124cd9d1d64fbd90cc4de9a10ca83e560dce28225903461dd08b6e7dfd187b49c6faea4b7a075b6d0c4953026a8d10d8ce219a5d118d5e102c71f112d4434a05aa35d656c3ce811d2d2c486945057fa4246367aebcc226db70f20df662b807e00d174627f18335c32429b2a12e937704a0eab82cc5b0af26bb2c51c16891e0898eabb7bfe27f61dd1a82f0bc3af8bab781a73260fec4ce469caeae08bc11c510d1b500f346d9bad5750f6008f3ed7c50893671231356793f09973c15d1cab3bc98235f3cf7ec9e7a8ba963b264f96ba7ec7dd9b2b9264ba53caa9501500cd8b00dc3ef817ea92d718fe36e2f839cfd16210d83416cab153e0c84c74087b95eab78bb13f6a3adb16c5514e488a286864693100535d4951d4645d16bf7dbb6ff98b964832f4c00df1de10a3b49c7522c8e922b1421fb881d22246414911728a1bdf20147e2df99f6e77980cbe894b30736a10b64b5452819766bcf4bdcb4b7af02f5cfd549a6bdc222039357bebc7e50577bd0fad09aee6f3ffb837cd02ca33b6fcc5e272b1a6d341f68e0efe06e174eb4553334ec28eacfb52fd8dc496254f42e28ba34f6aeea8a746b838bb671bcb104dd84f3de3c9117f7918df474b3bd5bcad2aac29447784dacf76651625ee87038938c276f3f24ff0a02335a2853f6660e18c60875ee2184dfed4545b931de9b30a925e54c12bed9d254616266958579ca4657737a1f3ee7aeb275bd8819e2da2d23f0564a06cde47f8cdf8271693f0f6105b724e8ae37cf92b32bc59e20fd0efdb73890a62a13af8b1606f11f29d585d3ca57556d465f64ff3f396bcb2da678df2d30c19abaac3774de09e32ca2a036ca95231aa257eb9b80247deea10adfb0841e37a9b6b42598a0b46ad1c2b0a84271adab8a8e3bdbe13813d6b213ad2022544e18e8d7245014f202347a9af3ab24868b684de3408d03c90955f6e54e49d9f3382991279d982eac22e6e0b25c7fd6e2d62596eb25d44e3b8f197cacbeaacf0d0454d93df56043744540a8febd9282e9f6b5edb6e5accee7569b8d5ed2abd666228fabbcccd9eb8a6adf151bb6ae385fe968aca08c4f7ab0d978eae24864aede1d31524c566887a1dea81f79f6b0ab9c0ed4fb8142913efbc5971d5090ba6a0493a49e40f576b40fb1b1a97f77f1d54fc4c1c60557a5346f395fc574f49624de1484f45ad9b2fcdeb2ffb300a05280b0127f8b5f96f42140f6f5809fda84acac8a15f238ebfae0c77256d9c55b20f6926ed2ac2aa6f248afb6a426691e4c535e7c4f69b59783aa9f345fa9d6bce3f890ce2a44fd5556addffdb17b06008081252b84565500a15af39ba7b6c0bbfbef731cd1960d85111002a27cb98b05dbca98c1f029f7de40c9cc5d72fb9caa21559161605dac37bb65954d26b5d5a707dedefa2f43e0e42d2ed98cc1981e21b3a36bd696f1a0086ec7c9caeb94eb5321f23f471dac563bf960763dec60bc42985d001ebf86a93b01bee9bf9e38f2c29381dd53e55c16be82749c9b17bb3d89e4d55ee74189c410a9fa11b0189150a30aaea655c110a5c402b72b93aad72757f827161d47abdd3000ff44fa9e8d69a397add4fcdfaa6e34d36e8b83ad43f17d5d70d1f99939abdf76df87173952d09bd5aabc50e3aaa0e08934512b622baca3ea6a6f2b59f656828fd308952af33db1e7490ff96d7d65ced05f200af51ee7d3b657fe27439e0ebc29ff686d23c981763c8d822e32fecfa4833ce4da2a65e7ceb02bbc8f6c804b25934be486fe2d624c5df4bdb2fd9e65ea254f46561765ad66e16a9d43aac67688b2b26085958db232ce5127cd90efeaa805221d58d561baf16702a5ce0a0022a967d8b7d78f95520546e9614d9e281c3e1ff1df660ea2e0b44cd58b66fe265414e0fd0293278b8c9e1545c1fb3320ac5bb67b587ae72f402a56699b2c2d6845b18866f218a51ea325ed6c5001a780f61d254ee063de52ab55853a4ff86bbef8f5dc06e2b4f7a77e85ee4bc649f91fbfe0238a3b0f047584a58decd679625de0a24b4a6a0f79a2e357bc8ad58868ab1c470f0306fab05d8d339bab77ed456a8f688611c3174c9fc43affe0f0db3cbae815c42b2d77dd8d00bb9a5beadf95390e754409b1c4122769f34fe77fb078526efbb68849e6dab5639fdefcc1e4fbbe36ce9530945922254e72ea4cb86185eab9e1a24b4b323cc3655ed9bd6a177d262c68d4e6af3830f8bfb691aa24fe26ad146c9d674b89efc8985c356152fa4692bab54a25d4c906cc03a8b2739d689a4d39a1d8f1dba300bc09660f05b1da10d5d0248e8cd8e4514352e11b798b508dbc492c104982f52ed8476d95572a37aefcb8a1e23ea6d551765483afcecf58c6dcc19692257297e2e59cdc398d3439733545f8dcdaa6276196531ecfeafed0bcd4191a60c2623a017644476b9804179c5134f3717fa786fa49daf67a82ec9013ef0a1d7b201d0331a2a2a4d594c6d574a3904790260fc805a1d0bd42067de7b99d89f079c99fe5279d6fc53564fef6a353d30defb29b80c2974ca58afc0d7944a5537461d3c57ef55a3fbd8ae0ab27c7a6ab2ba764e25231d61617b62123ff1b0bc1892063c690226b2c61b9f8d807b29e2b9653baa043529953ad625a593ed48d9f406a38e10ec34e8a88781d74b89255a9da25f84212654b48a3a4af8f2fbe646933f5fa122072ea089f9869f193112634ba5f88534b6898dd2793ccca6e457bf4b4a153379a41ad3276f343c83e4cf9d7fe434f0675dc22ab0fcc939c4635389397d0af7a4ae9e420aa256c2d35f823da61da799d4c5285b8607bd0969bba545a8c14064c8e741d5f47e8c41c5f5cc0ab93f8c4a6d3e887c8e72cc440c5c13a31f7ee97146247a844e5a9307e4d6e81fa2c225d5f46de1668732896e2ba99256fa53b3fd301ff52cddff086d6a792e7834a1f6c916c550fed6efc2c4996be9d376319f40d5ebbe9e37822f9a214e06f923e92e5bee38e2e848302c7e9a33ed2e6712e7b8a715a5052a91809517810649470c1ebf15f1d0cc2fa59fe928b91747f8efe349452ff4c54f933c1ba311b07c465df9f1d2f429c99f9e3172bf0946cda37a30ba07e4136c74c5f954b4ab8ecb0dc3a57eee5cc1860170126219c1357b8f01a58b737731557369c19255c3bbb7c77a3e225fe1278f5ad45de0583da6fb9948c333fcea30cc2b5ee9d73698daa2ef12a7a31f08e1f2faea38a7a49d5c1306216a03f582ce79b42e46167799c9bf6c6fdff4cd2c91af1ab705695a937cf13f930239b6461aa36042683dec9b6d7d94f4e7c65e5cbc520cc24fe6a2764fc5f5eab9baa361204f091d09a8446ea17c43cbaa1cc3b035c402b980b1db2200eb6593471b02578428fa2a1f2596550023198a60568eb4c60234cb2a8eb6fe1ab1f6cb3768657f5ad2ea07a1bce8da1d706ec9f5c47f94ea28813dea8c84d3ab51bb9bbba746db1d2e92e2a7c2c093f7c7ab89b2750b126e50ec565000b6dd17d27a3833404e246ddc5b8f514130d2fddb9c4b27a4033910459a3d0d0396e92edb1e7be6678a04009f1dc372cb68db68df336f48ee616c839f22e5d5d81f470c91e0cabec4597d6c7a962ee06556a104e75d1669b6215d1ee22565eb37a5e58faf0f4429</script>
  <div class="hbe hbe-content">
    <div class="hbe hbe-input hbe-input-default">
      <input class="hbe hbe-input-field hbe-input-field-default" type="password" id="hbePass">
      <label class="hbe hbe-input-label hbe-input-label-default" for="hbePass">
        <span class="hbe hbe-input-label-content hbe-input-label-content-default">Hey, password is required here.</span>
      </label>
    </div>
  </div>
</div>
<script data-pjax src="/lib/hbe.js"></script><link href="/css/hbe.style.css" rel="stylesheet" type="text/css">]]></content>
  </entry>
  <entry>
    <title>2023.3.27 - 2023.3.31</title>
    <url>/2023/03/31/week-31/</url>
    <content><![CDATA[<div class="hbe hbe-container" id="hexo-blog-encrypt" data-wpm="Oh, this is an invalid password. Check and try again, please." data-whm="OOPS, these decrypted content may changed, but you can still have a look.">
  <script id="hbeData" type="hbeData" data-hmacdigest="92ed975dd03f650c2d000f0cc40612258d86290b54b1598d787aedfcf6a351cb">a99f2d1cd7f89812758242c57c62a59fe859e32cc19116fcceb1abacce500da0960986acd07eddb3568f524414b51feea94ed3a8842a2a7cb58681a02b461bf770f84ee1401d0da18103907eac52ca7792d6f557e3ead26bd281142b7f9ed4f871e91ef3e7a7a33b975e9ec3fdc7e809cba6edaeee4fa7968b24789bcd7e8f0d33a77808336fbc46ca8844b6f7668da38dc5c58df2696b59a5572a9c0589173c45d5457964e9e4e084f5dfa5c69d20d08d8ed9b1173bd2d6d702523516951b29c953488db7386f8f5740f97bc74000e0d98ef5fac82dcf6172b9c12be2ff4e1f12d11d649b3ba99e3f64f696a75dca3700748003208b608fb0a5aeb739641bca8903deacda515e3bcf06d9ad14235db011ded1bab9692d4a7482a05af2564997ec6324c115e980348d9977885d834e445028c25340f79f4bf725ec4b5213329ff84d91d25cff04607e5e31650766f394b537175bf1d87f8b2882dc47c80592d942d5b4af7bce37b08bc7e3dd85d880a13dc14b59e359d9bfa1e355ed08bce4d49adf0996ea81ef811f812453883d10326390d903b9f671502ba597ccc87239e5c5f9930cca4041d947f69777ab749fe5190ac91a82faaff42d3347044cd419e7286a877b01378dd131fea36086953f8bfbbda491b360caf1df6f4c631c96e420a1a34eb7f98ea0236ca10b798e26f7b98427bf85901fe4219cc65c6f43a7d6b67baea0694b8d53d733459c65a36607af9afa6e793d308ead9d016b615dff6f8948cdf4e3191b8632ba4d2569f8c9d999670d676c41a803578d89cd74f80528edaa3e03a1ee4ef06421a2ea269dd4368c5252747c96a70331debbec1257f5c73c3f2a1927db19c03dd5a756e07df294b4fb46c57bed45a4a08344f37e4e247610986e9b554bacab87da159737fffdc531fcfd3b8e10536c282c3527ec593bcbf6b851df725ea15d5eb59c74fa5d68ed9bb7779684fd23f85661ebed3e2e85764174ee6e9bfca4c65436015f25b5c88eaf61aeced050f89a83b8df65da43b8ddb16d0c095612243a8ba98ac26b207e474c4bbbe5bca8279f989bddb9081f20e4801ef1840fa0f7e4c2538ff9429caa8af1595ee803efba56cb4a9a7f7e64d4d0fc09cfee5708351a39fca88e852ddf6da0b0493cb7e1c285e09db7a9185e930b626e2ca3caf72fcf66f16f980fd1f01960a32810e208c136b3b57dd21e2e6ea2b99091faeb67498ffb2b28f39d0de6e4f0f248bf16f760493bb0a4ef48baa170483ec3f44d99abdc73830bf6c5dde210b6d672fdfc496e1149097d71b97468691b15498bd34fed3fe1b20b38da0967c5be2fe228468a5d763de2fbd358739020e9ae9c03fdd1b7fad0656184b134ebd5d30dc8472c362f9bfe37aa514c088d21f77d29fe7b0237b5c1008b43310cbebf68d4e788c6ac4325b3088f048851d73a001e006985add87e824f14700c7132318f1c409bbd89904cae6f8e4eeca2fe1223b0568aa7edf6ad7762f955e6a8f97202d1dd47719dab312a3ce58f54e5ab5ed6073e3a13a6ed5c6bf82f7033a15074d08058b4ea5880ed97b37bd83093550e9876b0fed6618215a194e5676f36ad3c63caac62f2815afaf4c06c68a18057a2a69a0bd8442f1d7348834db6c1e2e825c5073954f38e051689d4a1cad00fc729a8aee54b1cee4a2e7c18f1dc31878bfec996fc30e520668bf732822d9537124fb836a86fc03eab3c8a1475e8b02ad24d35015cce51c37bcfc3069be93747fe27f9b78842256b0ba0eae7d076713d009fc9a9d4685f2b3699d02e8ee292774a51bfde77949d3ca5910eb14253865273d0035cb13396a1676de4e766e44d1221e6a871aa8047f1eac4261be95d4e7f4a132a8cdf6ead8a7e044976ef7959d761984d07c4450ba1f9bbf19b0e1f78f17961f45f91b7c65cfa420e06ed6d6bcaf9454cbb8bb872874e8080f8aad3ad11360b0770fa04937a19a98117a9e1cb0bb830b603e5fd67c6a19350ca610bac922519a928643c8a1570c3de862ae5d196076ff184dfb67e1c69694bca45e3a0bd20b9d09009e120050ac8423119cf5f60cbad6c2d134b46f193a9904d14a82385059c2a011cd4d3c0487a815a54934d5cbdaa734f441c781db344fc57aaabfc8ccd4688126c6469d4322319c0fbb50973f3fe002a2ad7d434c4bc0696d03191483198f6b217006dcaf3fef5bb8d176274a6fb4c3626784b43ba177439bc1e40c2fedd18c33b523d830b209820046ef84fc14096db8e74844163c14c1cbf4a5040a95d25e9eebc256c8d1855a8b40200d2b6fdcde0e4877ea5757e65afbda65e28373b039f787da2ef6459c4ccf98a6d46423d45cf44797b85ba38a4f236cc1a1df8cec11d748934a637de17347c601886e8f3280c68d8e403224ca9530474b7486e79148c74fad02a4bf8e0b4737fbd8bfe0d6c96e9de6f2cfd5491d21ac7f4219976748eeec8541970677b3ede10efcd4297dbdc552ca767b7a08f6b3970a507275d069f0775766c46f1e2842c5947a984c10365f610de353d0c099134f3c6756a455b6e9dfe9b25475e51ed5c5b0115f57f719678b55b4957b4745945977b685c3633b654b6d0c671c997c3e949ed8ccb48933f1494eac6cd964e6b9d89d2e2e89ff27e08a783ec622c96c93480aaf69263f814a35486b765923678b187e9e66420945522b256058cca37085ff83663d515047cf76395e36360e0e7a54567a0a81df6987b7625a32905d7e766e0f98696d004</script>
  <div class="hbe hbe-content">
    <div class="hbe hbe-input hbe-input-default">
      <input class="hbe hbe-input-field hbe-input-field-default" type="password" id="hbePass">
      <label class="hbe hbe-input-label hbe-input-label-default" for="hbePass">
        <span class="hbe hbe-input-label-content hbe-input-label-content-default">Hey, password is required here.</span>
      </label>
    </div>
  </div>
</div>
<script data-pjax src="/lib/hbe.js"></script><link href="/css/hbe.style.css" rel="stylesheet" type="text/css">]]></content>
  </entry>
  <entry>
    <title>2023.4.24 - 2023.4.28</title>
    <url>/2023/04/27/week-35/</url>
    <content><![CDATA[<div class="hbe hbe-container" id="hexo-blog-encrypt" data-wpm="Oh, this is an invalid password. Check and try again, please." data-whm="OOPS, these decrypted content may changed, but you can still have a look.">
  <script id="hbeData" type="hbeData" data-hmacdigest="144c25826654f083e27f9eb7d575dda3d6a867a9467471130816a2dff007e4d6">a99f2d1cd7f89812758242c57c62a59fe859e32cc19116fcceb1abacce500da0960986acd07eddb3568f524414b51feea94ed3a8842a2a7cb58681a02b461bf770f84ee1401d0da18103907eac52ca775c9e6918f4a56e9ff0f2347f47b29979f9d1ad7ad12efe8660e400a17c0b51a2f5ca1fa6f10ed4ae7209ad756982fa9318f1f58a63c15c436ed34cd8b51a7552074ac663b642d728cfb2c9f147d61b1a10c0c0541b8c5cee3cd343e2e31807605d52b1f7491712723873da7adb981b527c787ad56c950d2ed89e740d7d2f5c0f22bacb90b245dfea850b721015c0d93585837af35a542e6be941907f6c9ca93a9fc6d167b9b9a8c637dee772a5d7b94800b4109b609ebf98315c8528fa12c88cee695123d6ccf4ea8203f42c3efa02d80bd0c09510c4dc4612f7283c713fbcd115523108edb619ba005534eddabf7c22e319f97b91fc00dc606c97a2390a40a19812228a09adcc988028b3efe433fedc077764ea0013a31c24f0fc7da8a59a6d4468512a092b7f793a11d45b4a7315882b39381a1c9946ba548ea6c415a5fe0e969376e9de3b4b857aba2cb114c7d22342e0258bcdf62e934082ce1f7942d98e3ada2c54bf18cedf3d055e964fcb0dd6421f36196a670d32445a9903aca76ca2d5545aa471b372bb0098407d6c1b750de8797e36c627e056914da406f6505a7b76780a93254d7c94c644e8ef33a0e497093682fd6383af067785da151253344aea8b2bf7622b37549b06a6a1bd604a6b75f35a4c454014d9830ef8a35caa9e2d161d7efc038f036f86fa0ac122c35631fc4abc748747cec1a65691bd9aa7171f535f58ba4b0563809f5a7d9ba06197ba1fe88f0d0511c6a1141b1a0c2dea6962375962be6956ad51fc215d3a249be0a12b941f8df17decf990f9fef2999b8bdbb5f6781eff4d3b927bad2df3a2fe0dcb3c3812fecac12663352e5f238e10bcebe02689e06a5acc8c7e52d0f5d247116a7d389bbf7f2435625a9b1b9fbec457dc183d7822008dfc5aa94184dc2ff893f020cb934378948809212461cae49655707b56867bd3081894ee0f00a0e06abf1899a2d362b063a375b5945bc95e753f6edb1f6e5ed3c36b25248ce7959ddafb8546565e7d5edee41e9396fae5e74ab4499710cf8040c80b28c4c67eefea852bf75e615a0469ea981bbd7f8977520b120acb84a58e78fa88dff88dd471cb0a6ee563ecff2862555606fdb8dfdb65edd4b9c3f8f8f9b44678aee2659d85bfe61023067665c136c2cc158ef667c752b6f12b22cc5b0421d6b3b2bd4c11249166dce473453d38c1f342d16d63ec0d76a7cb3fada638f7f596f38968534a9e66611c4c45222bbfdbc98c9e3de9938d0a1f7760b3916b85bd8b081c572776f62bc544aba749f02a1c2ea72e03e5717d9b34520595518219e7536c76dfdcbe346934b588464fb0bac9c3d83469de8ded498f4e1cae62fbf5d9bbadd4a16706362a195486031e66f2151870b2f2715955a2abab87b7cf16207a4419fd83c7ae9e49a1f58fbc464f21b4bd2b08e5262d78b6a44d41640bc1b299cf6c91563b7fa140d4ff72916e619a91d5cc638019cf5b6fce16b0e5899e274538711630f8b3758c6deabf8554b4e37f13a619a37601594027c09481edd945d4c3db66cd25e42612bc174d0a66cf629f9401e4b87c35d2a8aa0c62f04f121d4a4accc4e0242a2a9ab24ebdcb3a70cda1e5f1d6fe6f908bbca07fe58e730159ce80b34a096b4744d6768bf806c59935e71aa8bc0e1f9fcc03b7c485ee8ad4b5f4cf612a09ed1f558a1df04c674f5e83d2316b780b583441b3ac33ab65f23a29c6f6a0ac703a87d83cbbd4aab71b31d89be1b40841133e8985cd98b9b99b1245adc3f81fcd10db72ebada6ea281b6f223d465c0ffedb7ea8d05f65308cc95ceb3aabd49f814f5537ed500079aa7c7e2717c5c292bfc7113284802682e13b88759da3e352be6b54b3245e642bbecdb07f3fd5f7d3cb344fbc4cc303426de1ebf833e7074bbd55614850b5607eaff0ed76321d82979648b15f2bcb5efc31ceff95e61cca58f98fde14f144319f222f32b0dc4ac51fbed7ea7fde84bb7d3435558888cf653939d4dbd1437f19c2ca6e63279628f9a3d98989da4d9ce8582d87a64ed86018d3b970c15908b0599fb48f15270ee965bbf3cd3cf3c7b5f6db4d628da0493aaa9f7440727cd7a0fa7d679780343bc5b01db0f87c0227c76b90f06f657f80d097c906a47b74e581ebac6816023cd18fc8c57d1507aede5d75f0855c9e901763a1f978b34b6dafd0db61bc7cad070668bb87e0d63cc1c451df39e973bf552fec5902028aad298b8ba1e337fbcd3e6667365b63abacab32df06f2c5f2bc37574073aec0bb41c793e0a9c724fd368fecb3f7abc00c6ad7158bf8458fc6f7ca1b7c734a47722130b88773f800e580bdbc4c948f407a784c460b60acbd2677e1c54bbd46565c6997263f2a3b84d073f5ec9b5b2bf10a7b0380098a1b50a8a86a0ba5623f7c69f2843fe89518e15ce549b6fef4acf8af811bec243aef861570c84d4eb49530f345a82bbb611747a6853b90676495ff5e611874b50026b9eba160026691c7b0db54b376445585c4d4a2ef15c6a46fe85aa53f8ca19863d11c1e8a4a87cc2ddefb074b6338e82992c30ac84732877296ef2a4206aa223d7ffa2aafdb752eb8d20000a661629dad4c59a1584d46f9c76787b78d096d2574ca391b0d72f58abc0ee903ec9bb85197aa2ed2f714520351cf07012669cd38929319f66b103dc3119c81abcc9c286164047ba9a5d802a89594e471fc021e25e93dee9d3e51b3737de5256aaf8c755d142b2e770d703e7e0fd229d3945a404de479cf7085ccf4669e8ed4ef20c1546787fd5de53fc438fcfebf0b56010b5f2a90687fa0e9cc7c9d38dbc7dfde9925ebd1a8ad7c573ad588aa10e927db027387524517c6d6c96e8c2a0b50253a93f0661042ea371ced3fdec93182ea29be8e89534d57a4130444f2342ec5f7a0bb52688575f47bffe956d58917f47d4acd4ee8be908a9b9aa4bab71c18e1f80726694d479ee939250ac807c166eaf1fe6294a3db99fe292c26b67a3599513e5c7baa987b011308e8a506ecee7b85e00f60d5c3e6cd3e72274de6a9ac534841fdaf3402ca7203109b28291365c9be1be977047971dc8ca460fdc4fe80e0fe6a95b8c12298f769295832c0ad8ef02c8c630f9b422ac1a375a4d8e153741bbe175e63284d5528c759e39a2388cd159a97d323c0a45cd650d860e8f54f019f7fc39c1459676e798d56b747efc89d15dac146c3f97f3315194a9b52f14ad88e1ceac76d768cbab49096112f01f6ca4e0aea4aa9528fb5d1db2936f704b3b5cf5c9cc6e82b034d5a0dc523ec7bb7257e8b0b705f3cef6a094de9aaa6ebb88b5e2532d0a54981b4dda3a130cc5f5dabe5f38dd428a420504d940cf18fb2ae0d4461eb5f389a715772b2e87aa71572a6535c6566ce9eebee368d679b23fa4fd42014043bcd1bf8b4d96c35040d317f84de53aeea55bd1d7cc4b0ac459c1b42e32f4900246535b0a112f3725685c7ce4451d62c95f87049e94a56c80dff457ad4346dec5a2b290e6c06cf1bd552401161f112cdec6f676b7d121a6bd3713b14c012a4d415323f7839a3f98dec71d8425c18026443e91f7901b369e645ecbf97d523672c25f5fd7fb6c1b35d7cd8f2d6fff7ddbd7dcd4aa9bbcde3434796333edbcfa4d9e59a45d6c5dc99236c9c0302df2117f358eeefaca42d8d1bd25aa5503a3dbf10e62037b1ba7d102e6a0e090eced5bb826b1ed892da8fe2535a6aa3d3c2bddca8e7dad080bf8ea9d6e09abf0c3725d8758309ba7a09485236b65c9f1ed9cad0d00dd56784145315e36dcc43da377848caaa910ac891bc152da2cd6b8fabe324ac685186736d064d3aeeae38f3948979336e8b6982caf7a28e5bcf2485a43cbf075dc92e208c07d638961dfd72a2ee060dbe1ee92c57957ce9e3191d0486765e6bac00b70b2c392eb1576b78c6f9d45226a80d6750ba554d149d01dd26b17e5b56feb76774c4e6d68d6ada37c2529c207e927f30675a4d30e1dddfafc38b374e0be5a85d56ba10732199942a0333fd4956fc969d2c7949356ebcf0bce38d86f79369932f0d07c1db3a77103e79e597f8be9238381d4db1a300a8df3bb399f0f0af0e6568a5e26fd17b55563e01cbfd318e76385cac68322c0805f20adabbc3e9a3cffcb80b7166b28c3f992c14ddd494c6d657f1d7517e98a8443f057173d6942926725f609438ae1d228b22a397461cad352a6199463bc06e29c3aade786e7f446ca079566284b75c1b31b45cd428ce43c4917f96a09a9e399cf15143c2f4f66710285a4d0eae62cba0a4348c2709d46fefbaca5978df0c12068ff1ef76002e47b70e42fd8be6ac0590a9b2fa2e5aa815f147b830bc03f8e6b4b2f7af97246aad5034c33eb4c7e733b352e9df9368c88bc36d605f222a378d7c451f0d2a535cec70dd48e5c2413596a3e6d9e2cba61de86c5a7f999fd8e6b60f9e5056a4e201cb6233abf4041c8de2de4fadc51a77e38b7f8e42b49f63805a418ec0eda8d6c835fb42be5b49cc86d55b26a8dd9eee570979d46cfa67a417a015ef00a5e9e00b7bca3df1fd149a9054e9140866d192a5c1763e1e4dc9fcb0dd3e44f71a6730c5457bed69dd3e8806bfe1f9de41bdeea3592d24458e398af8f62cd559bf79ce8b0ac351388fbf6deccc9bbcab218b78dddb85af1adf48cf3b09ed5eefbf4ea5f715ba8945717d1a985b4f3722e300ddb5774d32061cb0dcf25570b0096d122185364ccd55def0a8d6e39b1e9975b74438aab4f329cd9259b4c486e790d65b8db550321b0c936dd456615b64d2b9441bb78906ad5832d946e56977c9308a0e4bef0d7264d34ba78cf7467b29a2dfa87217f83c3011cdc80912efffe005afa4f5eab1f89d75f54a191fd05558d4e8155e1295538f0ac6959d5071b43cc01dac5091f05eb11fc58b37f7fe4935d09b37377cdec3e68fbcaccdc1fb678b7b58bfc2a458e0d4f7a5cbc11b88ee2348c185831ff511a5c10544158fbc22b794ba4e6652d4e2f8c121acdd7488d5783be25a3f21ca9ab398c168cc2f02c483f90f999c547bc5d0dc3b2abbd1890eec67816de069fe12ad245e75bfe990d8262d502dd36c95bf7757f18463ee128dcf78546d6f206ee061e2047d9dd23accf648d7261cb1e9b77114e53bc7fdb2b9759e631c467eb3438d690156198e5ada055384686a741209c9464a6ac114b87a00e54cba2b72f7ff2287bb0691ed94b1f35293491ac5006e3d527be043bee94baf5e1e0293f2b7061d5a2eb6bccde92b0df60445dee7d2e9d6ac49785c7dda8d8025aba59ad1958038282600140cc0b798584f268ff847388a1a37a8e49e908c6df83aaf5f4afe3c46637c855c6a22c0cb75723d1067b9e9b00464aeca9616c64aa9f57862eb5c378a36a4e0654c86c3666cd8ae158e58327e7ef5642a707079df6e3df78efc1ea5498eb11b404d2ce80c34fff2da6c9cc42543c5b80908ceee6c551e4fcd6bab40d6be8083c8a2b78a8ed7406eb3db2b33d95de16ea298851c5c5581bc9bf3db1d03fc76b03e5912cb3592c561e5f895da0b77acc65fedbe7310cddb264835ea003daeceff718e676cb3f26e7e4f4a670c174d4d6668cdc198d3c83fb837a8651dbb2f079808a557bd7664ec4d5757f3d48b21902d97bb6487bcbc3023ea0bebac21850328c25a13a6891f49f3d80b21c659728859a47f0af4c13c898f619ba237affabcd75360223733631b27df649d8e1584a274ef2e7d7a3096904b2a45605bdb894aa55b709cc75e9703363262930289a094ef194aeb2155e6825028e6de1c52ad62f8e4d1b2b620f9bc31e77bcd1df73f0426a55d744a9359624a5874070940e5d67d20b2e3207495fa7a18185e93d0786430239e7f2fa42f96cd43410787596f62d808b113e114181d825443df305a359fd8cf84b5508de951ac490ea254717f3314f171b6077d1b0793ae2c42d733d35610f372902c947d76ef8592fbf4f87c27973ede34f2c335c6af12033f6c75ca8e4fa7cd2dd107b2a95ba7d4c3a9bccd59334f0005de80a6adca00a83ec512bb8f78f65d148f04d02b103ac1d8ec5cb05eeee273032fd7c79559a42d53808c00b6f3e206ac3979a11eee31d74ac03cf63dd0017ec3353c9ec56cf2e1363c85af2bd81f92e4bb37068b81291c08fbc5c319e5297e496141eba382f50caba7ba51df8bfa9cf0725f2c58eb758f598635c7fa0ade6adb09ce8a8cecb97a6e36d398319f176d1026f3a6a9b2d5e8aef8a37319043bd3394ed1978deb94f0a68076a498ee9bbee27cca10d352c66789b929ad3f5e846a5b2f54fd5d59251407ae8a7daccd525ce06eeff771c5622d088ef2ce8c632230cc51f4fcd5994ceca954e89c1478aad01cae3d3ffb854978346fd8f1a951812309be9e1398bf107f7830136c5bbb17d0f9011fb2eb36c4f8230ff5a1c00f7a5ab48ad01dae05df83583284a7e6a45f5c5dd770afc137143b8b408af025dbec40eafb41211879886819a503f1a752addef06b00e7b01dc9f33422b08e99e5c7bb882a886509e7417189cc6d666e69acb4ad0128d7daf920b2366da7d2bf04a9213e131c39afdad611413a32e160635c75f909a30dfd7098cb3e0cba569e7d601259983b67bd56751b448ad9c4f981f2f05722b537aceaa6f6010c7458d3814da8291b01b6395e5a14b669f05b984fcee843ad0227a6e707d79b1c1c1af109761892acca565f305dcdbfce7647488c67768da89fbea97db24461353f4d679df347321386a52dfff172a23ba2ad548199838ac8c1e3def0f4db0fd0997e280335a7280161b985582c8f68f5f7c9f3dc513e5a3272928562bf11af2a90e0bd57a997a1920be6f6b20b7cde1874783321c1cf0f48e5a36b68fe5efa689b46485db32528e0389904995dc3dc7e4e3ceed6b890efe7015b6fd4bbd69d215c62a453c2fd18f3c0daff477d29669c46c7d45d0dde0aeab433f3317ba5be6b7b99b1778974a95f623832a58bcfc0b3d8b9bf869fb03e17668c167254c17b269a31954c2d2f3fa490e03463aef78ec5971d5d3252b161a94cc67be7c571e1a62b480c50710d45e64f9407fbf9c3323b260f820f937e7193799c4bc089df73bba236a2e49a6d2c5537054f96a2e061f93a105e623e96a670bc138c5eb18e73604d069c56ffd645b7644f80fbed9308814f75fb7a98e2fd7be987862a927824c8ee13f8170c5812c0e7c4a9ad28da21183146ab0b72da99ba9943dac2efc7f70962132adadf852135cb2f21ae5d7054b421c7235298dac02610b8f4fc8bc30cbcf869a560001c00ffe47b54bd10cde66cc90f79d24bd1c1fa4f3aa1bd6c98e22b52b0899791e913e5b1bae58718b4d040c7eb8fe94e2b7ec655c912b531e62237062634e9171f2c28e08418ef534fe3af40da79abddc80f25edd34ef53f0c0a9232dbcdddfde68e3622a958d01ae0f7b2b38615bed9e356cf7c7cff3905a8b01fd846d5a4560a58d9f55b407f8cbaa9a035e1acfef01635f2b1460c2af6791eea2162147121b0f34f02e1a427993bee9e7c674a8ad18a2532061ea7659349a892473d8309a89c8aabe2a714163e093e0a4e02b938d405fd80290e2ccc4e2c4e444307b0d973202b6f7baa66485fef95c60734fa94c1b1002aa3313470573aa538729634952698f0f0778c7c0d24e1988ff13f90bc06c5141ab2c865c513070e03957a011bef375a875d69a154aeada3e8da8f2533c3da06761aa39d543cdb05ba21d8ff344a664b097e5d51bbeb20ea5de3f42491d50972c48753002dbd175690bb67363bd2a4190175d6aaf3c98718c1189cef9a5937d099f9455e8f35003a6858ab5b1d2b8622bc265a987203a9583ce7610668c7df29dba16b2767059973ae5b830e09ae88f785abb9fae61fa8ed203c7bb1da412fd1a0a2b890f964e5dc42bb914a7e286afe3bfe2bab64306c122d254073a3d8a504f4f00409617240da6c68f4b60211c9f77bdb9666c54d841f5681892ba5cd38c0d85e7fd6cfbc74f6838f56fc8ca38143419a190b6305173bd0f1d0cea3ea195f5ba7472bbe90bb69b6a29b5c552d69a2f08cf43ff13ca64043318270be7a8fb31d6b8f7fb2d2671b61f18a52d95120499f45ae5f3d5a3b72e6bb4efb7eb8ca21c3c48a8082aead59d2b09b8de679baebf26a698391484fbe0c29b4e0086cfcc21f1c5f6181888c72c34eff0bb4ff2cb3d0cd1cb865de2880574a322429a8f02ce3ffcc5ed2ad032b6243b68eaa39308870e7946fe31946ad49d70b1d0163cf0d94ccbecb7d42012d9ac68a37a30b04c432227c435e9adfed1e7035acd282004713c1748f5448d2b68797c75a12db4866afabe0c56bae52e022deef71329b97a08877f569e1c564f79f4e692817bd6910abc373f03e84c3daa1656afd40542f99796d75bc61e81ef35286d559046510cfacfc4d8098f7e74645096e492ca5491ad23d0580c8bc209cd9e20a07e8fe7978f18944be0fafba7ebf8b88e3744ad7eda116a21b56304fb54ca9747f5312306837988ba66acc91d45a27ad6f01a91e5ba5ad129bfdd5e903871d14ac51c383d703506f0621f4e0760ca473120af124459517b71fd8e04b1fd1963ade61c8fbc8467984ef2326438db0e4c0368f495486e31cb13e035f6e4986724ff78ab669e2a5b4d8397e92340771bd4ca3f02010814b88a26f6131663b594359672a4f1af65afd0b427232290654d0966346f5eb00abfac2d436b2de52d612d83a9ea1d345410a5420dffbe6e6b4c2f448ed302f5fb49ef95abafce094a0b89864d909f17f7f5718147dcd6fdef8185f04e5df3a38ffb470ec8b34371c17359a4a90e955457bb138b0f329a806e07771d12340323993af86f20d89191ab23b31fc69d0fa6c0aa90b2174a13a07a0bd531262b888b20679e8f0622503fa07e2fc28690ad9f09d806ab1fd7f5a6f9f746107ce690a26725f8e85faebb5a0c882d0e2021548c7413b46b6607a4ac598ad18c1d515c65540591aa5424330e143f4ffc8ad7010bf30d636e2abb5f97241702dbd4d1fe51c9ada25150e8d5cab0724e63881a023c4ad6c68c0a9ee6ba94682cecc7849f0b7bdfd5adf9ae90a89ab507262f589506539f75ff1a3d7475cdaf9a91a441c37ef151281c8cec0a5d008425ae974a23e72f26b4591aed2cd5aa6263040864299a5f767d90ed96acbfc24d60e89073ea82367de74c3c7724e38a66f3e87d5860c49704cc1480332bd31b224eb6563ea51ae3ede7d7a6940d607a2b70a31987e3c959428d6a918c0786a6fb40b323792672741400faef9164916cb030e474074ee4d0545f04720f52c11489cede64319e5a5e06871bbdb93ebe9d9ed35fd9be72931d6526d25214e8269a14d319a5a17d07092905592677bc3d4ac52fc002ff6029a7b1ee4db26064b066bc4dfa9d85993251da8e6162ee00bec355c7010bae3d717bff75ce54b60cbd2ddf6dc5daed495d934c7f3beb71bcd23c73d22107fbaadfc4b79645f09eda41d726bff11da7e0005eb7975ce4a2e41728b8a6443fcca7335101489d4007e7f4a0f8c36adbaaef3d1781530ab048d28ae72adf99c5dce98396624da57a57af6018b978e5fc0684e8ca135b08c593c5ea031245bdf077356476078f13f6a12364e578ec6feece50e9fb4c3e938f09765f62f07f1d55add29d6a46d1c525c1b0e5120bab4a362db89e36deb9b366a819835fcaf3694e7afbeed531596115a2f066392c07c440c07463e78ab1c93b56564ab84381fe85cdf8137ac6a4079061c3ed9caad80f6105f8792260e175bde1f855bc0ff128f7fc14c13e3294a00e830c880e67b0b9d7c10c6ed1a9812e01aa00a513f6689ee7f393a3d2ed70c5afef1618c433c12b2e59a7710ffa367aed48aca54ec4e3f8d4f079cd619c9ac76f26e2938e369a5b98d16af9d3656244c7c2a9631cf3b3a48b97e5b9c8cf1015db5a89f632a901d6197034fbd9d2a864c216e9573d06fac7b3e536bde75c5e34fc604f73ae6950543f1f283c6341e548550315b78e0fad78016c6911d63d03fae156a2e7b674e1113a97ca9ea80a781483c4220ab92dc3f19e699e4cc4b7c254871451a5c5b1f14613dfb5f0ca4f5ae977abd784f2e922c3ec8003c7d30ffb8b7f7f7b2a814c175b2a274af8ced608b822ddb144fb1835a3db81deb7295dc0efae7ce6258d78d4893b666fcadbd689d92052d32b8c3209a49975766e60490fb21c6ac265fedd7f9e3f38156265e1cd69f0ae003e564c77170e6c102a296e3c22e9ca19df6327abba9da87ed12e8e1b9a0159c80321005312cc851e3519412b86ba0603f2aedd5a57aeae8179109accaa4f5a1d46c2e134f22794a609d66c2f34cdb53c924a71965c7c1238b9ce03ec45af845a532b51ac875dfc3b90bb64dc03d9a4fe0d67f26fbaeaa6ea245618381baa537b5ba15101f1263b85609a857eeeb3fb2b0079a1134f7719d9469502b3900891d1c2f3dd0dc37dc8239090a5d180a2330bc8b0e712bc005d64c40cf3e740964c43f17168c356af4d50f0477d09b160089d3441ef6bd1fe391bdee5bd822e7659aaeac4c572bbaba5121c8b49ecf3cebb535b8862d1cded899f07e0dc47c4f30e7912a2754bc54e7295e75fbe5004a045adfdc5cdb32bb63bef23991d08626399d43f5224bedc79ca50ebc846b368ac641391045e360047acd3752e7912c6cf8e062d4a72b629c81750b6690222b4252ccc4e9010219dafa38c61d8f546229d6faa8c31906c3dc14c3c3ac1ce8aa8aa1b034a72d17515712c331b3a38015d7948a2b8453ef2d506af2cdb59717f4b1d60ade31d62abd9f9ec2be8e1543535f85aba66ffffc0059741be8693a0630f81bfb2533b5560fdb38dac4a97cbe0c19e408a6b3cd9616128aa500c7e84a9b0b91d123a9e88eb9e6ee61f32f947b66a074085bd747a2d03481fd04b688d3ff981ef49a0e2915d4b19fd91d669f54818902874022c7b64a984df01c8e378a921f1e3f5d39acf4363a7c39ab7419f29ef62bf7137a9895b6482124276f1f4f051e4936e6097f7adae62fa05b5affc0d1ef1f3591a930020829890a76bf84320181b7b1f7ea35af153768bc0c58f8d49ab1442f21191a054e949a38a2777c7745124830e186ac19592f39effde92c2de9349f2702979a824f1ea9a5a9d41191e8beff7d587d239d8a52637f2d1b0c711ca8b47927329b5db2601dc699c6f898c90d5e72c8c8c9c03c8ddbfac3439b78cbea810868a01ceb3626fd7d1e167098ab88fba571bda9efd3e70650e0ee2498009c0a0846328e016305bbb384b85624e6284fe137fa239f7125465d647a443edf86ab853ca75b2835103d5c57d7035ea5a5a6f2acec99ea2a79c1d52583cf555c186268714db31734b46863187e57f7e382d5bb93214f76f16828430628e3e7f0172fd5c81bd9524d2366f292e11b3d5ef841534ddca8cb8e6229d4467a5b2f2098aa6f6edd16cee7d097ffa83b776650033f1c2f86ea374fc46a285c4d072ab0518c5103dcf8d08d6e19039765e174b4661b2b00f0bf567e0b040cb541d0fc07023fd263e6b4d8296b936533d808da95aed4d6beb6fb0b3da56b52660ffd621064e74a729c60497477e35b5a6a6b887e223f0bed2779b01ad5d52ff1775b17d024b44515d07fceb55aa81c77716b8efd3e593ac054f0ced00252713ab9d3424f851fb996fb488145841a3fe01d817feedf4db553b7e0181f8b64bc5248e99c5cbaa1ff6ba071176f91a4b5017e89666f40bd51107d1f64febe2ebfcfb6bd651ae26db00872740ac0e31094e3fe1fdf28c1064ca62a74c38bdf68e65bfa89a25269c3000c3703088aa368c3f41c1bff04d6a987c962ffdd426877c97e92dfd260992d7390ef752a79f3433d340ced55345e9fa387379885b1b7024488206e1e49e08eb7c39a6c91a6cb0e4b9ef09131f7a2116190b17211c0712aedd1fdb3a5a062197250c5383ae786897350aec3ed2556bb75e664b5410dbdb8a7166df773372eb3a2ee073d56c00b24343dc6c8f101acac5133b089097e5393954ba9cdf3889a16fd98510157eca39d076b8ab28864fc220e78f954e13ff53d866eda5dc96d9528accc2fe45703b72a107f4f39b5ac91d88d09f96e63c2b4f606c82091bd9feaa0ac9407547980dc6dd82957058559526651134298b3b10ad41a86084e1406fc5634fd38cb8c4386983eaf6fd5ab024715421b31e1e7b3682aa7d810d167c4cd70c6c596686a4a82705cd77f3ded44530dd1fa76a86dccab90ba68bfbf76db91bb0bd2a0c046acd63ae1afebfa04742ca7920c33947a9aedc028019dda672ab7ba5359be531669b69d72572033a2be67c6bfb6fc3088f667f05da539f5b89f920443d3dcb528dcd655fc562f52541048eeb44a831db18c8838436aa5d79afc43d654eaf1118f696c2a01b815c4747b32a9a76334c88c008b980660202ff1d8001e7085033994781e33fe1d78d553db735ffbe2cb2651e2c2edbf3ad4e9b545166a8ea360a451c26cd594c4e0e5a38bf972909f9e531f33a0bb418509452d94081a38a0b63a32fae44c3ee9bae0e815cf4566de11f8183cc97957ef2fa02bf2bcb28dd0800381c6de550d95e330bfd24939685ed64f4cf833a4f8ce676fa52e0bbcade5f0f91f84320e2a3d9322ea27ac001ee8e88850dc48aeb00f312f38e3e4684c6da4afd08d1f3570935b9a2a230a1ea944a2c0f6395e609105f79d7999e5c2ef301feacf592f138443cb7290f23eebe948c525d748adbf7dbe6d049470f06b272d140ed5e3a7e3f6271f4f39479e8508fcdf76d9355d86e1852c7fb5ef89c0461933731dbf5431dd631010c24482e5620fb1d9d464d013bef8727721bc24dad43e5f9d8627b538756f9574b7dd0fb8e6bbc52b8171e45250a67e194f63972f550a1ce3e3f2a59a218818435de6874c0b5477e60508e0f028831295f3e579a31b4ded6426da0b1aebc6ea27f4aa01d0d647cbca7da822dc6ce0f3ec8be4bfa31742377564a8a7ae1d10322983a559f5aa1988f34663ff5a741e90cb09730fc36f4207c78936d3363f4161376690802875def280edccbff97b721b4d733ee32fe55fbc3285fba086166fb6e0e5538e596b9644769a6149b85c4af5427ec48c4e59d4ee896fb0c2e1c1bcf5b535132f51f3b3af95c50c4546493ef21e18377911e1dc1aed798ed0135c367c03b066bbe23eaf2f39cb6b03d50280920aa8f0fef50a154e5357d7e8067ffbfac7a0a382b01cb333e73b33a554a78bdb053dc5217b5bb3bfb8febe7a4dcb165ef78d490294a4093e26b1bf3dfef1876f5be975168fc28354fe9045dbef073c7630ca00b8124b79e40d6d42d8cfa742afebd8b4d51573d0f0f4134ba21ffea2d4fe5be64f8c3f491c871ba9cf2c811d05b3713595ecc26694d3e38be01957b3a5407510f5f3f6cddc4b96906c52f54aa8a02df0e2926cc027eecd1671cb81d2a94c4d8330d542f54fcc82151dfb8bc2fdcbf6c26e16ee997e6e3acf1a62ff54148bca2569d1e5b64fbf7452e63607998f943f15611947f8e41ab89a2dcc7885467fb6622981c3d4444f35f0b19be6457a954b85311ed72d7d33282f8be58b553748b44fff00c9022a5afe29e83c620336fe08d0b1772b4e4aa702d43c6e2eb9b30c78e951002221249b4c4ccae1ce6ee29ff70bacb9f5ca1cce62dc4683354854ff65df9aae42f49e8e36f554fcba2860e8566551ad6374e5897758fbd5aca30b37f1f09de4644a40a72a27776551bd7f68a3dc87344fc948d3a1928bb71b3cba6f4966d156d2457e8343d78fcd8a5f46974f87959d197718b7342d90c415d89580849ff8b875de8c61a773c251de1f566492ddba79db9c588412a44a4caa122cd6bd5058b2ab728d9a45297b81559fa1e72b337d6a478fc25a1f28ad1f3a1dae1497ec0007112599e94f436029760d2f2e8cef443b9dca1694c713260f6dff8754c04452280509a10ca4d3f401a1e99b5098ebc0688565956d0062a219811f3d4e7f7e4b4bc3dbb18586b26e8f164b826a0e57dbca4217c644317597580bf0fee5772c8c8d62ec7c263fd477511687882de872badddc4f4a92b8718fddd07ed8066fd235b2f10e11f7815c5441e2068c3415af2bdf13d80f981a4e2f82a08e61d7cf13218f1a83ff2065a872f5201d4d7b38942f904d8df35f8c185bc7c487170db45f50fc55b41d061a5e47c03e625c7abe963a57662df64c15c5676b0569054e2f97b32201449c93c7d00dc62e29fc33cc2d508eda16d94b8209128c812da981031a97ad4fae960ab617b004a623c5d0fbc4e1565ba3f3bc03221b6e7088e1a5df18bc1dbd31639c376cb817a99a77b5638a9808349851e38293f1ed8b13f3fb01094be95d7dbbcc39a26eed8bdefec82ecf7e3abd9b7fb6b1428df091714d87b10d6442a286ca4d776305a2554ce3457460ca7eec7001c21c231b6a3a52bc8ad5bd7700d87e189f7eb429cb9fefaae00e86435b91dcd1756514c83d14a60531cac2046170c23a3b46c2d7401b5880b027468a362884964e39698ac927aa1942b3f774b446ca82c5c3359a5bc825d72a5a9c3b103ac73c0a8d18c6b54d81027c355bd2c32d61f37f649e95af062cbc3604f0ebc963307c0e46c1efd9c4eba6b950eed591060d4958e9d8aab6d50d280c383dba205ba7efae45d9bd835c389731605cf6716efbb997d3403de41cec872ae4abebd828a32d3b77aed42bc7e669cb3b982efd62d6a79fdd057d962303e400acc855b612640c3155ee2be9e76edcc7397d27aa02cc3acfaa748963fdf64c6e116861a15d22e716a53c0831ccfc1f13b6fd9e80e162bb72ded1c14a0a519af99485ddb94c2167cec51fd49acf4fc40447603ed74a7da6cf7633382037e96492756e11d87cc8b7b5320246a422155a2fb74833f7c733724a318ec4688608c510056d8de3d9c7704a29a20bcb184914eac4730dd107757d3c11f946deb94a23666fe35aa6ac4291f0a4a16195df38980975691545cd6e63cf81732490abce796a436e8ca148169ce4ae0f625170fb24a679a0c78dc242de13e39db0bb86e3432f2a536aae2f76a6a1152aaf0b7cfbc9aaa8890cdc38ad249db383b55379ef71ad685141c3cc0ef68ebc4a7cb05ae840e149d70ee1f342b3798f5888fcb2b42f2e21ef3dfde60e0f282973bf4d7065af0b87b56054e5cc5f30c2560938ebceb9fc23b4109e2cc38578f2d4b257537cf3449054678cae531e232b11a5b09755e0f2f5e16dc0ed742ef37c92946b3908b55087608371c0c4e919ccd95e001885ba9d6507552425a34f9bbfa1679ab1eb15bf05e73faeed72d977924891ecb4e92a20fa977e477ac48c6963b72806cdf47bdac682b65bb7dd51f08d15ae783688e1aab652a4dad7fc690d0386605d3b08ec706187031f868f93935708c8844c00907610dc6fc8d4c5e3372f0759f82abda6279af5528b9918beb28524ab2bcd3502564c18a35beda0e325ba409f147be59cd37248c379e87e2ae69c7be402cca6736ccc4de7af4915f84623e2bcb7d4fadfa188083137cbeb360834d415c3dc671eac644308c1eefd8323ac6c34455080e532da559d445571e8fa1c48c6bd3e3266d12fd8c1d715fcc94d1a226cd34b87b4ae2781a59ea875c7cde682db1e769cf9dedf85ebb3100130e944214e0002a7fffce7b3e3de61ec2080e7100b44f5b1dcc898049159061725895592d27bc9fa89aa95fa2de6661aa441dbe14743333800022b9a1323a5d2ea120b7225f77ed99b557be8897b4e2465b94198e934a332c6f176ededcbad057a6fcad741122f21fd1dc79539f0cfce387fa9ef16148009edca6330a4ef94d7fb8c8f2cea6dfc9987dfa5ec5dbee2a4c65e5f8b23a5292cb3ff9b142b9ee887cb40a99374554f09f35f26521e863a86814841ee0f3be08c3e8cdab35fa0eb021b24fea3cfd560dc1b0ff60892a98ba4de9fd09c9562e5b1f5185bd239e09da3297d4d7e18e680d9c42fbf7bfebb2d0634fde74c62b534a375fec1d7dd4529804f69e24979053b86d69306ca7bcca0840a02fb0dbabdd675cb3621db6d465ed816c181b67af4d4fe403b8b77f98aaa221eb70396a8bb091a034318407a084f913e8aaef4ddf6a746936c5553e4ae7787cc7b9a2423bf63301b921900729adeeec838dfbc17d68e04a86737f8497470d8d21fffe4628802b1bf0226c621395138f8e5e1986b3701863c45923bbc3ebfa7739046a782f8341b42b5b8728a6df7f75026430d3233f7a093067c8c09d80d4ae466c1de8f04e84ed71e55c81f5e555262a9797951b103a98da45e76902d7fe384847e5d2b0ac7509e0474d52bde55e66584a5908e0212446af790d88ac322b3a9c6c0c3f83e6f30dc937cdeb338593f2407219b63d26087adcd3a0547afbbecdffe7ffe8fbdb04de68677f52d5d6c032e966252432dee969d2bbdb86952f6ba5afab885102c7f6978584c46a90dc3d6fa6d0ba4db3038c83aa1a4a343eb05c07bb5c39e834d4c4f53e1b75366c453ea33c89c4640c0a81659d3908b552e0f6b7e308334346758f8e65a3dca5db9080fbe4a4523ad11754d1c63146acaba836726335c28f59653824ef689df1cd58a4ffca67a56244e162c05373c2aa74fa9dbc1645a5c6cba67efffc987681f2bbe0e97f02370d5c0318c8ab54afc7e60452a666729895de460f75cbd893150fbb392e5d9ee1f310211cd17980c9c33cf10e36b4af4b418f38e685accdd7b3cc1a343797a9e35ba80c38935ba0cd03ec7eb17c1ef1044200e80b57b65e814c15ea7d9e39d4f6ced9258a5ed918bf7339b6f82e40eabdbbbc4029cc0bc9ed70f65b9952d1d5c38c2292d3b4e27e6ae500e92c6c942a0f35e1d59cd4ff629b0dbf9078a91217d61864bf3489a8d2e87a2c972311e21243e1f872db61062016c65f682b8b0ed3ab9bf5d512bb142f9aa8721a321a64b54865a0f4944316528018094d4b581701f329c0e071dd8408fbac7d3e5d2842d54052a5a02b225168bdcce274f6c99502ebc4054e4911df9abc76502653e44f28f9ade8e4ff29df73c114ecc75ca5a8b3adb7cff96b0666ec7b54dd88136dd1a99f5cd4f05b868654986e2e0ac60401e5a7bc682d9bf76b7fed6d9690742b254f2eeeb799a7986a60a912b3b73877f99c6fde9c8ed2300c9b70fdacfc0da866652166bfffa6aee1c18c99bb889941b44d167aa40033d844bda1f02ef721759465a17ac5e1ca126135c5ca76a27ee32d920220184c69a3300a128e582847dd8a56375a53371b47ac6afe6356417efe1d78bcde222317c4e4a1cf9e4d1a6d91e1784a377229e1574d1f1fb360085d60e041a13e680db148d8d85442078171755b8039039e518dcdcec7eed27b2fedd59bebabadd694a40752ed4f57685f2389c3cf729db0e9a3593d344bb88fff9d7377e20470c7c7cd37e215a691309cb9450d7ce7cea56e7d6abb0110e62bd7d7e33b8337237516aba1cb234025c202cc0f10b01fd6211ffcb73db47e6764f138a21bda7058b0e7d59f05f347e57e198cabc11f793d6ca9ee84dc082b07a07745722deed9b10bba37a5fa5ae6af8356013aab574c94d67cb84f0b4bb86c6e1b42eb7b9d6fd17e8a9700ed8a4f27277fc4e02ae7654a3e05a3753163a15ab97e8afce0f3c9aa93675b4a37a00aedb7ca49f3b5eadd8069308fb0f71cfc9936fd2fb7a9b4a19d66f3cf4859a4a549d8ec6b6cda03927b94434343514980a0c76265d9fd777496e9a353c4c8d950fc2de7e27f2dc111a2cd057d8a9809452fed971961fb57e9c9eec5d4f04c1bea591d78a506bc7fc9306968843c03a5553eae433b0886dd0fa8c4544d8ec576a7cbcdb4f20592f8d029488c46e69d0663109516b942b6d357f80620c3e5bbe09d2de833b1980e2faf48ed561e711807aca09b3ed8bf55d2bc7f31e11208c625e17cb8574e4dd769bdf16074e3d67c91e1f806feac72f76a24765b70ef1219c5a6e979940b0ad70ee921fb4858f87435cacc1a2ecd164f15a5765e014c4820a8cfef42bf55d264768f4ab581a7ff425b7a800720007eacdea7a08e29e4de6afe0c6de1bc0756fc49928ff51f472b89395f56c79c588c871455f5c8a1cf3f217c0dd0b727297a12dd7b843e58d03f30a004cc8a3cb192215ada009cd5bca71db36cc204f018cafb3c216ce776c2a8a4c4c71122cdc4641f791a3d7e881058e7ee8f948d3696c0791eb0ff7cfb05dc3868945017e398d2d1dd88e8b5ee22c741b28f39be39fb9b7bc7c44d72300baeed49d4191b649649bab71664e28b4657691edc3ff0f0823c0d4a82e13dceabae99833d9d527fdd05ef979bbb8f3e523daa1758dc44c1a937090bd110301097146a522309227b5d530b21c077b5d664f537590abb2e0fef14369432eedc69daa5ca4b78953615573f1780ef249be7fea1d5956bb8eaba74d135e9457930819a7832086360338521a86c99b11a155b5f8bcab0f74a370ee9073d77494c5fa9c1cda82e6090e3bd313d7bd8527c435b26aad9eba92c5a235251b35f182af10e8d319647f2c375e2df5db1e4228910dbe2a48ec2c4b73b12efc9d44ddf1bb58dc6d384def7feb5d1eae67df6a57500a4e1fba437ee70b7771924f005c50d21d897597625c3b91b62357502d770b0ce82441bb513e586a0400cc3d9e9ac0283a8cdb7088fcca38c7945dddd1875fdb815b7e752bce92c6692a9dea688079edba264dad9d174b1f9a984aa4e05e79bfb7668f1e1b4793a87fd5f5573ea62159d4f6c62e158fbd60bdcbfd6f09c10a9ed22ddc30b3ba5ddb676dd69e9b94216dc20d1d899f8fc5051504ac61ec54f14349a5e464665a5d7ccc740abaf5ef06e40d815292274173c64698e6a8788e7ce2b46641813daff1986b89bba58a26eea3ed0c743818e889055ef83ac87e36902e6f73b4613766d76889723bea10e47b0b56554fa576a7e7d05667dd6c39e7709f313cea4c615f3b5c4b110a36379c9fb27db4d57298c3f288f741bc17d9f5012c3bd7ef90ad888b1a515e722ea2ad870c6608fd4286ab9aadcd64810b20a9df8664b9be8411bb25d29fecc7c4e4bd5b1c6339b71c23a1ad5ccd610c88b78e87f764e1bf02db512eb0f2617cefda52f3560d6f32819b0e110524a5e790ca21ab76ef1c0a63a64cbb4897dfe8e3404d16723194e81b4b5b785d3a1d668961fc2641e559646d1405f48ae60a7702e9e03b350161064dd9c48b88c261d07d74844c7ba55c6e75f4ca54399fc1dcad4e4ad07b7bedfb83860a9eece48920d70de57f9f615c5faa02660900dd8b4a7d0ae3d96c3b0ff2c57b3d5ce445e6c9e9b87ef5b4923d97a16eeeb9a479ff7b1873a92837e5dd7629c39a32ce631072e2b167903e542bbc6e2ebc1b7eb57ff552f5de8a025545e74bd01545f7deb627e7bb22d1aff94eadd58ccfe76d3aa549cccae93b3abe9cf4ecdbd945b25a4f547ee693618867b96aac675a999b2d7db32dbb41200c8b11f9519b88a518dd3dfa155736f0267abb902d59b6ec422ae715db1634a5a48a49a6228c39c3a21d61631c07931f2b462ea6433335814dbbd8fab5bb1003f419ae5ac147dfc8ff34bff6e1bba8dba5e3a0edccf4e2e2bd307fbc854e97ff0de8d02a718e626ceb310b31728c23fde116d565ab2c60e045ee8594a53870516bafcf33431aa493f8f2f4ac44b0a76a4fb511d27da274288c0ec256a0ca60f060202dde87f37caa7ea94daecdb41715b36f2fb5dd0aa8d552b617198abdc2fd60f0c91819402f4045557006a6c78a592726edc304d993ce9c301a36888edd4ef770b48ef8a977466f2c9f5704aac379fb853ac5e6de1feb496ce75c649509004e2352f3f2c4dfb611c2adda9b71488c703c9fe1ad4e85656ded2721b8dd644e969f92020254406644af52d0574d3eb34b2f4c50e8fc16d2183a82f83da96aaed3e051655f63be5b042c75a848fe03154273c40b61d11a60ee5fe89413a372202c4e7f1fa221924b3b0ca7bf7b91c1ce87cc5760943e4285094d9e75c802f3a266db916fca618a585152c692a49ff20fded33f46228b474a332789eb7989bd565556018116c4bd83c07af50f065783cdb22d5db9a49229b12ac610d505eb62fa272a865d98f0965a10fc272bd09fed340973c64ef150af8d64afa568a0e924894875cc60baea264a3b2d1f52272effc7f9338bead838fbfde3f861e007f0b7b70c181d8f1c8753f85ba597c40378ddfe941c8340b6566dff914b93f0fe9d52463c3b3e2648ab8ed06c516122fc148a2e157588a1641a33559caee7247f36bd36903a3118c52297ff04aea3c8bf5287e8eb49aee2612f49bdbb05f0d754d343cd1acf936c9dda8130ed8f5ee27f3dae851a9304d05876b8a4f9caca142990c492a4bf67c084efd296038f53c13eff380107cc15220d537fff104deea8c8117cc9f43a901974dcb91d78e7474e4ee047c7451217135b7a632acaa38c11135d03d916ea487dc90045b182b7fc1e92b3a7a5529d0300c3ec73b6ec8e503ec02c77f1eb4187312a860b51230bd638cada321c009e62e5dfe4f012175089223ea01cbb19ba15507ac656758e347a4fd0806652b7d2e8fcc0718a9c277f0b5046d320d199f3ac384e66a5d703e99a6a60422fc438396dfd2144a57aaa5903497ffcbcea17c233c74f9132b7de0f833a085497844bf0a5b16bca6cec3694de33aa14d5e0cf6edfe23e066983747b14b11c1a17cdc2b23ba38873314f73e89f46d4777929f1441dde0a977ae83a6ea96d3c7f4aa7b73ce946fa8e1435f5e0ec795f3d297b2edb86714e27627b174b7185cf2692084badc389cff304343fe04799bed7d9168a3f621164c79523ec79760c3afab320c38ea8c4883a7e4a40797f3078b86984b497ecdd1f4a14e301b61c21ce411876675845fe9f4916b8ab265e5e33b2ab7bd661b9a2f40d7794bb997b534039b3f3233b62f1ceff5933cc78051a0628f0c6f68153eeea0f448d77363b6bb62f20cfff64fc2f30dded361423059a4bc74818ab294d78347c7722676b6f00f4ce765ca09529d52cc125b05038a1c1ec70f2b74fc8e77920fc15d93cdfa928fee8f0867e75fb6b7bb85101fd95e64801e972ea72d50d84b26346b3f9c4f20f8af8668e43e58ae53e440956966f8a500c464c870c640709fb118b88fb0ad9a7c5e65cd982f8d997ef7dfffae0061467d626fb5c7595fcbabe3ddba27829314a618ab7f1c00a161cccdc31769aa0d0a4aef6c1fcb9a393e07d2b56a1b2340cb1baf42d982e55925d0a2e1842137be80b74014f315a5fd81e6dc46475c09ef0f72e970d7be66ba1955715910784cc9df1e7616cb7b4194a2fe5ccf25e354a015c32c3d25d9ab6ebb2c103e1e92699e18f1e9a0b7e991cf5ef034886863a0d442d89e3ac708fd1f55eb4abe05f6d40b0c84af48d054ccb640d1e823e27e2d1881c4f14db382d27b059e35617fb601f2309ec5a1967e5131c4b675290a7030d3f96b6a269bf1b3cf84774dc2a67f1bcdf5892631dddc59b0f97b2393db13fbfe9918eb264e54424f36a57d39d9b2017ab2ac379a30a56578d2b5f65ee434253802d94c4b277735c41932213e126bcbd3d7debf1448eb8323821355f1b1f8c1e786a0ced3cb97690158de528fd65700c143fa6c14c7bc1d46893e8e82302c927b9cf010d2cf36088748e470d5ae868ebe68b0a5b755cd6ac7f0371a59d7baf454cea02994d0a2974f3edbac0f3ba722a697c8de2c0cf3dc25627df1e9bd5f6f8e4c0947f2b5a70e839eb5ec8da87de73bc84836136f5d7e0e06cf944f6cff01a1f42ec9088f737cc4d5526008b9eeb03a13b88bb09007b4646f6542bee59e20f62f4d04db84ef5e9a2fa611ac9bd9a532612be247c113856a435636a64d6369c961872205e522920d6d076dc87cb390616b05f2ec3b74bc163087e2e86c37dec82431b5b7d8632c507380a67a5e01a481b0d58174da641fe6526f4d07e5be021f5880de440dd6ccb9b158dd1bf91c09bba9124d321711b02da81f21d3e71c3eb3e91df543440935dfb5081fcd1068d159321e526456877f41a8f5d07c15f8775d4ed552a59213b0ac14caeec76bdcf954ed695ceaf536c60216e373508c2e4e08309c5a415d174eea3e22574f81f59b9889428840b22b7d0829312516b48a33785b0250baa5bb97906620a71904fc3dc5ead37050d4059f0fa260f0a7c945cb2b730770b2d01b67dda531226f6eabf4a8d47e83b16facb4a26b2eb2a433bea6035dacff49e142f374612cc818edb07b52a80cfe15f142cf4bd02ec017472cae2329d3cbdec43171c9eb94710f76c7872b6ba06239746f77756c7e331090cb740451898dfe7ee4f251307b9d08e675d19c436c795732ecd5e4f2a9688bce39127497eda7dd22338fe27c5caeb4312cd3487ef48e784477ac5be8f0473b67d77414455a7710dc240d8300649745e2d33180b2817461e49cf01e2c4b082d045cc03d8c813d80b7b5e9295ce93630f00f940b55ddf7a7748bed244291d79d0856a115f458aaaf8de08523d86d9b35d17781df695fa336d089230652c2b8e22b9b9518cb3bc97201471a229bd41b7fc9e88ffa2d8154687aeb8b0c6468fcb991a22116719f9e28edfa5589cfeba21cd7ff35af480e2655c5455cb086a4547d4bc7a349ee15118b885781334ecf5956ce10ecf8723b4802fe8ceacba9063f1de4b550d1069b8c5ca104ddbbb876f9359857db863e7788af6104136510dcf313074db614246203cb2c24ccd40102c10083b4fc19820b0b3a320041dce9d3a3c66ee687b95df9b6da3e6141a496f4243cfca9009f21b82e9b635c07125450638abda1653c09a832e1e587209a0f494acc8319a1e714811d07a559cc07990f7b3a8ca4efc200b9bac28c58370c996a3e7553119a290e472e17567192580710633c04fd23a8a01bfa44b99ea7d345a2b652753929acf41b225cea1e728dc4c457894e4cbd2af8ccaa34741301dd0c70c859d2c2e47a1c3bf7ec1fc01db9efb1be4dbc2ac11dc37c0fa8ee406434aba847c6379cdd885d29c30991579d36501ded38b7e56e3e33fdbb28a148faf90f421758f1b10026023567da2895e6033b3ed595b0613c51ba065fab01b15b947e69b37da3c4c41737ff20e52d2a1527d348f4cb1bbab18eebb18a2dcb8e8350a9bc71454cabb24d5d378d312d3d4bede83120d9fe80405c760778b67584f3878b0f6a1dd9428da80e01106524d515ac808822e045cb0fc81c8fe95556170082da2981ec10208ad316a16c5c91cde8c9239a3ff3e787767f5b9eef3d4909e350a3e5750786ae63c593b1491e32ea20a68bad0ebc26aedfa587fc63e59ef6c44fac8c65ede8423863fce739db9ea06d7a587049112603d861c9ba715f6a0cd4e8b9106399823c791a6402de66eba8f9707aa32044edb3cc9b48e5b3fd17c401231af0c1b0d074e5ef4f4dc8fd10b41f919ff699480d738038a39d226738cb185fd4678e494b83ff2a6cc8825de2ff8dff2e3853c34db6b7cf4fbf07d444310932c2ee55a4f90dc9d58dbce334c5bd876cc498f70357d93e926ac0ecf243b655ac4d8c103d5bfb937a85836c6bfee46fa06f59e6fcbc060ec8f3b7a1ff8b1b1e7dc3c49dc10f981d48401badc8c40781d2503a791544dc0206b5b3c4110ddf977b27d09f953d222c352eea23cd93077184f67393598d147094cbb412b2556af6934f2721bcf1d6e7ccd7b57e4c1ffc0a7ac387950b3bcb184e30cade38393876151e34a13fb034387ef6714b51d03e5c509552f5b0e6214a48f7a11fd372394eb14de9e08225a1066eb6b05ab768c73f43e79d51852709434ce2e449761180a4d14d83e4785f18b94deda3f3fa71c4236130631236ef017b5891c8d301750cf002b4f4a8fe1a963b510d2b01831320ef5cb4d9cdf6c28e71d8abb5c99c823a36c696812de9c6b98f2ba72c38ba97f82f8e09e4185e5aec60ec4ab05998c562cd72e726e4c9f64037dd48051f205f232bd5500c306e60b01893b6c7aff07fd735bf8acd419655e07b9d2f6c9d128d8e8daa08455f4d7822d0a4e97d453906dcbaa54e9425665270e16c4f6979fae3c1ace9bbac46e9dc43a382b206f56c2ada5ae6616b0c50e11005fcc780ae2542e77077fc8f12a8f424d500c28d923f935e75d6c5b9a87ab31213b5f0b536e1a47e5b383f1d4525cb1f386656f36fbfece20720a71289b2158b5fd9772a998792dee80248e21ee84039fd7a2c8fe2333194ba29b304cd64e4618964e239d451e3c935a1614a0517fb9045b1a7357513eafbc8b1ac4904027fe8b76a683492d20b9d4c76dcc980963d059eb8637874786ed95c394f777fd0b73f7f6449d7b283dcf5d7fa38c81e87f42cefcfc01cafe58e42a4ce3cce469dc9d3798509e48d3e0171d297d636093bd7de07a65e0551ed198f3f8c00650b1430cc59e0fca52eba5c549659b688dfcaa63e35a860e63597242fa8a362a7ea22e8f1254d3b96fa21b8fd62cdef552a0fa741208fe7fd28a9a81436d2554f8c27e5b97644b9d4aa8df267233bdb9afed23316b6186b33d7bbff781b49c9c9735bb625c9c51e442b7eb1c68e2779c84d33903570ab6b18fe731f65641adcf75be65fe4cc6252e9dc7dcd83043325b9d0f96fe136c33cb05f15e8aabf88570a0d0ea723d162bbae8a56181bcad1cc7f3ab1244ada2134d9525ae782af1e31872d1487acc3ba99c055572e8702ab536476f6c7d20d1410f6c465bf6b1eeaf19074c009cd602378ad687b3d37d01957095718ab864d77f80462320f5eb23f60cb5e86f01cf999c5859dad6047291a9ce335f587de07e4de813b34b82ad8cc6664ae9682f4a9d35767670f99f55824a77b7321c83a3ef5710f51c4bc99fe867af20ba102f27f5a8b19407b3a04489ee74758f4838fdaaabcbe37b0638dd2364c2326fddc700cc5b9117020e381f7d6c42c4c12adfcc1d1712ca8649ac3a5ff8e2c9833b84dfc4de3d468a375c258ab4fb9ab34d2afa6b96989fde0c0f4398193a07c7cbc6e4cd4caa5d8ea4670ad964cc14b0e613176567e1ee8f8cb7a92369820b7bd363ac1ab54976380ced157fb0c6141ca6067eb053b4f5397e557d8d54550bfedeed6ebb013e9462e30730fcc82488d738c31171712754cead21f7185a68313b71e86f5c1f376f707ca8059075550447f86ffbf31fc1eb08b0be886bd64cdc11a1ba3c63a8f1f77148e74c860b43f56f6d1bdcf96a43034bdc0675ea100d847fe11ca6291098861b7781d04a551c0b98b7b6f033674daf9e112f92a89c05fc03db3558f333d141cea3ecb84256c9c247d92fd6a0421ef2b93844d99338aa6a2a99957f8080854001eec40195a042b10d53644ee95a10159a4b2082dc8fadea8b9e28a2453924965d1dc39bd6fe2ee6b1810928fdf3fb64c9ecfa1ec29564f71830ab9acaa0b4956d9a3de51c77a9e9a2dff58f88fbb342be8ce9320dc963e4d476b3fcdcf1b000b9db8f84d9df73408b6402b3335205a40caa4f7c9d3a3cfb7c2d1d0e9e8aee5f4a01bd6fd571289c64fc7c31f51f550f99c57927826cef82ad2809e9ec41c1da06f0a4ff4a65621f0e5d60fa444574f23ee4ca00fe7bc8638417f3203e95db6f88b97e4ef0c127e47ebee5f4e520e37006d6e8661ad4260023761d0a8cab9d74f5a93608d4686a083bc857a960de437e3f1dc0f66c9535d74a75c11992fc37a4bcadae8b38b1227ad6bf2c3edb296f2c56ca0cbbd93df7c13f15ea7cdfc379b18558b776a23bcba84791bd64eb534362f4fe46daab96fdab2ae17698b5b1142fe622353301b2eab9086270fb1821ecbae446f31daf883376435193040adb6fe86d401c2ad2c8440e685d3c1805e68a63a00df5549cb5f8946d73919458014274c0488588b3248c8eb4b2a0a2a4a5b7cbdbed19be8c8db4b342c9590f3d5dd953a0749850846e066f32a370c17cff11cd1cf70939fbcd9cfadf15e1ae2be4579d1e79eaeec2a28675e9c09c86699ddeec13cecc1b3defe4fff4ff3d8f215e10da46f1bc00e93eb1098007745e14d44e87febe74fe123d4fa1cb274e3c988b99f1e3fa51ccc14496ff5462cce530a3299457a594363dc0f5da3c5f8ac4fee60fe9f2998f0d5ff65803fe1d948edabeeb233d533b218d6d17acfdf46a18a7144ff6d95d21221838556f26065b4d4c5dd17ad76dad65e648204338e77a4e40dcdf4ee2b9c63f981f5669a3cc98ba52c6597fa4effe539114c2208b735c1bb11fc1b01ca92a9bda0fbe642c67f2106b52c59855d2bbefbd0a91c4859331cffc7a9ef004a7c7ea021a3388cad92d48b913a8979a930ba6c3b0e5d2a3dbbada14d65aeb6a2a839043a919845d79fe499f05a80c17b89df938eef997092a2ea63877db5a0866b65b2bf668b531a5da700b4634e3c9804322227ce5d3e3974f766656d5c3589f5b768f7bf3b6dcd95d20be50728a3c1a52e35e603f6800be9ecb38dfb0497065eb1b31e340cd6f285675c3dd5d52d14abddb4c7e6d4ef8c5f799d75fbfd9f243c0968042629567e29ae48571e6e8c69a1189d8c09c95eb8a0a066b078a53e4be051c33090750350a059d29f7a44a77bf6494d1cba8552bf3db3b2d384a1b399155d9c313e7766bf03685db5f9d096f1624d2d30dfd815ab8d96cdbe9bd2a962be165adaa46df7a5aa2338a780613c9b6602412e82f819db3c3965c64ba997722a48482d25ffc63c735a24fed1aee34923b38a9f54838542b7ab827dfb1d2ca46bf2d03b2207afd2d2fc704aa0163a29c27ffc8d685e68efa4c044b0b7dab0d0829b1c4cb6f1898c0e7f6d4d3141851fc1488718fe1888439fee227508c0b71ef6aa8dcd9ca27bb22b2b62036d1380d6b2b0b5fb78153537edf1dc8948057678627d1268f224ccf243d0eed5ce04765dfc387eccf49fcab52f7aa11b9fc762cc06760a489d53eff2883e6f0c2fb55e24736e9be70b658f78f620a0ad0ebd8c7a603541c2ea4701fce4b2517b51a031bb3af14b42d48877ca4a146fb469395eec5b8860bb816a05d54e34f1510fe107a59dc2cc14df138a7a2a979914711bb7822b8c43951b6e85fe90107fa9440fe7416329b94eec3bd2bff8810456e61c4b9e98797e91bbeef2b7f43ae7a9fed3bddc5a44610563add95fcb514d3e783b243e93fe86f119b87eb191a421ded14a6f4eec6386697f82102dfad640004a35dd2d7331abe50ca28d20d92869e00f5c54b06b1ad331a18a749dbabbe73031fb0977c51fe7f6857776305d7a2762145910260ddd2faf25e03ef508ccbe12e8637efb6dccbd11098752d0193648cb8efc11e701f0e83ea3c61829f27a82536b4c4d07677cdbd86fcec627ece56988b605c1649e0f6c98c2480de894e1ca7434071f8b8e8ff3a2fcb5a8130809278c6e0eb720663f08712f288d7ea93cc25bb6adfac4357908cb1b3da814ae33357a5a1270b7a80bc419a4148e4cee8fe5bf27f9c520cb6e7268226d0daada6c8cdff5f6c0eeb09e2660db05dd1742175a13549a126f81b1cf88716161c3f5360365a44958e7902c9fe9943f3d4f930391ec1abc306fe01bc855fbd9420acc5836f9afcba95aeb3a64405271832e2f50120ebe06a203aa4bfd9fbfce9ce001a00f5d3215109e8babeed5f5c47adcb7ff37d384ca228730f2f318e9a551d68e5bb588c06c4b2fe95050ee300041d6eed56cb3f244d8c81c70cb3c7f6572ec1ee2f23aa2e5212a0d14599fb99f6062974bf73f5994402a48b8e18dd26c1ee1d8699d1c835a0953fd2b6be7ddbb16116423f5fd1c9fac014ae937e76468682bcf9a2f5ac2cbd9f9b47074e51d613eb6fda68b1efd9e3e754251f3603d4da222fe043342c46c41591284412f267f49aafe69c4c3bf333269503fd7ee27cf4a690761827fcff563272c9de3645004b937a536de7b5b5d318acf5eb8f407bc8b06d579aae056f52099b0cefcf26538d185f0173577ca5f1a8978d7c6bdcfc2988afa048a0606e67fd37685352329e3d21b5688ba4d4585ce2e315458d5b2f5cf2db3784c0a6bd35c504318262dfbab9a1111ea05397ecd1f4aa2582580990c50ebb36fee37da20266b7623b24cac97ec2bf8aba33ffcc7d5db438de37dc57819de4712df858771afc7c684f6049e03e1add097be3103d9b019045d055dbc18ece4b7a00b9f8b5705ce1ff5ca511e13c647e86ed576eaf06d297ee39a517f00c090ba0d525c2e9726f40834fc21ca12cd798eef3a973dfd76c769938cba3f727844595621d3c30b592246ec7592b2f74bb610f5cbb275dc21c27c62e6ab057766dfa3ff344fda5c701177fefc8b995b857e43feda6ec0f23b61ce08ee951d90b66360b7fd6c70f22b777b3f848e774cefe69757c3c1d945aa66e054ecb1f7a15643e96e327a7369c6fea64b5ab7a2005e4ddab80123fbe76af70c633c2804359b8562e231148ddabc914c31edfe5704c26e61d3732d91b72924b2f233da12821ad4cb41f0caf93df37a7e31a787491e5b0702d06c59c9f29f99cc666eb11778e81ac599a252d37d9b0a3c8c6807e23dd0ebff26adc236b99c313382316c2581f67545970116773deeb1e489ff6f279720cb3ec1c59f1135089626c7b3e0c2bff1fd761c30ea4e9bbb56f424700cc64a3e98542458e907e957834b28b2932c2a57cc184c82855de87a2ce35e0d9fb8af793b7aea1eaaa47cc638ad3dbf2348e017c4b4d5b79b2cdc27668f0d16ff5722df32420e9008dab1cbdc14aa57a8621b1fa3ef24d8e641b65a0acc59fbd56138337986eecd3f7f481fb4ded93a65c1cb608d8a1f98e81e957958b7678da6def2ea938eeda5399e4e82396a94dc061eb255a4077c77edc6a55a1f9189744e81076fdd5b95b0da088b2d24b654261c8fe069f6156529df0341f148887e48fe2a83e8aa7662423716c6ff77ba0dd7c4b1436251f69be23320fa89e4d0ff4d723edacffabfb2a1c60f67389c52b2fdbb53846c757361b691020291b6fd73282039d4dc884ccb2907aa54c5700944efa08c5d55fedd816552fa0569a23d85287ace14f7b9cbb78662b7621b8d076b2d4ef0a12163a730a8d6a00e986ec3b152e2d9bb84b84a47ec2069d7460101f0cf6b7eeb59f4ed5fa3aabf196f66d5d345f541e3a84727a06d12ec19207af59696d529b73757875afa836ff1e1c53842495a73afaf036bcfd62326ba1115d64c7260b35704fb6082388b2c2bf38ab739413a4e0548bc25f04bfbc70eac7df3ce2c6b9e88c7f4ca19d6589be68670dd87bad317a150fe332f56f09a16e3a5ec7c4c21315b3ec7af194aeba652b536179f745cb57a600ed59d3bbdf33de2144f15e890648c8862e4d00e89337537950775a84bb91c4b2085109a9f3324978160b96dbb69e7bcc6cb074f629437e225f4fc940675f94ef92509f433348d28df82963ed6732b21c02f055155ef5a8177cf1c8be1cf7c317c749007f0fcb7dfd62ad4838d23197d79d57495228e97e7fa1bff12e7621cfde3d0533bf6e6e983b177dda0e65bc9913a20270a3444f509e573e435a5005daded19c170b5c425b662c715684dfb1f41d2afc92d502034415fd9db0349892911581b86c535d47ea9e7eb9d04eb2b22459887c6d04b1fed42bbdb76093034a81c85f2e851c092e3959abbac8585eef43fec467efc89fdaa8a09e71a6af19608f5cd6a9d56193730416e78b6368101003e1b3747be55541d1ebce4b577be51192620537194891695c2babb62e8c4765693e9cdb3a1a287a846b47ef3eb30bbc271df279c38d3d06e93a0f4c8d4d1360f29eaeeb68b452389724b589730d3f6abab2190bb6a599b7ce5f70d2291b21d09568e211a7d74da60eb81da7c840e8d3e15bb27af5188ff595f9f10a32008b0d00854bc7afe6434a38a5f331037a733ab6b780d26ff5ea6e94c5ffa48f38b63db8026dc3ef7be618e9aeadfe0ddf82d16aae9980f9a2f38ce46e5aa5070268fdbf662400ae644a7f3fcae8e4cc74a08e0189ae7684a620f023cbb478205722cf98b2ce349e919076edd5a2ee70438e06f4ee8b88b5af0aa1fab6bcb472bc49cf5b475f8d2cb829221b7258b471a2a51a34fd1427fd267d4bcd119859fbc6f93d92251ef6b5bd265805d2e2fe83318f0e04c299d1563d84f6d9b637a074fcab3ff475759fd936e64e5ccfb1bb34dced3b89a9ef79adfeb35c3d570321873580739f5371752ebfccb96c8e306aa9cae6009df0951962ca1587dd9d0cbe278d2f7b93dde4086c75127f557399b92f90bd9ca845d71f5f0297f02061378f3958d5193dfd84e67884e5e418098c4ab71d26365d7c4b912c98d4c7f10aa2ac39fcd2303c6028b639cdb2910da1c53205379b52c130789ea3e942e3d708fbafec5ce7265364c445e171fac1af1dc0718aa0400646576215e2be2e82c96360f9d054f073d486a619c5f7f1011112dbbb52a80388ec910825ba4a6217aad3fc6072a3c4083061986ce6b6387f84d60a954096fb7bcdc2e0dc4db5a74c33e24312e88d018ed24f1b6a6b50f246d4908d8e52a5009ec5230f057d8108f2d70e34d0698eebbf8a024ad3d07e821dcd17a13de6bd28d6406401d925e522a888db361054aba9c7572ef62edfc38c23b2d7a8e7f554345dcf7c3f5b3378d9fe941dbaa913abe9f4214e1517bc1143e09f0a363da0718ede3a30052e5b753bfb49bb4709c76a6358619d31e54424fb5cd8d78e2856a536e851aac61da8e2f82cdd1af03a2c3f079b73646a1bd7d45059a1e8f82d17efcf22385730467aa3eb5aa659798075be977c09d67cfcf1036da739650e1d1badbff5c9a9236584ca6127addb11d1341edb0450df6421d8afed3a3744332af0ba0088ea7d081221313598122440ab2f62eaf496d1e7895cd7c83c59521604a0ad081b52c3d5ca6835ffc7cc5c3d1219944caaa62cdb6dfeeb9479cc15325140545c81b4f54abbb87229050f1fb157162703cbac68c10f8e8274bb3a1bc1e91f4e005fa86534f9f9da21b33f315843daa095c6776f94478323d8c8ccdf19a647e6867ed1eb454b288b82280d289b68d709c7f803203fc11aeaac3236febd09c4278fa188868be7b7aa83f89a63dec5746c9df81e866eac079c28b37eac715b1a9603333682aa7ed6677cc69412cf4e4e39603fb4ec9453fbd276c5f1936a197563fd0ea67424f0dcf94041bc941696ea524d2fc077cf83afa69c70592129a5ba76b4fee64803186f5a4f18d82f9decaf3e11ebd4df1420bdfd22e01fcd155ecfb0203a6909e2fdefe7e2a88eafbbbd2f67a020f141a9b9652b94c29fcef35c8d387e1ed49e767df6789e3f0f815c8377d4d3f68bdf0045ec7fd29f98d2203a4708fddaf5ed321772c873d2a4cf36b8a1ca2708135f11b6a8bfa0e19c7a8c0e59b3b6cc3d044aa99bbf5bca644c548f9521a0215c0bddf169b21e4b5219d3fbcbb578b2c2677f63940e30cc827e2f2794c7f69612a302ecba9fdad88362ba3442fdd4da5aad0caf64d5cc607bf383bb82ccb7757c016b5b5a15711e650dd11aae4d2b1a2eb098024b3bb624d413d5a343d34d626085edada7001727aeef6fd887ddc45e328614b4f6acd249a707bc82f7e4fdb206e282138911119de6dc8834a9c5f082149f4123b1419b02b6ab625ae7d750d9c19f6ef30130a9b5106ed89affd04c727227ccfcfdba71ab41d3b9eae8f3ce7b1b18bcdf22fd33723787ba61ba8fc60e6cc77884bda6c07b2c16b95ec2ccfcd202c58686dbffb9117c4cd768bbe81a670560103ae24be53397edc1663c4ace437afe56523227fe6d8a6e12d02cc4b9d2fcbacdf0c090bda65867df1a131682e2758278d0acddc71ce70afe23eae92c1b988a93af678bba9b17a2544c64f33d31bf8bb6c87e625ee933ee354327e645d50298c6e468149076d3f14bf1b2d4ee333918f8c030b26b299e4ad2e44774dffa916db59048e846bd0c2cb5efb17487aab89205ad8b02a5302fc0640c33c3e5a891c289bfd0dde6166d8268c9cf165d378c818967c891d7318ce06ab766d1dc35d886710c2e70569532743ceee69257da2d719647d7391fe3a44e4e2d23b1cc34550c42c8c198c6a0cee89b13e014b2cf2a8db83f4f913362229141667b824c5875d5a0e20a149cf86d4b165ad0e56792770311215c5daeae7dc65c14e959d358370cb5cdfdcf693b45566e3934035a171c210386d7344d2f38d37e60f1d53814f3ab6da4dd3b915e28951c63b4d690d1c65f7e73960eef0c58c2b137129f52a822baa2abbd5919f9426dc72f3babb3ffd85c1500ca70cec990946919908ece75c453ddc4515648b45a2797a4ced0cc598f3e03973799a73ec81aada100719962a4268c7540c87b2747f92a61c088e8aa860cfeba4d3a85584ad3877b9c599691dd3516bd0a063c707211380a0576ac15809afb5efb1e9cd6ddc7abdd89e13a97c2e224848a4c9334fdc85902b3aa25e8fd639250fa23c92cf317dcd7db4ece0230805b768406a3eebf53d5cad1cbed4d1cce1d770c189e3ae40f6a8cbb99140f1e0fb25e4d392c2ec5741f7fed4bb75c00a771b4e31a32d3b35c347ef8b9a62aa7fcb59a29f8d01d663934430f8931b1f7ae0c5b6360b48b94ab82fb68f6c482dc9d86f65e29979e5ccff919b77b86e63e07659e154c45a184902c64240012e306702a6ac70aeb2157c7cc1ca68546405208a07f2ed2dfd57b3a9ebedbb6a424fe441af59176f334d0749c98709f98022417646d05bd578ee61ea3d4b7828a74b2542b13f409ad04ad7639e344b5212779d8bd2f89aaf7e2c81b7850631a02e151a9351482704e96649b072bcb5f9b856fc12c8bf7c3a53e1c5cb8545e816ec9a0d71bef9a29666262e992da253eb46c55102a1f21629820bb2a8968b192a0bd97c1c1b4f28c9200d01ad18da275101f015f9e4c509a6dea53854b53439092a05788b56853209bb9c0643fce26083550e5c0f4d90454f0af1308d6b1f601c7c8faad78762c96821eaa5ec8e486289697e5f4b7db6b0077231f0062ce98a615839c6e66e08433a61a394acc8522397ec561b3cc042e718413c2afd2c4240e8a37ee6016a4640c5443448b6f2122bef7d26ab26a476e07c2788f71d8215ce55b908d872bd3e1d57e9f173d85a1444a2cf18ed676e0956a6b962b5419cd50369c9db63a8928836949d0ddfc9323e1dcb9d96d44bc097f9c834762c40a3fb991344d06892cdf623978e8b3222221e4cba9b68eac8fe75e7c658152081cc5be322167c668137dc22e95ccf2516036907285679640c38b718d88fc30093fb8b5a16d22e36575d0a90f015e4f0887c879ad0aaf9fb75724ee687098451a18b998c3385d0afc1f0bbb351d2040c2e27a92cb6eee354502e698eb8ceb726a700d5300a35a5591dc2802c633ed2293da7b406f5d3923500ee1bdb00657a67c4c5e45c20a435247e2705f638adb72a21832721c7035c11eca6fe4b221912ce089718e47bb6127e0ff0bcadd2242936816827905e2c65e9af98b844b7a38bfcc2f93ccaeebe857e3131f690931d959881ed6de05a3ba912dea076641ee3cd774efda3e04b83ab14621c724e7ee2aa8761c660a6b553ae760795e2ce473cde57ae8e6431a801dc02bc99b143db55e08e90ec6b0966a71832f99435591a1545563f0dbda291cd7463c088475dd5521af1402e2b9be489d62dc23b89f5ea3a46d9bf13daeb72a2443a51edfc2e7ce5b950223abae8c030c545871b2934865ca313f53083acaddb894c150bffc96bbb4500b73652d2a73c5d2c4ef38b95cd9665a5671b17147be860dbb996818b1ec043e1a8408c0c4426ed9331b1dff9f1a5343c90afd662f80180e80b1e7ea7b6aa35a67dbde972d0ea653806d6026472391b2b0b83f22f936ad2a7a33086c3a7c2db0d936cea08bf77c831dc87ccc1b3d4101a72d52cfbbd2d309d25a86359e05f7cf3868a9c6c4f58fddec3643b3a53c210c579aea32c9eefcb5eaa527c7fbfd77cd6074596971e20c04130dd3d2e30df03f9287402d14a451f45564941d682378847b0480b3d4d6b185aa5f6cab8b253a1dc669d2d93ab190506a56fece90613fe94061a6d7e48401a22bafbc95ab380c5379d7a8b357e130c5d85db0bc5d1bdf55d8af2d3cf4281aa6e3f0abb5e23c1e040bae9df2b4250ac1edd7daab15dd0a1d9fb199b705ad7fd4250ce23325f0e18a41f533b11f0d61cf46416b8432971ac9cba6af742c20b7c709bb21ffae4d7f6cc22bca49136a58a94ded4d73e193d7fc9989154ca0bbc286aa71c5a763293fce49127f533ce2bfa3def94524b5234ebe075c6a141b5237e9f4e5e94dee397164b93d383faed230c68b7e378abfb3fea10d8cf6e0c20d5e678bd0a3e4318ad3a5cb55314cb7b69f10d4b7d1cae26a483503d0d1d36d9dd6f9afc0ca3c635cac751ff34f9ace77f5c01e304a26887babd10bfe9d6eaa42595f9f2f63516a089243bc4d79080aa67daf753d202096aa92f9cbc558d4f69074e8f55c84ff159fe7f5685a8909bc66aa258015c99751ab6329a8fed16bd5ec9aab96a7cd87bc53273c685b768cfda3f031e5326a1bb363cbfd6203b67c431ec03fac973aeb60480708878a41d803505d2c6b5ed4f261cb4511bfe4862d51f435f8c83611b09861e2f529e81fef2ce3e9e02f7062cb2a5d2659e2c5a130f2e24eaa378a498d41b0ebb95014d64356a6ff6c28666792a19e0d385f5d1cff634f5130b9a51ec357edb630fb506367a401567fe6b95874d3dc32a374dc67f23510dff811681286a4ce371cd121e2a47f77ff1f5d03ac1e5016788fb9f6625c788aaf1abb293311e28538c88d49eca43fc6b9b02748b16862ff28f400cfb16aa2ec23a16d626f0a71d768b9d66740bf2c3b45be140fd6c66a9fcb54dccabbd8bb2484e07eb030fe8b843773272c392af8c3b7c8e3da28900191b857bd85c6d1aa48e82295db636442ade7c159001a2dce46e6c421dff9e112e667068c340fdd9c2b41e6d0d84e8b878c2f3feaf161d47be3bc3c9e09bc9d1932370e41be6cf0ba294c61a53a1b142e0a055ba9b33ec928ec4dfb73108f3bbb57588cfadc7a13b47c0d231d0cdc5e3fe394930ee660e4bcdc444bcf59b7393cfa13d4e18968ed0678f894120d207c886c69d722cbb13b90768bd99d8ed5cbfe7d41993f1d1fb50a645810b5e9de1ba4b47524a430818994c446bec4acfbddbd1dca12bd06f910b00a75031ba68909d7a751bd541a3f583f73671b43d64b7455cdb3bbfdfc8ba49be93198bba4eb5524669567e753c146ad70c92e9bf1703110bd5a624a118c366bf35257f757da77de921ee4e7c36357e55b0e374bdd4efd48353cd00e2b96da69562abc49904277b0cffc00bbfea1c71b17399acce72f5effd3e1059c1a5c879fdcb294f93954d4b956c31f300ad350e718d0c6c53a9049d9f8b960e885256da66dca906014167e4ec82be90890132060d28c2e121fbdf30994e2ec494854adc3adda64c1d1e5477b474042744d45d38d38af70100f69298204575fe54f31b27527b7351e041892800b2f1c490912f7cb412d10c2ee627dc893321b4d09d3bd7e03037044c30dc469845602d566af41af705e6c72f7dfe622d0bfaaf3e2a4b45ce2539f21d21ac4fac7d5bb0b30786e99decec26f4c5a4edd8162dccc8718162c9c63360ee9828911f27542ae77fe7e982201d3076452a48626f5e31c2eca5237ce7164b1b66962223c40f0848fab4e9e3c12328fc6067987f913b0ad6230081045d582b4b966c7a720d002b5a6e1c3b1c4ba8ee39486025336b0284053fc213c7917371eb07fc1cfadf4334b3392c68c4c31b769974d1b28decf0110d097bfdc3b4698fb1cf676383bec10317f6784f51d9eca75c9d6d6fc849baa599d9e368e2b50d751240a028fb4f2cfcdb7435357a824a1a28da0fde77d598f6fb5e889aa8e21ab4489d3a0ed790d13f76c786865ec7c6a8d08afdd3510e33437a294f9a979456f130c75a0ccfbcf302baa51805df9a1680aa2640c929d0c0bcfda3878ad157e8fd2f2f84e3c2d9de10d60e7ed976e13d8637c55f90be445f8bb6e3ac66015e3e346c56914aa110ac30f69360fcddb40f80f3b26e83d3c4a068da18068009da336a4ea090627f3424b0c3de1df7fe834da3fb7bf10223f45a7e26f786a55111a2abeef0bfb2fcf50f9587ca0b9c54e9faa28b1157546d70664ccb24a6cbc7a37a4d82d2ad42e2fe8f6f93029f2c667e198addf10bd081daa306053615794f43c7279cd133cdd98ae98b4320f99e6eebfcfefdda98f65f61fc487b3ea803bd9caec2ae2f1f6e60bbb92c8f1d1cbd3011a8e433bcc3795c0e6652a78fb018ee5b7da8c2840c1daadda783e6dd9c8d66833f13107083d540f8e48ef551802afe6435c83d4eb6e5e07f762e397222d05e40818f9bf43b0749cce250f180051c03ddf344bb57713e0aca73c5b4ea2f884e5ec47b59664d7fcd53c69d3ece67f2bd4d8e5668f101438acced4dd8f042af32caabf0c28d61734c0beb671c14f3d169f119429ea1c1453bd6578de5f0b4aa88124c972193e4709d10cb742231bd579ba17fd37a0b81127d86f80c6ac4ff8074ad781aadd2bb7b57d122519eedbc9bd3a8f27aec08d2d2b0aba170e785a23389f7f8c6bb7b6f3d59ae3e0e2584d21c3609ebddc09da26a82d5037b7eb739272a84c2a73853f6e308ceabdb397056d21c449b8039341f3130eadebeb74f2602d5146ce297bce0764318c20596ab19554f2daabd6984ab3a49c0b118d00fa1f9a5b08ed4531b5597fb2128ba73569967ebf01228a352b83a728caecf7db9b6bbe26fab4ff92bf959357aaa016bdfb5d8aeeb888fa83c5caf733fc212a2bb6210351c82e69683dcf3fafa5658a233a51780ce18949bdec36cd6d528bfacd6ab78d815d250afa3b32ed08b062919deca82f87b9f01187957c07907ec5ae452f929cf83159ab97a9e2843a675abf4c29918519faf1159315439885cff9cb6467117c3b641a444299db640116a1d9e7cf7042fdc02ca28af487021225527289eaef40a60176c0ba888c33958271e72c8c4b7cce6fdea7153c4eca67f79e4c1ef7d495b610c361847589527c802cf45a70cb6a0f3124d4c1502f5c2c461fc9c264ad0c4a3bb1b2e351aab7fe6f883f16dfbe73a36d0c3522c3adbb4139022adb1521b753d5f8827e004b5998b00de37fee42f09eaeed2ddeb2b5dd6e69946602c556f666e1a16235dbfcb6fc2c567db57cd024b388c3aedd7d7a35d406f9c52acfab48bd5a51d5eacc5189725f6724f53c08e1ce4520e035c5ac7812129e1e6dd99a75ae40ee0bd3936fae15db474ab5e6700fffd963ff816da47dd8bbc9150e164af09f7d84a602ae040814ec30ee77af7e7764841dee380b88ac8c12e6118de95e39e2e4b4f050bba2773e965594df89008fc85dbbd5c3018f16c3d74f3b3684904c8d332a59b7579e82c2e1387ef5d5ddd4f7d52e28677934d1b6d329b82f1671067eea151f63642fcfa8598f8257b4460143aefb7b68337a1af6b36cb69923612fccb423ad57dc27f518ba5d05d8321d4fb418a781f2ac654bfa3dd0c29508fe4e1e46516bab7cac5b11cd15a06566e11db4860bd523a3db4a1fd74c68b71c1b1e75429d45aa5955e1e389cfcc80ffb28d77ecfe1fa38dbbcbb7a216a650f2eadbfa1439cd4036da3771c7fab379d3fbbcf6de8d2561e57b337043250c229baf66b69f52facc1d98d52aecb73eded3f7763356622ed90775046618a0bbe820826ded0dbfbc8fe1c4303c3dfb28af149242784e96f8f4158d2d5c69d39b01774e0c7567db6c30892f899cc08ad752338b9e7dbb0a73106994a8ee3703397ce89253b47810d555e38d70ed1e4359f6add871df0c8007dab5ae377d12d7315d21f17248f4d5c690567700de6c545d2a112051ab7d9159be60328032ca6003061806dc970b6baa8f280006787446683fe1805ecea32d4248947cc6d0d37532ede44fd6328fcf25f40ed43a90859b91213c462d53349236f3142d3f441865096f230fa393cbb9fb9a2ac255e05da3f8d5b02942c35e7b6eb5f3dd73845bac990334540410ca0556bd7ec2292eedbddf53f95f8d11b42094c84096925f556d19b0b82fa15bf0837b58ec130fd10a6173c71b12b593aea4e0a437a710c1f75a481e530f297b73baca3f44903c2c917d0a9d7ee26f456b9248a2133663f4b811221c531b7c64f263ae31a2803a941e312938bfdb886f2cda5c7650da56fdbfe61ec5ffca8c5e7814393b1ee3bda6b734614a24241fa487e56294bde412117ae929afe7c6d9dac2ac20951887c3a591d21c101b82f9d4828e5177c4451095b43b2b2c75a01a996aa73aee81d5da78dcc1607dbd141a7a7b30850fa6727af980858e5d80f49ecd40270e2371e4f3927504ff13abeac789bae25feae1915bbbbd10b75b7f1afed3f8530acb41713509c3a0c3fa618915658faa8af4dafc23411384153b707114f08d38f72f8f8dae380c5dacb2fc708c92b2fc3e6467f265d07b96f8bafc543930e2bb7557661bfb810551f642b66b2c63bb8eec882817e40576f29dc172614a10767e7c55e90d4bd598c4e4a017837e397b8ffd4ade5f028cb12c92ad4f0ea7fa64299086d9ff4cdcb131740389b85b561d7e94dad9b70f59c963cc345759a04b50303219dc3006a7f098a538a6af48e97c49d79d401b8dece61636789fb520c2051d6a174f7d7f208116103f2b7cc7b787efcc8387ffa0c45cb3afdae13f3af2f05a1249fcd47c31c743c9f30e3ac39240cecd904182627f5cf4baede46ed25d077c5498127e38fb94236c260ecc7ab7f35516749def0b91615b1daddb37aa86c7874060710c25e82483921022a4e25931f703dde2620b4fbb82a219919c6585157dbed6f00996f1ef4919969ed2b9d2f818be593b462bd76133800363480c36ce645320af86ddb9b9b544883e20541f37243dfe4d6adb224d5ec8dbf148505b1740f5be31be5d0f6c67093efd7d7a32625bdab5a6e15dcb882ecdac6fff26f7956a0c18f59871284bafc5afbace5191cfedb6896d5fc57ca6aa7cd99517dd9ceadfe578944279dd175d09724ae1f42073eee077639ea38ecc60671114c159efc8bdf660f2b59c0e20226409967f0d96f9fa46a70b0cb89322cf044e93cf4001289d8e08bdb0c1b6ef69bb1fc306a5ea03985a53a58b7b2295d30d5abe2729c75d4e3e73b9dd6d39d63bbe68f5fbd2041a9709a0d8c1e68b0f1153b21bfc33ee1b0cbcb5744e7a27ac28666205527bf906f9e92fb6d170454a0633f600cf03e178f1ca47fe6798840c92b623d9fc999333bee0d0097d73301da5453bea74cebdd62a52466400329b34295612e9654f9662bfa998de2f772b2626264c7b39618dbece11db99ab5c0ec43de3b361997294416930a03dc7c723e95facb4fbf0b540ca597e0ddb0741aea1abf5ea9860fc9ccb0d04c41b6656499e4a97be5e20cdd588c7775fea4ba3d615510b11f06db3e4bca61255136e2060dc70468434a49d4a411b149cc1f7b8c3c18bdf798c0b0a02a12bd5e9902b297154dad2df30dffe32ba0e57ab94e5a9f46073a804843d5e7f9a5515954c401f0d2bfdac583c94267d1e5eb78f447f3599604d48f2202cb6f5c5efc037fed6e4aa79ff0c852a6a4570b6fcf57c0e01e4d781bf6b489dd30f5b03d916b701193f0e93dc177d64d9421e066346a89aa3fab07bd52615b75ae2718e8460a4295d0e00038eefad293fe97aa2dc686c9729f41733bfe83c2eb7271074212606bb3e9c295145b6d63caf444e139710064b6e8d2af22bcef55962c2eecc892484c00138430085321f09efe01984aa294128fa6d7423d8c6bdd275b6fb78643411d19e090f27be6cea872d01c62958e9daa3c1af61c8fd6402ccd06d245c7e5796462ab1e8a41f75463a1766e24eea0bd5fa4a496c6cc68be373345e895c3c83e6115f3ef71375b88fde4fcd21d00870f73220ba87cf8fac2b3e401bdf73e2e6a618174b06828202f20b21e27e68ba4896353c3a8fb81caf0952365cce1292141e06991870754ec08fa20c217ac6676459be4fcfcf7b14a15e1d6b559ca52ead168f11594239ab611cc8299cd3b1104d7bbdeb41f8d050bb13f2ce55b8e6bc5fc8fdebcba092fe0eb7592127a3eeeda2bd4623f56f85fc5b8f6d57d6</script>
  <div class="hbe hbe-content">
    <div class="hbe hbe-input hbe-input-default">
      <input class="hbe hbe-input-field hbe-input-field-default" type="password" id="hbePass">
      <label class="hbe hbe-input-label hbe-input-label-default" for="hbePass">
        <span class="hbe hbe-input-label-content hbe-input-label-content-default">Hey, password is required here.</span>
      </label>
    </div>
  </div>
</div>
<script data-pjax src="/lib/hbe.js"></script><link href="/css/hbe.style.css" rel="stylesheet" type="text/css">]]></content>
  </entry>
  <entry>
    <title>2023.3.20 - 2023.3.24</title>
    <url>/2023/03/24/week-30/</url>
    <content><![CDATA[<div class="hbe hbe-container" id="hexo-blog-encrypt" data-wpm="Oh, this is an invalid password. Check and try again, please." data-whm="OOPS, these decrypted content may changed, but you can still have a look.">
  <script id="hbeData" type="hbeData" data-hmacdigest="e6074a39e0b08f7984fceeb4bd1c700e94154b06bffaef73918747dbb0786cf9">a99f2d1cd7f89812758242c57c62a59fe859e32cc19116fcceb1abacce500da0960986acd07eddb3568f524414b51feea94ed3a8842a2a7cb58681a02b461bf770f84ee1401d0da18103907eac52ca7791386b16ae0714d317ad3c10b8cfcb276ed3c467af9a7c54660fdf3935bb8e63e958025e345735325ffed34216c3f9d20b9b3fcd1fc54d7c3ed2a5528a80d70c2f42ba0b1c18e087dd4174204ac109967c5694d83b86740b903dd52313ef9ed14c4240425fe8d649a3b883fded8a337858a7de9ff0a48f580243bfa81a41f721c13884d34c381e9aaae9c2f807bcc9b771e5e3dea3ded732a49aa0ff22a0aaaf8d0e3ae90413a9937d706005b7cc6225394a7b74c126450ee71f0f3acd7bed885d5d7a824d15f97d103d46b6af6eb991148c497e0783737308014ecfa4116ae198493e42cce1259b96b6e41b889ed5089c3eecbfc493fc6c98afa191c369f8b5b35e3d29476b302f3ea52a90736c75379509cfcd7b715053dd9da819b44fe15c118a9a795651d676c2c8d32fcc691e615020733d9c0ba2c1a65e111ee6981d3c0a1e2998dcaa5f463055066644ae71d8e6df14dea36dc3f9b352bf6f0ebac445131ed8fdcde17d99a863cc64ccb3ffb05322357edcc84beff06d9740c81b7969381c682f8de362daefac7ec327dfa1a16beaeb1690e6ed9cfe0117b6d255b5aa100c67a7e5a842d86ddb390ea9f9bbf05937d424499b4d8441a03bcbdcbda1ba71339ecca4a99e444571185b211540d924a260d78d743ea0837834d5a2bb260d6201c156eb5b735845082fa3f686588338c6ccf71a979537427942ba8837b879ccc5ee1e4aef66189f58a40c2e3a1401ef65fd12aa4d74254bd2d9dec815f258e08bfc2559b551454adb4aa0cc140761737478a94ee0e319cf0c587123c2ea60fed09506205bfade16b095a8ffdbf19838182ff7601d565f26f15f479ecea63fd9c1d888a50c6e2a9b03c6a39afb4bf2441b4f355c1fee2ee4584f1c71afd49e9357eb452b19e6c85e05301e8b9891ce67f2b8e0d4233d1c525fa4e7eb43ecb1eca17ed103b2590e22d4ef3695f2aa912c3d0fe89db969d2861a9bbfef6d21300c6237e70f33303a172618cdc0986eb607f4e34b27c7002d6bc90e7f0d706e975322c13c9d47103f40eff4844d04df536adeb2d5f5e88bcfa8089ca252f43ffce14ba545b4072118bb0960a6ace42b597bc305a659a748d7884b3da48653e48180688c16ffc5a4d1c79dce766514a308c60825cd2667f39d9914646971121f50eac7516c3d4ca14a1d91f7809686cbf06e9994368c7d6a9d2b11ce5736ca850c8e3dd23b3217df9dd5ae8ceb1953afd5aa6d2082719a317c23e95045f9b6af5562b13217c4030c2f730d708f06a4012a35f7f5fa44d2d37b3efaee436d412d31dac3a91adf99994983fe3138964324b40c91fbef8ef4680e570e35c25056ab5a88b7ba5a3a1894398558a766b0de93cde7da5008b66d75342c71c5be3d0262f775facd30f58e4f0567b6a1cdf313c086e6b9dff7a43aaed4bba0071cf3ef76820d300c50c7a5e471f143020b34fc125a26de3fce7ac6e62a7cab3047100e8aa5176952213af29fcbd3cc42e9e456187c0c028e43713236fdabf1911c873500c13ea857a4ea32519f9783c0049c990daadcc3431f611f8b0c67401529b6beddfcace850fead613a0d35bea50c7a43e6978eaf9fc1126f3ac4aeafd01037b4a67e6e792d9feaf3cded2c15415e380a9ab39e6b8d59d9f62614c97d9993d8a20ce37b6843ff0802f7126ea9b08261edf7cad9c542a289214baa580eb2052fe63a4382cd71191834c08de25ec7e4e05c52981dbd13aba6841e037fb6793ad717853b1440a86fa9630bd78462c3363976b1a8609cbe7eba86b64e9a0a75a17db70eb0743abd2a675c41743eb46db0fb96b25a659091e04a73ccd548e6ddb1280e57345777259d7c9063e6b2a1fa3d87dc0e6155cfb5ff489c5a5e010e0644ce89fef38690ff469fcb2f93a11d71cc294d8d1f91dd3e2350404ef36654e1703fba74b481b55d7fe9c45dd1f45f6ed9dc2736bf32a7cbe95a0b84bda11aaa4d4dab5737eec8396c9d475d2b2bd1de2ec31b65a694f219249611ce99c8735925b3ade50c54e0a489caeb6bab5bbac889b3519b4ee3357e3e8d503f2856963dbaefa7b486d2a4f1bc84fdeac2002691eabe86ceb678fcedf282b5acf109d3e10b71ffab53308b0ec20204daf51bc9180b77c87a67b763d5a1f730024ffb2ac0b00a17f6e8d8a2a74313fb03aa2c118d28866a0e4e81f5893addfb9a2d70a00290048382d9c5b3c8df0d6352340daf44ae120b3e8696f2546df9c311082df158956152ecf74bd8b27f74023cf0b64553da9d4b14f432a752ba0cbe4c67d54fb40c75114b29092c15c861e2a70aba668755408dd3353f86c384e34fd9def29a815d02eb577ce34a7dc7690fc008f7de90cf7f008eb2d12e8c500153f5345aa25365f4316974a2e29e218502d3b1b3d80ddd3a9a684de47da100d37bac4f5972b1dd0b0a3432cecb8b239ea773f42581b0fd7260f5c240b8c99326844aecdea81a7ce6e9f1552265e10964604323c95ee16ab20aeba1d724e14ec80d092df6842f32c0b66d3749ecf7a7fb49b0bed12d374335063007dea9626d8775de74b74e9284917a8b2115b1887ea27db123b86da8840ed9d10f47c5e03655cc8b2af22c7326d52499799c70d1661d04fc405f62e9d9e4dffd1509fbc24a9a8df63f9939d3c797a86db999011e2d6979abf7be389ff7407f07d616e512ff64d8bdf3b038b17ee5156099c543c21ac761d000b23e7ff11fb88197d61702f36b4d9ba349b62fb8d064858a4998186eea319d62539c89fd99e9fe4eddb232b013fa3eab9b3b18b5e88cb33ec92eab82079e264cdc13688fef9bd1fa2e03ff6385ebba8ad79f22d0034f34ef6300ad650972beddea1debcbae8c00eba12d25d13d4bbabb5b3b6bd8c6222598cafafc7cbffa5430e1e88823675f0e2fcac39600a625955b635c17457ef2a8823258923330d5bf22a6fff027ebbade3c5e251c3cfddf969a095e6e720ed357090b3b90d96b52a7a5bbadc10b4fc879d39fb6c08d516a1c5e76bfcfc3559f2b3b2aea36b6e626956a585b2ff8b4fc57f4a3452ba4f5c544b28710fc7e0c3e56902babed9c4b0a4c897bc5e7a2f84dbc036f9048f73d13ef0ec0a30a23d8d294f1e5517b14632b24d2bf96b581e2cdcee6691780c7173cc6779a9c9037085b41d40e19cf72c0c89473acb9b62e7f2ebce1614d015a952b54eb66b7a513676aa83ba2bdfa0d064e67294c2f42cf99bc786a1cd5d22a330862d368ca0092bcb44aec7c8175337793e773ba8141188442be5ad6cca335c08bb9892ac251f16d491af9201e7095ac1e2a6829cbb0f88109b31fdcb44f333edfd0bc30dbd748856b5f05c57acf62ff4dceebf6354f1ae64b371969926afc5f7b8799ddb7891f3976bc4ed9a4f922b362be8baa6c5b77697d1f2be41c9fe64fbe0d41cc5f1cdb5dd2107f12bbbb1371abd4c783d4a2a6fbde54cb08e6ac45cad9c3b2c34a6ad03421add25234fa0eafce6541f153e0934a5ca93b10f53a982891d176c3faf6af9ccd63c7a3320f05e4c38cf11d129dbda658580202a24792d46e9ef1fb1aec6bd598561a4475f7b1cf8f91a596f1640729db1d14e2aa63aced5fb4d83584c891f33dce6206de00fcfce3d96008351105b160504b915e39de428e3f9a33468fc69f66fd7466ee6a297049434ba2074bf1782f280701cf4f309e4eac2b9f0e44f4f1b48bc05ebf4ae7dbcb26c6b5c0c075ce98815dddd4e82482dba9f246516b45111b3596c65745b29381d1d0823364b58b1cfbc33b02f1abbbf9be8b86f43f5531773e25545a0a351a71043041584fe7cde5f19898abaa9c6f9c3ae942684d56f5f2f7932ff24155f916d2ddbce17ce2199f14bdb4c9b6ea70c89c0d6c4af61dbaca0ccc0bef522831b82e0b4fe702087bc867c538909c8b36f398556c0d48b4a57eb39392be1666915b9282d9582ad3fece647b3f16736b1ed1314ca913b86961110947da7fe2c582fe126448383ec7999aa58149a1c265e1e80da1e29247e288a601a6cf3daa9078e00c1000838c0bd3d80405156148af12179f485e9beffe0ef4ca8d1f12798e45d4131081d52a50d194a18648433899e08adf7af9f9f00a002c9ba4ef9d9854deb5ba280c34e72d1cc5213c9d6c072fe545e7831543283138ca4e734297d9efc0de7c797b3cbdad917194c0eedb31fa622a32a5065427be45710a19900ca8a3fe1a1f136ffd1f904b92f8e765a5435b6c413d517ac77f43f3c4873e042f1e8143aef9902a6599c0a4764152639f4a8d671d14b4a38a13043b4c2a691776c87b9438144598b9605ada59f8b2cddde5fec126379e3b03922f629cd8a27856b8da7039f1f7ad19370f3c624172905b0c3dd8559813d6ecfac82aeb6756eccf80bc80404671f7222b59b867100f364263a9fedd93daab46a1e4bf66530b39be45b3e4d30cb80d84d4491a1266cc29da284b9e301b4b28b3f0e0f841055434debccd94523c71a87f7e9619cccdc7edeac32047c5fa070b7e41881b4f701f313eb8e51142b9e7591610e7deb39e3d6f2a61f3ab91100da36d18d2ed8fa5a499188faee39642520d00d611b4c3e0f368a7f0473e7b0dbb2ea2ad4e9da45ed0308b2c0f2208299cbf2ca59d8ea7a9b32b599f814a12fced4f28ee2f0a0bd37252b5ab388a8a5ea8dec12df54dded713b7a73eca08bb3e7b1e7e17add36612db7a0f8509516336eba2cc66e84ef8f620eaee746f536bf4db71507fed9c651848dc8fbbff1319b8410d92501e5f4b873cff51b271c526bc2feb00a22796dd19a4e007639a890a4c4102793cbb0dd829d6700d145c5ff263aa427bce1e9be5117aa0b3b17a69b428afd4fb26fcae90da430294e9c9ecfe678b09ebd43a6992c205f5d5bcac255014e994f2a54aba99fa1db0ef70a4b21f742cf0e967909a03c3214c5e8656e0996cdeda105886b41711a1c259134250e472f40ae65fad14a7e97dc5ea9bce9bf6cd75eb226b3410c97d85fad849d078ea1c3baa0831778c03d2d574c02d95ffc0e35c343b07340b1a010f697df6a98ce2565afb5de69debe95922b7fd2cbb841e95b5ee25ea939c33401511c1331bf7011f6553c83da6433e1b7317836aac7979d4d5daa5c97a1dad46fa663ddfd03557fff3d19498a22b1e2f07d63a11674f36ab2f27cb2bb7a1713465ca4176da69f5e8f8a5f6a94011f2562302f943e1a7a0dfe79636d9ceb636ebdee42d94c47960dcf6903f3d699638ddb41085139014983cf4ca2982d1ebd4700542fee7dc98540f98b8e29fbd2eda82684663d0422b4f1416ddcc0468f7612fd3543692e073de0ed02c7e160391db9c30750a53c5c7fceebe67beac6755c523dcdfd69e9d81e03664da35f20fdd2a0b56b95fee43a8edee9928bfa9630aaadae033da5b2eead0210245d103397146cf3fd7cdb9ba8681801fa7405765209b55c848c6343eae266f2108fd702ac616fd6021a3c789f35ff0e84af7197f22c8c9a3ee5aba0aa856ea57816e0d7cc0159a112e935b70da1a11d95332e528ef584c4288c5d79f8d6da7baa5e9ade23aefeddfc97209f12fd6079a00aa988d349339f14f4af7dac8cbcab69371a11b1618ea13be1df497008f841f4145c83a3f586863be5b72d8d886d917ce795201d9889481c77e0339c68cda3e041c68d95b6b5045550e0e30a860d4b5665368a53685090454e769494948be84175b14aa11cfd65410706c1c39eabb36bc66d4b4a89a7e1ca9f90442a0110438f0ef6cb935771e3b663e5e9615ee336823b41f1f21778c1dca4b52885b4af7b0cbc62a8d6665bd52189c87e50b825065f7ccb51deeec03a4be28bcfbefe6320a3d502a4487fcf0ab5f258d136e494d8449b0ee0ac8dd69b0cb859324fc585518b8e08004fc55e604e7a9fce125c260a798fef9665bf464a971de966c0582c749d812a904579c60f244ced33c75888af29c27fef69efb74f59c5d1822f99b020ad8c4230f8d65cb127f78cff1b3dab332b31ff330503d4cf871caaacb195014d6d585463bc313d05dddd9bd9f04a92eee09f7151e15d1715124c4cd9c00105001ec7a8b595c44065f7ae3ffd7bff062b29e57cabd4a08c781aa1092923c8ce8b78bd46c7d9823b89783eceec7366595c0dc17aa5ce28b4c7b046ab440cab87093de79a340e823c98e31808353c93e07eb9470c71f8f73fc41702d68d2db34b055f1e8dfc409f319297df94eb058df11dcb7450a73b76a73644a49c92228430cf557c36204fe47cbccb898b81eacd3b21abb8b41a57c84268d97a9ffc9263929a66b4fd1f8a493bada63827dd5cfaee9498724b52af77d433c44891e9b7c6b7f646408ef7d42c09afa4615b2090cc7e6749fe0c615d325d3614ba196ab784e044e88db3f8f62a2e95fb2527933c5a980e18f36184cc2b68c60719c1f553bc8d0d1ce5ccefe41bc648dc0341273540300ede6c305c3e3e480d306ca8ddf5205f3add34a58097bcfd221c877b7a80aead7bdbcb760a8e275fbc07eb81b612cc9957ae6da4ee00745561ef928850ea57c02a6b1db868b8f800feeb287c2c44db239c9071dea1ec711a6b01ba638bd1fddeb6ed5a459f0f755811c16fabf7e3b51b25d3cdb3c7dd1a3989314dc2feb39b136413b913f53d68db1766a2a7129e07e13f840b80b8dc8523df47b771889dc2cccf31fbee167db0827d7e2299f8f63ba0e32d5838bde8a409e3f5daffbd0ca3be063150125017f5e9a4850b3c075bb5662e0a610f71c3b222d6c47869c9145989ab82f08e5a4eb3caabef13c173b7830f89fcad967c7ece36888fa354cc9010ddb8fd922317753f80284c810cd366794443f699f5de70054fdf498483adbb11406c311951726bc99bc8eb5373af7bfca12bc2e46cc64258a5037525ab446394888bcca1d6314e3b1ed9a60a3a50fd7463f1a72ebc5be4af9c3a77e18b39a8fb9a1f4fdff7fc983b20ee0259f4251eb5242bb3da5814d6f93dc960c49b487fe0591aa1875f8c8d586e6c889a73a9ee87beecac111fe38283f37c533d0cd89b416e2f43d3b0510d39cedb4783eb77594854422664e201c588c09833a0542d965cc09e438c660499c2e63057cdd771b54655eab90ceed5b18175d947c85441c261ee6c3ca5318e11218ae4602c9cb5a35f860d4d802fd8d59aaca889915c1235319970ffa053e13aba8653f4e7bb52ec09bf1312636a32b9c1ae8eeec2be5b021c47c6d3c666ea23dcfad431c9154839b62c4b766fbde27404ebb82125edda8e36612d14129090fbff441abac4cec80faaf0beb58744ba863beb69afdb202c1693484b52b5e67d67c9425933763d46470eb095cfbaff054c331e3105944e3fd4c95f7d4f50d86bb324721f173c3727fa6e32d245cddfbe864feb94df84494bc7059146c9c35a59bd4201abcb94a548c029d48384597965311e0abe44f7a1fe3c861fda8db3d786d85b8f79a6a9cb1711148ab99464ec9c5457389dad2d0ffd27c5a366d8d4bd848819a81b410258ec18ca600df628b9c682d762a2d9c2329252dabeb1e27046e86026167e0a98fc26889357f484670c36443da0e54d4e8579892a89cfc37573be62911be578a65009bb73c0498bcd6c4f4ebe8fbae73ae163306e567a40200742edef4f5147e20c44ab241312bcd8f7d519b6ec40d7a206c4f8c34e801dc63cd1e8d575af4fa7e75cce669110d7dd74eb4ba0666c8c3147667c1b3040326d45f161181d77ad5a4d218753947397ef02a554054c0f35d00d3cbc7273cb38cbf2aadb748dbb1413f7fe816fe127b4f7825e52e175449334c88726b93e3e3e2313714826450514fa1682aa3861797e9f6f2bea9f0831536a7f7b819b59ecfd8df1a27914e89088210e2350dcffbece90e7fa8fd9690524ff46eee84edcd6259ed8b2919d281396230bdd3867ed61516d3f7c4054246ae69a22c9a4e7ce1a159592bad3b19ab6b7ff03764c711ba3392a9920e0dfc48da694d727f27bd973534187145cb091d748c6aaf673ba31eaf243621881f953aadbef10a4a7bfced4339678847049119a9843bec98993b58deeeab5ea7daf8f22ff160fc8172c6b95867d99c1e5f3e1acd99130d115d557400da29258fc2b1837e01ad41911404abe50e93176fc15a492725e02c25564580012e30b0a407f8dcf2f46e33cbb8461783ac28e65ad60c7b77bad155a7995cc42ef7f5d57fc11ced92876251f3fcc450a3058fcb26e88f038abc07c54b84175096a2507d33c3f8e62cf5c9a9f838f6c93d08275309ec833f52d658341ded66be53dd837e561c15e9190dd49be2557aa5c10d5e364b47718a1344feb1d7ee46f84716ee93cd050657fea6fa4dff6a495242e9dcc8f0facebbcf811c305476b708387b83776059c78b58eaf70d8ea4a51387229c44672c279b16f2f64236ab60c71dd95a80cf025ac5fc9bf2f1764bff5caf05706d3665907f77b422b3ba4bc65e8dec0fa4857ea7896342c0abf1fa5a378d773b08e4642f0bc69b4809fad366296fdc3b25bcce9d2cb5a4410c089f7daf953bd0b61323827b0a9471456d1a122a8cc50bc7ea02cb808def685c01235816fae22fea3224eefacd7b59d3948efb14ca5bb8b792a04b72661c3d007704e214fed93945ec9c8e20ec0c272c706e9ae88e38edcf01b78df7f5f897cd24bde5ad04cd2bffd5ee60e7b950b37412e374462619b4e00633d3d67478fb15a719abfa33e6b3c33ef69e23ce4bc951e59c28718d120e5cd4ecd47b7b964078c979a2b6db82c6a84603ff1ffd78a175059f46ea13fb6c707ed09778651de39bb5b67be8a9ae0ea0cc734d83461c6f5b9c7d2e264f60c645254b783ce4d24c55756f9af55a1bc9d5e5bdc4ef12cf0bed4b6196be6ce66d032aa60e28a58622303e818b354cce4353031ed8d0174ed5960dd05dc8810fd922100485d57c6ce467aeb26f8f6a7460db4c22ac8d102663683ca1a6bc1742ac587a6b6f7dae30afc6ab2f72a158f61d733dc19c6b62679ca168239d2946e5ed50e41d49066436b31391711046643c26b556cc6d362e206aabe3b200d37dbda26475fa0c52c79ffcebbbb283a68a551d2cb67ea0e55c9c3290971c60acf1a0f83542ef45f7a7ea5f4dd5439a9d7c37ebea50b3ea1666426dd6ec4be1a39423373086632dc6d3458267e395db19ed2d267176f87d922c4cbb7cb9a9a9ddd18e25f19137d962bd1455db2492cb61b21f3cbf037b195733aa0ef590f0b44e377d20335015a0f65ed2e28d1528ac2326fabbe629716a69460e2add26650f282d27a4a4fcde82e0903188f7f17434d5cf29dcca5e882cf39ad734a5754dd6aca2d43dc27e434e966660137ca841c08e1a40bc12fcba4cb2ff18592d05ebd96b2e2cf6064b04ad8d5c26dd33d1527913522310ef7048687809e50a0cf0fae6c089b5878829b0412d419fac143242f1d14b06e89573f0dbcec108d6cead2a2b78ca80310b9fb705d84f9a0733ea52be4abef8b90150269307f0c91a6c6cb3e5c4a32e682e3c706711eaa3d6f267b3fba88cf697ab76e4f86d344b1339a56d7d2c53916341e79d31683136013ab2241f5deba58b1e587fa33d752eae8b9015d3a7a393981743825efe720a5574e02a16cadf4e183d0b633234a6155d4711ced70e163a1c42cc349aa0df4988c839dab6a78eb0151426ef8414a6a4816b113d1134bc63ddcbeee6842a6c53e8861e87609184cbebf3009dc0548ffb4b2547bd184d7c65c70eb10fdcd0601d3c7ec0506d30a89d86ff2756b8a3cd807c49c5556445068de7d9f8337eb477e6bd5587a2d92115b2f31d33ae9a4e726506e27a4ba62155f90d1cc33d0b40d65427d48f69d6c1af2ebf402f2fcfe4c23e294c32914f641a208c7dfc9da5f7bcde04f907bb5ab824c117615ebc3f2e5f850aebb55dbb4cf544efac68f5ad9880881d53b8ec120790dbc3a276e0c424b34fb6ebc5866ba1c7c1992d7d611eec4bcb749fb7126e98e5109c0d5872cb5f8b3b070b693e83dcec4de2bfc1e7086ec36c571745609e9e3cb8799f36e165a294b20bad3bc36f215f42dcab9cb3a048aba193d03a80cf2abef1bd8af04ce9faf5f58ca58ee6a2223eddddc4eba5b3e778fb85ada7755e0a34e7211fc96b7c04513e1d9afb37fb5299f8c68c0d96861d22e3c4bc53a3f40b6c15e005b0d6ba8cfec684f31c0e9168fb0f6dd3ffb07872470b7ae5d6312d13604711d5765cbb5fe5a3a7cb95b72e29bcd2a71e5479e49d7074569e04384ba2cb64606fcc97cd71f15845a7128148d7386729e0415f3770af55f4230bf77775b671d85b0aa96ba658d1777997cb8c0086f2841a297e939247a23b12306f810d448f4c43d792cd4826680227a21e747e2bf0bdb11960861befeec92304d349e7092bd67f6d175d5ac043dc4d7eea8d5d93ac082403cffffacf38bb5075420bd27e87e1bf3ef04a19352eeb925435c5caba203ca1f20abeb6107498944831c2dd07ceedcf867a5b0d8b64ca8720f29b6a8e02a26f3e1bed3ca217db3fcf27987309c89cfb24a2407d4da2d4c61e12c81c9c48cb89198174a23d7cabea348f0310b44a37f03e9a64b5d2799626848b15ee8e84aef0a6d008364ad368b00f0c7203e956061b61e17a859671ea35459b8a7ce54e9c0b0404f69e11d5f73ddb92044e120a999b251bf47c972eca1e3a2edb8614f97b7a5e66d459e3d023c6ad9dab44bfeacacbca90647619507c8ec65a4e0cd66b8aa6a7d47f27cde19906558b517e9567bfed76c3de6ff6dcef0a18c7aeb9c8274d000605ecbda97fb6bf224ac8287b5b606c64d576a742dabe406bc0a8040a5e4f935c9f38c67565be15b095a1e0eab74c4add362a6e09a8a96e91712d02693908f605c6b5d6588e8698a1ddf32cf0f1d897b5aaa6c78ef8ff92e5afae8eb332d637d3c10de6f0c5ce75cc07d32b277625791327dae864ff6a5cd6758fe8baea47a4c72c0824057335076200200d6d0f0f0b8a5040691ab90ec30bb2c1dd8b12dba62548de0eddee95d157f99c43f8b0947dab6c4be8a0bd64dd8c96a5cd7718c1a984bc30a6d13763519084adee73a1011058d8f92424bbe986490037e57e88be27ec250e75e7cade58473da51c308f7793ae9d86c45884d90539ab7910e0e72b893b5060bd3bdeff40204253c6f7f0a7ad2f7889ece55df9fe55a415c7eb802bf5217960f8885469beb8e917ecde118bda3c620162118bde0868eb76809cdad044347cc575137548c1b001c226569d5ff9b4acc283800f36fae539ff080ca7f4b0f2a8c491729b0aa24e3bb9e33750a1c18a7e40d7e26ebf333f123a59617b460f2ab381547fdde97d526f91960a1a77d3df444e80b0e000a7c70d3a7b93805d627150ee49066e095b7c05ccd6c4207f18cce70b77226b075589963e4f4eb591c144153609bc9686a7dd9f04e781960d4af735eb2329814f5f4fad17abb9ab90903f520b2b727a059742c945bc9244eb0956d1eee9e34be2866fff91f91049d6cd6dcd270c46463cb402a57194961932bd4db03906590167ceb8c162d6c4f85a34788e9ea273e2fbf9fad0457e62445857c6f93bd791244f3f663abbf40b189f8c4f420e2a7372f388bf9f2672f526dca3e44348e955e9b5b2d34319e5f62d2d538be01fd58d5415cac8f92fb1318480f5efc1be1809a0eec4a6a1bd0732ecaa9ffab1d6368bf827a4d6081e25031120a2782ea4d4e8d32d0e7edeb1c64f8eb4b34d00c81cbd47ec6b55af94800639b25625b92c8df6bdc6d2b85e6de89418e1fd10575cfc9b2a3e5ea58b550c732f83ded5b59e52f51f88d93f09011483ab15d4b6fc30c91e0da4fbe72e1cd1ff657d55395f818a5bf9e73c83436398b646b7ac97073f3b361482420f71b0b9be5515a037a856d7db778fe399062abdf8423fba4ea6d3a3ba3258aead480abbe5e8102824dc9e362965c05339c4dae2e0aacf0278ee26ce0c1ee263994ca03bfd5f2e725a310f0adea404d51cfe71249c1fc1ab1b7e704bd2e45631fc03144232dfd862d650f6470e569804cf227fd1cc952754d09ad315ee22b783e4cd8cc3c0e8eb58f3c9289ef99a47d551799a928bdd82bbf3e9b0d1786aae6a22ac7f4b33ca1b71cb9af5cfeb1090ffe061055c6e37afe73158d32804dc4f19022f3e5c06a113d6f38be8076f4b67f5b402e33213c61a9785ef6ceb84ef17615220de25235e6dce3f1d50e8d8054c6ad6aaf1bb075c5055b674fddec65dfff825403679ed2efcbf6b72bd318b3beba0d9596c566fe5901dc999f4a36f268cdf37e4baf697fae6bf15b7e63728a45c6cd064ab21c701d874874139721ce9b765ac134d3a0059597a40a1a37c551ab6048a12880910a4edce6dc8469bc26462edddf8add890cd3155b15c0fe6678339712022399b0c822aca83ccdfc3e5e2806e8859cc190d6664ae2c3d9953921781f6454ab7fac1de47868e3bca6d6fa29985a8406a0d960704e2f1926cb91a1999667b31856b62534cc0988c0fb27123f6ec76b6f7dabbf2f1a1bfbe2ad9702fe06fe9f901ed9cacb3c515aec9b16172f913993de949d05f3b4562d2801ac70efcb5361c7d5be81fb22fd1c212534d62ebcfbb1903b15835428bbe30e961a002793748806f43e3de904d7b131feb48da478a9714784a9ce7659087a2c1861b1be08bcd5c3f36615682bfab5e9ac3b75048d31420ea8b952b5e5892a8ca772647d6383ebd0f896b9477538b38486f1cedde67f4c3a99973c33169e7cfdf9b452d6e607cd39f57dde6171a6153de3dae3cae0f636e493e12b62bbdb62f6946a46a41fdc90e770d0a2ae773e03f4bdd0855c99c41eaff3ea50ce6f5ce834cb9cee406047d9b238efafcebdbf31c358e277adb16116aa23c1ebb86b364b417578b6156dcca23888ff441f4abe85633f849cce8062e94c46a7f9fd2b338de5063c3ec1f6c1d600cd065777215750116ee13524928da9c230fbd2dafb6dd2b5a0363c5202ae8cf86180aa81ca775fb225a3ecbe0234fe9090adfb92b0ec6ea8897f5dfd173cc56b33eafa8f95944af8de622e3be92a9033f89d4ba93dc4bfd1d0f3cb4602abc9578438a90217ef87cdbdfc6663590399c3d3691e4b2595b8e46e05840ebe000555b410e57f5697680100fb67ae5a7eea490208012fc2fe41673bac377f4219d88b68d7aa51ee076b766bd8d58c472b5cfae64bf345a89050433ec3d5c301066eb89a4acdf798ff71e0830d16864fbbe6d09c4b98b0b45d3b4c0690ee43f5e580efcde00286635116c7103c478592f39fe5874012c3d53c4fcd7ee81951e8c59a3b9c074aca9dc2aa5b9328499e6761ba20a969d49d411e05dcc1dedb9cfa139a446c242acb1e23e8082e9754fc51114900dde636406291a9fdd4aa801859f3f65b9c63693ea413a0d628c98c379fe8eafc1663c5f7c3b915b844f50d72ff33df5e42197abcb690e9c716c47eae9aa1168a3d3f8e9c08ba014dad5dbceb17c8fa7f267dde3f239bfb101bfd0c71fe56aec4c4f9cde7abbafd0c5000fc6e17b7f67a24acbc593940846fd51ab07050475c6ad7be7493c2e968020facd47b2d5f001b23891d91135108eef614ec7dfe457ea8c0e99a49c33383189779b260d289b6471d43fc7abde04e8e9279772aac1398776a30230c0fc14b41d5847e6c08920424f9fea3ea2911727989ab8a9a74a3bbb9a3cd15e511d448be263311b0a234d6ffc2ef726db1e7ae89deafd525914468ebc0a230d0b4fc384623f957e37bff9ee13b08d126365ed3d7e5e3d432b760080b7c01b8269603d06c2050846ed0e22d2e4ae368c666eb90198e015c0d3f2ad59089595df2d5e5851f9d520e88d60ee4df998d7c3cfec89daeac751ac992d8d13082290645d41ed49c7ea199c13e0a320323d9c0d7425bb44ec2fb038befe8a712e883afca6c6daf0898d6637af308c94f0a6d8d8ee9144ea8bcfdacbed64a6bec2984dbfc0d199197b4e88c7eaaf42f4f56291cfc93e2f6b5fee9deb2a2ca6edc9cb1b42133f9a12a8c48f8049444e0517ae7cc3b8ac9d598e97b99d105c6584a719a2ba532dec8fae84f189bf1d8a5b05b69f370ed80b712fa93f8c1f9f34055caaef34a28b55f0bacd07e0b685cb6aeb9933aed7335ed2fa92df2c6b5d54fb0727c7fd847578f60243e33aa137004eb51681a1467f3837cb84d5540d684c7f2bfc9a76242d8378a25dfab62873e78b806e652610fe3daa7f3c85517de1d26c4fd88a5a774faf58e10cb66da9c5695abb9b6b66bc1945e511a236714a15f506cb2f44608b6038631a2d8eda736a8e785d8cb999e99f7c7614cf002fa83c50c82ba385e27e9e0417554191f927ab5527f65dab928aa35e3799b46a0364116312c3c7dfcd5cbaf8e5af81d9c221a75111efce33cb183ba5927b281176b873a625a4f7fb3281fb88c5cd273aea738b7e1be2cc64b5600522e3a522ad93cbdc7b13bd7e15056ebdbfeed56685e85cb5a1c8a4ac208e16cb608ba80638096a20521ddbdb0fd21881be34ab75bf0115875131541b8b46b684e9c33bef85689d7cf21735c356eb1024666350e5b37ab21e1b8ec8f5df68eaa89bdef5098df3423c83ec80d3628b785362bcae75ff75679fcc490a1064b776ce72b4af1a1faee84750207165ae6368e3ac21b9f581cc48d86cf91d9bcf1a0008024e3f4a50fe9ebad780a450055f28df1303bed81e106a6d6135ce695e5ea56c18948e9a70fa4b9ab7a2a88747ef925a5fdbda04cde8f5b20130416294b329e171848e74451dc0566d4e82a01df7310720f086c9d2a955c1d795ae5188eb816f23a854314577d31b490877f2ea61f56c38944d2051e5185c6f44cb324d14c53a46e58c867e431580ae6e9654ef87cd8a171b9206032279449e26a10b83f664566bb5ecd2dd778db3d93aeb7a39214849d32e0ec80dc488c740b639658854885cfc087cf0b76383a437c544e213d364e29d6778b9add699cdfcc6d22fa2f473d781ad1d58396c62854601771f0bc9e7e2311f53bc633b7a5c42bcd6abba27c0dccf61bd679e0742e9e7b629427c222f45f36f8101288aa25cda708795c0d731e8f96febbbd2d95f92d6256fa1dcce39b07f218b833fb83151044f487ffe18da7005ece70af135f528dd0da41216822b669a14234bb23072a439db8a74724ca190773d35b186e8ebbe5aa0565b64e61fa6027a0f5ce07f699a27498b442a8054a28d065950595efc040018c9ab5414525a5e0c480d0eeb51da07fdd424e66bcdbe11cf35a1c37780b1a02db0e7f51211c6d05ad536735ab254ae1cb78f99d017c87d6f31c5a4ab33e928ffc5f484b84633ed26352e7fb2383bc41d15ffe61b6bffbebb8eda2d1744f9b6dc7dea6791e242d4536f3a0f88f7578ca8ad687284f59411ca4b7835ca48c0db8f537adc92b238ef4cbb2452bc1f6aef7e192f7f3c31399e7e030205e5f8dfd88ade56d235eb0c97439d09fe2c4d870f9cd1666a4d99e21bfe4518531d16e141c6ff47fdc366c369968d93e1e9e146ed9b490c6e453299a9c0a8d62042be62bffa07eac80f4ada9ae9d77a11e236bca6a2553de313bce19c10e2635cc0fc26bd9464712a5042a537bf7a1dd8587fd6d8ec6a272156695bc17a9f3468d53f96ba2be03ffe5830459f438bdbc18ee84da8cc2eacaeec4554fd28b7f96cb42f1c969d695306f310e44b31620f86db49a3a01e69920eb88cf18756ac0263b61e6c44ff1daaab35cd0807f2743981c55ebd55f54d29e4bbba16347030f4af233f427ef57b1edc21b1d625127c3597383273d0863b4afca217de2b08aa46378d997e516f0f9f304134766675b5f2e6aa5714eb6b6857561a9a1f8b70f755f637ab2416ee57ddefe4cb77db8e244e5a728ec043827dc83a486847d9edcf9c6184ee508ee9f4ad45df533080158f41e1d6e0babdce6f1a17e58b09ec8cb98cc16fe7e2063a19cdf43c42158d3b99fa881f5ae6c32fb3cfe1d43600dc50546ebdbdaa4a0e473645abb27f7d1c8a2093d822d7ad1521b528a331ace5402b5dcd9d017e69c07b8cb097ac7f2d5de540954efb2d65380f40d0afb1de47818c2ce61f86d4597470f60eb67b423a0c975f4b4f18c7f8c8eacf44e0c6ea1c1490d2ff9f6d61333cf2daf167425a66af1ee4e0c5eddbde1f42e5e17831526a73986136707502b51c2abab505f34ad0e8cf27a56a379f7a89fab0922e5f737f9480249ed59362516e241e89a691677cc8c5722bf95a6539c1c3db2f1a3c07a796acef47113836dc9668fb4f80d8b457916809a0d1a58ec1e3d96ef70f64eb122be81832629c206f1ea26e49557026fcc1e7ed2fdf3593234e659ee51aa0a5ba65681d8b3822110a9d11a42401ca7386fc8e4c81b6bb475b9e4a98494039d776e24c8d820ed336911f98066c862069bd32ce369c7c7861081c28078c705cd8c3d36c506799ad127f930f4b9ed814004b1c3ec205ff7ff5ed0fb3fbbe2b6eff1f49ca1e2c4d801d4edaeff51eed253a4f9150486ee123576327bbf80d26978aa32925f322d3f5094cf8485582f96d8ad01b4f954f3c2cb8500c7cb9a78c1ceed40097bb608c67f45dd8eaf377bbe34bf1ae272268ef32078e6e238230604bb50c133392da43d2b9cc76bd5ffb038f67e94019be18f5cc41a44bb02e0fc91e319817bb9a5d04f8d67cec6e85b0ddbea7b7b3de183c2ac778c085b60cf3c93a5fd6ad0e4c7609763ade999bf9ef30a17402957af44e5abf420cad35f567f87eac624f8ad89cc72e940a2b6c078e47b8e7997c0e90b346c0ab4a4d08363bcfd2314a6c1c02c095bb9fa9a9365c1be23bdfcc16813fbd6fd11c991a11347649c42c88664eef9a80fba4c1de89b721b71a22adfe088426a823ae5694c3d4b9568b5a9dd8594ccef50153dccdb990667126e03faed54ef674d04bf57618c186c5c6fa54f67c3f91fbe364e51d6f5345bf76bec3098698a1d6d9d7c3011936a9bef0a0b712bcaab13a40717dd04e080bfe36002a060f2108f033893ce7c002fdb668dce8dda62c3a3b9f64a1b3208b34df3202dbd732df44f31ff1e7e7a3ac50149c907c8ff9c4349bec7326518cea927e8b1943721a9606b7c36adfa3f0bb989471fc967144c669b6b80c1d8ab823b5ff02a05c3b223740a26fb24f0f384cb13fefa251cc331382a1e80bd7367be2a274ec566c8aec00b62a7d6d0cfc5ba0acffeb9eee5e59460c1b53dca8bffd33b5f2cacfc47d109c9f47cc4336b9f56ce97c9fbcb88a1a47a26e38b2d632c05a5435b82e46fa98058fc0019f99dce4b9003af8f7e7252f7b6a31fbbe2252142b63e4e7d3671a5d5ea413dd6c22aee0aac12a61b7558d7a3ac5ea7fff7b4a4c0f92b07993daa520e7b4896b8149af160f0f303b825841f6977759c03b9fc527759f72cb5a256e00e492db9ae8b77f71ba9290493ac8357f0571df0e3c494681864faf11102aac0481639d256ac7925b15f3c05d579f5836a7fe522d68a8f5a54055516e969eb23c80d6f417cff7af4ea77e8fedb0068f8de8fd526dcdac24aae4bd52038d57d61eaeb0f5bf939442ca8ea4c8b32f8d1f1fdc9964baa090a91cabd1022d288a2ce6f9c825f759820e8717ffa3010c077c6fdb62f4817ec7587a6eaede012d9a5bad4a3a91086e04f34c077528ac132964644dbc85583f97271c0fa5c6f699b49505044db91adce2172ce4847673e888cddcaf33e1f828d6816bdb5c2d6c196c318eae173f030cbc98c535109cfc38945d19c90955adcb5a369c07e34aae883edd7f8ca1de0749b0ea225c49504c0db135149eb05300733619faf3c6d361eaf1c20a6871b2e20faff1c3cb98c04b3337cc9275fddc4824c724a6f5430011cfc777700da3cc641f5d80db989bb54047ff8199609979d64100a10e68bed0e5f06c5a686b788144d7e6728d6c13f22760067e1e2a2873108024cbbfa6b1483adc334cb850c58f0e5de6c2da8a913c3b06a8f40b07a3ef8963aa940d5229a3f956ea19a9040852fa13cf92bcde41046fb90f63e8969febab3b16096490370fd7e432a54b4a83f45bedc8fef3519fac9190948a11af4905d5c1478f2e49112a41b78e1920399feeb2fb779cf95c1b09bbccf61b275e48c386929adad3266f34eb5a7dd754e1f4cdbe01b17fd9e860800e75deb2982e08afb2b1ba45f2a14c2869e0164e8363656271a9bcf24e1f79359cfd947ee2fd188532ea3cf9ac7583a216ff628785722dcddb54011855429ffbc26e145ba0c87cff294cb86bd46d0940f5c9111b17fe04d6e28b6ca044331b359214be5c70b6899e578f0a0eab7a098e499d2bb4223a17167db24e7d7bbeb9ee3c7c06cec49bc92573ac39efdf9d369cfb0577baa5dad7ebba73d16619e4026d13ed26d3fae419af721d9d97e0a1b15429e92ea0b3f438a364f0e56940aad11dfbdc27afc816cd65ca71e5b77074d3539ae25697bdcab94251f147ffe5f0acf99b349d622e1e21bd3e7f217ca9517ea5d7965f11faf57a47649a7a414929e95f35de8dd757c6b8699e445655651a28cbce5f1edca3fed0136792ca1769cfe07042eea17d1303637824a81ee3c31f671fda943679c17edb7c8a6a85dcdc663021e4855e684707736d21d64dfbe917b13ce5bb86844530f6c0b83caa3fb6f4df55669290cb7faf56552c05921bc79b038868275e5d6e7d2eb6de46126c35d463751d424a23293a0ab4a40b68c82efcfcb8e73e5a7e01da2037bf93c94e762817c164327b0933ca4e1a04b752ddee6fba5a71e5b4aef4d5c28686190dae0a19bca7c85f61734991bec6cd658abd1c15dea63afdd77e72a5556b61d0ebf27d4f23d614792bfde9b61c6bb2a048a94960da62b0e609cf5078f5807420fdf9d94cdc023d8797d9a80de8066e1468ca8a45f8be4d2bdce4c7f2add08984d01d2096ebd5ec9b080be2b4d4253706805e8ebe4368f13c9abe388539b8a1ed15be684380c4c25263bc978295d2978e76a57f336c5dccd6fff585884d39c5f122d389097b6c72eb879614e0c930677ff90c28c0a525f4b5178e47c27d8776e497cb69573b6e48230820fd08c491c0267f5f0c4d7e118d6cdca41ae10c45a2501f9cc9a1072d3d98bf0cb47898228e16bc8bbe3fe3ebbd6c7d6730377d3ac1ee993cd3e598002f9e98902d668f743708670da71a2da8e4470759a3c4bc6b5306c0432b9d5dd5509f0a228350fa61ed7e9271185d2e6317b5a374aa38b8faca520f0a4e82b35b464941c5115049bc152e24fb67acf1b29cf1bb13f8f41a70120264579457e693e014a6b59b231e0167805ce777d27467d3414d355d6bcc3ff1113ae227402fca16d0118c9c9df801f07a8fde1d266184b3bc6e7322c241f842410153b183d94d58c2b98749fa966707a9149c604e635b0cddb119d948c50131b75332fff8efb579245bd99fdf043ff4b25c8adecc8a2d98cbf0e56a0d747a54a45576f04385a9a7c4ebcbf86f8b6d29c850f88c5ad57760d02b607cc76780429741e28eb69c3059a63c738c1328225202c83c2ff57e1df9231cbacd403981bcbbde363bd4eb1cec20756445865cf0acb70350a7d586634d881a2436cf6c721fb4070dd705292f2f7eb55eea6c8f73d55859c4134537a31b527cb9c89c30007d0c229dad6beb0156e9a06f74b16ecd3b3462855775b5baf66ffd0f2e020b9b9fd00cc8f6c70f89360d48d54dad583db1e9e1cf5ac6f2ad9f74bcd75d79a675c143366720f8917fdbc080b1f9dc3b32c5fbfd36ff81d036d56a4a7c275992a1ffd1234b53f3e85d85a834380f2ccaa5b224f53c1f6b8f25a139a737efc48b207b49aa57ccde514e77606b76a4125494dd70217a26d4aaf3054e4cdf7ed3c0c389e5e0142a1b78e457cd531cce5720453f714c6d8c41749018f5d2cdbca431ac0f812d92327d20ce9d77fdbeb86ec776bbe7d6370bf3f1b35f9feda4ba689b7ea69e5d777f32260ae2163080fa82913c4012dd5811a92de099f5a6855b3714f66a566051220d9ecf7fbea6eaae87cf68ad71dea1ecc3242706badf0fddd4a7ef9ebc7015d16f69723ac917b0e50afc7dcd9a6d200150d22e48beabbf17ab6bb96e62f99a1074cd1c0ec2ee3cd130e57c71c89a439ee688fae7a92fdcd20a9774fb8d2e4f0066f594a20ca1a79c0ec524603ca12f9e36794a3cc75f253222fb5e88bfa98e8a40d57835bf4243e57f38a02dc39dbb804a79b1d41cf54af11092b3ecec4b2fef20de7f6326ba8b99e1d117e9dac44b70e818b946e809dc97deaa0beafbb76307f830efbe64943dcedc5c965fb054db91ef76e59cc4053edcbc4cd493694854d9e708aa3dab59e628b3277762aed57bf99bdef6c227ada9425161a11d472367bc91152364d902c9c3effe1425a3e66ca79cf3d87c258bfb455fb2b327f7638810bc4e81a48fe811b8c3b2cbbd73f681cefa1436fe21cc78d1f1cdb51115e7c4d6a9c80da4b7b15f55361167a084f891ee62c9a819db7a78bdaa1041ba7d5dbabe1f2aa623e1ad40cb8dc7b2cb4dc75061b71b717be33f6050e210592c5e8a2fa01d9a0b01f27d208af42bf68a8b6a7b21db8af2caed8391e792ad7dcb29c2510a8b029e6b71ffe1cc64b205f251d31d35b6f4d97f2265d5e2ef1f1695a6ff0e8120997f87444447cfd344615fad886de19e940b6e1804c65ea5a09b3dc1cadddd0d7d6bc561fe9f283cf580a7f50a98a0c5729b2b10fa308be5d6b381065717499db4a5fe4c0d11be8a76e18b98294c90cc2a8a0a740543ce7b2b67fd84f46a2b44b42760c440df9d2e8fdea11e66bedc51ea64259d808fe893b41611999e57243db8767c517fb3334119106238c89260e086a57735503ccbb2aa4fbcdf17d93cf9001a6401bfd63f090548e9f9cca91a5ca264c0d1b50efd06efc38622fc906f4c51accacfc7034ca61c0c36f05fe6ce320c88febd1926074585b326320764e46c5f7062c7a694dc30d9a9fd3d9df711bfdbf7cff590fd7d518020c474d8279ebb95c53b2d3b86ec5a81a95e93e60702cd5fd2af1d7a1f88ca14e9a3f360af1bbc196963a08812a9b96afd1aa5579f08b9ab3df0a37a483244fcd9d5a775b225da7ca894dbf8055144bc3be91fe1efe9909318fc974a7d8fe1a619e10528901d17689c2fd6a0330f91fc79d514682af884f76fb54b3cd633d9c1065b0e983b87ecc3ce40e6e7998640bf0ea2de842b81978bffc367963195d0df724860dc1d6270f8f1687521e3da6267e0a8d6408445e9888708f1eafb18b168172a8d66957138f7db49d7919755d4fb3b4561379378cc40dfc8e60acdc480da826d09fd7f292442b070802c184a77bae871836750d22878b35d11b19232d536dad69461c7800a89c590ac876a57ea5e4a9a1b73374df086f7814c5c6291b77eee3a05e81081bb5f061c8f434e0936c38781aafa9ab983dd5393ee06497a7db9a47597f44fbda97e937541d96d1528725d23f921686978246a57e35766088311171f8b7a6546f1e581f59c39211b3a7a7957de1ea7ba71b6a933354edacda31b27cd06ceea007d4d6b3140da82bde884e8c2dfb44a7e64db26ce53ebe412f5dae452ce77aa39f0f22d4bcb4122682877f16880d96346dccbc37cccb47da6041f4e7881ba091fb7c29ad2861e33c67266b5147b186e3ed78a8adbacb5a8d521aead93f55459cef2531f00b80ec79a29d451d1df2f55bee49780aa46a6f00a4a6b2f1b98d7ea665468f4153c894c6fa511c073bb5ffc0906531f72cae20ceea14ceb12b5be19a61cdeffe976cfc18e1efba36e9e88bc3487b53a6fe4ff8c076b577a2c257b0dcc2348a1aeaa9c8717fdabe52cfd4607b61b8226b48f944691d94e1107a460a443efb6887fe2e0c6940a90f364a931fb48bad1d261ed1d0393cb51405eab2cb79390685f5f34b07b74b1788a62e96c9ebdab3ed857bb5ba728cd23de66c0c38cd8546dff022f18825ae7315b09ca7a1bbfebfad20d69d8ac76ef04734b161f895619f5f008da034d2e6e256a28cdc326956a50b5096e3d872d7a31dd503d097efed12644f1d090b2c13368ad60ae8d782ff3e0819347b6b31e790dc5c6645dbdd7d007b7eb03c200885fdf4018f34bf8ddfbfe88bca181ecc6363b7e1040cb083ad281ed7fe60f698a7d89d0b3fedda8e429a53b3d9fff9b60c2df9999b739ba86434c6917526e445675dd193a4314a488bc2624b4645d2b1bb8fdf80da97933595d1c801f65db4118bdf973f6ff9c6bac4751cdf2e11ce3f5ea9f0c09f9a098df496adc1966dbbae882522de38858878ca55825a997603e5cfd7e9933018e88eca5a6d55a83ad1db6be367aa2440489e2dbfd7fa81a6205b745da3c804528dc7db2a47bac3d8ab911727fb916c7334d764709009c533ef624a4e40ba1985c1967364dbff372129991a911fd6fd308e01e3887e8fb0de66a871785930916433a6627db9493f7bfbc93e0ce6ead77326553034a028ebf60f4e4affde64384e7e9c11a0021e52e88e215ae5f8cccb923e520fc920ca77c7204c4ffea819fe58c35ccd95dc4e41a1e98d3e16f9075bce1c558c14bb085aea92f3a3575676cfeec7583a568f65c75a5195debf7f4e88498f80abfd3e19ef3df412e3c571f2b90bbac711fcd7cb24cf445344d27f88b32bfce9fa786d72ce6ac166d44b7c9d69a1b50122627c91dab243e644a3b9d707e4cd9ba3cf2f2dddd67dbdf38ce64101ad658e7d1d929a0ace3466e4bcddb1a16c035f635e56e278148eada060a63007659adc14aca4fd726201aefd91a8eb51f1a72f50efd1ae859150c18d0d3be5a9fb8b82b9f0ee9353c212324f09c223699cb4555918413d036741f1ed0603f80ffb4024de207e8c40c0ec249f0d69f1b220defbf0a748e24c73a1965ccf1de5162080d15f5a8dc01a10693e5150530963114a4f57302883ca1bde6f4c76ee16aa88909a20a7eb9e6cfa1f451d354371cdb5570fcbaf0db602b4e92895502cb643a0959e27ad2e3f0f99c9325b273c00517da5fecdac30c7c334446428e7738cd18ff970b263c262ce6c9fe3e0b70cefd1e849fcb59849c91f66412d3a6cea1957527b8808d7a879350b9c8e131bd5ed79b7406e6c94c33770b1da624f8ff6aaed17fa364e712cc6186ef0f649f45d60ad0e89e8f5a51ab15de0118d4c758c054a83d029a6667531cf35b52df243ab4504f2ad5906c3b8cd00eef59adb43011d4a7d508cab2de5f4ea5237c70ec4ed061657aab2c0f578b63f7558cae7c81d28e922466acf7ff26fd659a4fe5cea804f66098bf8c84bfc48ca2db3fc2dc46378ebc17f2dc1a5dce9e45b5193c8cd073aedde88f78aee69ef70c70be540658a3513822b0791f9ea2d51d8400ff84970ee646655ffe72ce50a7dc26cb6f92e525c6c1d7345174a7bc79a6cafc7559b08e68394a1a661d9c1ef073ffb23ef93521ea7ca72ffa016711b6457c5f0d11cd4d2857ba75ea4499c854eec2a566366500deb5cdd2419e3efedee76c1e2064c77b1f89f85644d31cbe639ef998bb4e82f3ad63e8bf38b9d340717d2eb47389de64af481d8ebba114d794e41e234c2c788c309151fd45db7ddd798de2ed43217be8ae32c535cbabc605264309cd9fae88bb7b59477bebcac90775a8583b4cd6905df697676c238918f9171975156c13a8198da9a0eb545bca72ee2b70218678b8f2297bc582186fe4323bfb068fa87761afc05859e147d289f92bb911490054a69ef555d71c50c61e5addf9fa4aa72d8a9a1187257e9d462978254c3d7a4f46031abb94b754ebb60aa91d6f7872f75f82e9f577f2151e76e1ce8a32ee1d237960c9235253b56f4715696fc4b93b2a3041e2fd3fc58262c246c8acdcdb6a891d07e7751013faa48a61fcd9c12c8c9601bd9ee7c5d61e74ce7b3d90a7f4ff38425b3e398023ca4678ef6b429b31191b39690586e02cdf63885c9f3a97cbf1392275e59d4dee354c76937a89dde411cd15366d144119d6376bb70a383f7e6d80d574b2acd833c9229e2f56c5f78993e94abd05d0822a66f649609c8cf693f9053bd86a91dc6feb42d45a5c8ccaf39201699b3edf55c2cc9e57320e0b33077511e375c4a576f707de01832cbd3f37e02ff4021790756653a710a66a84c091926e5109998a6d5b5bffc2ffc22ebfdda0c2aad2b05cd7ac5ef9c055c4048846fa082aa345639b28b234f9aee54bcf66efdd12d2c7573c4a68d3e2cf5de86df712fe65c646aa647ae5d66d8f6c038aeab04597dca28ab16307107a79dadb1aa26c60bada65c9a0a1c70be416a942ed8bf88872365c168a422ffd83720b318a0c85d9072ecf7d224101d398a6390138761e4f6ba9478541c11d9623df35deb4c6078300e3cf9d76f08034baacea11c884a812f94b548f0f3edc7d4f74f52b4d161679b931776c71c02872e46c4115a922441a1d8ec95991660ed6b99369d5a60554949b156f83c5fe24c151964e8eec9f2b4a464f875eb7ac57d3674b3fc63abff99c8058ff8ca7c2228495364dffcb0003ae8266bc1ee89f8ca893bb5ae93598791e0a2a5484625ee4c9df439785f85a315f3fa443b3495aa2e5bd06d4c99e0dfa018417b081515ac15ecb3787c082faca506a47334572976a5036f452ec989c23c7eb69de745b1bca8d05d96421ed7b8be95470edaf2d631780d7d45a96b31f739cc9cbb67a1b13f928b03eb2734f650db4476c84e2f3fe50c63899f07f4a05400955b8a0e4f8e4de964ec21af4f45624834d6ed4765b2ea0817da8740303a4c40bd928ca7a83da61141120c1fa2a8e8454ba21e527443fb49f5d537462755e655d5ca481dbb8d23c59f125ad183964ae883ede3531b84023fd192634b14efb6938424963558e8a2a2b24fd1aead3da22dd4b2137521b5c2e04dc69321a055ea67ad0eedb1b2e9f26b5b99269f3eaff016074aacf7d0ffd07596774e793d172d143ef05299884091879cb326efc3e595d01894338c9f99d01db6c7a590910c074d3952502d82465083b6c3b8d9698ab44e5b7ba36e8c0f56f7451214232c0f4984ec8e9f470dc747ada938f429184e82e85973bda98b62f2a2145054e1a422d07cd795c2afae943f2f0b504ac61563a9c65d21aa1bbc9878eef4b817f3fc7eed2ab1fa428cbeb5c445277be345151c79f53ea52a93bf10839737c41569eb4d941d6f7e6b3d71de8a22ac32eac097b692edc7138189df5bcbd9f09f5198b38f899a335210abc79ac8bba26a9ccd62d324037122dd552e6c23caf46047c39986b25ec643ff64834eaa52c9eba2c8cef6bcc6272babceb56b3213d03fd9d1a9c6eeee91a8cc6a0adf895ee8b93887502a0996f36759be7f9c654c9763da6bb8b5c086dd773915bb25b4e0deedb6cd51130e8f4e05b724717efc6207e19595ef12544a8e9e60cc215ed9795430b5a9888dd976aa661eac584c31499efc0a57f58402f457a71fe46360118eef6cd5efebb8505d377113ca9e7ef06b9313f19a44805d13bb126475ced90cb39e888166a9c53a6ce888615b9163f8c0f1716f4fd6e21cd51cf12a7c3d939aeb990f8f9a1c000f9afaae1ed96bc6768a813d36f2d2223e59bb3e42cdc1cd819e920944af7b7cec055325a0c5a101b2b7252c011852aad949f0e311c57d6b57e802804c9e591824d0449ffef033dc4fd60749e014dbf5d1b51215caec17ca57411c66fac687f56413c2532201873d694d7f47d7b8ee20805adb12722e52af5d975e6103159b2487359e55ebde99d487f281b28e33041a26299296ea406f8d391aedec4420d200b823cbc49c83fc2d70ffc7596d3d49ea32b889883e568285eba7bef16f409ca11ea3fa07a2fa1ddc9a78dd79ae027878632348ae8c19556509f8e71ae312964a41c42a795f05eecd00f988a25ef72724336f27397c9a1ee26efd7de8dd91f44955f2ee2120c71e313a5d6f5c72958c1d8afd5491b4c7c744cc3c9c6859eef7b299a12b74b0b3c14ca9e7dee6bf74c6486acc8d8661f94ddca2e0f97110ac93d1fb4e028e6fc50f13b952eaae456a57aa07325fc821e5da7a7bff4d02af2110b2ecc233965889d7ff48bd65a577c8c53eb4b5212df00da0466da889ed7ae1f0ac33b5f257993e70df8a9fe64903831800be8f0f8dde0aeeb10abed78fa16f225833c8beda0da8875c2c3380ea1e19da6a502cbf68e6a78517ce8e3151b303a418b0693532d3254440ba4092d9838a5db256ab3f1e390e10ef68c1acfc167cdf934c0273fe52289661f6cc3f3c18a2d1412f72610a03afd8b7feb921081d4b9ee0739f077d948c963e2b24926feddec6e8aa66925a44bbc7bd252f9711c22635601b61448e8f0e44f1a728349440f5954fc411656fa9a08733c86fea00305595e35f9ebc79e528d2e7415a344c0cf49933dde210fae08777e9155364a37ce3a89e53c4ccb817b1dee0d8ec9fac07e8fcc483ff0cf8f4db157beafb5207df795340f3082e867d1f13cfab587defbaef85b8053bbdcb6e399b8831fe6409b5a02fe6ba53e182594b0ab9c46c3fea61a56edcf4794c804732b6306ca0542a8c3fb7b332244d5a70ab67246424c0ac916ebe1986eacffea4cd15ccaac58ca80c651fa87ef1991ceabb0254284122cb8902a124332d223afb246c2bb994a2e9b20ca74b4538b14a687cd4caa37f53b69048839909190b4e87dea111a4fed5cdf2cffb8737288965938794def2203663e2cf94c1bcfc5cc8cb547b8d7f477afb6f989267c6e92bdca916960a9f959cc7a5bed03eaf26a4de7b2c73f2242ed7cd0fb749efe5c3c64666b6d0b9f04e6c9cc9df4adfdbb90873cbbd1b3ef784f7a9b24b86a3ce0bb0860d4ad8bdb36a19ea009ade982e7c8fe3b019f53a18e6b68a17cbb852883c5813989ffe0332a71eceeb804adaf7498cc4a5a7a12d96819ec604fb436dfe8051732ef1d5c8c8557352d6392aece042fa651eaf2236e9357076e94ecae3b05714c4a416619ebda9fb014e89eaf5d340880a010fb059a206b5a16d5dc7c239f7c61c138f11b7f7ccca427be0906e9e070e1f2269a4f539cae4d2fb88d7bc215fc612b39bd0245dac3d26918646530f9f2dabf7368c80f9e604274fc16b99bad73b3cdca27eb63dc17407a28b4357caa5f364b397c42214a4cb8da7ca3712131ffc711088e14694697b2f3e65edaf7834c7d80f9cd632593acce117a9d689b5aa65f09fb06f0aa50baf777d998cc50044cb78852ca020d5a5f65b9d7ec1d34b84479b35b089669643ba632f4d3455c7a9acb4be6af9f8f03e7bf9ae365c11556854f957918f29ef447533ccca05a09c1cb926efde76c781eed6545ba0f45a3ac7487465aa4168fb7aef5a37d9abeece3fa4f6158235e1fd82dc814117c234d72fadff2a1a5853198e4467605f6addc2123b2e326325b5cf9533afdec573ee0c63db2f120fe2e4e367ed8ba0743bd1270b78a1f02985ee5d54310a3be6ce5e27c9a9fc640634b27234e0aeb958c07de15c421c5043c4bbc80213150a6e73e80edf5348a342469c4b82d0ff47e5a4f947a773a0af770bcb12c46e5c56f2bee342d2d9539442c97e3d3c252290ccecdff9c3d2eec9574e23a9db2c243b8ee152195cd5c99a04b8e29d8303d3b9850a9fc937a0b8fa2357168f4f212d196de5f18c386b048c1e50f6f2ecc8cc274bcbc284bf206716d10e17234cf3c8fa8d628b03729a6d4b57b3c6198641f3dd709a2b40b3a84f8c407e49c349d0ea606bf765fa9f277de41ade50c567b86a9587f5d8a01515e34df4c251894a7b816f7ce575fa144fb463b5887246a6584982e0db9d011d3378451e9ab92879e67b0a65e5af0beda026d62b5bca5bc0bc6aca7857deb6275f631998946150330970a20e88a80f20ef1d4fa408eb25227882c56e545675e96b6a8c075fda402be652364d077dbcced8754b98ad58dd9b8487bc04047e329568783c9146e8211106e9682d9a5fb710a8edfce2fe86771e4e3aba3f38be0dd2390242ef6ad4080a94abe443f2f363872442817d118a4d742bd5d00f384e75e41d42f039d4dc082da5b611fa2db71df57bb877c96f1829b56848807eb8e52036bc5d48e67d729debf19bfa97b5e83f5887356ddb65840226a4899dca3d05e8a499e7ca4440321251ec62869a88a5d0d3e2c3cf33c6cff86dff84ec874d07c54d1426e97fc5581cfb38f8263d7a98ff5b9185ff4774d5cac79d0b5364ed6dc94a2ad3d8d372a095415d94f1d4e5da85d49bc77eb115adb6c0fe5f7c4d3026ee3905c36d15509d74de08db9c9e56038e5421f4341c1ebbd42cb11d01052a0b07ec1a04d46a8e5f5d365d7d8ac98ab74f83724d0747c1ca244653b3cbc906846b74b2f98871f9de0c0f76dc65a74738cfeb8d12fe020c98dde073f651c7e1ebfff05196d95572ddb55585254339457632d1c8d303813ebb41d41d518fce65ef78d4f17283fcaa09a332557d57608a831a82bdd342d06797546636289e27f258e25b9fd1355efe1f392a793c0395e8eefd02dcfe07abf54f897961e2e528b6a18789c28fe86679ed7426a90036930176df68639a0fbf44f760444448d9a9a00f8def99f4b342b73f8fe5a26ada1daeba9bc6574633c023b02d77d3f0b46dddca166d8bd967434052e1b70683f4487719ed800d875f45402c8db74b86958a5753754025aba806875df19e2f965d9bbfcb37bb33e6b0c640c2126bd189b3125d06c1acd39bd4f28ea436dd28c29f18036064b879a7e8c7f16b9c84c32a014b944966da0c53083ae3b194c6001000cb6a5e4612dab9e021be5369ba7cea0fa0e27e0827b79a688eddb901d76eb66882e02b32b34456325b4e8715050d692ea8c088433f9010468b61e6221193130d9aa2193f68e06fc464d5284a1068ee3d641b7a176191e20e243a287c7e93f6acb882ee4425017bbfcc3234d8ed7de059aed78a106ed7722e6ed7f044db0b1d374bccaaa8ab5a1a4eae322568f00e0d4d04575698be5b91a93d44425c41e2b7e09480bb839b21d45191982bafaf17534e9a7422e0717aaf09f7acb1e4c459b58437958384651230d9fa0ea1a8db7b833289e37d8315f9b80956783ed51d923110124d894b54b336547cce21fa1ba0c8d2a8cca3d71c2c4809147f93cf74436c7ad7b99cff6fb5fc0677c88a8a6dc5659c901e9b7af80e4c72a1e677dd9bb73f743080f3c6d40845ec95bbc7e99f73f926162d780c9d387b89d652dbd6962f0b40c83aa2feac20226f1caa3a96ec705eebd1ca38a912027b8b0884bbd3f2559b7f492a2ee00320cb50fa95bb4ebc7ee22e07fe4b1c145fd823c540cccb651fd5a5bde5ec4e25b626156de62cec451fca0edd704ab1d33e5c0144255940366c68dc839eeb6a77bc1660f15aafeea3f1b661b4424bcdcda6c91d0a403c092e6e9efb688f0225d20c943f9efc20608c4554700fdcf4bb96d8688f3fcc0f1cf708baa046bedb980fc47089609e9da614f3554063c492e6c3b86e8d445a885d5e4b03f95d7fd4bd6ba15f4c88714be40378fad045a72e958eaaa64d7429ab91d8c266ddcc833125bd4ac12d5a18df2b7485012d2acacaf688b5e64a9935a3d83cdd54be0299b1a42c65f23cc46b5c50fa386828d6c7c8b6e9ce11caa667a512ba21484e67f9bb386cc1a650500c7e2a35bc829db07177286c36343333260c2f50fd81f59d17c442c6dce484d81b8f84ac45757fdd79d9bb1002dbc75d296ad2ca40229063689ec299a624fa4af5aec23af67bd7d50957defdf420ed806b1e9330490ff1e47e1a78a11abe4b864968e4bf67f5a7de14768a995d2c6579ead5cfa31e5fcaf76a7de2d124af1653624b376d5f75255f0e0e22027a9306088be9f94f42649920c9aa46a6605b72ca127767578ea57724e841e2b30bc97b833cd38959ca0da74af66110eeac72a4cce2428edc424dd253e40666322ef9e2b1f96f1f6558d71f942b1593da61a689ea19cdca28b8cefa5fe4254cb071db6cc6cfcc75f6fc14cab5a6be5408837d8e56c23c0f86c48d2f16607cf4dcd47547704df9272f71e9a8a8a98f9cfe6a7cb48ced1a22a9c11d98ab07e6fb32966e0bbc5aee7f1ffd90b96113264308e6b4eaf40f57be678b471840934bb1479ea492179fc1cb033466db66a4497c4fcad2a1ad4fe92a8ef6704e3e3f05c860367820ba3d1cd5fd03ce921c6705917e11458572d657d7ed106e26fa7490de5be94eb7505484828b7b6e0b52e58104d02c2b8aadda19b2750370c818e4d7f678aadba7d632c07a66d470a1e0be0afde2757cb39e71efafabc24384d2823668eecdf3d4e59b5bebd6f35e7bcacbe758867d858a5e96ecc394fa7cc815212cbb0bc6c4939451ac23863f8f4e2e28cd14db8b330716005c4517361c1396e9f3cd9455b7774711d0857ca2e6d506fcdc82b5487a428b46a3ff38be0b5c73e3197210160ebfd0c421ea83e0db409de552bd6b88186f22293fd316a2ba32cc9e1d585b1e89bdd05fdf237652dcecec4d063bedf0607dd0dd6fa7cc2e744dfc22bfb8ff063808bbca9b0c753ae05ade7836610259c377368978505dc518219d75924f8e79a070bf6edf83e6ea41b9f318b0220368d227530cf015fc17db430831c5fc5dbec9f612ca79c4ef600b9b8bc8cc172fb67f1202fb1708b2cc135f92187fb36bc467d0fa68e04fd64fa4bf3862a4e6170c05508e5f751794a8197a3d7c264b1651a34cd422a2868dc4edb04c62b0b59a0be035671322636038193bac4bcb371b655126dbb3e6912f4cc20bcb17f563c2078980b8443fae4c3d2360e5c47ff402f3094a4742a2deb19b56d9af188de9f06aebabaa96ac365ad94428f3bcb1795f4538652dee92b05837f6063b3396e0c68a23c95ca9deed4e33c6a2c1adb625521896e48107381aa09bc341dc7c348e1f44becf64e28507c29292e0de99773ab9f09ccfe74455e791c4ef5934124b354508fb03b59a81db1426dd10e643135de326ce7ae9a1ab2a3b50577d22b39d450247ab64100190ea2a85a84bf1a9f406227ab275f5f3239f4e5195d4bec8ac6b83b9ef7e4ee24429c2f5cd3d539a483930185e4e09e3949f75444878b10b81cdc7e9bbeee6b35755ffc0d79dc24c247cb96506ba03bc164af9a5884899821e2e626fbd62acfaeeca13ca92b350c7a56c123a7e27acb67c44750a6ce1ec5859afab6527ab1876a3ff2a2b2b30588400fff2e4032b3a9f73bed6bbe8f46c4a41faa78aebd6e7fa2fbec9ecc98338daab61498ea7a1c91258a9e4c84fb9e979db03f61427b888f53b7d765e4aef6e9a9d5e4bf9ab933e9db45375e525d29422f19f96d661881451ab1e82a31c00076c0e8d464efe8e46d3274df21c8fdd233d350df07d8787ab74f445853050083e25eb53b9e7e764fa60f3fa5137f0def8c92faf55f6e377d68ffd0c57a87930a727c3c02863c1bfdd81574c12c8cc8f91eb8c682ef9960387d94cb360cbe291abed570a4cc74e713e6d0054d921678feb40d1c8711fc413945183f2e0e96c36a32fef83fab245b0d9e9b684ef1eb5abfdacb2b805c2f4d699fe094e8187fe1b8cf3cf0d04eaa8d47f702f7ab4712d3391a76a5b9586ffa5003151c77411f2e41e5cd72b7f4d0cb1cd14b873373a99466379e13571fd16587de5c556c41893307c79802c4fd9d0297988cbe4760215974fafc9a777cc6aa40efb76ab6f9a724c52cc259bdba9c74c9e060df09abcd78aefb16440917d2245341d862be98d50dd4028daf5704e4d64dcec8a987c7a0be399b03086688f641caabf52e9b14b56a42cb560f9527252f048418f57541a9429eb000e58da2e362778d09afa819224576899283bdab5d709f1ea7f4ad7b7cded682beefbf33692ae884db7ba5220eddf3816a36ac991cd897599a5e50826935bb28c470d08e3478c7f3eef9efbe11a8edc527ff12b084b9dc007ab665155794f850231a787e92df9c7188f33daea51c25f8eaa48beddf757379dc9551ab29a2b63d91caa04e579862320e37c41bc7ee65aecc31af7f8811152b200475eddc5ae705041d35f4435c27b93ecdb9dd80fa791643adff37889895444cca373ce2808969c201c3fdd2f17e389a964fc15d26e7d32bdff3872daf3d5d5508c9f2f30bf93b612fef248279653122451c727661ee5640f859b00009d575c5248e6f39148c4a90aaa76cc39dfb9428c5566cd48308e47ae55154ac004dbab2389c854e00e366095052c070fd54672a370379d012560a272035a76c42703f6a66fabf3df2e7edb099ddea50f2c869ea4cc5e14d6dfa071d166e197cc500714f0bdce6dadaa55971e374e5a5934b5fa8ee47dc81f3ae23b685ab9c0be6af5a9febb3ce65338045c9d4665f88d8e5e5201e6498a4f8d8db4c2862a5373e5c2f2824b51d142fe2a2b29f42533474c2de6d0ac7734bc2f4cbe4d59a5cf6af9b14a54c3b8e731dd4c906ffc49097b28ef2b6b44b33ff3a60aec98d225b138db64a03b7311ac12ea174a4d0909fa6dbad05b965bdf1b6251abde72f9ded4b8b895f6f030e3a419b6ad77722998c7824ccf4ddf860ebe4b165ff507da6637458a8277f9fee67a89e7080281a3e314323e80c6b55291da6240b6a84be6a111c6636c3f48e74e73900c7764ea62b0dc1826601cf9c539e8971b883680e383a5cc065f84c017c1601c329e0fcce3fb2a33520ed06ed8b739b63c0af623508c169e83d88c1f9c2a4f46805f821b0a3ee4c197ed7780c03a7102d0b8eeea45b6c0dd3d28bde4c3363aa3f17d0a351b801ca5dffed01f9dc0c5bfd11d708d4e7fc839bc6b87200a89b228241f599bc9c64629faf7471b74c7d086948d5195cedf3852d85f6b85c149fe7078cd749e4f0d27397698242216c3ee3646b55046334c87d48f3a7c8b8f72869d39ce0fd75f11aa7597faca442b8b258618795aeba3d543bf9855fdab0ef2c6e88765e446d1232b721b0212d22040462a00e98130ef808442f6b0526ce8c1ed2ef497294dab47e3835ba62bf17f38bb0db9388f6ccbab16c61360408f003d2f70672f9f169c9d0cf46d4e7fa3de5528da02e130286e58737e7965a73d08a18fd812cbd7aa2a86a73b0471ffa9abe0d11da8c3c2a97562c0a6ad0846c002d6b431fb581315937dfa69511d27d05ed2124fc06a65097cca723c15e19c49a362070ed53795103ec4cb9481501040f3443e3e9b67c62cd323d913307314d70a5129c227598e51e99aa37f5d9dbb18fcb69077d18da443f7f1ef4a6493e76818f0ea1ae5c6ca50fdc77d53e79c8b5ff5345e0bf04f1e1811f3bc3e12ffae22f1ce5781c7b7dbd7979eb83f3d523d0e82e7ab3a8bead60ee7a747ff63a63f7dcf43acee4dd338b146671c8e717c18f2414cf7921995b64d536807bd85824b6ef051fe7df2b586fe5757f78dce75a55e114e9873bf4b2bd9b8a215cbc104af783ceaf1b1608a73fb03d51e85dcd241b4cb1a4454c0386e6660d194483a159dba7849617c8e79ebd996c4fb7af0b7776ee5f8019e2016ed037e109fea5d4011668eb4cabe2ad993e563ca32d9860b0e6138e9f02b83b7ceb304696f195bd3387c59544004a10da7a1572fc1768dc0c0bca278093ec978dfa7c7d0403f76c0ff092340b59cce030661746380e429b7056564a698c78f84696a7d076e231e5846235bff4ed9013cdb813b4ba9905b313206f8245df56976853b970eeb8e8306e6ff037f6b70284c747036a2f9e7eca87d6904c3226efa135d291e1ce21a0e89edd5b864b611d390ab2fbdae9a65e1e1bf65ffaa720db625f8cbf38805c2e33bd8c35695c64ff0466a192e46bfbeb3064ea296f5bc579fa67ee7fff034c73ab86e317b84ea03746415fd827b361132e18e4f535956e18f5b758a4c0e06f8b32833ac3230b3df666dacbf122df5a574beb6157a6c35771d4551f4f839f170ad2f41376624f0bdc58972d41187439289532f652f4d30fa8ab1ea19c763de5b5769876658f9a337993e45c945ba0cf199cf55b7eabd9414b8a6a3071bcc6717f2bf61352ce9c340af45f3423515a079cc66305362c8d2f7222b5f0d4ab4feb798a7342cb071c8bdbdd175c28916ac6119a9d1083f358dd73f1f25c27bbcd089cc37a41d4f344840defce024bf8c5fd1926777d0a178240d685ff3fd0211faa468a653862da1afc57442435e6a0e196fda5283043347394e9a9b8e317c1f5b22cbf1e502d9a1574723efe5a7c6de8307eb5e37214a9ef31ab7e47d2803a8051b1292bb6579d6e148c74a378f284b704efc18d9c45b4e0e7a4d4897605f6bbd670f4d8ff5b5f682e996995a5b16319d91faa478e18ec81b6ffc99e76cb2357759e18052a85602322231eb948dd90c5cf748b4c36360e3fd005c83638efdfefc8551def94322f2050ef61423983406240f9c466fa0385a1d2eaf12221f8d5e14c6c18eae70378951e0213d91f0ef4e794fea1d9c100d1e12228ce07e698b9feec8540e12b122ceb561400428757f9e296c3ee91a1088a2cff0ddfe1091f491a6409adc201d6c9dca22dc4252cb7d1df6b3161417249eeff2fac575f34e654cc0132b05832f3b83d17c0c93bc126eb487d47e699dbd3d4997ddfeec30c012eda229d893170c76c3f8768653c2da5b4de55ca5193cb6789545a4571e93d9ec08a3c0fe61ecc9f983bfb1d352b8f9f45224846025c51ce4a6bc6a3ec43f070f6f0a8675eb4b679306822ff1d220ebea6b17feab89566a003f4af37b90da2e37240c7c4513ae2b3d4355e4fc0710e84a2addb0a3439eea62e7ead47d3681ed6a356b4e4533183cfeedeb966bf6dc3c915687e9775aa4ad9f1de89261f5c821c7e98ea6eea0c698f00aaf730ce4b89a30c8638d24accfda63f64b6d301c31acc823976b13fd3664b64a6d9e13860676c0057172580ee79f4e92a436f31565fdd932df42e253e064d388fdc93ea493bb5f5040a5c7abfb758f87a99fee2e9ccc4e58231a4a06ccb4755d8761893e02a1cdcf78e68bf3a23b111d21175ba33be6d5b844adbe0adfb28c0dace7b7fa615a84ee03dc8398c36ef89c7a0084fee53a41c557cdd5070529005b2f3f0d2c9cd8a1763b1be0b556ba824ba36f0699d8d7d3330182d99182bcb3c23521f6b016b8f5661777ff0d3f312c85ee33544673672fc6cc017b5ff8a891e7bc943d6bb12d465510eac1f3889a878ed76f7d36c233829206b733df7a0dd2f2653a4fda81539888990b2cc7e9914d8894efadedab77014f58f94bd13ad7773e135f7422fb626e84f8d9afd3af0638d9c6b98038ba713e76ccabde9dc1da8c8dcfd989ed62e1797139536000115844a509b485c1070495205ebb8b3a3f6a2b52f4717cd7cd0c6c91e26be6757dcaa5653b0e305f01d01a8c821b25f3e4df5c7bf1d74653c8cec86aa319ef8e63d46f8373cf851e8006d8a0192482a22794358f20add0dc3d22e772f0fd9e0ce475c4d4993145ceb7bc764a340c7850ca5dfe69e42d5c1744105011fc7dca1ed2da22b019cb2032e380e087cb22ea95b7b403647fe4b8c66b11c5e7bceb98b57fca84344dd893ed88b5d5746901714daa20d698b61057c9bf175be03653a88985457a6b0566d10ae5a4bd08336c5f9ae1796cdc78ee23eef3426032a9a41009719aadb13440f5e7e814e7a1389ec771f3fc6f1af53c786e0078479734a457b00e6f34d1a80ec30f014693d859978ef3e652a3062b4ded254e4e861ce93bdc7e43a919ad41e60410e20055d9ac17549133d3d8ec0aa4fa4c69c67c13679119d5e640fae25265618fe577384a0dda5c7fdf449c09844207f838fc1634bf120085141d5ec4cf303c5af1bedf3cbefd8aea4dcf83a6b589c827abc2f4dd00332b33d5829b30f90ef236d51dcbf0c819502e02b5b8ee57362dcf155114e25b6d9c70a651d032bb720dea5645e98daf76698741271db40d0082178ec8a6ade8e86584c16a6194f2994d07e276cc2df606ac8f262d4f7b8bfc4125c300c2389603e13c545ab56a9ccfbd11be48801ebc4f5638de4ee578b46ce70860194a01c0815d7a25db3379e49ed618bbb25f30be9ab39957ed38ac3930e65337f066e86eb0e5a17b10d5e394ebb5b5c5d4506f56c450339ae9f22255c45c3b6c83257a8cbd5671c753f243aeac800ca0d66626fa11505e2a78d7b0425b12abe96e9daa1128fb05f8330af63da6d11396b8e099c5d842b953c7b89f5d8e88bde91cb76139f61914a6b63cb147f6c11ae33c6191631910c9eae14a8fd61f4b49da883e662da080d60008eeaf1e2975be66ac99802ae39409d87afad9e5c0be801ef99fc978d48f6843566de0c4766888ff7a4a5de6569110d49e8244e3292bf57f86f4e08d71ae52a86be155abc8bb924ee522b6078c5e735cdcbc0bb74a0c1b7d5dd75d581e5cf3baca292f50c57e70498b72c84eb00ae559dd44f3582ffd169951c4ce8a6c88294b1b59cc606ef964b5c8ab80be18132562cd7005b7fa0cde271067ad2ff45ebb0dd5e699e207e0eec51145a63b8058f2fd540204ca198bba2dcf0c7082e79a783cbc52f310db3ceca529b7a280e2967786f6337fc95b3bfd1df35e8257f502f81e726193b8dd243ce1f70dd26adc71bc00b48db34334bbd188326c41890f909f8f89bc49f8485f105ba7ad7ec96f9b76d0227b48e5b5928ff8b387895e8db6ca8e28050d6e3b153f37e30f6a314a76475e6963ef5f917ad869700faae3f3ff73274f7ffd538fba6f60d45bdc1bc65da47e971d372c99f19655f34c578418fd1f6425c7bb1dfb11da1cb7f4f55ee69dbefcf5c52837a1da0ccc46ff14af764777a68ebd5554f5490b2b1621aeae9b070018eb46644ea3a32babc56f7889d5ea5a4e0908fead18916096d7ca2bf501619d496a4bcab417ce48e0235e447596204b4028ed12ae533a4cf06edf83522648d046ba1a35fcbe98a0e437983a8d7ab7cf7ce0ca25b78b160c074bb4e1171a2f124571846c1ae984277036535832a34872f91e774478b0e3aa8a1f16af629c691bc72cdf517103b499f70e47b4829229d28220a78264f358df33a95c2ca2d48bfb2d73227c25b9ce0859fba09369160a21b48a3e65ce434b157b9653683c8c60862292031cbc1412b573dc600489e23580499fe52670c7c686c41a0f9a7b4fc68115805bbadfae451d747fc4aa06c8b2755d788972e47be09f986c72f3c196128498f4bd8610ac3f000cbf481649123d9a63d1af75f182f75d312a4218c86f233bcf644275038c5560708e87ff791c6bd246b1581571f55de63bdbac570a1e07090a719051e6559ce7ec41153ccfa28df5028f8949e94be5a4f98b73fea8140047f7434d5148cce9024462278c02a56a0c86d139278d43d632058570cc15a6cc3fc667a9e98c8bc2b906b1f1bda658abb5160b8688dc15751bee33adfa0f27b07dcd68026f695e29b0417185a57f422cf31e46c2e872a4415727dad127813fcd91ff28160950d656685a6d45524384da0f26ac7ba073086a03e88ca022eb5782bae38b589d3df471bcf64fd9b947ae12c91c8546709139884ed847e939b8ffec3617eff4023883635fd3ea1d45ec53258f3e9f64ab7fbeea1752669a05320280c145c38d3ba6caa4782bbdd48fb9bab8897b40dc22b4994a91fc6dfdd8daaabddce4bd2bdc8ddc7005286c1804877a29c72fd3739b8ef7da7dfe4c8cf735a6c90d95d3502124b0522c31e32a841f585e82e4f379914cf156ed310a4e9dd1add85e19838b8a6459e70bdf915b1d15471fdbd341dd6297c918abfa247b1475cd9a7a7904d9b9c1f5b27a10770d5153cd685800c4732c9b6515e5b68038673228dc93efb2772c367dab6ad66560c948a283692174e896eb21ab4433f242b95a6351d131719747b3a5fefae82b32c59d594ebf354374e59aa8de74c75957e5faf35cb93879b0da5cf0a8759adae696612ada4719a1106a6e0c0a0fd9c96d842777bf5a3447b7f3f600715ba08aeb009f6f71b477c642956c8ebc652831a8d4ff1aa420c82603b8d4c92fa2b5a36f133761314ba21b772444b39cfec5e16b83905c09e832e2841853d87fb9631e0788355116db2dd6a8cacb54c7f82ac4381c27879810c1f4ca97fba59600278d8c9e3e981e6166416b57cd03974277b8ff10c823ee90763e4339810fc441e4f5a34a85e9f345f1485d66878591ad8489ec39c28508cb1eb9f442dcdeb8462a4c035062e91240ac379a3858d0140280acdcb74e8653136becae5883b0cd622aac28c5087bda955742e0c7c812033692df0cd2c6c04a0094eb99b8c8065d6dedf32a3f80997543bff66018b252c69dd11f8c9180f962be4d6e49bbf090f98fa7e81e81820117219bbe5a423d7e72ec70386f0d9969317c4d34f1c5367ace8162ae88a13d2c08116627f4b98df7809b587bd42d18e45d86061a8cb30b147de949b9ffc5a3687cbd89b442f933f7cef4c8d5b35ef816198a528ae3e07bef7d7eb78483a293dd3a1b9b86cfd450eff050e39d582ceba5ff9595741ffcbd3fd2b49460c1556a260d74ea53dfac87ddbbdd541c02e93667d8889b6c8c067669278e6230ba570c29de199300c9237638420db1a4eae79bcbb745d045be1d36bb659f49227b376d81389caa92299c982962fcb4a48b78a4d165239117f79427a2c432d4ded051b631dbad55297b427daac3dc0a520026d3d6533eb75cb54de4dc3b7ac92a85c4e0c838cf314e1ee325d6c2ff8862c28a11e6b35321c19c9cfd7d9ddf2614fef56ca8e35f399f044e005d0c10013c6051b51d0c6e4d82b878891a26e96aeeefbd86e1960c18fc552d682e834d34b749a75179ce98c71b7a1fbd0eba65dd634c5932a62679fa3c38fdbd19b7a64ef5f47c8208a32394e9910f8d0e960694c15a082a4b8bf3a4abe2610cf599ed600cb7704e2d23533f6e811a755a979456f54378aca6787e8665ecd96170292717bdf773ac1c684bcd5c83e09ca171a3133e6c1d60b212d42cd9e31a0864272891c5b4cd3f352fb</script>
  <div class="hbe hbe-content">
    <div class="hbe hbe-input hbe-input-default">
      <input class="hbe hbe-input-field hbe-input-field-default" type="password" id="hbePass">
      <label class="hbe hbe-input-label hbe-input-label-default" for="hbePass">
        <span class="hbe hbe-input-label-content hbe-input-label-content-default">Hey, password is required here.</span>
      </label>
    </div>
  </div>
</div>
<script data-pjax src="/lib/hbe.js"></script><link href="/css/hbe.style.css" rel="stylesheet" type="text/css">]]></content>
  </entry>
  <entry>
    <title>2023.5.2 - 2023.5.5</title>
    <url>/2023/05/03/week-36/</url>
    <content><![CDATA[<div class="hbe hbe-container" id="hexo-blog-encrypt" data-wpm="Oh, this is an invalid password. Check and try again, please." data-whm="OOPS, these decrypted content may changed, but you can still have a look.">
  <script id="hbeData" type="hbeData" data-hmacdigest="934378479325634fd0389956800ad43ff69d17f39f8606cdece59186ea4ce72d">a99f2d1cd7f89812758242c57c62a59fe859e32cc19116fcceb1abacce500da0960986acd07eddb3568f524414b51feea94ed3a8842a2a7cb58681a02b461bf770f84ee1401d0da18103907eac52ca77e0f0ced5d320f2caf13251d4e50836bac57c8a898bf0c1cc0ca6d4c7977cd51c8aaa37d4d8ecc3bfcb600b970b3c77329a431f3e1244d28073937ce2a856fe127ac14c333a6f8cc70e50cc5ee795bee190e358f674b04207e2e896ed986327e42bb194ab6bf8fa6e8aefa90ea6818f8cb816b0f6a86b54d807474e2469232f46190fa918e2c1ed30f1875d2c28c40c9b650936e97d1d4aee608b164cd25a48c1be6b43df10e8fb0df83d5cbdcd280ffc21b219a967df453c16ff11e1888c584ee63b97166be5379e6af149b45723f862cdfd2451283253a0f9ecf406273fdb73388e00c4349743b47cd3eca951009f6bb38c2aaa257bb6c6c6f4925c87374c19a2bbf3bae7b1d7351adb505a76e95226c1f74b9dbdb2b49cad67f506970f98e0830a0e7ca46bcf369f661df4b60d23d6a75cce7149db8205e500a33cf847adea3725e24b924dd9b778325031a175f501d0dfddfa9dd4c8f27e38ba54233c42608e66348cc979a7a3b9b3616196c6cb46048711aee08c1a8411ab88cc546aba0a72d045f2bf1dbcd8e3959fd14e782d35b7550c771754fe1cd687a4e3783d319281dc26e93cf67d3f4585af8110c1b55db2bc52dbc97c0d298f272860430cd39adf258b5604ff74bc2ddd0e23e5d905eeb8d519525cd3fd1350f4194db8844568d7521df4cb3ce54b59f224184bf63cdf984c346cabbb23dbf794cebbe1bcd467f9a87da7b127a59a242cff818085463c863083f165664d6ad2be8f123882921b9b103be6d96a009da063a67df83879a1532e4a6633625a65c7861d9e5b0ec6232653da49ad4cac88f8d03a695875c27a15bc032bc21c2987667aaf07b27941e6b63ef22b3e0a7f963abb991a4bb3fd64c7c6d7b46bfe009e9f060f9d29883964273df58ec372d4a2b3520583b271d063181d8e24fae90097f1485179e8240853998a5a378ba979630e43334a89219f3e55731e1aa236c273ace9620486f50934acc1cdac0c7a3c076c8fb5d99e89661e96122c2e8a104e7c850016729d1aa7d27fa9e45f54abf097d88710b52e8dbc1df291a1e12b1e9f84a7eb6f1b2695a32be3ee183347c2b7745362048048da75e23a98855241c2e81a96adf2eb48db43b746f08631d99baff4bf155c56066825a69fe5cc59cc6d19b15de7ee7cba79594b4339d8c4866018ec8872a4bf77d59821669a30a6b934fc7cef0d9e13f511923293a79e62a09736591b6f49251936dbd5ec6599a8741fb226cacb4139d956bb6aa134bb22254fabaf7457ab787117b7329fed6e084912823395606aa9926ce0ae85e70183fc276a90eb35d00bed090b36dadabd51e2efa08e6382a60b29f98a0fd87a53aa842554dedc8f5d18b5d8eb19cc44da58e50b650542694ae4ec5945961bb69b72f9c97f99948d353ec40999ad89f6e92985b94191da84f08bd482552f89988ce31b4926adb786862511df5c0f28701761cf4d45934b6f360b4d4ef369f03021cdf5cd1e1a83badf38bad4962a5eb23f2d6dcd6f918c034f5e2862b6797fa42e5b5d914b2340d8570c3c2748c545e2f3d0faafbffc7dc5463919bfdff7ddffb6092517289d18a57eeb1e25914335d414828507bec291dbb757f2ea0a67a7dcd7d1187b1153fc48718f087a0cf7fe62a4e5f19e0d2ee9f1f96703d4fbd8ccc6f17ff4fd9bedf910e7e7b7c21c4da7a2bdd5699486fcd8f27647b954bb2ba46648d58b27d314c02c0329a6a824d8d529c7ccbb3d28b589a60549b626016bf166fcd0474cf024ab7745b85fcc5c9aa711274fa5b257f10b620538796dc9fcad45f5dedaa639dc06a07473c056d34b8847275f1ec7fb51ac0fb7dcbcd1e5ade1aa46c057c8fa391c16599030615c61e63683041d09338ad191bf22f281f644198fd79939b3026410329f8b672ef97a107ec5b714939bef92a4bd897db8dcb2123c8dd00e9d10a04296ddfc44af9889f279af49242ca56829ba4777ec9485a8642dc905d791ae0ccf066d57d0b2d0fcd0ee3a484e29b9d2e078a03a34e50bbb10428fad353209563568649c0a827bb0f0330b9725859fcc48497d09fdbab875fbbbe6115c861a5cd738bc53593a77a6fe5140cbc4265feb668c42ef9f29b00be32459539b42f1ed40280d3dd5bcf0bde8aaed92bf8da8f4f87dc1aec0e1f5ff2916f66b00eef3b2d5acee1c3252cdbd0120ac8eb66a8ed7e22b77aeea85b1ce68508e98e54b539981b506193a9bff8fb1551af8d371913beecdcdb8dbdcd8ece0722f8e4b5aa495fc61a831829682384d7a7df44573aacd551c0d566147b55297d34d6b4e77421120dea109b85c7de5c457abcf5966d305430e669552ab6d8594fddb7570be31be2d781fd6fa9f14e2a49002cfb996ad045fde5a08fe1f001eb8748a4a432f97b1947fdf8e75e607eb36f1542670d72798abb969c00b1f5e5a2d0dd52d841bbab4e42dbb3622633c83dc8c7aa353644485b4e84be0079175d0d19f6d01ca5db9a3a4f043b9993bb1d7ab3b160fd6ebc6845f4154c36ef4422eccc066c987d9e1b4204880f52c9af32084a1b297bbe400488a0f1950e6e1321e6020e8f1d65160eafa1862490d72b80c95015d2ffdddfe4015ea2505590b687e8e827c0c7cb0a76e8aa1efdd79d9f64152a5f80e9ee812880b858e8b26eb1c54ed96de27e76e67800bf1b0c23bd5b9050ee37ce5dc53174b9ce013ea469ad88c88a534a958c14b3db0aedb0360b3340e4546cd7c6a2cca0455a76f8787d762ef9c7382245a1e9694469804f464a018b6bcd000699ea28fdb99ab8d8b92017eb6c8f0704da66bb4f2b442a5a5400319f776ce9856ebcfd76adeac8a8f520a3ae9889cbb788095c721e7faa60a18b9746405cc686cef592d31bf442850c69f41539d83124f15140aaa9308e0543d2abc70d46d9ac3afab5f3aaa24f56b341ca7187cb9b3d424cfe64533866afafe9df82e7e850cb8b32f5c874ad908015f9422b34f851d7961594c30d511e7f178ea9fdd8451a943cd445c7c93ecb5511f1d33660634f4daf3b72ecebe78eadb36796e1084cf7aff35d6c1a40af5505af629881f77783ea8f4840cd7a0fa1454d11892f5e8648a4adbfb38a624a22c5fabffbee467dc2bdc7e4ac4043e3fa5fb3554fdba987eb270894f4c66dd936654f5daa5a91e342b4fcc9cbb02c58d3d9736956ced769676da476a9d83fe3e73641739f8eecd852f2a6274f643702b2fbef0a788d36111acb22f3f6db40e8112df51b069ce2d706e784d194bb324012feb1ce39a046bdda869d1023c8194b90e52b2e588aa6f164a105b6129d644e7da697d5f0d4b7f2961ff48f5a9cebfb434f33f2ba165e1c2abbe91ae0194104a772b801aee18424df7cd668c102566255b7d3acbe9c536ceb3d466215fcc592e79cea17705f607f92e100bb5e0383a9af8d50f0d2194fe2b58e2346fc1d322226c6bdbc4c2bfee3e2888d32b612863fe435aa04fe9137b8dad7e0b8d705637a328292f07cd426330e0c8ea949756bf9b9f1b8ea019c1a7dde35998b47499f50e64a127dcbaf2476dd83d777be415649e904af10eab6aa854c072b52875740a5d8acc253673553ab521acfb39c5063b6984c3d0007aaae645ca6445e2914b2c302137b9b249bd59d9b0ccbeac4f39cefb29abe3bcee7b93934332928ccc07aa85ccdaa0fddc704e1bdaffa4d558831cf92e62426c3693440ba5fdefda85ca522be2eaf8779b3a96abc741a4b18f59bfe9c9b879d54f525afe463032aac8ad7397d40e1d2e656c01eb6e79cbc32ea49c0e0e9a98d314cef5ced3462d2bd36c9378fceff92e624e65de0f64b370520660be9aece4d46cbcb1267fc472a24f28a931087aa100551216fb65ed54e279642e10908aa57c9cd3839e5dacbcf75537c2ece2f3eae18e9ae4ce53a9713c336f81abf05db08c2fb3440c82512b3ce420dca52411a57595f6be2af88f06af5a9af5c43022da1fd98d5df6aba9bc334376561bab11af2a5f6f6df69dc522b5f4031f5ba77da2bc0edb08819a7dca2df5e278b6c35fabc855509dd2c05a0582a4d05bb8880c6f8177f8a1f5336c7828d4e6eba92887cee54b4d4d3c35467fc380f89c3cf0cd3ea60b722059b627500fb05a7432ea47e421b984c9b8d02a45580f34931c16c672eb4c717b2a19e19d6636b5cbc161e7e27c46feae03f91fa4c794487f27a163899a864d7378a0faac03354514c09a03c2e8c0ae53bf58583d8aac976d2f912e325deafded04097cefe5317ab1b8967ad641548b895a926c09b9e384a5c632c10d0d1307ac49f48d4e086a23aef94dfab1e9427bbe906c882a005277dcb86db057665653c76af2628918167387e092670103d1b89bc6fdcb8efbc1ed5f2541a5f4d0cc9706a1fd8d0840d95947e24a61be49b221d93382bc8922578f8581dc2a335242893f4e854a6730d1306043646cca7626f0d392d780fa10945f505c4f193ebe7db0bd32865a9f151e9acee34b8e392f2f2017472d49a06f2f35d2c9c5ca36784587d66dfdfd9d4dd0c6878e04ebfe03af9f2d2748ea9aa7e879f0e10f96fa341294e3439e949104c62c1cd272a18ea9437b59b07a2613c59e22554389e7b3c534d65ce2ecbcb0ed2878e54db7ba8e413ad7da2cffa198526a2b78be31798cd484bcab87d1bcef06801cb2faf0fb0c1808426f22d16f50df7270f4f2ac916a7b48c6f3c24cb269e3c63774f8e20f7f75fb0c878e0abc1aa363ff34e9817fa60d6938cb640859301fca126fbf3b7df0a226bc81ba8c1b5e7c670f48b2a57513276584d8554f3bf6a3ae04b8e670710b49923f8521f1c94edcb75a3322b0f74f360d24edae50afb95dcef555105fbe9d00a36dc89215131db26cd10a669c34859579e6cc75e12cdcb2ca6e8a952abf593732b6d57be94728f056e8701516d69398c7c690c28f5543287cac6c0a91d2b165907cca1196174e3820c39a1837240f34ee3df1d0deb3b769bf8bfab69413176ced2219fe8271201f35533b5e8d7971b800e2cd9bee63b462698f8bc2920676b222ba2ebbdec7899d3a82dcf52f49cd5578897aca3b06a42f5d8dd2e9501df633ddebe67f668f5ea03cccab75c2eb362917d92bde832b95500247371808152d057de67d04f43a16f1ec5c133dadc9427798179d2e08396f4b0b585570d0f169609c38909fd183a956753e359da0b12717acd9dc48346f54e5c7c1a9e1d5e0665ac7c62204f6e364f0129331cdc9a60b037d52c124ce9dda3da531afb592208869aff1e2ca2c60fa056042f35d398c9ba1f95b826d550685f6398511b180a4657bd5fdc4979bd49242de5abb6970291227e9a6762e0306a0da6170a1efece2c45451b46fa6ab9ca6f694a8831bf54b20bf4ba5d810420cde8ccbcc9e99b33282408840b5409f435319b045b94a39244800ca37de30cceaf5d5abf027f58a1db932935c81f0a1edb24d348e4bd83a588a1c2d075cb3780f308a9f8cad08ce0f43df4e608476135a98ec80ca8ed9d5e6ae79f73a0c8f3680078dc3f7a06f67fc0eb0ffa350c04fdf8c80bb614df6cdfd79ce28b49bacdab34c4c84ac922a309bff2ec14f866b91cc2827001bf24072faa9c79ee09897f311978354f9fbca3bf98e8214df11410996e4218e7a3404217596af352fbff140f6a0d1f66bd4e9887b2b19d752136ba4eef9fd5476199f942ee42af9828b60f73af1aa2dc9fc6575cb21a514d915bc5cde294cf33c9d6004b85784b884284bca03712c8b62fd1ffa32acd07dc3401e35bb6a55bd3d2e43fa271356878e62563e783661ce1d331f6d673cf618a6867a15a4b56dab4e3432b14afd08dd4bbaaec8742b891a6ed8f58840f2cd0e17bdd567fd88213bcad1e4ab97d9c4674375cb87d912672e1e5f0bd5bd9d98619299668f5b5cd18b0768c1de496e6840ea3e4a8e98f3a025b42cae9be8fc010f9860574be6279adb99d1fadf0909f7485aac20a7e4d640346601c52761843cb0bff1c4a3be6e45d5083f379eee1ffffa617d6ef71763c05659638694b767e6bf833006c18d7f62d55268b83d7de714860ee82ef5e157ff5c3dcddfcad08cd17a5c2c3059214750858f906b5e635baea79b0e9bd1b523d3da5c29f79687e91d201ee48308ff75f3c0f6447915c48c77c8e0d77244b0e88d403009cd26046782c8ad40c11a5a15aa5a43adf85a9b34331f8a1c99ef90ee4fc22b345b796423f019b5a82b2ea88a47dc761a0cbd91d1ae3d3a45f79d1e529dd91ec87febaa783b102aeed3fdb43b6bc6434628816133ecf6c0aba35c68cc3512655918e7ecf8ad459f9334413ab495a79c9305c761f5aa40181c0df4d8ba52e4f646ea57779f636246ade2f99c50c79bde96527552e790ae217085e08874876f0b95b6129f0ee89361bd120ba64cc7e13594f45da2452636e6c8420ad32867d689bd1fc8773ac1d5fd21c76ab474e3b0342d4ab9ac6f01a75fe73fea3935a06518e3a9612b8a29c96f7e10d76e187ce2331234f38d4f73d849e8cda4664340f5c6530cb0aa54f1994d6ec81081d0660779e22e3cbff9a5897dfdf1717681a66a5ef5f41021c0c880e0ff7ff3a10c541fcd4069f8bc50ebb042335377699209e33ac25ba8a98c9aaef524736e6d87a32b225baba8837dfb7f8f797954f7cbb11ebb53d51bea233dfe8d3fa5d9569ed0255e5f1bef701be387974363d80afde43c030d774d1b94e91601492c26275f7792c38effa8ef7fbe82e0e66ebe3d3a7011184d8cbced9eeb97fdc990e2318c5b75546b3e6ae4946e5abff62ee9302731519fbe064aa1543e07e079fbce0938089e9523348214c53f6cb71690ffa634471c3243549f6105f136b9be083ba563aa969ea05e2bd77301dd23cb1cfa2d509e2e145e7bd6f9e67c29d0219756de60706d169378f6a8f8520fe04c3826d64bb2a2c69f00971994f810b294c62135566b950e805f6c89be54d65de8c223cf428dbf4b39402cde967dad456b7ac608b770f30ea1ee9d916a34ce50fe21634aa4ffd54491ecccff14781a04a5821463c6405153ce55a42de2c6d0616e6d740adbc085ca0ca44b6678328c5bc6316239f963be7aa25551b28493359abde3c05a2994810b6b3a6fecfff024f221b3b11cce30c16ddfe3ff501ba094488abd0a731366ff35e7a4bea646f6b7486208248525ef0f157deca3b92d2a37d811a4f490e43106f9476a498ae4b10f15c0149d599cfcf82afb444ea07b36f0d054b860a7c45b69fd561ed723a714794374a18111ac5092b5b796a4d92b916d2da735da6b925d6d18c3474f767e14e6bbae268911c1af357a023f29ed3b97cab2724684899e097998522a7c3b6c1a2819f1e0a83fb459ce1ed156f9e7a207169f4020e4add37b3d4d9219095168bd2c4b85ef8e6dd3a6f0619399cc50208eba7f43788792dc2734c8bb2431ccc8562c99f474206cb2bcb096e01d5d3cf7888d93cdcc1c92eac6d63f8c37f540afb95380271ebf58532af9b113b10bc97f759baea29b0331606661166fb103b514acf64539db4733634b49e4e8043440df08692cb86d56c6a8319af4deb5e4bf39694f01b89c924a90af31bea5e4b9621d3da347d52836bbbbd9d12b823e424ddb1857a14c28d26cc0eb5f7dfdfc427593888a5b14be05eee1b6a110e1f7a9fd7996f13cdb2e9a72072deee3acc77b595f3ed93f8b4d160030d3fef2fd105632e58a2f9e08ec9a98f1d90be9382b3623a4ac966acac0f55026e3a8c92ba21cca1d44bdde72cdc0627caa0c0f5d83e1d7424150918a51ec4378ee09cb26f4d3cdabbc54848bb5323e74159ed46a5ae00f939bcecec5eb07ae63fddf1d8b6f9e8b744d358493a0084c44d3ec48ff2c3c5184aaae849038abce178f2f81c41efaef192beb52cecc6855f7d67b6af02d7fdb32ca306b2c37ee5c9c85a920c49f9e4379442e808ede449e94f63fe30f5dcbe6033e308c35896be9c5d924bc329100eaad425fdd527bbe8d7d5be35e170fba20adfdff6e32e167de9c9fea88688a4d591813ebbd103120d8f4a6b2644bbc31e0126ebc2a1f5957d5b7c3e911c8ce43a89c3cd419b7f5f3dea5d27bd46270215c2f63ef0fea0e1c6c51e366b9f19f128786e7da48537fc54caae37decf0ffaa2f772f5a3f3c8dd6e9bb1847b46fb2f593c7319d5bb74fe3e4df0b51e8e940aec041d41576f73d92a4d9c75f5de58f4b1919b4539fcae0a801dae2c389c781964e3988ee8c815a527b57de9605703a21d0b265b3aaa3b95a47638685a0941d0bcbedd3e2a383ffdf7949b6c9fb6a7fced9e19d1e1a1dc03deafe565aae67a46b7a298db99cf92d6b60bf25987812c63e6c12283e276ef1a89a87f95374b459fd2c671404ac4acad78f46e13e2e35120b3a4ed4813592cc5eb41b4858e22df875213537660834e8264af2bc61c3ad85de23d1069f0f2187ab70514cc49cc9d9f45b485f1378fd8a68f4f17dd3ef353b70fc0e8c075a18de5173fa429a157d782f35fd91af28f235c895c2e531c3f92a8896b446d828be4247a30efa33ac841e330afa830f0ed32ae631ff73235972b9e9cdbb8c6e100db7721a28e7f2e6453cd83806fe6d5b179f2b3ac5de52af0d5713e00ba96095152730e2fab661a44aeabdc5f7ea7a8505df67f039a7e93eed3baf1256a7a79a310aef4fb7563659cc1585d62648fe234045d1cb3aa923904bf4ff7c4bb238cc41c18eeaca293349b95b098b1a0c45872a9a061887f3f48a58ffaf7729526a19fc5130457940c6eccbc638f6b73b095f5177beb15576a5b55730bbb6a6c2984544ba9f755afea5877e5bfaf1873a1446d57df5bec211c055950382b43323ed2052170bd8e3f555b049f0a20ae80808e5ee4c6b18aacd2c09e1a12facb870fbace1bff8a8ac3f569266b8a21baf4052459d4784c89ab836b1a62f6653fdd22cbae16266071fe0dd04ca1c628463c4365d8dbc736b92477d6e8fb0edd071026039fbc03c12332c82bc1aff2c0ab7b392ce72a9561f07f591c4734f9050ce7c078e50125091ee9161326ba41532d090ef62ef4819bfcb17f60f2b2f2af18854f28b1b3a795334268cac1d8585561be3a8cb16a5a324143731e4fdb5429c6d19db0f0006aa1220efec3eb83decb24b6f64d3395135b7f586550c6ec12cad973d13acb95c8e0972a1619367483fad55b1ab89a6dec16cd76b6715d57cb75d7413da7c9ca2806d1b0a959e17ae782ef7582585fad0c084c7f2d27cd97d9099f7a087c7cfb0cb9ab6d2b1783cb7fa5adaf83e3df819634b705e709a6e1bf8aeff8cb7e88f9f6d05421a9a61e3f781affed99822a774951737964a2bdac61a5883ad91097f257b68368d25d856dde012dbfeeecd2d1a0d85c325eb9894dd8d2455ba987c976a679dc0b967c09d228fcd4f0d90f92046ed6e41ccaa1301c24c1ac80db50ac3163d3d24f74bd2a529edf6041d94408c031783de56e7dfe8a70764813cefa2aa00b11c9f22e844867ed666a27b9a4704107bb5dae6b0392ac8f7559ab8951ec7d07f814c58db18fe2b21ee47d35e519f5a75ea5c685e9ce4d5dc8cdabcece430818674b891b580668e5ca87a4584ebe25d33e9d2ec1f5302fb2d934a9d541905a66f7f60bae59e8b788a7b970f698166fb64c1d44c2bc928e62954e6c2cae4bc7da11bd6e409e920378bb816b3789b7ba0aef8f40ae49426c70e80016b039f863141a8ce91e60faccee6abda39b7944f666313330a22ab0bd810b0e64a1a663a2528d4f6ac1947a0d4cdfca037cb875ce3e0dbb8a5e977d67c52e2827479999f05c5feabd13ec0dd2b83465cf089979075d79cd7a3ace45813b5ef69f0c7c5c670562ddcf118394468df8ac6fe3f7ee10217276e3bb7e2f81b15ffa8e8753cc631fe4e5a1ed4265c483dc0e8024e6d8a47d3818e9c29943fab119a730cb978b5e5998beb4ae96d6a66b8f41decb50ddef4656e4c2ce3d97d8e880e704bf44e90930bf5345ca00dd72b94da4bbf4ba3a8918361304e969d9578ec9e4e21f85f1d9383690ce5a6f931c17549ac81e8a37d465e1ae4f83262141594067cf92afb588b59614c5d0c3ef2dd1779e6696e3b0ab775260468925d55c7d87dd514a4499e7a0613c1ba5b2381eebd251cbfe6bac267e716dc1b8ad3cc5bda8fea181ed218aceea3bd7db4a9547b5a28e615042f870cf313efd49ea6d79d5d4ca3a2bd43f654ee1f93c7aeade21c2b54794f3436f304f846585af4ea87c9bbb8d70d066617e0d5e7a07e325262ec1c8a7b44bdd60f2d45b3e35bf62d62d9edc45c47cddaf2db5934a98e162fe9d677e9ecd6b1724d3adb316e3d2c97b53644f0769a3604e890c39065355ee4364da3922737d39518e907ad77daf9718ee967dbe751f050ef8a829781496661b45837aacd28f628e726d53a374a99b5cbeded57fc5abf94d67188a7f6a8cddc62352ada32290ae09bb1115f7f60846b7428f48c4c755ede6cf6a248bb94ed6ba351338d74b86ed944dde06555d8c54b9a911731353370121ea872ce4fb961f723dff223467901c65480cc29bc25b0bdcc794d9847eba43f76c9473e2109dcbb288b1441c7b88e496eb6c1c3a35a01a3c21560918d8b32044d331c2ad4b25329040dbf869fe836b068b6bc75357da47f8e519d3a2628e42a86abbedf722b8553e762d27b48672a7984b2b476268a1cb0408a68de294736fbd3c65bd2135623d2953b69e136ee03897de55cba6a10899f4e95d00af60483556be6e6c499d10f3be16243b25813445a218249bb9ffc2a36c6c3a286c8f3cd0d9e6113378f4b1aebe17006dfd2f24d66df31bd1a1b75364496f355e2ed55d4a45373b3c0e46bf4a51c0ef99a154ae5b53d2ae60f0b59394de2d62ab99427c5cfe93fcb13b02550e594d062655554381084bd3a9a26e55dee2553e22110e4911c4aea12d558b6341cf217c13e897fe078f9ca995083d72ee31132c2a1580ee506901e5f141288bfcfe0cd5c139648b8f35571af4b3fcad4400772ab43f7431039b01d80328f4f7551dcd0e0dab969a4692c42854decc8bc03a430301ab93dda8ef5c68c9b26579eb6c75efc518de141fde4adb3ffae291abd7d100d57a17d50334091b66061e19719cc204afa5adada699e76957c3fb5a426f89221c75a1ac174f1fe828c2fa753fe9481e154b9f4c5fa3f6fa7ac772d62f573d30e9226e26903a41cefcc337fd7978e39d74d56ed1c64baac308f259656c9280eeeaa511a90f8a54cb49da498a492201ca77d9a92c286b420794b7aeebe2dd7ddb3828760f18edcba9cc2f4e8bcae5fa5a83b693883a5fd593ddb85b42d60a23ff5a24ba9d229f4200b770c9a5fe5396019fb55b6dd2a0f8ce3b9733a9479a6355de2a9cd5cafb43161854a66583dcad3bda01865315c14fddbe33b30b9ec6b81ebd8558f1f5384465a4d6bc8a2fd8146f4f00091a8010d156a119a9284e73b8c3a2d4ccafa4d66677a7a8da3fc5f9582faf9ce0c91c7a885833c4196ff70a9b52e3c2b395e15ff62165b63eff15070ab3f0e504235c3c1ea9f8c6a24269a869cb531562a930c444dd142df31b909dbbe34a32d536f4ef9122782da9369b311a62095ea31b23529ad983a7011e30a55e70b1d4b65be5d794c77d8133d48368770e5002729f304ef35a697dcbbe7ea602fe658a3bf6f7da2c677ebfde1f026b60cb2870bf8b106c72ba51ea3ceaf3e4d39aadf109120b1633d820b0a67c91a10bafe1dd12253e7de6ae1510d95fae9673985f4d76361c63e40f79b44d7b4ac286b4c3a048f9703949413a51090d5a54496032c170d8ec5aa01bd103461be3078aa1c704d91890ef829051883a0fd4b4e1da89bb9d7ea1217916b4daa16dcb42ff2b7cb818890da4c12b8d857f13e234ad2e1914b3b059b2bdac30c21db709512ccd25c72f3c4a18c1a54e8c35976053685b4ca1822c416e861fc195ea81f3bea36993f1a94bc6479bf0643614f4147afdf0059aed2f07b3dda4f1c35942ce7f2b109996b74fc95246cd01722078b5d98cd3098eb134c7702bff361599957f7da489c55bd4a0cdb4c071a9cc1ad2679b17743fa803b12bfe3210ecf4ef01cce8025b92eb10c883ab2d387b9ced262c2d1dbdf701e9b210d7fd9b51469220fad3670a0f6683f3feef3a5f5396996e0d15a2571b69365024ed7a76eb6dfb6b789a315e3a6f908a19921b4a8910d042dc132f7ed4004a5bb3d037c5043081e26ccd3f0e42c8a8aec08a5cf6c3a213d91b1f9bffedb0ee9f30e409592c345862aaf8aab3e10c610581073f08502371624ff15e9f3b84d8428957a031114e61351cfcbe35169d24ab9237fe552b0ab8a5200e9f4c73a55852d216a6551826639a6fca6d6c12fb5b5139b3552e899543f93e3b5ef19edf302c2666a55b60b85070c6191d241a3b141a95667cef002bd7b9fca993c17096b132940f0d545446f9cabd9ddf57f7d98c1872dd825cccafb926097a14bc85646fbf1573628c9c1a47e73635fc558ec3c4c5f5923e8ec75a654f28d1eb821af735ab265b557b01a90f32f65c0af8a130aabf66d5660fd0d2d9c39c1554274b3f4853374b9ef9cf5198e6f89a1a0ef1cd8a1bddd44b5b92bc417bb7a6b02af1b3e7d260f8af2fbce22de294bc47d6927690a2190514927732c9d02e94bf299470a2057035a7e17231d815ea13178e28b1af0e21e9307d08368cd30108806e275201e3a3f7b6c72bb3ef6636395bc6a30dd8034501f55f226dcffff5776d3080af88575aea84a4dc53b81b2703e189db839f64bf90209cda988eb125ecd5a2f814572470c9a70150968d76b2cf4990fd2b8161678d6ec63f6ecf23cfafe6f7755b035b53caf9964075298d808632b4b9ca2535c1a5c0fc9c8f1d5851cd3c7c8c6aa747df917c63b09d7d91ebab19f332fb02da60033b3f4cf048b58db47e57528fbb3a1b6c70db030db15cddb55822c459ff9872008bb455804f363503772a486b903f1f0761054fdbef74ccd8a32eb6ae73eac9fecae9d553262ba71ee4be56b32c0adee5eb5225ae6bd9799600fdd2971af93492656cf73e9c6ca564930ab4c761e56f6f890f5f7f0e08b3ebc89a3d000343e8dc9b4b117e63c9af6b215d53387e037819b1270fbd325b2450208d4722ddd28681402adaa39e5c817568b94a94379eedde5766786b2a05ea6612e42e49a3bfea5ba0922b1cd880540636853f14fae64904a12fb382e60d4c7e71ab239ed1e7a213c197b245d06d2dee20b24988bfe34ad71721f0d9ed83ea51906dee8e0bbaeb52f941c5e1b28c862a2811351fcd706f4ce15645d2156839eacbeb89776c6ccbdf982a63a452c4bdbcc0616cd3eebefac3837cddee06e0bec7cdad075d1a1494798a67a006031c5410231bd1f7eac728431f70cf947278b62c04aaef6605ceabea6f19c00042d6c8732ec94c7193181d1f4fc61c75154106fcd2659780418bc6c38c35819a0862557ce6ecafe06512831d68b4e35e10c2c6551861276b0c7724ea3f81fb621dc9dd2cc6cb1e37df6405b6210ca5abae3ec3c792fa7f97472236b1be2bca6ad540a985f5934df3d7038b39b9c89396cc3e475e665dfe54dec3e803298e685508084092218710e988a443bbb3b28bc53c666c250334a20cec90c9a612102c9bf97311e962dac7a1322b89f7afc22f61439fed4d25b74ffa34a7c25464aff50d0414c8408f6bcddab3d5ab7727ff2bb6ea1da81e22a9714d5ffd3db46ddda608223a53f9912ae71e0b22b13811af50e59c71a926aa328298c4a203521c9591be464d22f642f31e69e595a7d522761a2fb6bbf52d9811668494925b596d2b51495eb251dd8a06863db77fb069e327673f2909d9d65e3d7eb549725dbef3913fc780f965050593ac2640d43c545f8a9c39082eac1562a610867ffb19f4c73d591c1f7a645430795e0d57e25cecf302fff543fd85b51bfd4bc70cd391b28773841cb7cbe79a9174dda7afb9ac7ed3afe7f394c24795ebcba91cd0f3515daa8a7d9e171f0590b74452766110617b8223194a3ba07ad851259fdfc18e1fefe21ab6fd1301b365aa386822e2ada7a321b4a5e9a0b778c7b2157ef3964cabd2344c52800536b9ef6850f51a6e893cb71ab2207c02ea447e6aef3aaede6121b9501cac4ee03d98cfd4561ab011efbf129016f0c24f9e3207b1ceb2891a3cdcf191879dbe5ed6c95d55a8ba80a8f7819a61e78688dfd9e77a5fc88158e16f0ea96a61bd608ee6e12db9744b1bcd7c968cdd628216154209973dd82d825f6624082ee8b5d989d6cf981bf03ccfddd819350e25ef31b263a8c112b1826e5717a7cc95a03f9fccff53422687be7e6443bb68a172182807c6bd53ddacc1371cad475f4b8243c8f9419a766690ccbafd9c897e19948691d9bf4c768a564e1ba5341c5c7fc967ed59a10ff317fc20d4f9f665e0d6b825ba1b67c9416799fc6f7f7596772d3ea3dfc9fd0b842871f0cfaef2feba62ec5ef9f9f37a0daefea20c070b81cea23680e54ef53bdfca87522f1df5f710c46aa9d801f0d1c5f3675158d0e1a828904973e497f4365df0024a54fc1812a9162e8eaca34d5442c823742af2fb0a23d9ef39ca318272612af9e6ba1cfa97e384cf813e72116a6e295d3752d12e6f12ff56ee30ed4574bd3b2ffe0e2ec4b544c072381996ea227baa77f9e858aa21f82ac5a41d899f0021edbb0e46435b0fa146032310c7afd235896b62043beab3e76bcf44d8c5a47ddf3472a6db034c483da1d0ba45a5b369245e5c7e6a62b49a4302eba376a796d2b4bf0755621e692d0d94a5da8fb6db5681ba2586184e1ae0ad505aeb7d92ef364e945689d8f286aa2ea67e7f91e5dcd78ce817723e4068e6b67e6b8874205a9507b6d231de3ca56eaacc0853b68022675babc9361b7fbd50e29f330d16ef88864355085f2af37fa14fd0cdbe09b8bc76db946ac8d9ecc7ea98a2092571dbcc936a9518f2c5b6f7169e4ecb270214870616b2319c4a2c090df03c6cebf777e613b4fe990a8ce4650b544017fc20e432fccb095225dc6e84755e40c947626816902eb8b06648a56fc7157b203bba542ea51f13257dbeaaac337c7ce281cfb505c618db2870817bfd32eefa9d04dacd7f34cf492f53c40f49fe9f1e7b3e7bb04cd54765a437890a5cee00a3204db9330239849f6582b30247c57bee9d8b42282c76eace6595298c89333d47b90d741a7b884d243230217b03bc099a2f4e842bee891f989683dd4faae266324984957069152531ebde629c4c93c7eb2c375e0be2d968c45ec560f9e07f9b630843efbaf59d71aca9d90bf024a256247d1127e0c6422f5c108ff21c16f255b9d6ece568fda53e491daf51d26061db071bed55631bd27d585d78bfd24e65721a5b64c9c525cdf270167fabb9f13d176bb9bb6d4cf12870d6d633af776040c95dc4d64773706c4b93a3ee5206c2bbac017f9522351a6c80bf86d8eb3170b17eaca1bd2433a2e27c1c6cd555268810682c06dd142ebd189f7b4beff30f3a3f18e51ec65ad0a23cc2b1809e07071f55481ebb1fa14e53c03a9f7222d23944eaa77b70747c13a6b41f2e563e344b57b3d5dad82621c06ff573a21fb0de1864d97e214a85b944a954eada79fa727dd0db0c90f9b7b514b66bda31cf85ab951f495f047928d422ff6d9287f8a12cc6de9ab6484977a38bf2e2b6a2daa89803a9b8a41b818ad5193c2bdad343893737e84ed7a2d8f818d11831fd72c307185e00e20b1ba960ffb3cc5579c0124c1444d0032e8bcb1f7e2fbede3d1554a26ad56478d434fcd5e9bdb0af920d31638e351ed9912f01c0f491d4f3a01e3ed727f47434e5a087e811fce43be310f387fdca9025b5e52faab2ce3e3406831020641ecf77e19e73a7d38f4aa9850842fadf690334a10c9256fada8bc215b9e49afdf9c9ac5ea2dc6785d876acd4cda2a4bcafb1cc2d95f834ed46706741f111ef3f5b528064c6e94f65de46585d73b64e4a5e2304d9399a529ca0f8e1f7d1e165e74bf46f0cb6a2ab198a1cf28f7a2f6a9e8428f4aec326893a1a9abf9d6e76292a6ac364ac597e2a81b70e1b978ed3ac706f5aff446824a1ceb93925d140e7880ecfcdb06cd01030ac6bd1f3e8f3d73535c596f8e4cef09863d74ec4020d2656abbbe1b75b8a365b4488c4d07ea5e0b3b71f9960efb077ab1cddddb42a28f02b79e60934a796c8615e77edf05b9e18dafa81db7b1c8a314afe9016d337a65e9196fac04ca8cecfbe4670ce79763bc187897624b5c6ff7839659ff9b43efecdae76cd823a5030ed495c2fda69dc1dcfa714f3a7a24b7fe9d323d08f4755f655c20c904ece944e8ce67ef8be2f111b9d70e35bd74491f1bc2a0b9441c0ddd867f310c68fd64f46fc92a4331dc71afaae5fe0221f12d16303e895fbaeba7acde721c1be7ee107153bcf969bc0840b2f9e500443fdb516fd52ffd71aeaa665458b9319cdec3dbb0517af24ebf78b8a475631f22ffb98e8ad8ddc9760e2f58274db37800bc228859af6298c2b7ed0b5adba05018bb00276c822bffb0baa5295876709ed871743bea74d8bbf1bdb280a808386c394d8457e54f88496c7736b961094c03fece5b383a3eeb33b0da987ddee5b1b3ed5e3ac3e7d6df226c022bd2f3f3ddf9dc2fa725aff4c0744a64d46e1b95e0d007faa06fe20ef10cc7320f629ae8acd950e32d98191fddcf7824aaadeaf5411ade8cc94fe514a690ac67ceae643625dd1075a76a5e1b7dc8025a96fb02ee5cb25de58482e029f07fffc4330196156fdb32f9c9faf17d1fc243a3cf65c8a65d84b52572b5b5c9e6d228a8f03af8e18e61f27438a2b77bff3cc15cf3dc09d8b9072b6ea4c7fcac1c575186326f2ca2d33fb8c1cbe1db8fbcdf213c225ff273aa0d38a001056581fad872b3d8c028a557b982ee6e929fd41b715d24fcc836cf0bbb8a25c67f02a81eb4f2d93cf0bb47f258ae2901a96390102608fea2de037e84455b0f545209e6cf9460453239a23250226fa302b3b9e1bc60b00260579b7fb5edecbcc29b3bcde249e7cffccf1c77ff7f01d86accdc9e8b76e3c927fd80a017dacf6f0b21171a122bd9620c99f6a328471b575b8bb6ab7873e89096f583b27389dd78a92c8b2d43da4214075a475d2c9af404d02c91fdcda1f8cc015632ba7e1478706b42c16f78198012b9b2cd69a2bd82ec2e215c4f9c7f0decbae8dc215a9622fc4290999a4cf55dd65b05d4e49e835d057596d99984ddb08971564d502d7d658641e267591b69fcf10a30de96d8ca3ca30098dbd4e628a7b6be70540e906c60c56bffcc3c7fbc251214ce15200f9098821f66edeaa8b1bef9ed3b6d47e3cd494460fa3d7bc764851c79bdb48aa2b3b727b3f3f3935bd06830bc20c3e6b56443287bbe4a628b262209754c62a6b2e85b40ee1c40954a692c23dc91d5470912551ebbae752f03514dbc0e63c8885dad5f7c755fdc2db0e575ab22543af3ef64eada3c5c301cef608dfc6122f9633f43de269f3e017972f2d681fa3723527851ed329a10595c1916aff8379f8f13c45c34d60c3082af04fcb2bb9e49910a8c680915f4bbaffe7b33a78b75aa983d78b9b5928b5fae0a389c3726d58e0f9196205c8a6c41255f07d40382ea1f744cda09f5c2cdb9cc7095bffce41035a4ab8138080eff2d4eccd37487f9a26225470d4b59b44eb2b08f9151981612f0092a9b8fed01ca1c74873c848c32c66bd7af421a65cf82e06e6cdf60726a45007a49b433dacd80eb05ff4c6b891ebe549ed47568387eea770bd32d787ea411af4ed4e5b217a7ec19594a4aad250b0b054896287987c7859a471efcbac8ccd32717c41764c8b06241649544dde45f7fc98f7ff528e819a65fef026acc60c69bd8e63baf23ac5e9bdfdc724b010e5b3e0403107d4c3539fb96299fcd2b30d0541dacc2c90a0ce0bc16f5d9684ca649a04a4c0eb7c87c5eb718512208315847ff9b877c81d9a0e121bd99422bf494d1ce1b0ec0a9047943b6fb977b91a7049d892c714875d543534a3f6edbc8f48c52a36415194e018fd65a25214c444293b2ad9ee437739ec1db8195c3585573820179480f137f58956d076e68ae2695a4684007dce77c5b73f66a1c603492629b422aa85b180766349b10043ad37edd2c8ee0a71fb6c502a93e5ff0a89f1209c42cf765ada138a6ac0bf4b136dde12fddd7f675a2b9a178f87a1a5115fa6eb3657a4ab70668abd4d6749fe92b84424f21adc2d70d301cd2bb118d518187cc3b7c5bd8a7f60d9682ed30a22595ec4433f6a9908f2aadce299fb10ed6d9be70ccd80bdf1ac79b299587f66d0ae7b4679327a446441b23eff0262609a8cdb3916fd3117c21c2829ec60a85091afeb08bb0bd13b7c76d9b464a7fd7cdcf7eb5d6bc0b7185b2feb1c92a0390ecfcc047f780a23263e42f261745af8f69cb975875e78ae775369da21ac78a72c59272f1cb0d868dc147055ad58652ae28b347bc73ac0812239c5466b1ef63ade2d39f6f4bec9c129ade918f2b39eedd7501002a5a43d16f6ec4126e957c8c37797a79827a42abe21b4c27ef7cb170f2f18850633c3e39f65a6203a2c247802751eef7a29905797a74dabe7ca3054aecab86b8310e523b104026fcf9d7229143ed4f1953e85cd2f10c810120b4fbffd14e1d3b6fe228884228357f55dbabda3c17a64f77c393f0b2077994c7b9a8d3777ea74e3cf8c9415ddadd763fce68945fedbc1907104061405ac511171c507613581b821605ce9c1c55d9a5f3f25b10aaf850f1f0161b26ed8f508046cfe3082ad4181c827cc33e7ae1a7b1de3a3e68318160ed6907f4dcafef9e721b47ac5955865ec60a0c193614459f5f49d5d52ffc9eef932e1bed40f3ec72af3aab5ddfe0fe019ccc920142eee6c6614b2006c4caf02dc35381878a27d92fd557084d5af54375f9a1e94eb2110cd0b25b2611581b609fa72fa2ebd65df86c6fe4bf5eb29dc75b249477573278a9d947705b99e3393967f5044f57644ffed77272773787f7c14bb9c8f9e9db7febf8dd201f4474c400b7b37242de29d3eb6ccd4e17717d01b8d7e7d58d8fc50c2628b3245bc51b511f9e325e8cfd13f819e5eeacb422f1d12babe7b19c8c654c530660132f37facabe1d383eaf99f048a746851e025edfd2c55f243eae3a3bd00efe75a5d582781ee044458a1fb71f4e73a2d02fb5351975854390f56e12e6aff16736b1a1ebd406f25e9a73d63a1c385ad2fdd912679df2db9815a35aceffc484a6d4c948a31afd492d15797b89ce360d0f14b2354a546ea0ad2d0d1cd1d286758d182f16f5fd18e14783cc62d2e0ad684f6e663d80baca5bdc691ee2254146366cf9e07fa7b3c3e21930f1a01e522e032928e90484d13f1f9225059215e82eff277e65343854eec71a4d0cc2463a0fe49ce337272d7953f9adb59b32f9d7fcba89d6c0f5669e2cbfb2d0596d1d36766a391881edf8119868bf87afc657e0641d097550b21d67ecf41e781dd0dc88a0b60caadd4e0598c02cd64153992be83d965523e7f79d0692fffbbd449fdc8b139e570383cc6e2908ae857c21fd66e85e1f10eb2be6254ad543e2f342d51688b1709b50c16a6fb46f3093ced415bd8dda9f3ddc660f89e57eec572c118d54625b920b7be84f1ed107db6215e795c9696a32b252d28c1e2bcec71a31ac2dd8ed9cc9246689a356a980f4dbd8390d52bd481568737b58496f20a40dce7bb6491a48cfbb445f1049786510818da01e0a162d1cefc07902a7f91719216ddbd054908998e8fb83896fcfc37f9e9b32e32c40441c808f487f126e8dd5cd2a733921406dbb875e00940b40ba5e728c8c029018e77563f417fd099ec1c0df9f28f746f64e2957f358a99614451f5d5f318401b7c9ea7d6aa8c1a6bffa1658a1bb76a86aec112f1cbdd33d3be15a5d4a85dcbb77d83e1fbb864fb85a4b55ed2faf7ec4f1028b847516de402729a4df88ef4b1c6dbb227c3378eb66ab151a29e5f47158703d1cc4b94a2c83372e721d008edc7f5b249df8a25184f3362662066a8904945bdb81704fd005769d705a04716819f2eb67341dd5e23d7f5ca0ca57773baf90a26d92f1e19e71e732a9dfea44a2a2334afda314dd0827c4a0976bff059e2452079cd74bd0027479b12d81bf6c4fa6d96e64fefebbd911b74a3df10a256280790a35e7124aac65fc185f51e1039dc14cc08e550c72f7ca27ccd755352c8a91254a76d95e21b00dac48821370af5c1c4389a7f9fa366db33848a971ec157b00f5e5c5fc8672d508b2bc0a42d55ac3d44a7951973a38ef4b87e1a89893d162bd9c6a388acb62d43f50fb838b83eaae43560cd2af99562cb0430ee76bb8633ab7f038786a13fd9c447933e4739d7c3e408ac1878259adae268f1341cc6be825d05405e8569acd8e4eb3b8a31f140dbef204e41316d244016c1ae6161e154476fe06ec30bd9aac8d8fe8cfeae8bd9d68433e175a548536092e9437054214f735dbb62409d41fd76c35732c270eb26c37684fe92f0c8a6b30ff9f7394c32545d7625d8f2631395454763f04c6ada0cfd5da63ea8c065160d9e269f3e72e491ff1f27e97c7ae63670464c83630c60bf7ee6fa14a922040255e92780dbf3ff24eb5f5fbb8b68a7b9fc87e332dc8cb7dd5c771ca12832ffe2c63a5510bcb3c5fbf3abe8655ff1b2ea823cb0d4f350cea52564df03506f332e3d80fc37a6ab8a878ab695c0aa0b61af35aeda5567cf2faa2ce9009332e1694e2da5ddcac3f08a3e35e0f71d151b9c99621ce16e11f57a46825b7df9706ce62c8a0092c482fca00dea89526c76c08e586632d76d1b1e7f800d8e4101443596967edec55684a00283d868570a0b2cc3d99e20c173fc47df9798c9e34d5665774d666ae9655f9d134525415c10480f2f4b098b55522d7c97c5d9ddb7c8e67416e210de21be61aed2512977b7cec929d8324bbadd8647b9ac2cc59583c6359a59af38968b7363e2b715f61c9ad1940f29e8c416b235337eb16ca06113febd01c721f0b54835fd44739f74a65a6a196b04a01d02de3367bfa3645e352b8581d43964a43257870839897230f10ec96fab4910aaf792fed2aa40859a70c362e648f079b1a33a83ec668a485a449d2c02cceb360145e046f9d04850754000b81994e16b876e82dc07d7c5b5dc9e8d2e60fffdb6f41dd3982d96d251ad1962fe3405ad1852301b70319b0394a08652b49772e44a887f4ff3138792541c9657296a43cad5722de44f29b711d3b434255a47e0de8f825f33c04e33b59a08bcb31ed26f6fb02399c37a2b6bec838cebf9017f83bc0cc11b21470e4a047e81053eecde9fa2616b273d8e295c8c27edc48578c4dc228c7c39e77b732951acd98e81c19dc6884a4fa0fd4123d4c1eb7eaf9ed14d51e3007f6b90294665804ebde6755710c242e0196cc3f562a3fa7bf18c30974029a65306f0352c3fec8747eebfc335e32db631329b914bf2687348084bf62776fa5463ca4875398963393a6488628d59e5a253b48ac6878b6b44d9ff2187a44a3b65f729d2d95fdb290cec46da7a6d867bcb3bbbed352849836afc42e05278f83f202d5791cdc3731a392b1abed2698c81da5e7da4bd07b77115b258a3b1c514f19883fffda14fc1731eb5e35270db29c07887e142dbd2787698c99daa10462b265c45a1dc4f18b6ac957ee1fdb887ec482dbeb98c1b3a97af06779b3a4fbf5e7c46c1655dc6d32fd9b13dd48e826a05b3a4d54719822492b3b63d49ca0fc87e678ab8f6873ac9c4d52ab6054be430850a45ea8941c8d1976fb5a6d5e95a248df6ee8017bd8f2b9ef16f4c7cb00815d8ae491e26a682fc77afbf852155152ba6def8d191a89f12104321d6235102b2fb730d0ceacdf95cb49b1c0d6f214bea29796812f7e4e2d3e75db0546aad8cfbff1bfbf01bdbb41aa2939bd801af59b0320f952e37575a98e9bf693d22ed1226cbfe36389df97be474382fa29a6119bd9fbf696904b1502ee514eb00392b4346da2cef1c5bcb4089cfafc8d1229732ace076f6a12b6b7b76b7ea0b141dbe6c2e1a0d70c29ae18d90d0d9b409ca2041df59b10394bd8dff4dc284a455a16a6a8a24955d2fb6afcd74533c838e526e54e0494c8e6211d05b429bcaa159e98c1ee38a87af0ea71f83d163d517aacc5203be109e410fa1513f7b5108484ac7e85763e5d0860f90149fa58ce9370b7db68a30e4440e59aa36d5e95d0533899616f0cef6882647bb9fc10c8bcbc4a6274ad3ffe8fe6bca3fc91347cf1710f038eee940847b79dce88c0354458a79890fa7348ff99f0ca501a502531181ddbc3585990aa80f27699596bfd017fe3a1dffeea9cabeb9ff501b9bce45e0c2da3c9bf77269231817eb21d7a90692110f31e3bd21bdeb351cd5a4f6d93270ff0deb3d20a42949c692225bffe81f9ecbfc0af0e5a508848268518d7706514044292158debfe38dfe96dc6e27b9a2462443fcdd7275cfe8c9405c2b31a89a602e89f8ff303bcd752afcb8989d9f03fcd49ef321d5eb160959f9e9fae8f1ce90dbb73fe111a4508b478a0a1ea85af4a4c653b3b8dbe090b2a09b441bc9a222c8f1076220cc6f4b527136830f4d894e3b6121772eda92005bd7236c826d207ed37d5c726ba013e3472154ee84c7dc880b1b55d43519e122b0ef618d75aa1ecc2111921f5f4568084427b1850422640d7f4d3f3012bd0c16cd24fef87547aa9c6144282ddd721b7ebceee43077fa0e5a46f5e057a958bc21b018f016a7eb6b0f5c52725bc8c108edd3083cf092af27add7c95b5838944cb0abd6670a1bbf7fb775fe4be6e69bf72f0bce388901b8f05c996fbcbbf8feb7a3c0033297a82df5facd0447cc222922229de36a6a832bf96b2918480e3e2503451c1a2d15e266c0068479ca859f899fcb06faf12ab4169b62059a0b1850e13f975e0882a3ed04d73f0a8d5e4b74ed4af87b866491f7e8d994597f29fc6f48de1d932e4ca854d66d419d4586571e3cc4c6176bebe4fa1c0214c6750dc215d9ac06995e6197d873cfe4655de2d210eadd747745b03c47ff4b0644bd494709ae07fb5bd4ccc52e3c2cf1d26f0c92e330ca5a052d882800e275d4fe3bea5f59b3fdaadbb7013c9e0a50518bc1d657f991f020b63e49e869aa1857f5a1c14c11c76b89217589bdcc2da6cfbdebc5c7023e8150fc21e3f6e704fdec170a095f92de994fd96fa2446fd905028de85a23bae170c23fb438bf4012b7744b0b188d9a83ad9ef4b9597a74b7e09ef427a0422484afb3daaa09ff4219bd345a4fb309b9cf20efb2d45cb6102208edef67b20637733645a3adf44cea0c59408354e412977aef0986ec30b21d1e4454548c035fd09b8e1afce9bed086ae5916b94e39c0e060d358e4d02db856ba18df61a71c6bf90f707f84fe0ac70f1c5bedd4674c7afad7688502c2afc2917cd146d696fbaa738cf4b43c42d9bcb8440fb4ee15b1d1960118a7fede9e25b74ce92a9a4236fe235fc08bb63bb7e1f719474a05511d0b1fa0ca04074c223a60c461f68268d86fdfd3f8a08fae4235a128dfa70102c0a403477534f57cff1cd6173c31ecf28f03e857e771aaa5a8808d02148af52b8cb55337c4b5066e76ab8e3300698e1caef2edefe11bfa98160060d155f1ad4b5970cbd384914821f6474189cefb513ba8b17e9b01240e0bf582e171c1fe9818557d18f0980bae4457ee98911530129d211697328c3731a87e0a73bc4868fe4b72745cfdd57f25ccdff2875b88c43f940801ab184f21650683ca0e99d6c543577c094b8d307fb79797e2a4b2c06cd733ea1d07af9e73d69b5d3784c6c7246b6f11040357d439dad75ba98dce1dabd69eee1580df3b2a24def92915953fafbe70bcff2552109fe4e864117ccdab5065f9713f2be9d7f94599d72ddaaa9a47c6099bc76ac28f8f02b18b02b43a2da944a8566d7c82e301041029b7dfd7a67b1a4b7ca9b43a12e89e57b6097f6ce23bc82175eac15a88ebd3c0b4cc49c1d4032e1f3a208769a79323ee4de0b6e862ddcf2addfed11bbe52aa76d1026a5d0c637945f2730bd460775c43e5c5e007e95647ea71c0c6dcc745f919757ecf9186a91448e875c1f31a6729a821b30694e5f6fea5c967a791f031f1cd48b920b2e555b16c676966b85c036c81762d4e99a3a0c143bf7</script>
  <div class="hbe hbe-content">
    <div class="hbe hbe-input hbe-input-default">
      <input class="hbe hbe-input-field hbe-input-field-default" type="password" id="hbePass">
      <label class="hbe hbe-input-label hbe-input-label-default" for="hbePass">
        <span class="hbe hbe-input-label-content hbe-input-label-content-default">Hey, password is required here.</span>
      </label>
    </div>
  </div>
</div>
<script data-pjax src="/lib/hbe.js"></script><link href="/css/hbe.style.css" rel="stylesheet" type="text/css">]]></content>
  </entry>
  <entry>
    <title>2023.4.3 - 2023.4.7</title>
    <url>/2023/04/07/week-32/</url>
    <content><![CDATA[<div class="hbe hbe-container" id="hexo-blog-encrypt" data-wpm="Oh, this is an invalid password. Check and try again, please." data-whm="OOPS, these decrypted content may changed, but you can still have a look.">
  <script id="hbeData" type="hbeData" data-hmacdigest="1e48e9f8d4a3106a7b2a060eed3960aabe7b297bc6098463ba62bc8fe71db94d">a99f2d1cd7f89812758242c57c62a59fe859e32cc19116fcceb1abacce500da0960986acd07eddb3568f524414b51feea94ed3a8842a2a7cb58681a02b461bf770f84ee1401d0da18103907eac52ca77e5d224e9576ed2c11ce6dc26299aac11a995718fc745ab986d2844384f629f9485634f199921535aad847ef11c3f4b99c91afb4729b68d83d332ef8e6e1b761d3e9685be2a2cc650144561bd86904a45177eaa57f3d89d3139d8a8a03fba683bacb5338bc54e0e2baa7bcf853b77f690964e1250c4d034bc4160290eaa745bae14d020a679fedbb73f0f6836de80957bc39e7b638ed4b43623a8229fbac9996399579609bcca4a37252692c26c7a1d2e5641289264cb50272abe763c7d1c759272273052c655ebad78ce4858f57009afde11d23cbcfa0b0e57be9ad12e54366b83d3daf0e9d6a25ca28ea88c8aeef90e7428f186ad8ef245dd1c36a4e048f51e9c3fdfd234164103db05c8a7a5c583ac37104fd5cb485545ae37cff2532f55ff4941939913ec51d3d40a262128f1d2296c122fbea430498cb554b6d13c8f624717b70d093e8a6278e751c883ab80603a57330e69ba85d7796469d3fd8edd79bf0f28c258634f1cae4f2104ecdbb2a32c120103bb571a242400af110e7a34753ea8bea15d67fc0d127c3ca7f81d9793cebda34e033d333714eccf167b17e5cd9232d380b6b0a993bd8df09e966e25650dd8f726ef13fe09b4741781b1334f2b6e65b5fe710f8a634abb21c030173d7d1d9434e87473818b2bbacd0f742ddd1e632f2860a38f1df7e4533c673615978ee2146dfd97a8401967eaa223b55311fab9faf98ef0b9d7fa6c8c0ff8c64f12c9aa781d8c83a7659a44b1b5939e64977790640616173204546aec5f69e0cb7b6893e4d521f5f5b44d82772f006feb3c679257d3057bf16f4832785066355885e582ab78b30a855681a46bc80a5633419e92c51ee2deb436b5cd7b10b5d77c3f3a09ed1528da71db4280b0197ff31ce01a97c3ff001c4ba17f55360b7af25100607025a5b8bed5025fbbb1ee1d537d8a021404ad9799626abce10d9bd779d713f9c5eb4d581fbdbac9de8029f106207b64e4843cfaedd04d75809fc9b5c0de8cb2632865313dd3811b373a6c6b8f742d64f63a577e87074a7c46a57ba4fad6592f6e9ad9409b54d99781440279dd29e57a7b4210233f4a916d84fa287ed24c6aa9e16d0ce05a50b1b803553966ae00f1d2494497c9fc9d604179699ede412ce8e883857bcfe936828180c08dd00a0de46f18cab01d3278443be12b6e730d79e9bd17736fa45cb7f2e79bb1c65547a49851220b2353796310c0790721989b91c8387cafc02e67d0fbe737f9451f3cae11d5f5f08e774ac2c37416038c8035009155bf8f3ec86f926163f2576c9494165b7243a4760faae10ba23968d8d342dc0b3aca022c57b899083068c8b6a6191af3fbca765849c5f3629bdb17475aa96ee3fbcbf7ce2813b713d9998f39a0e0c53792ac714bfbfcabb193c72a8805707ceed9ba4576f3663575bf385bde8ce2f6e0e11824f082b0760b387fa1663547f1bad9e5e3dad3ffa6f66e33794d51adfc96cbf3f26cc40283513a42771080e9200fa8f855b76ae1c293b49f2fe6b9b4a89c478b748cf4cd4a180d04ea6b5edc62f8183f5a24816d05e70de02921c4dc720b0bf436804cecbfadcb14b0a8bfbafdab64a9af5698c936798ef9d880413ec9e32aafa758e90e81b0d6a4efb6387723e2777ab62168e957eab676f93c89bcf9c7923975314129c4b9b7130817e1e6459fb03018c7db82cd313a89a55f9297ca8c415d82eb2bbed3f471c7afb8d53b0d46a256678881b33c1c19f4948ba059d21974f05dab4fa9700524388036f6e25ba21295cf6a48734a76e79806ea155da6a5cbb0b9a202f6fdfa3d1187792a7ae4a66f662e7c1319857f078fb0f189d6cc2f4a71205cba7f44ef43cc01e1610255e580a974d8ecdcdde71acfefff715fefb5c8fa426c80b0428f2ec6b7ed6ef1d6d24e55889cdc50d5a4de7bb9514c2c9ff4f1713ee3267d7380dea67146612db2889f717d7e321e8f0d30f6558cb0021ace334018dab343fc0b8c570b27aed843cb6c5e17861b63ba7c877e11637b0eaf6a1488a6cb9bb28c38fb4cb93907f8a17ed577704901006e5d9a5beac2f01df9ea0ae84f5ca81b4c4fee0a64c1875b9eb426a7be1b67edda1e27bf971da8bfe36db7b80ca244a7b5fd17d73e26ec294986064932970406820a07e8e5cc6982bc4601f67ea38346f46bd401e61466c7f050deac307c765215213e709ecfcc56f405aa6ef21a45be11afbdbfbb16011ad47a91fe8f86252ea3274017a4d640eec251989d5f9b304eee7488ce2661fc4a59788bd09b636a073a62f7a1e7ca51ff0cd07ae2e737d70752ac8d19674efa4e4e32ba6f42468b73bdc4a08068f1ad985a62356a216c11223d31f28b02d564f967254e8747d2adf5b7c3a15d0b1be5308cb7c58b53966d4aa13149ed42918053258a8d08ce5d4bc426798b7a16689355caf9faf339e3fe211fb92b81b9ed6069e858a82dcca3a2b736ddedd11a275e32bc9d93a71e18821fb16c7a7cf6ad76556a2a50078f767b9c4878df6aa10c36daed2250d69a1855b91cc40ac43010409d095bd66b4e24158aa53af93b00fa34586f7ac3bba66146a9851c899f098a0dff8feb9c48422fe5c5df4d7f9ad59988439690c4e8f04636fd3448cd48665ebdda4eebc70bfcc77ef8f93f25769d96ed2dd3561c12e52864b96c650fc5420817db0a8f63b69b411e434884ffecd42a93087201794b730fa711e9c50289ca6ad74b87e080421870d3f9db18958c6a6451fcae81c3a1ec89f2495a1cddd0aa8307dc199c0c5d562aa322a4ae2227454da95b70579f386e5ffd844d3c1e3f98551f879b7bf859f6188910eb48e7db76bcefc98a2c4b0117d04399c1252f3d73cfbcb1c52f3701709d3a58a94e70b8e15f3e1c7f4a89a2681b5a735523a69e6233e1bff4acfaa445bf44848adc0824c84f79b416d2f0c58f645d278309a23267d1672ea80bf3555386eac4a59eedaf3221785298b482b141f5a4263d95bd541b4efbb0b90fb806f6256b7e41a0ed9112cca429fe40b5a67e41ab71f6c995095d16c9b6d5f3dc616c4e72e77667a6386107af4e7f32561c724e9be30e15cb5c0d5dd79c70b0281b11a1d5aa5fc60dca5bee649c649be78095c12fc5abdd6c2f250f50caeb898c85bc54083208bdb8390661ee9e0ce5c7fb9b8deea00ecb004f105c7c6937c6af3c9ffeafecbf6c936c300f7f252a6ccc02b0f42a3f87541a688912ab6773fc4a54dd5daa895af125205f73cf30b6fb7f5e66a5c93fec1a5fc62575301dd05d70753f45ada68b236115e15762d63a5c39989946ab57f6cb489da7e018ef1de1699a05283e928367facc75b41e2eeff466885e8cdd5b38215e817e5cec2504699152e4cc327d2fde7673105b00f1b8e30a2085ae3350c070f73b257c42740d7e7291192a9f03d73b6f87b9b788141dda24fa73ab4cefbd07cec651769359646ba5c6e5e6bf155e64d01206ea9884d3dc5eb91b174e447bdfc766f585cb906919b05f8694abdc7831470568522993b41dc4743f01cf98d9e0f4668984992ceece5ea237f406ae121e93bb53b10e2a21aafbdffba2b431a90bd6225bdd8cdab3f45bfd4c5082e5fa40b168e0f2b93dbf0e9ca81857760b62c9b27448359f47e662c33fa02ee2ca2afff7797514b2101811c4ba2b85e217fdb61128e626f8aebf9da4ca8eb59c31cadf56ea718a702a274204941251bb146f1b7b6bc04c661a78bc87c7f33dc50867f689b7a4a79bd7e93fff14a86b371c28ef71799e6066927be341fe9b7b88d6989f31781bbe1156d157d64602205fd5045aed46b3e7ce393b5d79a3e717cb39edecdced89ee2b9158f830406313ec0e59938af68970db66c5a61225c8f6fb8a6267911847a222da32ee235c1c6305a3ee874c9fa3c2579480707002fc003a17ab5352859c712c4096e9f55b4e09697f8138d9eab241914dc3f21477a27c67560dccaad5f4c7a5d9cff21057500b1f7a4a9ec13185e36d1510787850c1df3e9e2bdf0dc3400acd9ba12edfa9458d1fcb87f2909990fc609f65c8f14148c07cfd0ceb626e81a7dbac627b96c1dc52cd269c95ec11f1f4b77da9934ed7a842cc9866853abfe4be9e1691de5c98cde5cdbff1ef4c16941e2e2e76f8c9c0fe817aa53e53cdab7772a7fc1bc5e4876f5d854fae09db3f8df61f8ebbd92972a3ec015650a1e0f4815a878388355fd75cd6032ed63eed5436a1a1e7e548bec3f9a01c859c2aa9f35005ecfb5a693587bc538c0b991b62d490c32b6e5c5f347393dd492f79e8d941ea273c684de080ff852ca18e5b5144fb3cda2f44cd59be6db7e6f7b340e5b71565751d91c179fa29b3635a406d22e880712c793ea9393feda4d9f4c8d4c9c0f50a953b8d75547afd2bfdde5d5bd6542817584d0ab7b69704c87d5af1606e7f0db499a1804f921054351732c5d1f5f22cfc4c15f3621d99024cc94239a207538220882d1ab875feb8cb7bb1d44b397c759f951334e94f83f3c8b49282450c0d7502ecd4a5391c06eb51109daf4e57387e9d458392b3a5334069d3724beeefb337c400731bd9559a0870ec8a50cca70d54cb3df518e4c9db1f97638779ed87aee053c2c93bae24b1cf26e4a710e8a7f2cde52be8ae4565967a600c0aef42cb14dfefd2d713834c0786ee1f0352c987d23ca9d32d323ee1ab82f423c0bc9a9ff70e07c844e4205e3de9e514d747b34e307c4c1db5a6705dc6c4fd786745ce09abf3175b8e834ead4cd4f184b652914032b6cfd24891508716474689fd9f80f6b1ffe26912a39827fe39aa3bb40205629bdd9194aee59aab445167500bbacbf9d152f74a2c4ef63d73c86329ecf72b99f653b6c781981d7a034f35fdd4936be3b75d7c532d1e6210a25a22d274734d80e8c6900ef7bcab4578690e2303ad9c26526bb84e3cc9d38a7d42ab7edce3f76b4b70f77551feffcda85fd737afb33bdb8dc403c516ef0af9eac1dc05d440de9f3bb19ce1f78cbf63c055cfc94fbedc01e6250123fa6eb6ecdf07d37b91d2c363f3978fe796941a6c6455864f82912748747ee53a3690f94928ac0e872ffec0d5a2c4174902c0e17ef46fcf7798d0d37d40993f623bb2f0342a567d746c39a693d1696b721019b2eebd1ab1fdc23be819b0a3ae84fe3e49eba7d8e3be74452f65dc103ada0d5d60e0d96d4a59965a7f5a398df2ba34662a73dcd04e8ca7c44e100969935b692f6afd6afeffb6d684a5969b008f152a509a882486d2870a6f6497973315058a132cdf133be80fc14853b8cae5cd9d6a7b1c6e25a5fcf8cc5b856d38ef0bb95eb2ba7ad78ab67759196d59867e4226badb3b68085702d3914f05cc02459637f5c0219ec9ad6d43c79150dca177d041b9ae9830cf0ab3ad6d98f837f7d70b4f8c78aef2eff7850c1d7182818154d07eddc67511d29e2d2cfcf46f8c7783adb330f0bf28dd0af2f52b9bc38c04cbccad115a84aaba870a25bfb6101b60ffeec9037c537e89d158d295b713bc9006a052ece8e4dad316d076fad71a4638012f628c73d6847163051513d1b8f39bc20c83760b471dc477ab477a867ed8e554c74918e141ee88600e3ceca54202208adc2486067c940c2338d605311fa90a045d4de58af5c9cc7f42af6caeca70ec9d46ba7f8897d42e264f2f06661df5b69baeb049c291ec33d01dec881720ef4cf6897bee2c99a9b49ee1e6159fbab23bc08ae947af57e277093623094250823c721ed8c31b35a2330f0b639723ead510b92a78c81464467cdc6f24db807777f095e26e0202ce643c70813587bf373f257aa73b0be266375734968beb31fb3ad3c99c93a02ed30b5f2a78ced5f7b1cafcc20363c674435a831fc494047b606f2d23202d17735b78d148e6cb082477d47eb1d0aeb8df2fd522a933a69a086656bb78963c4e97730be8d2a7130cd9a0eb5a8f3f30c807907b7905d32cef716a8bc387d02e2781e7237c738da5f833194ced671eb825c10793333e447daeef34ff03f1f265925db877d59571f2d6c6cbf9439a720bd2786f2de2844894741dc35c8ea7bdb181d48d1862b1954bf584dc6c321d5050c08e0269fc4d8e2f667bcaf0656e1e63a0eaef2e74e799fb451ed9f00b50762eaf3c69a5265f44847c23d76217933b4b6a697bf2b5b62d17426659e0df6e41d7150d8af1c5de1bbf16366b7f71e831ede03aaecb5e001005ff55e2d5d573e74511ae2b5f86ef4c1e98823f04941ecfe0a55259d2d79954933fcf1c7cc0c3e9ceb8676810056c5ddb1d975a8371cae6ffc6ec0347647c82bd0077a39e98f17271f2ed9565cc059d9ed474b8e23001b445bfcf1eadf9ef36a24f8325066102fa5f5ea1ad3f1b121e03aff5bad0b0e8519421c04dead580e67f1d3e2b1cd61cf2f8eb62d68203c85623b68fdaacddb6918aebc99051dd833a84788d48ec7dfa491e5119f9ea3091b60e120d1cf3562f39c03425a75963ef4c0e552e5a6bdcb6bdf8cbc2b2ebd0c30d5041c3991235b02c869ed1588765c659bc61476b9c5e2cf3e4799cba9c1d1c58eabf6dadc6d08564d17b8e2a7e2d8da1c629814bc6245ab2964758199b8f7ee20d46e4c6c2160defa9daf57cccbeb67d2e1de597fc38ebf1800e3cba25a1c9181e9e9efddacfccc701119e5ae6e313c789fa9543f7815de5ae1f64dfc58e5d0bca8da84c7267732be71e945df3e52eb025e4b256ef0017f91a69ff5a73c0c3a290181cee5d4e789637461756cfd1a617a09d9bac81e2fe23c45be5308dff7f51857e24491a55b7cce828c19d217be40ba384ebfe29f5d731a623397b140c7c4d3334c3258cfb3add5a9c8a883f0dd3d1e8bece8ca83fe348ced418e775691c4aee914c6056dd5756175ea41d8c0555445a5977c4a283faa9535b8afa8cf2a720eb64965fe5b219080c335d7126cbb7b77937d7f1b9a71695621cfa0883d079b6faa453c1767822db3230874b7fd3e1b9359d8406aaa3e45ebf9611892922145bbf313b758d151c18a0e3b50821322fb1b245cd80587fc7738266767b577232ec6a050b2afa35e7e96d66c28fb349acd638b0a156052b1c40e5ba7b92f61d27e642c6e2e1e0229d3fdaeb2b0d239fc2755ab8a11bab9234ff474de916ae9603e443c9348eca94af7fa699dd8df4349052b937e355c80b627d6715a7d6c51662242dd8887ca271fc910cd03f852b8aaed8eee5222ab656b34f998466fd0a0f03412dac8b47d7c6572f42c66c70ca7542f733e91f6d40b2f328568661df341186fda5c8174b261a27c864e9db6402d981db49cb04feb538adb7828f63b83987384fb33f8ce2118a9459fe51b0faf04cf4b3f602b5522fcd92351c4174d8b8b871d6167d9809396f661e8b5fafdc2e8f8f4a7e97932d3bb1acc502bf93c835e35cc2c7b2bd548fb79f675523b062802c7ec5e48fb562eb46ebd7018001593bd2b5046a8b9207e68b001f94f3dc97783cdf3e8bb6254789445402fd6388d7beaf9235e605efe3a1b7581f8c7aad6deb24ef5b18edb9ea4771f41d0490c618957d77269ac1a44b604dc4573c3ab530b1e1b433ce72ba4aaed19dea6c52bae11d1b5e9b0dc0f11e8e72fb627429af0426fbad713df61af851a925ff231c6adf219423283056b831230ce9ed2dcc9357e80f7ddc4516301b14db1edb21c7c2d3dbf284ed28bc5dae12f0e0e130d979153978041c45282381aace7f33c445ba0b133b3b4f396ca2ce54369e077fb2fe95c4332e7ebfc07a326b6b9ff4bd462ee62381e8f9e451d26fd816f609108ed85d6a68f5569942b57f0acc29fcb4c5d06785ce8436f96e382494965749d32a7920d40e6af2fd4b262e40be3fd77913ec07ce45c3312a0ca4aa6e345dfee8f08d1e858e91f835cc559c90078083a190c5fd9368184568d161f45a908d424b4b47acb44b0654f89dec9159044ce423cacf7f9fc8b80ce404787cb7700a3a4b3dd9a7f340e0353081e5e3a7160c6d980af34cfc64854cc0dbcd80e796cd811f3019e50b63d401e6cd0bf6fbc59cd9decbdce78af23c54e909b9700c415c024b26a9fcda1c3de576256d807c1b69841c51b143463d816ad09e49fc0657eba374b65febf5fe177ba4234caf7121410d74a6bb0dd46114aeb0cf818daef02a5b41f0d92d35545b00e66ee581282aad7757ce9b2caf0cb7ef665512aedffd4b794c6806179a5aec431f28b1346256cbb3a540c2aca3d1afb59fb6a80a9f64e24f993b4fec64594971fb79c7b3ba51b1ed5c879f8c52a9b5f426ca127decc51f605d0aaeb6b959d37e62a1517843245a50de7cb995fa8dfd6bed86b86eba2e91b9b36916c4ea2c58f6dc283026bb97c702f5a1538a1a0a702070641aa24042ee9dbbfb54cce61730a317cbeb29995d871c05c3cb095ac21ab85810337663de465a82430d9c8baa797d37e31de180ae2411f5267392914df5d1dac8c9554ca340aa586a51917f086d5e39c8c2484050f766a8a270917978e63ef9b2d89020d441161ce14468382814b664f4d436cf840d8215531687f2b3b5b3bec1a6b15c2d030a6114855458a7fd98947cc31844ab7553cba77fc04823e2185788c6214a56f91cc22b33f980e4d5af2ef41022411cdab821816182d6598d294bad0cf5b5f9d6363d5c458efa618777c212b790ab88ecdbb4f0c9bd4f6e39f79421005de22645bb85e42bfca4935890cc745e949bee5338435ef7c06f88d6f4e6087c44d3072d220ce83671252f13fc5d6500b692f4fdce49284c13dc1c5ad350653dfbf627b7ab0de0c5d943df9287e1e78d74070f7289bcb7672b58327ec9838f707a099453b1bd07142dc57db751c865c08e5b17c8b9d47fc5c9874cb4febe7bbeb82ab38547f6e1223dc4265544b4915fc32a73f3ee01be1c9578d9eca4820a070b631b29e887204de595d71b99df340bd4b05cb409729dedfe563c0cbf43c24f3d44183de2b8b522da0624013e73b1468dce172388f874c2876c1a375d66d280b7fb4908e1cdf37012a23947b6c844a0b8d7a4180012fb9428e2978828f5116e5c6e9851d1fcbd48272c45873656a0d430be3344cce05a0b157644d7062ac9f68706779266b9a82b5cd73a80884115a979efcd2e296592fe890438fe55dd84ee2a61a951b8da52679b7b4ed666d54a6d50676a5598dfd4523ea5ca543e3b2b06cfe2265ae10aa4d0a70a8f48f823bb5283cbd89297771b4e68c12482507cf43fe61f93be9a7ebc852d06d6ff1660b0cdcad0a1667498d7ad83abbefac13eadbff3848c3167ea7dd206f5a3e2191c2c756707fb9692d97c06d5aeb56b86145e5a338d4181b63802d4f871985123769c86de8746f933e356f21ebe9b0a8a4d7691eee361b3bdbe68945ec8e4fb53e0914457faf4ada3c5768a83392a1f7127ef00f3c7942e7184777246ed7fe7556f434fff8a9a03cd073fddee7a97b0d3735f140d9aeae7b515dfdf1a6e35ee3143cdd1882d0dc7aef71b0d18b53809f670b302271e47a5691d5026d44818fa0dff3a935adcfa0658b6a6c49d917148d45128c604c75a76c4c2f8e92782e2d00b2a37fc0f9b4731ad8a95ea9938cf6ba819d9499beef17a6781d96e88ee235ba91a5916f6ef14862755eed0291f3e467e862226715dbc26e7207c29c51bc8d30b545bb4a5ebf49f9566443d4ab9b709eac6210bca774c6ac1c49c8e9d25f64f5dddeec3ed4ca47130b00d7ed00345d96bd94239b5af0c0295ca786415dea54be9f2613139761912a9419e54ce5e1d84531e31bc93af840fccb3b558c41efa8fd1d40e481bfdc1800209b115fe5711a39da1c7c1cb843d8fa3c051537b9696a3b26ddd2bf1e4db1687e0c2839b837076d01a6bc7c59e99e2700ca1985f2f0c432e8f8fdba451b33cbe9a26b71f4093eae9cf3de2c05e514e845bb15d64af9acf66433528a328cfa37d527d0218d1f716de63299f00ebe0bbf132409b66e3ec3543060722a5b987916208077c0787874e0d50a0c9b4d2b3836e35c9e0953b18086666fe15cca08d6b07825f65143fbc39285171700ffdcdbf2924459c2447fce968bc3e0192e2c3aed319c7112fceadf5801c8626ef274b864e5e38d8827ea8fefc6ec5a038aeab547a68368219b6aca710191d5a94fe82dc0ca9aa2e8259a70a99280187ffebbf886e677a4329decd1da68551578e821be1dd021d0e52adf271b7e410a823e94585e03f4265308e4fe86b306ca034ee5fc5d1764fac16870a5b95f674894f0b7050c731918f917b0de552f2c70b56dfa99fbd59d0fc9fb3f00f4adf8cbe819ed3800133d50270237d6f0b83070ef785e259c434172f955566fc5f398d0723a78534e5be53e2e60ba94484e278db6ed1edfa6d7537ca23c2cd381dabcdcf198a33e071430abd0abe66b76ba9a06c83183416b44c8a80edd89b574de6b28fdb97146f74070dbd30bd6ba7f3728322408d1bcb5e8ea2a2502b2174583ec9f01cda1a4af93e7551949115408b2c3764faf29f6c9ff4abaa04e9eaacb91d79f39bb41556d57ed9a07c3016f3445eb58656b62b663358b6783447a19811c51ae6cf1647d147dc4b49074a4c1374db7dc3e23bae31806c672d4387f6cbaa54ad95a4f900109620bd8a344e46fc2bc49ffafabd001d5fad42513cc17f3a68ce879dc6f48d8fce42e9f9ab5ead4e737b363a7323780cfd629f012aaf3981fc8df45609f3368b43d32d15738d3c55dda1acb5bf5075aa7f4a05d694f52e1de8bc5cfb99b9a67b9c4401a81da33b06905265d75e2764ea34b1cd9e56a55ab373b4edc52830369d6c3da52752508a82b1544f4cba7d4c54176d7342f3806ee8</script>
  <div class="hbe hbe-content">
    <div class="hbe hbe-input hbe-input-default">
      <input class="hbe hbe-input-field hbe-input-field-default" type="password" id="hbePass">
      <label class="hbe hbe-input-label hbe-input-label-default" for="hbePass">
        <span class="hbe hbe-input-label-content hbe-input-label-content-default">Hey, password is required here.</span>
      </label>
    </div>
  </div>
</div>
<script data-pjax src="/lib/hbe.js"></script><link href="/css/hbe.style.css" rel="stylesheet" type="text/css">]]></content>
  </entry>
  <entry>
    <title>2022.9.19 - 2022.9.23</title>
    <url>/2022/09/19/week-4/</url>
    <content><![CDATA[<div class="hbe hbe-container" id="hexo-blog-encrypt" data-wpm="Oh, this is an invalid password. Check and try again, please." data-whm="OOPS, these decrypted content may changed, but you can still have a look.">
  <script id="hbeData" type="hbeData" data-hmacdigest="485912766a4ee49f81f16cbcfde265903e5ad8cd941e77b51a2269cd5757aeb1">a99f2d1cd7f89812758242c57c62a59fe859e32cc19116fcceb1abacce500da0960986acd07eddb3568f524414b51fee4eae1f2d89babe34509d3fa1df95b4363aee381debf042b0eb9cbcf843074cb212d90c00417978bdc27a2cd15becb3e70ed5de08b6f274f06d49f51521387c5c0fb6c91f363e6001b53f3264829a67f4ad808873c2926c3e3918ef68a8351cf86093aa7c5ba84c6deae909688f77fc962f1e821c108ab8547d91b7bfb09e34db45316d50c91c497335bd90b5219d10378268b3875ea8a6fc187f56f9ff3c4e080d547a90a5a17f76cfe8ddcfb79306718f0184b6cb66df3fd55a67293142952645a931f6a6d8303eae91efb23ca30316c158f0581d3680084de686e1032d77c26327d031347740de7134e7a519287e782dc673b564d17cd693a2fc66aa40cd9adb6a99d153724675751f7391963c809129149e50b8f8e678191ee05f83543d182a0bdd55da6ab44919727d822656d7178f769b76ae07de3aeda223ecd5d32b0a17218bc73fb5d766d2ce1fd7756afed88fb42c59362f359b971716a51e3f1b0e6389cb8a46ebf8541990f2a39977b24c4ab2fbca76aa71b0072426c1fb211e9ae20fb0debf7a8642d7954ad8b238f42f2c4e86e5c41d454b51fd6775da6dded352cfd086908473bbc73c03ed92b86efe3a79cf9429d8580db8c0687440ea3b1bc9ab1ac6b3176f477400491afc8aba936c4dbe7fbbe72bb5a27686ec8902a9478f2c940945f313706046913951abbe35189e7fc52258b0950b39f4f691610c804290135f64bbcd73a2b94f329a74d53146320413f41c634e65a9374d6e6c2c413888960acda7b84c1824ef2cadfac98b245433518b3825776d5d3b14a121ae4973f63fe98fab15d21be3a1c07628cbfbe8d3bb0d4a5c9f74871099ab70ef5ca57659428271d11b948ceaee47cb3c15feb68c3ec96c63233e731ce14b1b9187cca5964d46972e90f3033d677a68b4905eeae259517365d98cffb45bd67931e7fd0de8d1ebe320bacfb2035c00d85e256dc3de11e65a666b87f26093bd178cdacb15b32c4728390c4f791fc422a2e3f0da2304d2bce20b96a2d3d8160c5ae744cea6b0e3855a4e12db11ad4c1aa90a95083581e9256b90340581543e831863209697869e5f1a5d875f0c7a5a803fef3deb4907658a3276a2407a3b1875c8edac23efc3e65f683e7b5b4cac252ca99ae33ab1f7a210b08cf54661efebd1a2fff532a64c69c5af29cc4510a3d04e85021781357a3040a776499b27e535cdc9038a9192bb6de707878a0dce5822c0cec1a056dfbd4ac30563471a59ec11628b7f1b86430beb52ab9c47d9f9834b2292d824ca34aa259adc74353df8053247407dfa52399091f8177fb71954a91a99f1cd7f1621dedfd01b045ff3cd8c1eb51b108e9e6178cd660efd47b34f81f4b26a7cead4f049374b339b26bd36dabbc336b7e6ba70e6d37a18fff709accef8f9718c7c43ca63d1e1143ba40748275a230c81da0a263242be057234745ead8b40d172755dc4e969d99e6922cff944bd7a0aeb5f11e3256287454646e4d847c1137bf2cb598e5bc589fc1ef535271ce4ed752f4c2e5a651f10f0a33c65b055ff95f2ce13670eda44aa71ed58dff06b912d736eb7c7ad1750e48126c23f10d2b9410a61f2fa449a378f4ae45384c4eafbe9a98d9787c24d26a4f6326508f6d26baa32e01d3e335239ab3a4db9161a6fa3dbde1f6d1d189fa79d33301f2d6a8f14bd1029c4dcdf72c386d723a31e31444a4000b59bef7e82dd90040d72455a043e93706125c7a2e4568f488c274b9e81a7bd105abc27</script>
  <div class="hbe hbe-content">
    <div class="hbe hbe-input hbe-input-default">
      <input class="hbe hbe-input-field hbe-input-field-default" type="password" id="hbePass">
      <label class="hbe hbe-input-label hbe-input-label-default" for="hbePass">
        <span class="hbe hbe-input-label-content hbe-input-label-content-default">Hey, password is required here.</span>
      </label>
    </div>
  </div>
</div>
<script data-pjax src="/lib/hbe.js"></script><link href="/css/hbe.style.css" rel="stylesheet" type="text/css">]]></content>
  </entry>
  <entry>
    <title>2023.6.5 - 2023.6.9</title>
    <url>/2023/06/06/week-41/</url>
    <content><![CDATA[<div class="hbe hbe-container" id="hexo-blog-encrypt" data-wpm="Oh, this is an invalid password. Check and try again, please." data-whm="OOPS, these decrypted content may changed, but you can still have a look.">
  <script id="hbeData" type="hbeData" data-hmacdigest="c9ad8d0251e450d3d5e596800c5ff3dda486da622d92445fe03494ad69472dde">a99f2d1cd7f89812758242c57c62a59fe859e32cc19116fcceb1abacce500da0960986acd07eddb3568f524414b51feea94ed3a8842a2a7cb58681a02b461bf770f84ee1401d0da18103907eac52ca77643783bd46225ee9434c8008fb1a95f07a4fe6fa193016b0df2ada9979f01bd22a6a7615891899c96e31c1c11898a534da5b3d1edce7c764321c4043cd0e6992903d8824086e74d3a8186480e8a38921979fe269dd69b134227961ab2763b07d948a9743ae6bbda7e169ba1f3330de2a6cde0270783b840174360f6554ad1eaf236881e4299f4882235bb185927cbcaafc75170df247ef5af926029415e32c3a99f46343d09ae422cfae98b9c833de876d0cd3449c582a67a7f744dadcffadabe415c76d3014dec5058c695919395e669997bc8bd41d90de2012ef319edbfbc7bbcc6c602fe0af1c28fb741cb71a662a5a853447fa583be96d2d738806af2f7fa8aa12269321b2a1bcb214d1614bb7785376efb9ee73fcff68710f4799dc547c3d8d9ad40b2bfe1796ed391e1375400c0b63c387a6776a0188fc54f3d554e9c9f333b2e47bdb418ff2a762f8f43ad244e9391296f411aacf657a8421c4cf09f938f2b66466c150d7166afab92145228666dae7c8ac997e4d806191f39ab9f21019fc9064af4e346f40328348d0a571f9c44c730e0179eaab9792d42025a87dbd543cff9e834ab08f1f67837117496ae8df3d74cbf696b52e39d92c912a7f24c822a092ee7c1f07406649a17059f15780cc4e92a5ec73ab440256311a3f6d751691e1651fd7fdf70d98d1043a3e18028c79b96f935f6434e6ebef2e5a7f9d3d8d23ee3bee6e973a921545ef20af41f616f56e598f250407c8926e2f94dac68f8195c961362c4a63fdc0a58b91b7ebec6a71f07ddb198f87a5b3e712d91f3540e3ac973c7ad386a405376068c44a5ffb0440ef6eb827f52a349e5411fdb7196e5374d913660ba775deda87ab76b91ce4e9946c6dd2f40e9eb7b0523fd60e9ab8ae9d23010a7ed13b8db60fca906c7609b97c2e0fbb3e187d3258dbaa7168ca672311ad748a4f820c71920f88e9dabea383a6ced2ac0873417ecf9909c1798f0a6ee32f9f23da0bc78c0fe01dd10ca7b4db9e978f3ed6afe3cc965ffddaf8b7f091a1f9b26fabc22f6b9e49b7bcf9b2180151965d4ae883da7a3a239b7eded597051095b1fafb50aea59d97de8bb48cb7c00e1e76e282cfc404be8fae8879c2dc4768235605917eb8f6d1d146157abf94f081d5b1375cd4dd29b295bd7419131fa83fb3f958cbdf5c9f3e8c5845f391507796088907c184c494680becd89224fc7a52b5812d8ecafa41c5c69e16cd1785daecb8ee7670728ab0903aaf44f88d70fb0c85c77010e799356dcfa4f093eb3c411fd6457557f154891f1adf5d7918da88e3ceb3b0c461eda5a0f7f6dca7a0a71326f59110d40893ac9ba59a3808ec0225c044b578611b53dca0e84f9b6560dc6deabe90e0b909c46238ba34cb8ed6b48534fa73a690f65b5f5d3873c061186542a60ca58859f45d6f311e1962daa411b190c0f1b02ab4a3550d5dca8e2a1a8a0f4be5cf683b55b7e18c6443db7ad0cec3c27ca0488c7c15dd873c1994051fc9355184b3aadc6ada2478c49848148d0143d232de4ab988c997058760acce9ee96f26340ec6de19625dd84bf97d93b92a9f38509c720ffc1dcae7647f9f4d25740f00f61fe2190661d877911222b619adf4756d60d3671b3ad84c143cf8040b9c8b9a9ee5db967540e49147f3cb62f97611b5b0df89afd245127dfd63a31922adeb1acf7c803dfbccadc06d52969a22210bcbd76293d20fad686119727c31d99322465c38ddbe193cc94e37a7b3ec2def74ab51fac0ac97d33865d1367a157ecae67dc6fd01c60f87dd53ad6ea02e8d0b50e3880bf8d35bf3590533fae3b011639ced9882661f0d996c050644f0140552a8ae0a8df99a1e7a26582e19b769f31def6a07d617da0edbb5c490924ab507b76c94c9bf7e56756000600f86ed8b45c71728588851337f387cd9df62dd0a5ab7c958cddcf8131ff9375836d81daa0d2f89c551c6fb9e5ed6ab03b6fae4d8ec2aaa2714ff7f51cd6238037df652fc467c5026f8c2eb64406cacf9d25cbfbcfccf9d5a76be4479b631e7a16f4e02c651223753731e372ae3c2fb95ffb19d07eda611f2e01759940fdd492348327ec388b98edc813d69f7642d16fee21424b8360529b8e7003701d97fcece662af7fc4e2b8054293f886ed7c37ee2c46ade7b9a349a5a51064e65c08ef98b099336ffe103396dc38a5ef332380c891fb49fa1e66b86410ba9798521ed28097538c125e97be0053114ef927f5a70ad3d9625297570fabefe51cf4e76cdf4e02623b8b8e55f16c64afa39021ad26f192af7c3a9c7881517bf632dc0844663be80fc8a2f608bb0ff5d34b366f29cd70139d412341fdc9158c662221f0750e50067f7c693612653dce56f5718d5effc9a45c6dd2bf4064c12bf30acbe96e9f065a7a1f0339ee24abce4962ee2e07ed145a193482a323862d4579c665307fe26047434d575244061391c44c4d887b14185e0936d6de9c65574990d33d1b7f354b8ba1ad1105f37dd3ccd846eca8043fd08b098dbcc9f15d72c8cacb9548db866d3ce38dcf6a9529d743b0ee3ddedaa54979072e3b2bc86907575f07257981562ab1640c25bef0c999d610d1c50b2796fe9dc7d3be3c37da53d594f74d115dfc7cc7e3b8fcac2ff9d20242cb9c7132e5414c5143eb2a64510b29acdf676fe2ae659ed7c79e05910a89db453f1daf741058b1eef9c1cdb71ea652fb9c556fbdb1db34b042466e343f93e1dd4eb986fbdb6618c9eeb84e55b9b4dcad33ba385a6ae3670a33294df466f547ccc4175e1c50e1cf57c3f735e8821144663197db780175955a3bf761d62111200e4dde40c8f5dabed11b094a51513e482a4c0a42d222beba56fc4ec8bf57043dfd605b04b13ce998c25dac5f3b0fe99f6e86e27c4abb6d604a4eff7a45e6d20c8c66703dd0b73363b1a2d39e7caac59c5ecbc96fa41a523ec52efe0eefb532b104fe8d0728ed9f182e98476de369d8f738a60bd2e7c2ed85209a19b21491ffcd038ef3cde572a612fc275acebc86e25f78e500ea33dd087379bc12a3f498a90fefe482d603489b982e0ce6ae0911f31fb5f6dd7d4610ee9501932e7bfd643191d368f3c39e4ff95069f308014a2142ef94c8332771d494c8fecdb369ed289d34c10ac217c53aefafcf7f3607a1cb5dcdd4dd5931cbe7061ddf50b64c7ee8219fa8576bb8a95af3bc7cb0920807f413ca922a325657221c1335e60bdcc628f</script>
  <div class="hbe hbe-content">
    <div class="hbe hbe-input hbe-input-default">
      <input class="hbe hbe-input-field hbe-input-field-default" type="password" id="hbePass">
      <label class="hbe hbe-input-label hbe-input-label-default" for="hbePass">
        <span class="hbe hbe-input-label-content hbe-input-label-content-default">Hey, password is required here.</span>
      </label>
    </div>
  </div>
</div>
<script data-pjax src="/lib/hbe.js"></script><link href="/css/hbe.style.css" rel="stylesheet" type="text/css">]]></content>
  </entry>
  <entry>
    <title>2023.5.15 - 2023.5.19</title>
    <url>/2023/05/19/week-38/</url>
    <content><![CDATA[<div class="hbe hbe-container" id="hexo-blog-encrypt" data-wpm="Oh, this is an invalid password. Check and try again, please." data-whm="OOPS, these decrypted content may changed, but you can still have a look.">
  <script id="hbeData" type="hbeData" data-hmacdigest="8b9a380c6675f1125d6a015e43a36781ec9d09740f2c8297fa9822ba8b5264fe">a99f2d1cd7f89812758242c57c62a59fe859e32cc19116fcceb1abacce500da0960986acd07eddb3568f524414b51fee4357382677edc4c308bfab105e69c0df09264e18e1bc8d0bf855265d9356aa1ea857a30d576cfee3cc8f8e772b7685e8f08c8e4b2e75f04edff1ddc2089c61d4d2c14e7cd251b18cee64c0ee5d8550082ecc05177481e736e5dbfb453f2df2110eadabccf236cd1666da50c7a995df22515d9f8b8c01ee255e23f7bc0ebb03571681cdb7df4ebe5e1de154a8997b10dc97922353c58d63ddbcbaed7d7bfbcbfc1be43f581673f4f4e3ba7de841e85c7235ff4ad34b5c7393332c63840852ae201a53cd79e5262100fce73abc8abdf0a7dacc779911c453bd072004b32245186d52723509595f95c2fa59ac1bfe9bce723a3daedabcb324cb59b8ac94ebdc2f9baf24f369dac58b40a9a15a3d85d3c188db74716cfc9b7e3f1ebfffb3454a8650beb2afae0e2cfc432ec77fd26c17d09ef3d40685c2029dfe5c36f64080b1df81fe166962c23405b13d16b722126de82592cd1eaaa004b4ecbb0c146f563c8b8a080804b82d1183562110987644a3fe0036581c46fdb6ab90eceb0f46d72f71fa80870a0fbd03b6afff7c5570d2ffed8bd4275ada03e0ffdbf7d5a5fe63d1122a701dc02fff5f3c9af8aad55f2596b428060dbd7763834058fd7ff82ba411cdc79f419bd3691cc22fdbd17a79794ef439f8dc208cb99973403905c1c95420644ef43bbf933edde1599c8fcb8c8b3cffd8c2984627d03f347853902fafa97e247abda8dfe35a06af3b07dc5a2fd152c2ff91bf76767b144b77c2fc3696fa7a1db735761802215e7ca412512b6105c5de091da9a1079d3141e33c52a4e879e797798f9e4f51a1e6a6de693d5a43cef43e3da5a0fb8a878eebdf1273701c437c8c2b7a6128df5f7871e3f87b155834ff0b286161b4ef42a0807131ce17f90ea9fec6f6d29aa16fe7bac248f33d97115600dcd9c4970b4c070ae8a689d40c96bf81bd8fc71ed00705883dbeaae7d1ac9154b76ae304f9fadfb1475cde01051293fb11ea0c795f4fee018b4519e465aed43c15cb1a0731afd729e8840f4a4dd248dc2a8c84529ea4da79c9154c56c26de17927b32cb9d23c2002f42b635f5b3d793e2b9791b98ea513f7f9f7fdf52e959b850713299b9e57ce75cbe097ea21228b0a828b0c4c676c938eff2b78765011393765a026437877e605371bb242bbff7ada223ef0be07291398d85593fc71df85d5b6b98a179ba4a5225b9e5e23e3162260351aca40b5f8ec33af2921de91a8d7e758bb83450be2f7ff783cc25c5edea91b3479f7373436ab87c10dfd216fdfe6de93a7a4011faa4dfe4b68cd65b6d48eaf5a92f2d81331817ad470fe7062ddb5baff314db8f1fd224a3c26937fcc6d6ea6c97bc71c5c9e839e8423a2eb22096a0113cbe201d8b1b61ada51e196db601e0920abaf881e3ecbaf861e007f911e281b6db7c7c39f7310a1f8bf87899c9db3091d12f583449a1e2bd854ddc508ba74538c85a3c44116b2b7a88561fff2e82c1f9e9062c4b68d3208b1f95e9ac8a9c0ed67f7ec7e50970becf94a4a927443cb503cba41530fc90449a9218bb5e620f34061d10f0d26ab74582a09f4d89598b6c44c1aea2950a737c7e8eed7a0a1a1976cd72560ca3b79cfe01aea2b35b3e803271c385535d9a53147013c0aded7d249908988c1c3874c30df63585fb558a787d717862465cfc6b570054b55f5fdae1f5c25be6a85e78dd54315409a2987c8fea35af55a158a7ffaebf8d26b901d783aff2c1b5eec1757ae669d2ad68ddc94073be3edafa2f10e37493c847ebea50d9953806e1f4292a911d9320a265c3b76468e40907cf56612c3689e2ee5202cc492e7dffd5f8237e316a25cb00181f4c7baaf12d1b193a59fe0abd29dc30e96c301e8b2656a09f92aed0de0731cb4292e87f034b106ab5ca58226e74dab8318cf44434723d6b0d6231e3e349191764134eeb656600d82b5bc90bfcb508f8fe3dc940540073da93d7499b65072aad9fa10eb24ea1040b4be92de6b86d358032a442cbc052c099ef2e1c02f66bf7dfe53d65da6119befb2cec8818225f19c72567a3f8d15fd7831a0aaf94e9e8c79193c10864842b918fa87ca31f262c3cd5bd1919d9d3449e89cf8686a43b474388755ff09d2991c18bff5bb5886f6062669dddfc0d150c3c6ce6dea1525382f6ee5a781cb213bc6b6800a8761a68a54bfb7d7326de7fd2c99272c00d4a6b6f90e93822efa9c328cf9aae6a3a6fd1892a02b2ca29f946963ac5884348c266f076d924298958afc4de5e60698f2cad30cd50e0dfea16a5a3614dbc726496ffeeef5d841b320dd59f524544b142dc8e58b8701f481d0d32fc831a9ab973c5d2074bc3e937b8767a52e5e5a6c606149679a6c8271d48cb2fe61c30cd57a9daaebf07955cd37cd01c8d87ce1f8ab9a2917e77d40b5814fd5dfae26c0f6ba3b6c30e9461f8fd790c4de136195b0149d43f5cfd4e17cf9dfa399f24a4a239fc275a016e459197fee669bc0c24eaf83e0e4dada2c7ce711c4f70772aeb66c53ae4675b805a70cd460791ab2aa99c5f4d0edb3672abf682d33416fa8097ba60293963f7dfe7b7e58d671be76491e5f10a28b376ea2f41572c5a0f1b60d6d0517223d2f1c7032a3c327a5834e681242e5d43f370323238e1784a0a126b621570e3d8bd6dda5b11f062127156bf12befcfc64c16d005929973283aa19b687965953787b102734cd33aa9205bfbc7c7f4d3b07f84a01c5703ba418a4cff6a772177387206e1170ceb1b8bca472cbbab4f1930a8c6ea2d2ab60af86ef955489882a2c8e0c7bc5a237a82ad693680439417027fccf046c4ee2d775de73ba1d6c3883b0752fedfa07172537d9a53438f8fd299ba5fcce2316a94d79edaffc821ad3db7571e54046857f4e7781adb06dfaed6a38a9c59541accd570931162e50e0fb60a5bd1f04a02a2427e5028a57179a0c60b201cb803f2f46bf95b0512fbc5f441ac2a607d7db86e8637f2945eb315abb3ce7d1798d68c283268a6dc2581718741d4d8f3ff59768cdb6f192789d2d472afadc3a8bd5881b63407181172b2114423f5541c52866e836ccd6128f6424fffc76e38d031c70513d74f0fe66796c44d48cb037f82dbce2fdfa9cc2cd897a0f27ae03a8d09ae2f09f14c09b3b34144e3fe26dbc4206ecfeca18317cde6c3224330088db095daeedee01ee9fe1582d37ac4ee0bf4fe48799fc0396e3e533663eecb1e31239cf92bdad34a87e3765873e7db97547df87c9715872d25f6e7072c726b4dd7ae18a93b03380dc07236e6ae530ecaaa893e058900f6b0fceb686e31a206b42afe7b17163aa547f879d9ec3ee07cfde3f3dfb2e538cca18f8246761567385a9eaeb506007c075ba4ca6dd2997341ab76e20cbdb60b2988f5b415d2bcb4e0977f182d516785cce6240f6524b5a978331a2cac843970cf45a972ea1862552cfcba3420eb8c34cd060aff8e1409401ca5ee8fc5f5d5358b547597824c62a6d0f0745d6dcf0e9295986e36cd54334d57e85fbace02617bd60f5378becdeb7f82118548792b72f2913269541f5e31696c8a68f3f04425fc1352718fc33f63cc694a978235c82a34f475c975a1363ee6a43d41cea61bd952ad6ec3d6f13d49bd78f3b050f9ad6d4b98b3557b1ede928c0df78a52aa45e73d590734e055b88f453136dc18314d27b5df4e8532760dffa58032b60244d664c67f3f3dff67bdef6bdcb463ec19c1ee6cc57077a039ea10a7cc18c47c3a9083f046077d21689cfd00c5d3b0a637667b09dfa57cad82962ad4ee128828d4f1735a0f8bd23de3e389c45576066ee39fe08d2c87c0f0b0e17d0e13151fcb6d109a7b1f0289da9648ef5bb4a9406aecfbf8bf5c8e3709963ea59975e7b20ad78474cc8b917529216f292da6e5a17832e8121f6466afd896b005eca808919bb9c76e9568ddf0ca4f82925a0fe90512dac6c21dcd5ae1ab695d97b682f47c97a547e743f7c903f707359777161e9d7aca2de6914cd59c8f7b1022aeb51a295ced8079722a885767f3ab55592eace4caf0d165953f5518396930f59a8b5b8428197ead9d5ef681b5ea7367a2e0d233b7a769861496a4a4601cbd4c3deb366a4ce15dad22dd7a15dbebf9decda353edc3a31a9d06fafc424ea68810453140f124c4edbb84c88613ad8f65f241747a5b62feb0bc9fa9e4466b8fd80de4bad2a58c22b0588a912d0b9a71b99fc72f88afd17183811d60e264a0b177eff06408bc4a5a04f540dd810dbb122ead8c5a28615b74e18454538b75666a354d104fd0b4c7870d64d71a486049286755cd707acf23c2071880e1ddc2b1c21fd6e6660c554b264c8cdbebf98a8b2d3565481dc86696d879e6c2345176bd79c4195d6c160758b55f6df1007530992c9dea23c3559360015bd096a798cb14625d750511b9305a9d707dbaabd06fe667d32b7ae62621ff5d36d41146b4f854924a405de55c7b282e3c28396fbbb5d64151b57d3941072b2c023138370d270845e7f454b07a2f650456db68d3683ccff81bb74d665ae6f2d9a8a35f31843f188ccefae9b40e8cffa1fd9b0f9bfa5148351d2b0f4141545ce1a3b0d6502587e026002213d448ae10c247ec1c774f4406c552d0e5e21733411abdf877c7acf7b3fd7148220c6d3012271b6a012dca3ece0e92bab7bd380ef030f9ce9adb05bcbad927d39a42fe3ec3f76cd455c79d682926837ee54cb3263f12db11a93735830b7d3eab32f28cd39df6cd45c607a2f7b47b2e5c89e164e73f34f6910e605ccb33b17cf0b98a06bfa24d520609f107957abea672d21c6c307af0953db838ec893b0068bc6aa231b292a9a43296f2613fd1d7f6a6aac40805edb8950ef5f32e24d3b675302eb2bf6152e4f278f9b01a619dff8ccf8e816aa071232bd4a30b4e7401be9c5068118506f5f655848a381f389926c3517efb43153520205ac35fd20c9d5bd119a34d7adf9fe586df787a1a7315561f7535b06ce26c094f321f6ebd6460f2e473198c388923bd75910561725a6d08b5ac66755ba9a8452d3a09d07ec543ef838d368303c7d315684d81d2902ac1f5bb9ea5a33d7b04c5c144aa67e8bdac0305017f4908a05887da600aadbbd6e0427818f2c104673d46878e29ec3b358c3a2747a6da665f824d9951b7e1dbc15a8480ea3ca6b28a1e38b97ff107f66e063f91ec5ca7ecc74e17e1b81020a694a0a0e2ec9e5f7e0b5d605460770bc388926ce6a84eae3d249c6da2d43f293ad9c71b00ea1f9fa916274024606430254d641ff45a547b46419f29a95dc3042aca6a10b29d5fb560136a2b30da6a5a8c2ff007f9489de601fb54cf48b83cfda6f61d31eb596aa48d003cdda68541e0e38888bfff41aafa3f4cd9a5be5adcc0a827b772da76a7b406caae5edf861a51b56fd6ad108e80aedde0f3dcccc1fefba9ead81bd6d084e0857a45859d44155387683e50effbe44504310edcf8bd6508547ba066eca46fcebc96fde58b2017aff4a59a8bdba8eada275e67f0fb68da19a386ad28338a3d88173238217d0afb870bfb6225caf5b3ec395136e70012f7934acaddd01183953e7a8fee6285dabff0e95bc45595912760f05d5f51f5d4df76ae46b010f11c4f610bc094e4475baf98f0b76f8f129f2a5e64ed5ca239ee24d7563bdf53d24745bb182437226f16a8d013304c21ee42c8284737942a71daa6a9c0fd73345c6cfe478425ac33183c019ddccb3f1075da7088bdae296d5b7fe5783d8ead243b7b31e57180b75112047feccf077a3d622b8863ee801df6d96211fd52d08781afaa2aec5689e533097ff42977fc3b13b72db69826471d4bc6ec5bb8a8b921c547da3f513882f187b9c43824f6a3615187d5f1e0a6397c5272648e8dba1cac778ac4ec60332c29376861012157fd1d02dad692cf82957455fdfc2be676a7f4b786f34879644cf3970cb791758167faeddc044e61f4630a9139a45db37378eaa4b5d1d6f4fe3ad91af331dd34a1b5bf5d35ed286c4edddb8a2453cd4bb8e848d7f081341a7f8a807a0895c44aabf58a8cb807eff8ba9d211f1847356be2456ffc58bb1f0fe1beac286cbfad03c6481b182e141355beccb707975d314900437ebcf269fcbcc876c2d5784c3af3613ca5949275332840f02e543049d0d75caa076e653eac41c07cda7417f005a69c8df711c2975893e1350347e22a0b1ab53839d62244ba44f01c8dd86ad58680b18df9989fa5624261517848a1601dbbfc319e32226b02c7d0ac7c1358f160d152736b0784e268567ae723642f4975038e53451fc438a33638186d2ecb8ed30b4f7d82d444968e7ccf31d8baed322614629f73690fde2368944608212c5aa6c44e1db8470822e7cd390f077837c6bacac9e767b84fde87c4d9a1c1804cb8f07ea2765d6a09a7c129d16f75846b767f7fb34a18e7bc8f746937dde8e7369ece9dceb448e39226bba7543c55328b9b2f65ac036446330f7e4ef4c8a4fc2313d6d36994428262d42e6e370300070fe4d522924c7bc651f3605c9cb5fcfcdde2c11d216810b54bb84610659b0fa5beadc14e23921cbea4acd7e531b707a050d1148c2fc9fa461960999290be9f79959eaee4218505ac837eec26c4302a401b1c6871760bdae763e0b4ded56629b686cc3213e180ee68dd25042372a766dd9c6688912d2b0850fdd770fbdf9424da79053d7ee4c9f3e041953c2490d15c149f1c42ec4a4fbdf20b9d75a254fa61d5cece2b631cec3dd74b22ab1bf7d58d8e54cbf24140821493ee888979333084ce21717108dc52ae6bd1b0bc12142b9e5ba668ee3de84726aaaf7f12c72a8eea8baf9fe4b9daa592a0304cd46962781f635001441fa74cfff92269abce0a4249384eb1ddeb25cb61277084c4f23622d92a52d34520e715147201deaafed0a11abdb542ebb0180cf2c3e87f55e4540c9248466ee055d5a33ef8662922bb04257c5f6829df3bb21ef21969a9c144ba9f55d066ed6321949144794a8a348c19bf7de3d4c20e35584f556ae295ebd994c24722e618b3aa6721dd9a67b8b4b8706e5d0e0895f496355bfc2f11dc8968e955f2190f355279af6595b8d7f67cfaa708b06db1b43c3ecb0ebe72e25aca3a2e17aeab32b0b8dcde72083f5966a9c55598d5b078d0346a5d1f12a7c660b1b3889c264e2c6b9647485f85cd60ece5b7057f2ab2694e6bc5b354f4235334ab205cba03b40aaff1361cc69097f23f2e81701b7bfc7e7fdeb0e9ff01031e8c7736d29f5ab1a5bb64cd71dcb499a827addfd803327c5f4aea73af8aaed77e23ebab362830e1289eb819b1fa672ee2f43be50bcbec075ed2a8d51e0f7c99ab3e33f0676775cbf6ee7f37ed72d8c44f30fcd89bb5241e1b476f8d59d0f87f91b4c32d61dcd1a89967a118b41fe776329bf7c77add28fc02867a4d3a7bef4c40c92a99b76dc9356f099a77a931294b132b4f8e7c3325e8fa3a8b4a5595be8b9fe0b486b4eeaca794d67db24e8bd52f23750376e5b0f4bc266cca03d7575240c66f0da5a8da0e654e7aa765fecf80493a2890bb7f7d3a82eecba250e078a3576a1efdcf3db6a579f61b9258408427957a8d8ba76ecb00d74499eb534bed2ec876fe85cc7460c1013b43d9324a3061dd71596647dd3f5996a33a6435fd3f4f91a88e671f0225fbd7405b29959104f04df3506c3a4db8a854125b3ec70cfa78502d991924abbb583cd1069e3fe10cb97e2e532c144084b6227bb9d15c60633e941daf186c40e3fadc60844f7abe2875184846c343d34d29e83e7195e70d5aeb9bdabdb78dcf23d48cebbca8c94b9d65040c6b07faa829221de2f9dcc4561b6c1650c410bec75b3b79a3b0ba28944c0f0e8eca6516a0f423964f09a707e9e74c7d2aa0dae95b3706030c7446f19132dabbccd134d5379e4cc66e8d6b2d30f4882125a41df228ba074f222492d147acb0cb8e3f6af2ecdcd5a1161eb26f45a6c1cf6a523186abccc798662e734c2b3661dbd32072ad4f04c6199aec7b4fabf1ae678c055568f269993193a27eeab1374b5d88de87e4f84010cebd3cd2b0991b59601147812ec714e6c9c517630284ba141b31b9ea9df76f419c0419039543f6a5aef524637ff9fb9a69a5f6694c9d18400161e81a2492f572db483be6f5969a39e4aa9f8de3fb84aaf6a04cb7e4320201eb300e954c5ad2c1b937bfa55f095a874918bc4c80553ef2d76285bfae8670de0676e3b36766cb2b59fdb40d931cab1c61d41e2d3a2984967d14ea5810c96763ad2af72b61eb8a0a3d2d00f55d7a39bd3919248fabb73b2cfafec019b28d456ca59242938ae2fb3182fd46d9da488a6d01ebf60069f380381e0fcfe730ecfb6829f7c8504022b6b6158328749d42e1807b9ef587570a4f81aa28ac881c86b0e681db1935f9e60a04578fd19e2740160f5e7dd0923b170c35e39860d7c970077bf4ab6051ec0d53a18ef957099398bca0c62cf87420f293d4b8cfb3ffa26c9d4b8cce9000d13dfca124bd930ce4673d36a8bcfc672b94d5fa444166a4a08cce12a569d70bbbb6cba565c8a356057b0b57b2c2569902edbe2b4c9965add03e8fc5b82848b4121750c2479922c7d25febf11c7369bbfb4913ef0e99999f725bf3b3595c590eade71252ec7a299838a4fe1e9652013824995afae24a510fe500b8ed0939544d7211c589deea623bb3ae24d5ef3da2a28c0a4692574e1453d0ed09070d6d8efe8fda7abd1ab01a8d513dc7c0be58281835028983eac66e83391e6b503b5bfd03dfb8c7b95176bde105bed00ed2b0bd97fda030122785366fc81756be1cee9b534d55f959223d1f6271ff5271a1c8a5f7bea3473886e208f49a16f03f792f8eeee9ab82fea7d8671773ec464a66e4f2fea2e379ffbd078a425d8f741851558b23aff3ec7da0e548dd98b94e464e1a6eee14b666c0ac5efcfa936d1f89aedd76b75b7494c6a9d224777fcf03c9e0ebe420b00baa5d52d59f05167c00e020e0db4ac5df7ab8045218be3dd28dd0894d77a2e3c8b20b2574e504125544cea468613557f7ebb4417ee12899d9fd1e6a15a345fb46e3b307d9175357f88cbcd45d9b2a4527940c7a1f869945fea244ea7956d1191510a07d26e6d501bebbdef129d599128395d50146fd5f5cf107957f480517174be55b454bdb71a99f8899f59ae0f19f38a203c8334be6444480a32bd2d70b9ee43b548325d432cf05315b975127e97d05a4f4ee4a39c77e47284f136be83cada1b10d4a9b425253e1563df842a620d0d143cf1a82b3b1be4f5ece4addf9fe823a56201a47adfae18bf993ad815de5d655440fd3d5891613ba530f70b60a0d369ebf497d8fb581d990092b56c6804072763d2b4bd58435b886d748c10b097822cd82a849bc93d66eff4d4b8c58b834eaf9a782ae69bbb73899510eb28e7224070dee07b5c1906aaf6e14aab50a872d18b622050274c0d771c574b65111b6e2f8a141c202e3e088a4e832d3fda3030d3ddbdbd0d4f5357c483df5b962ebc9c29b86195bf349d6a9cbe86ee0ab610f9f1a9e79bb61808069097c93165975b70c0e8acfcf0e4dd5cbdd1aaf6745627977bedfaa13eeb18dd87147efd61639fa3da4c50f41962d25c0cd345dffcf6b899ad192de31744eafd91844f8f0db5c7a82640472e2af85ad0cc2f8be6862710468d13f1eb1e5a50f88ad54711a161a3ded6cc7b739a77b3c06f909952be61fcced56d3bef77586ba892f37d5bb12d7a685d9c87cc86bd29ba5dd6211e6b831e20d016aca77f07c44451a1de57c78c70c3be265f0e2e91040fb45abb449fe2ed6cca09f5d39667f19133825e17c312825c49e8d16a67b7e947130884b4824f50b2e627cc0b53e3da0f34c2e6eeb92d8a20291918b599c7fac08bae77f1d60fa4fe6e95764304b14bcbc2e761706e1d19bcda933d8187d055fa9315b61bb2a5e29954a1c4d99cda759687404362dad04633334e626a562b879bd5518826ebccbbea93a291f46efc175fd21dc62470bfee3f873403a962a581f72fcc19b1a6d0b579c5adb11a2aeb12d3486d823bc08b286d219be4e7ca05cd7d00cd92f99b27925869e93f8e57a7f48409988fdbf1e5bf7815bc9df378182b58cebf82de83ec4be807c2506ced867a2050bd13a3a08e6f4e19730c8b7f45e6fa4c771a78c69b59a197fea56a77e5bab5aed6ef79d4e3905c833ededc00ab43c15896e7066e77c91adff2a54eb603520e78d295cb02c8056770f63a98c8a425ebea7784294b75a5908498264079c58472638ffa74b2a22ba5239b745558dbc8018dc2f003732cd659a01fa6b660ac21e4ac29b6a170dc7fa1eba62cf34826b93e55d779407e2e6275e5f15d73d31356180fb19580ba995c1c34d7d1ed9e2f28043a5bf27877bf0108226be10b35f6a3e84d994f8a7477cdaf3e6e3f7c584ed5bfe765e0d21bcfe26cfeff9159cce9bdeff989ebc520c40719e771f44e94a1cdf42cb362115595b7671daf345d6315718452d5d358574bd44e041e3626e6efc7859c32a8e57bdbc073abd278c77bfa06f35a078d264b5cce8a7bd9df8a1ecd14cc04c435f63a67b633f640aac8878f9a51e4acd291852a5f3093e153ef548bedd15f0c0cf3ef8e44ff7d665a6ee2af766330ac79c5a1cab2c623d745ae7b4dd2f01c6f890d5eb80256f263eff72245b4173873d817b7663d4c41e916b4b65850bfe7d885f63de52899f922d91b587badb029e563b104de426d45e20c2012e64f1d0d92723dc7907f8d4293d2ce3cecd26b84bdbd11da04316725be4025c4bc36c5936eb0d684a257b4d947222ba97c73f8efe07a343a3a1cbf5e98abd46ee9d80f29f6f6aa4402b7e8db154c06f35d93550eb7bbea0e0f5dad465f4b7c425dfea7ad386ef1c6f885aa9ebd593ea26dd8f5b6505561d5feab2f8c1f44362ef5ec3d187e680f283aa3a7442145353d05c0c5ab84fb125dce674199d777438fa2b799e750fc8d65f6e9ffe97107ed400f3ae1c1af4d189412caa5602466e6dd1f473076fc50537caedee1ec5ef658dfcaadfac924407ce219158f884cf846015b1bd577a5c9576f81984757b5c88fa7fad4cc42012cf43952b3f2202220e443bdc41cd8614d55fbaef8e02bc0119e9b789a00a11b45046fff3f9ca2007dc2ef1bd7a681d82d9908fc54b96c85d32db31066d4d0743461fa91d1dee5f83c1dada5eaa5d1c8ab59678db9f5c621a28940267e2d2b2aa2aeb7ea2bffc403b58ba33573485f00ec89594c4fd2bf4a5a4e4c593a692b1376359c41793682ed02a5a2bbaf66904564d97563d85b29e22e9d2b13f24384ec1920f0a085352c0a8ac5adab41da4fd7675456130d9783e97fde22ba835685ac7b5c71413cbf2809b462164cb3104d7293aae6a76e7326b9d9e57ff9e99f73ad658b336b8f24c2cba86eac3fb932999aca394ecb95c393c7a1831a4db186754911ea9edceecedd3db4c8d9c895bbbb7851ead069d789b0bb92e0341d532bf28dfb5987a511cb83ae1ecc632b20b56394187b27a092d00d5474b373c8b132d9237a7aecd7bdcebdf9f488c9873580915978ae21aea1caa0322164ffb1752d69ad1825931d987317bb7157262f1fcf7d8b5f5ff5e38d50b831b1332a0cd468e56be811627a47be0089a408c9b784f8632c56392b0703c61bbc26146b51587f2c9b081f16254cdddbe429ae2778f939214c4ba0e17b13cc61db88bf91a916866de8270ba7c1b6a2061b4b7c51ee76ed89915bb78ade31c4544efb574da235e21a701be05fcaad1281a94597bd84c1437c66a46b1c4a4d868002ea4da637390e7f1c4bbbab46dd8c92cef91e74fa5905c8a54a6b249279a979a3090d20d272dbf87aa73a32d1e4b3694473597c3008195aedeb35acec6305e5ccc73a986a0419994c813b5b0109c137075128809671a9dfc5c604af62db843c6ee2273d2063ac62390b23039c3d51361b2305e0d1936c116b65529287f869f6e81ebde930cbf32baee830d360d381b4c0cbb8f88398b06fa4b4f9676a148580d8cf117d385a30db5c53a768f4c798e3a7044ee0121cf2bd9cc9c74b6a709a620d955fbd53210f0726ff81fd2f52e1a4fe662fb009c143497fa2f951169ffa07efb134997e3f2ac00302a2b9ed7b10c84e3c4e342d7ddb3767f32cb08782cf75837f2d73f8c36985ae575ec50b654792edd73ec566269f5b9e73fc08906f8dfa306c6e8fa38d7697632ff6bed7849feb6543ff70a90ee3d720139206151af5d885834b7843b55cdfa468308de0865c3ee730e1384777b1d0e37a34f0015486026af2a74634061d5780e803b8d4d6a85a9cf90547ef45c56fe2ff7468dfaa7a8b796ac4fde053ea0331b326af5249b7db3d14ac4594be0d61611f4f599e8dca7dc3fbf331776dbef40766d28aa1b9d9d7e3decb6c261385cb7dbf037c97795ab1e7f91d8198f473dfc32dc84dfd24088c42cd8c39211e9824e330f466d28c51556784246139dc7f3e253c1969e417983af31b429be8148bc8b35ee4d1d3ee0d57af1d784243bbed13f7b0a6faf6e365165f5092a256137f44d43625bcb32571eeb7d8514023f8d30c74b8c52a1d3aaa9b941364233a68e60be1e3905f96318b0f36a50eeeb259c10248613e58cfe4a5675485697d92b396914d90fbdc88460e431097d565477aa6f420eb38d3a929cb4c68937d26c7976e2b527cceb7c6b2d3860e0b9c525f39c5ed0842c06c82ef17b596d79b05b2321a4f4189c5bb8f62c92fdc33df947e0c5864e010edf0f736fde31fd93f3da76af49589ad2897ad3bfaa88150940d7638f6b02fb702b4a4b9ca08fb4aae66f13e8379a28d22ff513e56ec7d2b9b5d91b08dc0bb1417cf7e9ac68743af4aa208587543954b04a15545b2357885d34849b2744ffcdeb85861d7884a3e649a499239cd806009c544adc810add82b75b0e4ce13deda4b7aa134a1dba82f32f5b857a2037218c670a1191737b1fdee45223b8a4b41c91f0736ce32a418b5381f29f2ab5ac74175a0b29c5e8beacbce13d5abdfa11cc36a3f068c9d81d59b607b285956b9f53334ce8703aa35937716a9bf1d0449bac89b1173c2363293e746597c2126015ebe6a5191fddabd4d68add75b2d0fc5e3a2ea78eca1da964d811cfb6bce46ab7db21d464ae70124f8e31ac560e88dd730268240be0b77a420e53594cd2eee4fe799c09b13afb5de9dfdc9e86d37bce232793f50068cdc1593d0866d08e1529e52d2594e7e6aba7dfb3621e4fe705687a1db014011ba1d60d3ad18fb39921c24328d05ae65b269e11c7119367e53ff36f9131f4265454d83698fcc9108842ea1442a79bc4adcac95aa047fde6c328b19da14a35daa4973d82a53d4afab063caef7088317e745b949c0c5563cfd6584679591d546a16931ed37639e65c7e8e4fef335be2a6bdff647c52fc9b0b59600c0339197c867866d5bb491d8e6cd149f314383ee43319b5a36e5a29612eb254e44ef0f887b308489cfc79ee41d440a890b7f6c92f5130c7ad48b0a9e5ce0cff0d7fb593df7470049be0eb578a24a8ceb14aa247030a03f2c853417989d0e5d692e84c935de3656d1457848280fbb743571396f5bcd96438b942a7f6a06cc1405532185c6047ea542d8db6f64356721fb07d33eac887aa4f82cb640cfc4730c9237ce23680bf78aafe58ce9e279a208f44c9baf76f9548a1afddb0e70e5a993447bbe785fb15acf650bbd00fab7b2786c51741f7361854a7d8401b056e75e90a52711b8bb1268b81cddb06e08a4b31e4e6e521ab4462a8aa734113f6eed2f8dd6facdc33d9a6b0cd1cea00f946658b154a249b52bac608e15449c121ac76352b568cf78fc1f488b58fa840ac3b16d698332a75145162a92619e3bcbbc92145cbec310a337efeb49af32c4b4369f50753c694dca2382a424dac6f4a65ffff0be9480df13e62bd064fad64ba7c3dc3ea0125701454c0969224f0d264834570b0eff6c1e2427471e3235eeb390743809e20712dba80901cc6c525b98c7c314e430c1ff10c17ea2c530d9c7d30a94905974a55f8fceb25540d7691d4c9d48406229993948bdcfff3d83c37bc4c27e4a7cb1733ac00da535ff52049f72a31e54493d3b06419a1979e30b89ddfd64b7240fccc85114041c8fd5abc49afc60ec9c350e7be12422a43f7dc324548c78315bf1270c7a4078f4c062d06412abdf6674d19346b4d6920fd73a0ab6512b8c964aa4c4f5714a7ad5d34f24fb7cd6a180d187e7635b3b0a3e542daa561acadad449a2a90bca60421717ee86146c375786d284854a70646ffa8141d8bce62516acea62e821da90543892f14f608449243b16098b63192644dcae4e6a725c8a079ff1cef3fc4e5373debb1c612bc00407f1262b029812b3fece9f40fa831bb4e49869a3dd3cda1b4578bbd536f6f05916c18eafaee6388b287cf7ae9b04d20918c30287412ee0bc84c6fb069010f15a751e90ea00e9daaa3b3993c62aa7a0ac84b57916e8fdf18c86bef3d1b54b83576e545a2a366f89b7599bd3c52a97eab361e8e51c82a1e1f4232be1a9d19706127d4a888f4849a9ca1f9864bb011d310f782ca9d58979c0211d4b0ada242e0673d424627b77dceeae6644d18901d22ce44f897ca997b223babacf0d6fbd176c1a4c653a4cd3a39c4d6168790b763cfcf5d3868cb0840ae2dc1ab38a5e684f16f54c67c98eeb25b11331e1fda24ec123efdf5d9618e4081dfe3c0f66c671c4d182bef84f3eb63fb5091d47cff2faf7699c60baa9a8fe79a69b368352ccb667ee6a25a19972633f90a4aa0d9a1dad2360906191d99966385b2a2858944e4caf9ff56eb062fa1e8476d828d083e6050131fa6f5db4ededce33f89c1f81d5256d0b21b9e20eaf0803e18b002434a94374d275f65b51945856515de7b2af5d6ffc032486e658b923bac5a0bf21a53f3ab30d532e1dda3e09768f58a0bbe812a8b87fc0739f5ae634bbc6215bccfe8a0e24c3a0f9ae71040996e9801da42dfadd6b21da311c1db9e1c49b76ba95e71b96f7a1252b7c7b685f4092ebf4ddd4968513a97a89fa3da99c9dcd301dbff8657688778d0e663cb9110c2150ef63a763250cdee173fb1520c9372918b49b24aa79688427c54648fe9f70dc8a8bce3458c3b3dc72cd9b523249548f290ec0325f4473e504f65b58945c265e3a4854df1f89ec012d88257b1f7a8e4a671a44a98179b3cb7dc3ae064ada190f5dfa8af1dddf6752432ee95e0cfb89583eeb674b7196831bbdec0c194a0915a9057042e1ebe98bb0d842dd6c5a91cbc3cb9e0580ce7882b5a0cfe7403f547dbc81df0b57929f393d1bc8f9d6f79d1841656902b34b3036c2a3abe0d9e5c98fc07263dbec1d9314bfc1e995e031d6afcf5acb88d2bfb67a66f9422d6c2bce1581b71d7aefeea3b0ca4a6630c87fe16ada5a4bfadaf940d6a45ca406f0ac7aa7776de0c9c35652a312683ebb615b163089d21d1d9bc5f3ee29813a1a11b771fa404ef0037f155b8a6bf19bec9f7231afb6065f3c6c82258a1aabfa54fda8d778f62a259850d92447f17acc6e25a4efd620b3127557e09d6d45754fa7e3edd2e1de6879005680b37d0c0180ac53daff8c4c1db88e1c624de99279ce81d980f156888f477f31fcfc05b095ded5285aa7562182b59406ec50736322b079d1abe52416d8001daf388593d0532124ad4a7405e20b327a622020ccf353f7657b157ef3c390b51f1b57fe8d5454f707f61e9b3d04989f58c00340f2b0bc00748cdf580976e39aedf728cf1b8fd37ff79626f07cb81f212ca29181d9531021a49f6db44b2a521f3dffd6f8b529135e2ea59e5d63645e7f1ddc012e5c711180933fc4840b687dfa5923dd56fedd60958c63dfa1f130aaebea4d226360256c40204e9d9d0b33040c995bf6ae610e784ee228aeab90da8cd2c0707259619fec6e13f409cbdaf41e842b9d289b92ec491bfe05fc83fb5e5bdc5a2c58010dc96d72d78c955e582f18534211552b78accaffd3b31773c05c7470733fd3be7e917c91880cd228250deee2dade045f91c0551eec46354123d66f7becfd32b2d22762d9f18b2293886d20719851dfd6aa72248d8a9a4a072f431b8ea5e853d6842d7c78d75c065c8beb46351ae14526fbdbec5ae2c8bf3a21a2529695da971f8262c276cc4ce1660862b72428e6973dede06ccdae6fea90a173d14da05da51b4ff9f026e35a5ad7c4d3782aa65a0450495622891780316c899d5ad9e96c734f9eadb4843b73a9d5a7cd91fbc9312d03a289780deb774d04e0259741deea36c2ab8ceb3a65423139dbb8555ecda16b4e3ec1047bc223c48189bb106fc41f970ec9758e3228906e819cdfa7e30a229a180a81a2d86df526827b8d7b1e77ca22eaea6439ff3931ebd8acdaa85729e62a91383391173843afe1aa8b453832b9cd4ec9c32afbea22158c437431106013501607abea465da94a3f8e47f0dc7bbae0230a81ad7a84e418bb2d7499eb0aa1f3a887b8f6505a87f99d9cf679352152ce3f92f54e48b298bab0832c5bb1bb781abd25a3906377d0350971652f1d71a59ae303d9b54012bb8ced8deccb196c2b4019a904f2c4659f05ec72ee36a83ee16d608a7f7ff2abd2fada1adf6921c266cda0138b2cdfb3d38e8dd5b354106ae658d0de8e67f5911846093cc32e5d08d981c6bdd1ed8069dfb7622dc18b62872ee3bbd9f7b9915e0bbcb0366122e149761b7a6bd08d58a61a6c16ff76a6bdab500a94f3fdaed8007db39723ee955ab7c9ed856d5392480845d6e61dcdcadadd5eb66b178822584231f0a6a3cedea85c21b7f0d741b30c601816f675f7e3caf45c635fd1fa54d4355ac2e8b15faeeac77f8d92f5f594475fb9641cbb0d9b9f3219c66561b3b9c1f3cd7e3f64bff3ed58514b09ebec755444a0789430368a746e8293c66c82f4a5f1cb703c6cea5dbb8b30ca3d75da8f0c06aacde6f90372158eea2482a35999af341baf8145df0e67b13fc9513c0bbfd651153c13cf69ea01aa613eba55fc78e7faccc44890dc66868caaa88e3214ed22a349f30618aa9124eab479891047ea32536941ae1b542f3030225dcecac0aa0731c11e9a5c3b3e8cf54478c7dac57c1a05f317130922793b520a33bd2c5462e972fd3fc2100547cc9b2d48f0ae4e42b3cb3abbb16446e84271c151243bde71ce41e90b6478f68d371daa23b203930167db6c1a68db178e545559378bbd8e5d3fd075356e36412319f9d8904aa66678a4a71af09b4d48c642c68d0618d501055bc6ea85c497a073b57c28efaaa63f2851d60490de6487f3a9cf08c116f8957ead3d48129125ff23d954a8b89e2a1f1688eee59fc2893d191dfee48da2aa79214c28f7135d9918dd19203615b433d5eaed73f5370a1bacc5272ce1888daf9783fa01b842f27aa93fcb6560cee259a99e5f30301ecd5b9d3543d31d1af89cf1b2e14085d6e9716b19156a425ccb0ef0574614ed11b2dd8f1d9c1da3a231d638c14fbdc1dc54d6af8c26e2aff8f8419a1d7b7a32aa0d9bd682593959221a5e3f374707bfafcd3cd15a12b5fb9933087d39db98fbc67c302047a1b2e48c7b69f561822b1cbad0cb8ca24e9ba5e5f8424b7eec25aeb0ef4f84582d57370a3d2dafc40149498946fe5d29e7c0ed2b75c3a5f0490ec4f50b9dce0ea7178d0f1bd3beb3ee62cdde7000b6259878b1ab8e5a2e448c1f240ce4901513701651dadb3636ba5d5efc317f7783dbef9bdad1d5468fa299c8cdc55397697a419134f0dbe3cbf48442cf0fedde91532219b5ed67e23c3104c11e1c6c5e9e7557bcaf46aa6b120379ff96a7838465121777e943bdf7f96daa82949d9a5016a522faa0655a6e9f58e9a21af9eb25883c3a8b73280e5818b4049a5c8348babed4e4c1417eec9a932094aad9c17f112961ad667c95d42b8f599d48171dcea29fae8ae22652cc1e18a9c1dd09e51b9c11fb71f5808b2d4ef9d055f2130a222b7eb5d2f23516e906f08cab685540ddb0aacde9cce6be8023516151b579c475461e806aafdeb48597a1cd487d170f4943b97c8570262aeb6f32b39f5bed1c3cd114c6edd49b57f3265eb807b49593c2e2affdab2e68fcccbf8182224d68aca97600a938bbc746c7a9b713898547ceb22951a59ce7ba2c98941ac56ab6cc2b50ebac1e7a34927426003c72c9b43b75c7f542f3a65fbbe5b30c319e7f59f58c8934b654a5aaf22bb64157fb57b9f7cf26a258322b5698c628c2244c6b12fc8954bdc96ad0ac5e71a96382e2c4bd2f0e5ed8367a2513ef40659dc13aae5b07b7e69c4e01c750619ab771f08e78a65e0ea5568cf0ba700795aacef8d989a9a7e4bcf03bd5d650c7938e861fdaee3e5d15c476d3896a94c82815835bb336932db8e75f4ffbe90aec8743cae27a133926e6f818a73fdc1a1d06b</script>
  <div class="hbe hbe-content">
    <div class="hbe hbe-input hbe-input-default">
      <input class="hbe hbe-input-field hbe-input-field-default" type="password" id="hbePass">
      <label class="hbe hbe-input-label hbe-input-label-default" for="hbePass">
        <span class="hbe hbe-input-label-content hbe-input-label-content-default">Hey, password is required here.</span>
      </label>
    </div>
  </div>
</div>
<script data-pjax src="/lib/hbe.js"></script><link href="/css/hbe.style.css" rel="stylesheet" type="text/css">]]></content>
  </entry>
  <entry>
    <title>2023.6.26 - 2023.6.30</title>
    <url>/2023/07/02/week-44/</url>
    <content><![CDATA[<div class="hbe hbe-container" id="hexo-blog-encrypt" data-wpm="Oh, this is an invalid password. Check and try again, please." data-whm="OOPS, these decrypted content may changed, but you can still have a look.">
  <script id="hbeData" type="hbeData" data-hmacdigest="7cd44ace88df5c7e9ba9c6dd364febc0c5cb31cbbb8e9be8562df0375da95d0a">a99f2d1cd7f89812758242c57c62a59fe859e32cc19116fcceb1abacce500da0960986acd07eddb3568f524414b51feedbd2c2a87190a96c5069a8f0e1fe25c997d8e507e5302401c3d0cf25c318945b5c9b0b451cee584629a536f1580680c97aeb53cff280a7dd41558658678a795a20a340e2c38260aa53006803a4775c4e6fa2c4c3cd3ca50256f0a7c9bd00dca4e606e847cd2be6cbf1886703816fcaa4b4506641abdfcb77ae049211e6c89d4fbbdcc83651eaae56f162c7db60a2e5ae8eb6c20c616d9f385df3afc68940f5d1e84cc7929253099e633a451edb619abedbe612edae83139f50185d50e689167e67b4e0f79809c8f171adb22bb5e0f8ee1dda54079e015dba626f1f332d21387d8892122862f3b1a9c6c4072bc15afcc97f757d12ec913e8c0e656a28adb7ecebb5ff5f173f7396da6082ffc29951545168bb795769c56c019c2c1b8797227d94214ec215237b03a5f91ec8136aacbdc54b52ae25a345a172b9c51ad2d528e80646ab8c92988a4b82e6edddc644946d380e56e1d40c3857ede453d2eae0f42885d6f19f613b362106b41ebdaec82b87d85863c187ebb51d6baf64bca834d7d0b6b0d615c76646b8dcb7c687b84b777131d258ea079c060f7e338c14e5d95288fbd706ecc6ae97f8e2ad08e8b0b0fdcf69b017b9af5a4ccd09a1626968fbbbc029f525400e603a38c50e0a073882e49142cfb6c603dccd7eec3a8e605af7336ec57cebc74cef7d401fd653d5b59c2e19815c5261191942f8bf2ba032afef0f6d6aab5dae27b616156779e2504e00c2d8bd0dbef9b71dcc748a44b9c0911b5ff079e407ab6b7f2e36b239ec6a7161d31fe07a8c99a4ea29e639f619646a71e08806a9a9dc85e54a69779f055b8f116715bcd285d5696fe68d786f1edeecf49270de74c5e85c634587c3632e8a5a2b2cbde12565783e6fd3a4357659e2ed3d3ba3dc3ff38b95f6d5e2d74a563fa785cb57b0ff5a290a4c604926bbc650b4c4618173331ba70a7048559fa52c44dd82d0624d6f5d022e540d771a0ceafc0b321b6a856dccd38661946be6b29ab29bec867133d8fb52c4ec2113b32a9f5abab77413a3ebf02ff48fd6d88cd8fbf38aa9e11da80c7ff8c950a8a30196e7de14db5b56734d31e862567330362b6f39e54999714137b9162f0982ad00be9e995dc3925741a9ff98edb504cbb1b18aaa5f5341663ac7d451355aad374b59b919d07aefdb9ad1f6c1a0838f9895c46b3c2c47f348f72e98573fd12dcdd131d5f522f66f40181c8ef138040922b3f2aae9c75a28c322544e543ff2cada92a4e0ab75eb01409b0ac960ec9f4c0c23b2ee3bfceb3fa13f3fe17185bc10447bb3b22b309d5c9fbbf7f4607d46774ad4dc3414d750e0421a2e6f6b43279bf6653117c2fffd7fe94402c9e9ef0cea944dc221570076ef0c29b51c59b64b5184592ed490713e052790a095b84668484850480997fc24a6af0564225f9d1a9ebd8f96a95354148822d1b8ab6e22a45a8724cdf524988e2b444b5bd41dbe5dc7f267a0927cfd36677025e3da252153796baeb9c2dab5f3803abb77d7b6b7fb36e555693af11dca50b074</script>
  <div class="hbe hbe-content">
    <div class="hbe hbe-input hbe-input-default">
      <input class="hbe hbe-input-field hbe-input-field-default" type="password" id="hbePass">
      <label class="hbe hbe-input-label hbe-input-label-default" for="hbePass">
        <span class="hbe hbe-input-label-content hbe-input-label-content-default">Hey, password is required here.</span>
      </label>
    </div>
  </div>
</div>
<script data-pjax src="/lib/hbe.js"></script><link href="/css/hbe.style.css" rel="stylesheet" type="text/css">]]></content>
  </entry>
  <entry>
    <title>2023.6.12 - 2023.6.16</title>
    <url>/2023/06/15/week-42/</url>
    <content><![CDATA[<div class="hbe hbe-container" id="hexo-blog-encrypt" data-wpm="Oh, this is an invalid password. Check and try again, please." data-whm="OOPS, these decrypted content may changed, but you can still have a look.">
  <script id="hbeData" type="hbeData" data-hmacdigest="07ac9fb80a53f3df5eca0cd3467a9e035b41d376c758346c14e2c4f59df7c5bc">a99f2d1cd7f89812758242c57c62a59fe859e32cc19116fcceb1abacce500da0960986acd07eddb3568f524414b51feea94ed3a8842a2a7cb58681a02b461bf770f84ee1401d0da18103907eac52ca77dfb92f704ea3947e345364b33355d318d77c472db8d68d290f52e2ba84057a0d8e895d34e9d357e217b45b5d9986f8e1e54a07cc92fcea7a6b56b45488c3b3901d61919a897a7e86fd858a048cfa4421524bf642967671ee4b0b7dd0c6701df3478b8f431f0a13279031f6bd0310d751b53c56ce2efff16713a9929037a41189e4d788d103da4ee164bad886de8abce1e62fd8f3db4db66ccb45b00f14db7d00b5dc061c774cb29132e6c3e8b3ce4ec60eb2f753892aecc94c3dc883384299bd84d4b2affdd45f9d3041f1b2f5fb276fc329bfbbd8b157773a57f58cb1c804bf789524368a206350e4dac595ec2f95c5a4d662fff2bcf80218d05732248b35e29368fce8970b7c1a3347bace778b0ba6488009490fb78e2e7a900f047c19f2451f0a24759c8b3bdf3205a588c41e69bc671fa4135bada99fab756cc4633723f92ef36e3bb8a42a389f5b4d61f5e51a4773ad04279210adb549848cb7e324ed69a7324e2425b2c43f09ab31029d1f460852dedcd6295f807d278af851c83e4fce6d22754eb9ed2eee5c7723c226f1098f756e1437aacd6d7aee787636d725861c5fbd42892e4fc0245d5db55067f54aec0ba0c42df23d01644fd3a4ba3dbc9429d7539160b5c885aabd470c918c512a2afcabd6dd572079dff33ea67785b056ce1635da148086a9674c01f55189407a1f3c83a264cc9acc22786a9c03c2fa054b9dc0555e40766a197afdf82f770b554e5e3c4647fc8fa91cb16d44bfcb83315cdf963b523d53ed205117cab88bc4c1d539aab8ee4e74105f54cb41efca8e344695c698ec55378ac96ce0a003ea23d5714fa2e2fecf1e714eacdd078cc04d9902f1668f72e2818edcec14381ced8d83087970d3ab6ca2b4543f17e5de72a154d1678290979a841da4cefb54f9116909bca6b3e53bb59a9162664260d8f7361b31302b03bcf35ba0409539cdecd2ace77bfd7c347c269af2e713543369d31e945871b969bb01a54c744166693a348ec8cbc00d43936362b06ec82164795a006d3fd96f8be01cc2621e832789822871d18e53dff08479fa214d440e79773036a941a83606942456a04c399bc2cc361240d85e1de9a226af79c717798228d95e5432a3d5dfda315834d328584ff3218fed71d3acb199cfb61cd486666d11a388d846f7efb67cea15b10c3566aa74bccf17c8f892f46b99ffd3c7f2fd5ad1c9212d064bfb12315bee7e8deaf13535b7a8928e8cbcd0eeac7895385dc18c24a428043286ba82f6f9e90004b65be7840f3a88094ab4ecf2327dd86114b707288a06361cac30b940602eb82e541a1aa3d7836d6bc0026f05cd60aa544c2c9e0b277298d3b0f4ae81c3a62e30a876a50db4964aeecd2f67b10bc3bdb1b5704d8373ca9b420c1246ac1c853ca780b5ef662e1bbd21885b3e9bbef5230cb59596e96fb2560e9150b9cf57e9fce01790c834cb301cdd5ff27b50f49dc4cbaf3d2bab8448e676a795dece7b513feda12b2b8421593da60aa4103ca938512131ba9d815924b416935d823bf028adbd48349faa5818d663a39922872aae42df7db30c1869b3dc016ba18e6c61108306838275cb67f03b91dd4cb193e03db78549510a7d54ef8d3f3cb158f554395f75d2ecf314cc087e0a942f528761d68e9a85c792eb80f764635ba93edbcaf8e50f6359a83511475faf9b3c4cf5329e70cc5689d865573e9972257078e8ed360d50f440320012aa95a9d95eb72bbcf143f2bd1d25eb8819a61a2c649e91580ca8413ae4d72bd9fec146cafc1d037a20a0b6c1f0c495a7b964402471b99ed0cea76a0090672bf486d811bd0a92afeaa1ef741f1f89fbafd221f8555298f01d2a65abf1403ec8bd15091f74131e966dcc51568cc85684d1ea2640f0c64278bea01fac4020e865e8974f9b97a7bbd3ccad248b0c64781a0555eba1e9e105225dc4714d1682826104745fda806a5e4929b8bb70da64add43cd455d2cbb60cbc12a809b562ded235dc5f737abfe93dbd0e9f51279df4537118de58022b9412c89d6b442c9d4810e93467eb480b41d5df39b328a1fe8484f0dfb19fb222fbf656827dacd24b7d461662908c106a3726520f25f904c723b605896a57943112b98a0033fc960a6c42668f027c69c0c5fa0c8a2c8bd04339b12238937d102c9b655f76b8b885847f3144fe3e6b2d353fd770af897138b589efc8180df9b04dba69aa456763ccc2209d9b1b8add01fac9e855943da140804df717eeb42471b656069e42e763cebe4bfe747c6313e2e2a5c9832f60255317a0882198002de06928e3db39fc51fdac3404c19262d2224b804cfef807453a73b84bac1527e5c20f64596d85f15c03202d28583335228ebe21c2b216a3242657b72ba1e634bbfc8edf5d1980ad9c4b3a658d4547cfa7b84d56bce78560d692bae27929d17c3b08d56306b0dbee3a706e167a03dd9e7a18809d978c04d914e9892a4f433e2b3bc0dab94d11e98148835799ee08037d52e885f08c3a6b9908e830ef4eba1c1458ef9772db64d03f1f380665a485c17bde50e3ea8f5e44745020ce365a804fd7ee6c0f44e902b827bc7a6105d69c481a6fdd0d6ff260fa384f470b2c04395336352307efb9ecb2581d3af6c06d04641ace6deed1671af6c81d220368c04ba19eb09285ceb8a0ec8a51ffeda71d5d549ccd91f9dcc59b30ea41d6d350c19e278ad0c39dacb4b718d9979f8df27d1baa9af4bb49b029ad6817755193350f63502289cc55c8a4e6b9362c9e547b928f367797d38dd971af57f8e823cfa64e31e204eaa5ceeecf8d33c9c65fb8ba5a3c807bae7f056a316e4f2a8883c85ae70fd709482ea2812e1e8de725f911babe15508846ae390ab12e22d407fff1a45d220c14cd71c27a04dcd894eafc0bbf5a81d1df4627f1b3730219633a2c91ac9fd60d497dd000382e9c53864a101f0713371571809ef01eafd954fd58f46985a2ac2816bc59cf25702efea58dd29bf5e4d0e9b4a0dd4c171550b296315c776303b2c8c25d123f86f59aff61435728c02fbca4c02876ef0448d78b6cb44d3cafa5337acd20e4817e77bcd5f37a0597173b6c000c9e56a5d4ce611d189b72279058eadd973610ea047ebd29e60422e1ee0119b26725636bc6395c1c1469b8efd91d9076a35aed23855dc4dd31fbfb0ba81a023a524bd1c8ad4d6965e87500e537558c3ed1f12c18c8a815885f3ce90e91c35bb612e2fda27fd61500dee21da03392126f3e238d8f46f517d0634a4a6da9a9d48840f335812c17a476f9390e4de47de62ca55e349145ed03ae64f70d739013c0fbe4ef0dfb2df635851d9a908f8d427870a8d8c8716666e09213fb9a2dc26a0ac0a80921a946f5027d3b6397fe14fc5a3b1853b6c35d4aa413c4c0e6cf0a235e337c21ae7de6fda68fdff812351605fddb8d53a8a92b08d5e9f9121493f258e0c6bdfa3f21ca7de5b916b11d9c171a370d1a151fb1f9d71ccc54cfa3f04767173ef646dac1fa452e960ec3bedd48ae51cfd58c98bd71e94e5c93d9f1274fc2da3d1e3db8ee3f5b001c4e46f15ee5adfef4aa221cac14701102e1a9a95887123a89ca34df90c7aa4762b812c30be07de3ed7e1177b9a2b474063d47c398ce54500335f42ab6c0c54b5b5082138bfd5ed1724de7d45c4e84d452a1133105271ed452245ade6d9738efd5f28d9e08a652f15a199f64fd5adea7da0c977212d646594df0010f8eed3aa91e69fd8048e02154c1acf4917ee2cf8b419e1606aeb18d77d32299ff0a36822dfb6b3adc0b263bc8c9aeebbabf1253beff9d391b5cbbf00d00bf9e86ca196464da13ab56052258e874088df1345a864db63f1786fdba5fd39fdfffbc5579d114576e8560c95ba25113473b38a744be5457e631fdecd8f311ac9511b5f00f17b1bedfd795e631ac224d19dd34dd0a773ba1e6b4181753638f4328d908ea750587a4ba67c9772b167e97e1713766584fe211ca9a032d155917ebbf6a893c1863a61dfa9381f931d6c65565760af00387aa6c0fb0d09aa9b37d42f75a0cc7127b4ce436f2e2d366c496fee3df483fc19438725a7b2e14ba714efa15566f534e47aa91e14ae31346b5eec14cb9f48dd5e6e8a6bfd89a31837e066cb9624fc217f8b6ac19fbc730830399bc01a50a53aaf8c95cbdfac01dff14b68e0aa8f7593633625de44510ac8d9cbfd5022c60742ecc1cf95179a2208bcba963135882148ace33a9be3a442fba1e84dd0532bf7167994fae0b07a85ed6797bd74a1ab68d1049790e8c11659b6bf2ed3194f86271248280aa2ebca84baf240df0d6e6bbf8d6a85ef0f73220d0e3bb3efce78ba917b2e416bf16412f05406a9b34d90dc1bb1d042f10f31c3df29f1a71f5b76656fcbc2395bb979e84293d314629eaac121203d1d3e9ca714bc21c45d97a26994c0577b387f895653f2ecab2d44d9824053d8e32436d5aeaff46198b734cd3a8b93949ff7ce87c12d8a8c3bd8c0425739b63e336b4af749f9fb4813369ff053b7ad7f4ca660e19f332864cce8985367ebb5a336f177d9b45caebc286a6f28e6a511b211dc5e87de3436c871752689e988d9050bd68fa64486a25f9ac906b6f137b477a64ea7f72ed6fc59119388b5a88160a5be7871d79ba544237bb5db278488c1aa84b142de19a680425e0127b4218824ce8c68fe7678cc7dad427c3c77fd3d5b0a3ea5f9c4149039ac99c5ee6c93c8c8347a4b1a0ca76ab891a188e6e9b077608ac0aa6bd57b0bf750f2066566e5f7963ce7eb6e4e302b19953c41f28dc82ef3f44b589f5ac6d826ee65121a321d99dcdfe310535383db269f92482d9beab70e573ad86c6d84a4ceed632ef24cc1009781e5e4440bb035daeeb9d041dcaa4fa7011da1ca1cec8cf77ef0b0c6d87a561cfd35d0f4ab94e856eedb718c0b006e2e518cafea9aad5bf6b42959a8994135c78bcfcb6e6995fe52fe597abc064a805071b27783b65035c484b2b09b83b7b17c10695a3b4f916493516f30c7d9091fba9427bb5f6a015f3c963e94c9eb353c152d1aaeade03f24c117987b2f6207feda4a1c90d24901fa2f12833e3c3e38c1219ef3be0526b662a70b9b37004f775777d0abbef1e3fc8a3ecb52b71648c00b9770e86964713592356913e93e38651808db955eedadd2c6b509f724d2ac3ba1ca18ff1b9d2d8bb409dbe0f0d3c57eff061073fc719948051ec0164ee66afe580da2e9a6ca95ff23700db06d6afa465fa</script>
  <div class="hbe hbe-content">
    <div class="hbe hbe-input hbe-input-default">
      <input class="hbe hbe-input-field hbe-input-field-default" type="password" id="hbePass">
      <label class="hbe hbe-input-label hbe-input-label-default" for="hbePass">
        <span class="hbe hbe-input-label-content hbe-input-label-content-default">Hey, password is required here.</span>
      </label>
    </div>
  </div>
</div>
<script data-pjax src="/lib/hbe.js"></script><link href="/css/hbe.style.css" rel="stylesheet" type="text/css">]]></content>
  </entry>
  <entry>
    <title>2023.7.24 - 2023.7.28</title>
    <url>/2023/07/29/week-48/</url>
    <content><![CDATA[<div class="hbe hbe-container" id="hexo-blog-encrypt" data-wpm="Oh, this is an invalid password. Check and try again, please." data-whm="OOPS, these decrypted content may changed, but you can still have a look.">
  <script id="hbeData" type="hbeData" data-hmacdigest="6b4cf7da588112494b5be4dbb3dc2447dda97c4cdc377bbc22bd0d34d0052694">a99f2d1cd7f89812758242c57c62a59fe859e32cc19116fcceb1abacce500da0960986acd07eddb3568f524414b51fee5e4503daa5cb86390536d560eaff69172befedaf1d40fe38c05a53ae1011c8e46f6bee2d308f53c07fe0180f4a14828ae69918251733ea6245fdbb1d7cbf3db79ab7ad27e6cc40deae58f375db47060dc1f513844d5a683f9709f97b70c9b0ad2c5e6c59c221ba8d403b868940c7cd263aa01e5b91102c97a9845d53dead0df0e57b9a45d9042f4c791d9a84950023d695c83f6bd869b978b8872f7368a5f5c5bf69469270e509b3740ddc917e5e2a683c7e1a78844c25e5f02cd6a7ec1714fd4f421cbe00020af76dc15d052adf49c6086678777f89108b6ac42a1bfc008f520fd5715b402df4c6bb232e1fc4239ca24c6d8532ea2d24f64d064e7740914914bf7c85eaead7483d735f4fb83763c0c9891158acfe1cf58992d3eef5678dc41514e8963d0f0db8b496a25c2fc6f72779f36faeecdeee04f4194396f924fa237dbedf573db360608268c595ed259bb537ce7a779d34343f13cd7e692d0d1a196c9ac726103e6153a88893c7e77cb8a95edb99c22049461c9f841c7126ca71050cb711777be30b335e6e43b5ec070c12c0ef63bf57d40bbcd542bf4724eb4813969a9e0b0ca485e87f30e9353ec515b0602361335ea686a9ff72d889e731f64bcd1c6feb9f800e4cd68b399234b216f4ed2c7006da7337d27ceda34aaf0d1baf5ef9a3aab893e49010824965a9d860ce66c895c5a9f911454883514706db82f530b78dba6a7216d13d0b6b72b6146d5bf5ad5786fed66eb2a383e1646b7f96552005e93d8a03a960c9251303233b0ad3af5d78b5cd9d3fb13552e74a4f72ad7f50ff9bce61f16c9f8222981525bf87143bfb2dfa0cdab265d27666a69da99eaa42f50d2b104d83026628224e3e3754ee6fb38e9718c29759a9acdf575c825a630cd1b0f2264d651dcff2a6342076c26ca68df25856784a8664fdf0edc7f6a1b4b5b30afc7a17f6a19bdf9c91fad85cc24c6fcc502bc81c5a601c58acce141ba234b870275022413c9480f98b9f577ce351c48a87c667af49a85956408814e9e6c093cd50cfe924d261b9be5d6fe0f76bf4005d7aac8482c74098fd4073c98ea5c750bb53d2b8304ef7ad2f40c2e8309a9758a8bd93f4b974eb24a20ad18f712b70a20ca2ee9c6b47b61cfc8f298b05c0ed4fefaa0a5bb268931cebd6a1ad5a30396e36ff67921b65ae875260253aa58dae982f87b0cdee88a647aa6ab5e648b4e09ddc04787b60827d220a3eb5fe321764ea797fc652521ed0c1cb76e8c21a26beb059ab7b78bcf97e1d8ccdb07055fd56412e772211b1a090c364f8a47c000dcedd3d802ed5b3d165a578e4927cfd9cc9aadf0119c28204e8f5fe25fe3c6c0dcbf86f31bd7e5a8562ef9bbee0d460237ac5b42cc903b09eee171ab573ef3b0ec50995b6cf92742d3b1e82d7c87dc54ff0e0626ef0e3a5bcefb00eccbc3bc93fe3c14ec06311fe29fffae24a265b64aa42308b7b9d704fe8925322e5f84d7c0b33f913d098453451c87e5c8a1feb07aa41fcfab9d1ff2d38adacedb58cb6cec4e2a596b1c30e4223b142caba4c55bce2eaafddf9cfe307a7a59c3ec127c60102f3f466f1160da088bdd9b149afe6a2dedd30b2ce1009a033ce2701faaacd4fe00d27ee1b50246847acf9b4f791c98a9c464f19e470e0017a40348a82a581b0f397ba7b8ef6ac78f89846d7e160f4d1302aaf3ea82a53f0d0c358cf62c255779e607763595af9d9cd4636cf8bbe434b8aa92d5a39f0efcc7e06f2f190fa8c175faaae2a5c395384a384decff49c02a5594bd1419dd908b4bb62c597bc288ce6544e772ea47739497c22ef091ea15d3a5e2d86cccc306a432ee54a4ea4a5409e40976fa7b2b041d47c572a7803dd0fb5f00af120ea1733009fc484243e1db88a7301603ba4300aff38cf9409d7108a8763b652a5339e78f3d097ef30a0420ace5d0939df577964c6537135f5df2e26a59f700cd857a4a49d2b576883b5773c1a7f2579de262b5200807db52f68771053ab88e16a7d525de8d87e242ba5f24d76499ff2dd78ceb5bebc8e04e3f8537322c37cfe60ef3b252637e96a16b2d4dd57ecaf7558f9bf73af94f50e391973f2cbd5684ec7916cd865d0c8d0e4368f5c04a58b084e1ac5f3ccc989cc754a68b18ab134e909343cada6abe9a98ddfc155d057833f7bdab8215ca595ff0dad97a4baaac109f79b2dded9f524c8f4b88a90095dd9c11a76220ba6c74405510840e1525b95fe4dc1f05b2e1d2a49a1ff54c1a387960a118895dbfbbaf441fb3ca3cd8e368fb53e402984e413800a39eef913d42e153f24e41dbeb6359322bfa86f64e8564e047586bba3b104d5668c59e17b77fa53502de595ee80620c06c8899281c519073cd71f5aaf57096e8a8482bc91a20cc50acc21329d480ef7b4d78ae87b5df402ad63fdc891f3b58f558680e4662856a8c16511b6ab383aa8489c729641f9a6d408d3b31032a88c8e7dd65032b51f017757e48243cef96ab1ae524074c83d152e35459ba9f38101f7a0e8549e46bf8866ed2cbb3fcf0af3c32a6103cd41bdfb2d5ae7e2144bd6dfe3fc20db064f2da9ed624b369d82c1954f5ad177e27ff0f1382c079fb9e28b322b1114a4ca788f6b5fae2c0da17445094befd3044fbc062f54dcb722c0931d8047edee4ec901b979adb954548d03e5e072e7da49373c773da6e94d1c2844eaaaa46897ec72388e15ef432f4af7fd4bca6b91c54eeb04a66061f847724c73db07aae24613a713b914365e41a89e03e37801f1207e53a471907aa53bb10a95199f599c701d199e6dd0eec022d6b2f54570412ade1ea49d3b4308</script>
  <div class="hbe hbe-content">
    <div class="hbe hbe-input hbe-input-default">
      <input class="hbe hbe-input-field hbe-input-field-default" type="password" id="hbePass">
      <label class="hbe hbe-input-label hbe-input-label-default" for="hbePass">
        <span class="hbe hbe-input-label-content hbe-input-label-content-default">Hey, password is required here.</span>
      </label>
    </div>
  </div>
</div>
<script data-pjax src="/lib/hbe.js"></script><link href="/css/hbe.style.css" rel="stylesheet" type="text/css">]]></content>
  </entry>
  <entry>
    <title>2022.9.26 - 2022.9.30</title>
    <url>/2022/09/27/week-5/</url>
    <content><![CDATA[<div class="hbe hbe-container" id="hexo-blog-encrypt" data-wpm="Oh, this is an invalid password. Check and try again, please." data-whm="OOPS, these decrypted content may changed, but you can still have a look.">
  <script id="hbeData" type="hbeData" data-hmacdigest="5dd80742d46996a08a6229ab430cb20a6e3f1da2bb305d644eae0f5320e89ef2">a99f2d1cd7f89812758242c57c62a59fe859e32cc19116fcceb1abacce500da0960986acd07eddb3568f524414b51fee58187479b78cd6b2717a85a8713582980c35fa6ec6d9ce352d7e5523f1d96576e29151f8df474741bfd8d8058ad792d8b328d96c9ce1f490c9a4571624f43ebe3f268c04034529c2eea2e13f605cfec747de9cefeb85273ad9ae1d79b4ecf086eb24982fe8a60d40d13e39cce636f8cdd818bd8012861886ab6c880ac3f8f7840a6e7b2ae79828d0ce7a330f3023dd35f9619543daec88145d91896da400a8104b1f4175206a2677e536e8459a3b7212dfed7f144374fa101e8e5f60580569efa996aad314fc047616c5ea075fdb28b3f42112781f7345e3c0f28d44c5851cd46ec81a022c8be79ccf4d7eaefd51a2f5873dae0c17d857581349585982ddc35ec0ae5da0da7ff0317545d858df02d4caed4c3515eb081844bee6b5e721efc17476ced233f44c01bb9289dab2132f3e6c0da2d5d39d2c5b3fa936a9f35e59afd9869efaabd379572d797f600b615410d60242adb56bff65ca8e5d49396a87cd42b1bd8dbd712218c055334a4bf514ff1624f00954c567f6fc1dd38e4f66ea5e7ae11d3cbb21a77970a6ddf7a23068d1d200db05408f4128b31f1ffe8bfbf73fa12f1aec08d7639bb4cd217fbbb6ddf0956551d9afaf288bb386553882772c2126553130775ba01b0356e32aebb3d76c82e1b766a5eab9900dca85bac38ea944fb215c5cd59574b1512b90e8ab683879bdd8ab66e4ea83eef24a10aac8a1001aeb978db85f69206e3547d4a1c15cb98dd3dca109a8ea1af0bf475efbce67897e33f6df8f61bfedc235b605d6d8a25c9738d637ed661e38e3127fd8a095decd064614b37545cd354ed13950c0ecb8011d114aa80664756bbf42e1b33b454850e2fcb8df0fd3491d60ecad912b056f27f396bba774f86ebffd0941099a78600e81c3bbdf826102995da4f3eae8ca9c52f4e670c76e3c16bd1ed8d9b1563bbc60eaba7227f6bcc3128b0e2528512b4b4eb7702df9dd9a20a0964bf7e018ed6f83b1cbb0f683ef26eefc5803fc0b34f53830b8c07c5d6da5a5254461b7250449682a79b026801a70020748cad60e1a39c8ae175d3e4107e846297d4e0d14d3e14e1e8c840caae19a3abd0296bdf8b1efe3dd881cbd7c0de291c8e0cdf06cd26f4eae93323c746f64e725847e0262b66352815e9bb07d37447ddcab2419f672072ad64d3f5475ccc493906426c00fcd51b93e6252ceb63156f2290e73fed4dec8bb97d60b0807a919f3d0c94fd1f59ffa576d3ab9f687b754a2941516f88e06a9bb4c51a15a42019f9f00c602766497bcc2d98e2272a71add34d17210b606a3c57be57965b5a8a83d3ed6275d7de6ba1e9a49e51bcb6428339f8632218c4002aee96ebc52725538d5df385f43fecdf6316746bf58e6648877de99132f313275027529557ab2915b0a9d07c2630ca575151f073ec80884a96389f7358a22ee46b9e6a340b460a6d7d39f47df71ca8e722139054d1150571e14d69f48a4198de207f700facc16179d12fe56142000705e2cbd4a9545b411b1fafc115d0e090b359d0877e848bf717ced716f3a1fda482be5e4d8cbfd9bd6fe892e23f8c18f51e6ca8e3720751342f890e6940c249323ac4f9e555fe6596ac8b5513f0675e2dd5f798d9235d247385337bf996eae5694ff23b35f392065d7e2e4dbbd90d7e362a1a192b5c4b7c24844d223f56ea57513337ab4ba98d6122cdb065b1638fe7e6a3843117338281baaf76514d103ef6f078b4c39cf5ed3ef855b522319cabdc0671f1a0acc4ba5f143545eaccc0ca177f2cba618fec3b7d8d71c574da0ec3d026fa820fcff7496ef0dc9e1e6c1ad686caa758ec13474e9d891f6fe190212f53bff73becd98d36fe782eb4dbbcf35143b670394398353affb0183eb1de9a1d57dc47585b3eaa444c6721f89cf345308f8d9be7d68d7fcc31a14d706f75bd3e88acce6a5c79f053c7a264a62a52e03d6a52b2c3f18eb7a2b611c0f6d0534250343c61145bad441fbb254b4f2ea60342242c9e5d73e789e66f69ad7445b8b4c112af0a93835209f52fef5ec91b71cdd0102bd30c9aa9dea64ee08a72ca34baf763e2f6aaa9676e8aec227b60bf46e2e530b325ccf82ae80a2ff24a472fefe5cb527a10071218f8962fe3f4b93d542a910d3314ec98b96ddb9178e1389d5fd0d939fc797a652f0a52d406e73c83d6fd2c5dd00c1531c7f767fd57230302e7a6b77c8cc51abe4278e9a9ea30cd9719f0527901824b9541396add2f4a97c9e5aedb195f96882b104ac44cda7215fb99d95f82017d78e5e09862471ab760175669bbde5a3f5075d6698d56bf783d0cf92fa83d1a6fc876371f2c33d18ec5e7c3fde5a6b577c20e666678b6244f29187e8a95bd2960c84d18bbe830fe5d5545620ddad1cdcfa296921c5ad7f6a2cc8ee1f09ca7319fb7bfa346c57b343ee3d0fb7000337591c1e609da08cd96a4e118186a8fe2a7cc98264285ad0187a36ded668c9186c6b53fb684096d00488d8dcfb193758f83349b3a023b6ae78362ac356b06bbe9d1f979d370c7c16325b4862e73b9f725c1ad25947f0faa67311eceaffcfcc2de833d211f4fa998149f471a6d24fd316f4d651cb3cdbe0d7b962227ae4661d96b668260a569bbcde0497ca1d0b4d0f7e067a91516ff227cef47d3afaa7109030d8d22e32cb604f7ee06bc2b19e48c9dea4575c8f6ef7f85aa900e17da9e76378e8c6dcbd75ac03c431da1b341aa7850da5d633ea17d571d799262ffe575abd402c0f1becb5bd0828e6b942dcc67ee82e2702f0723de298932f7d44a5620b6425ea0ad5a8d5247ff5af41d2a8bb5c2154ca80d288cdf4e473a565ffad1992be858c0534ef1e4dc0ac74e0a36230e34f53103c6d6d671a93728bd8f2aff4c09f778bd9c04c5f9747e9fa622a663b3239fa1e2be4400fc09f40e5e39b369991fd7652137e15f933e88c7329404fc1c1b7b5400fafdc9f920f5b14c8f2740afed2f12d4c7ca037f4e14c9fc8ad599c40bbad4c6801b13ac7b7739f551f360e11a7332533121a787116f4cb6f4b59e84b4b1bd637ed50238575869ee8244d442ce56477aeca8c502a49c3b3f210821f14d1a1f8fa55feeff5e58415bbc2c4052f65567b263c800a6450e6088468ed4a8d1769d6bcf3f7e7fe179c6e065d6d25c08f4bb7f2201c578851c885b989b87b44bf51e43525da861343d3b1720ef665bc759f5a51a48a5e530e6ce41f54926dbcd59a2c8b3fd102b17bdf383b8f1a4aa0b6c34264cbe23cd15f849c5202aba89918e16d74bdb15f22e3b345556ae81ae237f8d4fc665464d2b91329717205001b57eae87dc03c20a15365d39784f1b75af0cafaf70cc00155103a4c7a994756bd07c9f66309b4ef836e246874bf4e98bc4290c3e317c3e0e58736885857567c6357a7f456118780f8087b4a6914b551b046298ee52ffe2502573e26e7ca55b1e60e5e553c0f5a33cde4a4f6cf9d996de525cafda66f10365f57515d7a5f57a92b18cca0cccbff35beab96e824dae5df78aeb5a2c07d62572a36a47493c6ab6da63a2f47e1baf54a0383220ea409cab0c02c3d3c081cb092883e04f2c504189324d917866578e4b7db0f362288ba2b33d5e182d7b0021b2489dba880054d1d81c047b173c61982fd8e1b4314429cd301db04c93af712e340584e07501c031400713a74eb6c56d22f780ccaf0ce0ed10905c90c8866f4d5fa12a6bc151b706e5d30d3a7ba1c77e0ca0a424999b0730c362d6a64ea1e0b44f2ea46375a62cdae5d2bb5d3e193a3f6d7584170a0ba92fa079075b483ea9867c304de4912d267d6f1e7bbeb26caa7d2f1bd544f36f03d07f01e575aa061e4478b13749d37eb3ae5d31c89d260191404e283ed79dd4788a522e9ce374fefe6f1bf1987448839007227d92c9069693cae7b598e5b2084e4efd17b5c6b92283f95f7e6f2e3e2b2a47861559f1354679865001f745effdb4714d1999c7f5fb267384398670812852e286f99a52876796e23a5c723e07601ed5b5999a91236fe4efed7f1afc2dbb921da731640184d9a56a062ade0d2f08d9cb40d0213716cc3ad9ea52d49cbed1688415703ba7c89cdba43d0a8b00ff57af892f676f79b8ef0e0f1cedd630f428adb8d0511e1c05be878b9dcd9a31c6a59eab6a8811dd6cb7204a07ce53f5c65759eb9118a7912d48d205ea038136b01cc7a22a985b1dc15bd1bfcf7b62296a4ed096bcba27c3840d994eeac92bc59798f591faad1aadddabaf2df66e1f377cc84b632ffd6e91080e5e9a36260c35dcd59e66b81253ddc8f6e15c2e738b2f1f174637c00283fc707852a817bf6d76ca4ad70075e920318c1566b7740c721be5e201a5a04912db9db5bc3709d9a3ada281317a77cc1b5a2b5f931d8adc702fb809bc89611892c84f94f6c33318e52c23fa5673bccaa8eb079d3e2a21207124606a161f947f187770536c820a5d4975fd193bfa2029e0598670d355b7428e788b73e2f309c2fbe212284f6b937d9136b30ff1343f22f6fc2e6058cd7a942c0794e5c04e10680b5c449786a251db172184fed559713d9dffba8c1e70d1ca8305746c71f7fc3488cbee6fbe8ec40fbd07a2a9d79342dcff90ef722a794e1dd7a62cbbca6c036f0606959e67317f214a2142abc825a64fcb8a16dd275b8b3ee24c197e194ef58f01a31b64476031e469777c386d0d72f35f999b88e12a8bb543a84ed517daac0c9f584d87f7c5e255e8e057b9b8f951b4ca149d0befcaa3a6247c175467966f1f4cf2342b556360eab8289c51cbd316fd16d3167829ec1000ac8a4fdb0d3f24798a1aea168e1feccf8bb558d9f5f6ddd052a79540abbe82ea0c6279ac3a071ab17de2e9e2acd21791cc19822f7c07ee0823b6e1b6296765cabfee54894892b9d4f29aa1b15a279265bde5f7013d0248d265f2a1f22ba3503ee0e883aa162ffbc9824f7396208d8a9264597854469ca32be2946cc180788f0011afa73d6b9e9d64845ec8b19d7a0e5550cd262560de0bf0b94b7f33d61240daf43c0843b317f0ed136d30290d50957ff5189280301260e24b5a598dc83454e17e3976ff3156158ba0c905b22f021bfe128da38b4c4b84c0117d5ae757dcfe2aca2df81c4cc5858fd7c74f045478694d151c2f3db6c25e37b39622f3c31e70db6bb7cfaf3be7241b52c8d2cf4d7301fce35b4cd049dc5a0f779402b5d42fd309db2aa68be696d900989130f7d39cff6a6c0af905fbd63bf54fb72b3a3921af941605df334f620584cff8d8a0cd86a98a109cfe07d8fa236696326693d27b87fea409453913f4b0d38b0cc26b7a1a1d486ea3b4dbac8615ce19ab4f65e4d22bee32a925869fc45fce6bf32d2cbaa7ca4a811a926ed73463dab45c9f2d815164c37ea2e38b7c3f0243f43a190cf299e573b026520d172fa0da433f39216f2f142aa87f55f8f5217644ff7488ada120086f960ec8e58f0f68c10d4bc70de6488a5480957dc85332a4d57fc1abd8ff9732a478ef523d7e96240748dee36ee90150d3b4f83fa2843978ec36bfdc6a4c5c0ed4c94b3c6d0ca01b6cd4ca4186f33293233e9fafe8a5ac005ae6438307b283d5b4795c4226a991a58ba3608777ba98109bc203ea05099f42f463d33d6a907d12ab68ce5ecedb4448f623631b1d9488819e01d35206ee673291d3538bacf7b3e2f7020192453fe894add04f96db1d711d1f211ca598a44a8679acfedc2ff9e97f99c987b2b97f131e6f2fef724ced3a439b3db5fa0342bf91f7d5aec43a1d58fe5ccfaf516cedc094b6e5628d397fd01b95d850e89d1e860f64103960c73ff175ccda61eb0dd4075452e2a46d751f249999d1b72bcb3872851ee324c3c25440c8a1283791d419954d7fc8a229a2ec0f2ed2398a95e96df47dc6decfb63538fae318379ec90f142fd83193bd9df4691ffd923a2be2893266897dc74e43986c9390d16fc45d4a2d41b801f55409d469a5c94509e6cb84d875fde9b4dcc90336664ee570142ed2ff4badff61973e71a972b10b5063a3750e12090795f8787ae29a13a4f8fdbedae0b62239431881b8ca3b234c3894425fcbb7e230be489c6d3c4b399c988884539e4defd677edab4dfb3effae9057bdeedce4d237e2a7222fb6687101b5a5ea120db2ea1637d2313dafb84452ab7e5806fd4abaf751db796a7005ea60284cec842f755736682fe3a884ff3df96676af059e9307f93093ce84d7e78ac2e167789e444f5ad54e1d847c7e4f608d95ad4e4423f19a180824310abdd7eb01c0145dff5b3969c43448ef28cd3a1fba2336383e854a3298f7d301665f2f954844807c3b0696c75d9da43316a1e595d4beead2001dcdeb624a9258e90de765758872a4167e71ae9f40d209548d0744bdf96e5af4ddef2610abd39bc06d319856ee4a5ab743ec8352c3ea76f18636263f0b6d5be898849031d12ed48dc4cf631e91721ac97d4af8b8cb66d2e2fc51495be9e41b849621af5ca2235fee6de2dc4680e36dd73a07b3388160c470af9844726dca64a8711812158aebe409bdb86e6f57e725b30021a14b073a7375e61d8122106560132c0bcc0c338d3428cd36ebc66e806319637d21101ecfed249ddcd01a20022889b6402c1c6cfd3831cb208aef71382918839c4492cdb8d4253dbc936de3288a67e7af2d6a847ed3e120610ef180bc4c42504956540dfb2071d0272421a58db7e8dc47588c01f8f5b8e433c18a3661bedfa77281ad742a45c3308b95d5adc41181c4303dd7e0dd5371a3c45239e30878f0ad662db37d11496b7247628d06c09b9f6d0a5f8ac7e7dd721ed108431ed0babd9fbfcab29c1a10d9feecd20be1d40dee616ed929095611fbeb923ca4780bd5707aae9590f2e220668b01af817aa9e0e4c376b946026e167f5479b6d4d3f388ab1496c924e27d695ee9b844694ec7c45efa6bf7d0b0db4de072c362789567760d0c6aafa6a8c3e52b24ce62c1235497db3f72cef43433b4ba31d1be459faf150da275e0961a8e120fb84eb88453f50c16ef7d3ebe8eee6b4e8adc5756dc3e5698753071c9cbb25c0eb2f653e043b8df9cc5c23e8c07446bc096de99f0d49137af9bbf312768dba7adcb614be05ab82856617279a6026e281ec05044736e1af947a09e0a19dd1af0482db697503a815bf039aaaf2dc0bd78ab8254cb4248621c8d213af99f23fd42ff5b640bd539e378439ca88070308d90842c1d25cb43881ddf692cf3bc9e98cdafc8a3c2ddc6e625384ebcdc9cc4394b2b2a66d8b5445e0237f4f5734dcfa2eb941b5960270e1604e1a260488b634d0efede5ce4e4bb3ede04bc102608d52c20da79ea7cd4211c58f2d8584257daed59139147fa3834e3d44828ff77a755ff54f0547cda52826325c5ec189cd8bd88f1cdc1050c76b0d61277e7a11a2a96b5cf9cf24a57abb6e372f1cab86e4d573be2e7902cbe944a26618634e560ded7e273c034a9aa27ea8e52a2d5979574275c48081346c5abfd700cc2c0af76bc73bd5a3e64bf400bcecaa3e59d8521309dc4483e9b932ae556b57a8e171f9e4c7029544ab8addf97e0e4a3804eef28f62f405d8b455d9009bbf6d6274a43dd824e0fa47c79e9d6cc0ca76af6b04e40f93c01487ff6ea13949477ad3efb5dcfbdb4902176858a4432c290b27ca04ef9501c2762acc22042ba36a50908d5269a5e1177708bbb1ac9a1de3c21b503ff4ac2b25bae7a55137cfb16451604d9f808730e4d8378fff8863e046101c60c7878c1e53bc8141511979dca843800840e9fe97a4412b6e9eacc48634a6e9e44cf7f518430bdc2e297761196c4465eae8ee2b5bc86d6b218ab306c8706068e9769610cb90808a52fcebcb7e1b4e048cac68f132e65e04270b186651be4450fa6815f709454e04800d345a2e0f169e0e9b5f7b58985f88fef9cf1fb5a5ddd4720f233c5ef839ebd7ee811ebb6970fb3b22c9f4863a57bb717ea0daaeab77029fb1bab7c5198f750c234ed3df46e4a2ee86f3f03008087127e6589f55c169712af21575518071f10b14c40b45638c6dd9b6158430ec74bedd49806101e6d0b9ee415ccb7f3ca3209e6c6e4eb6b6a9201a8f486d1ceced09902394fff5c3bb0e5f92da477dd79d5123be8d3e6adb3bdf5a1f80608efdb2cfb4c0c39a972c799b56f76e3800c774d12eeb9fe187f05b0185d02d103354e7c22fdfd724062ddd0bc15449ba4d9ca08f9ad9f10fcbc6a9ac089780662c9dd2b69a844591a1a524412511418a87927007d33224e432c962a14b41882ff18b67bdb260816bebce0a701b17808b1c3f218d54b062896e2ff71bbd24af52a681b54338b1f09d4ebea8cfc06ae62d5b3a5efcb04de525d612d666f02daa86ca58cc5d6b7e9bc1c879e282fe104b6a4c4103bcda0434f8e260d679907b977acd475051b4708b29c26e3eb5880f69741b5d0469f4667e168f50bcba1862c197eab4ea2cc0e2798fa0265da7ec6909e512773ae031d41930834ad8dc97ce7b372c2f85f2abc54cb3b5b87e3865ab889e334af315a8fcdb1aca784c2592c7bf40ca368238a63e9112536956c526cae9f1dac9ea3cfcaaecd7386a865b50ebb634693ca8cba6418064840aa19a43fc79926d5dfc3fa3fce4993b5c77b7eee32e0c5a93a908b365163e40222994160bbba3b5d4067b9ffdec310f24167df187f3ae4e6a72f37fb2d6ee7d992feb7bb97916187197784e8e82c77f7ccb73e7f40d11fc8e70a4afe05cf90399ff3db091fc77fd3405ddd95f27d870861ae15fb4330d0f29cdcdd9e1d596d632860d4bdcc16af34ba57e06cdaf5e5bb9ebe2ac554eb339698df5df79617e771e084bb85e4d66c8f41995ce5cc6415f974261f059d5d9af234a6c16b437b19353c22069fba08fc0b4245b934e7aff8b66e074e59f4bd124a41b17230ba0766aae2c6e881d743b0d1d925ee71cee7c640596354c17529d93599b4dda3110b7a2852e3a024f5299478efeecea30ae457e0fbc57d25055b0a0b774bd6624d8306bfb84e043a712703bca2c0180c00bf3dc3c5169003e03ca6e428bfd38d68f196960e2ef87e08b7dd164cb6ad9cc5a4457bac26f9c3c2f91746443f0c7339348474cef1828f899e3a63c6e757f61c0b5c91ff7b4131ee6c9eaf4bb09ec69085df4798589dda43bd7cfe6830be7e5153154aa24b1fd83783dbcd9e70701741cfa61b9239607f3cbca7ead003a9709f3513f94a1b605fcd7fd2afd3a8e43d2e9f8774dbf173e8e50236eb3f8cf88cc6b22365ce85110ceaa3663d1c8e2c1647b1bffd0d4e2f5122957fde43296fa1b45f7a1b25f3b8f9bb6ba2971709d58c2b8025abe388fceb45aac04957c4f67467cbaa0b11aaef2024312a96bee029bdfc2661b487bb064832af5eaa1edf11c5e2217c5ef2d41907cbda5e5c5e09ab8f6256511b1ecba23b5a06b39cb70fd29b6ef6d68522078e9aa5e9b7609fb79abcaa58448670e4c5e0a5b8d2c845a8f514cb081d5f055ad49ab997129918d16e3666e1492f56057e734bea9565a84f4df64605d50d39686c8b1ee9e083afe0f0e76c927b5df42506fc93f8a5008bc711883208c5a24fb61af9928a2e8760d8a4afa8b6fd87c75432a7c7210e007028c8d4acc313239a00021de09beaacde739c05bb7ee6416e5c26e37cd10e2af03d4ac987234dcb892d7fa2e4ecb9c46b5047ec8fa09ff0b7490155b47feac96d59b9bd71e5a9cf6ca7ae5844724097f1e870d82551e3f4cc00b08109d67d8fb22189db4bee5c4b5a2f1a4b456c724f687135ed1343026db10dd18ab98566123b99dd1945d800f7e8157f508266646b7065df2523fcb96990902f5c1954e71ff872b9fc65e35caf65d0d1063cd78c9f8a00dd5ea747544b50f12d614e0bbd58986d4948c690dfdba6771890f7c32345f04bc75a69c818707b3258a457afae5ecf18ed85745556de4d139fc6cc64be9d41b9e5f2915f5648e46b168fdcab256312f808aaa8eb5536ba50a8dce1c9915e8b37f24c0ef65aa230f7fa682674d2c2e876b0be33b6b6d0385a5f818eacfa9a843c9ce60708d85f69e077d1fdf216da097e39592393ea28f723acd30d7b9e965e1c88085dff2eb9f240731db9cd6d72f199130526bf81641a35bcb98071cfea817f463fcb51985972310fa4cc3412075394cd6fb1669449ff1d17ae783d9cb4b8d9f41d453aaab7a8cc2afcf5d78e8fbbcf60d7e5fc5c8e9591c3f21a679f21aa5c80b411f20c8554ad4e54af17200b273036a584bd3e18668358dfedfaa3279b1156d46e9f70d4ac7eccf051b6ed843b55485cd870b875ea25d6073d19f627cc2dbc96268a14f127985577f2ab902f92bc5fc0e204594f74ba7081e2db9859f2044d97b21e3b5f46460c2fd5a3923acd2479bf608821ff957c5c1c4549df32d37a8fc7c48583d13b52846fe93e48c520edf1a5555f523c43ed41dc61405de8110e019e4b97ebe833b4175294932220443d0bc72bfc47d8df5e047cbe4b193e77c12b42e083c263fc5b675e6fd0034560fc513ff6f1a904f3fe91ed058d293a8a4ab1719acd37511816b95dc1bd73333bc3ee84ae98f9c51436ffdd3e0be0891668314a60bce389b6d1db37ce7075c1f881393f128606605577a895e946bda9581b68e5d6cb4b6d471a0cea5304c1e41dd7fb97d25ad76dc326d3a7ff8e754b71a342b34de5f3a616a093fba6543900fb0507ac2a7445500395ea8fd5ced71c433b6f59649e100dd9412f566882e6c589b4744ee42f2537289a476ea4aa5e798e1e671a2f2a7ef4a79dabfbd40bcb77b7a864c5e03869fe1e32fa2fe113093f215c8f32b97e937eee686bc4cc289545930f68b6714049317a6cd56781ac668e7e07d61b621f8ff3045d5982ab7a968f20937e3dd69e361b2298bc856bb8e53271092bd94b012301bdc500b9f035e64600f5d05bdb7fec808621b8e4cca05cbe6fa9d417ae4615bb4d69305869e40544390c3857ebba0629d2d443199234d5f0c36d245e7a47687611e60f649c1c8b70ec9b5778e44f40b6501765afc1fb03a94ad1a7e5b817eb354d936598cb44516c9a1f9c3d5f4211ea8b25f0a00f4b5e14a7d8bdc7c415b2e0b6d9b97719fb69f773a90b1a7537c27ff4104238d535ef5c7b1c24bd06b47bd535a8597fd87462dd6b9d4c81bbbde60422bdd4ae640eed62cc79db96c635f1ea5c0f6db9e4c08f5016afae0632aa580da9f4adafd75c6f728fe6686017fb9d29e10296820ade10663d6120ba07d798f64363a1e28088ce576d97ffd98de0194ae586604efae452749a7e4a6accf2c6afc746c2ba9bcd3747ca1d7e08ea875d11071697da5349f22392a9ec099ca8dd09324ab05b68b7e9f30080f3cbfaefb908074c3f99333df6adf3e38dfbaffa747fd0466788850d1c00b8f270ba1525235be7071187808f1370b4a4e0a648f347964705688daca97f062741c1bcd90daa734b111721621a8cff860872e83b87b51ed31c56c4ed81fa0e42d25c5f67aea68406f9303ca79f462779828eb8181c4f3b61f8e2c78d4c9daf9f515ddf66727ea8728e5fae7be757a5089daf305def05a7c478c663a01e2005b2475a744f2a724f27139ca5e54d3da486cd7b4b8c0cdf5779c0cb5f47d1474412ba562ac1fbe9fbbc50f4d3ed1cc85744b596254fcae30b84af7ffff17d5ae4dc84cfa965d988b5ca58d4629df19d129dfc486d959394d4689ebff190bd0d60aed9812e7719cc73314c2d80961a9021688d1e5d9b24bacdcf6821c75e222235d588007a2b0102d061fb648cd089d37e9f3240683b58fb642bcd3af9edd2b4d14d3d4b7fbe2fda8e4b7fbafebf0f7b3f6781746d8da8f29924c03334903ade614b1dca0173251eb54690bc69839c767bd0c9c82b8b05986a8c68ba9db34410258d9211bca73f09e6abe6ea855128cdeaff07d5156bddefd393c7ac06c645e76b1ca861eed5e0798dc4cb7ad9b610f5fe742b0eacb58b55da08aa39bcc746a6c1bb9f2ee76b33c686bab1140107f2820b8933ee9984a8a39eda0819efca58ae231dbc039898a4c4a41b5202884364b6824456cb1b3906be8a8e7c97576e1a606ae432f4c915122b9075f89c7c7c7a623a95b55311585fac97d883a5c36b1f63da20a84b2db1e369d200843d9900e3c5b0b0b959efd5f30de6801268a5a706eb8360e90a6902082324059d90ef2fb90b9707bb40dcc30be5fff7451c5d93789323d45a4cce10de3a7a2ebd715e34f968530bbaa77d1b2ad58643e2e5582be79572e20c14998c1382b74a2f0f63addd3712245c3556e525db27c023e69cf0ef402edaca239146f014f506743432972fdf48b4e48f9b2597782ab97d7d5f790197b7e51f94121873b4e85a95713099c0b1f1f6c3d489a612b62121a146d8307fe023fe3b32aab8b89df439d8079ebe61bfe3cf331088ee9fb3f08336d3ae53b917d50275e0701a7f63f11ea3f39f8a3f585eddb20ef009b4e5bad39043210291bb24c964e3b71dcbd49d88c8a99ebbd332490bcc4901f0abb4ba4fadbbd504a4534f2ed31d725bcc885f24330000bb3fad4a6959c8270cbb6cf3c36dd6cb19597038d3ddf89c5645cc4af294236ee0b0bdfeb4e8a637a70e732b6bcc99214e7c18dd3615d5a3c23b0e715f734652cdc1aba21cbc3f9a599b2e8ba4954bd3c1067a4e4b8da5a57ef4cdce856387893d146fbb4dfe886b735f0930cd62b5e6f0b3ccea9576b0955b99ef99a0a95e9378f6ac5a20f4b3e4df838a7d62338044c4a246fab71cab74da7f1d2e46d838abd5659331fc965cced626be998c598dd469dfa9ec23124af292fa551e80c6e0f76c4d14c3c1619b3fc15456eaaf91e98aef7601f393b70ade8f081dc98c3607c54d5e8137ed1ca951560cf09d88a636ccf62c34aa459aa8ac2d177edc6fbd2c0907e2a40f85be49ef54f2d84b175658bd96c755108aca033710b3f7a1688760366ee63cac3196ce09bc9803d87f16a784910336acf7304bde314ad4ffe8adb4538cd351be8ce3486418377e556f3ccae41289493d90529959dfc23999b918f5f367cbba40aafb8e43d6647bcdf8abea61e31630803c35d892764d0ca61b6e7077aa3616f18a5c8ed7358ef4ba66bf303d8411a223cf05746f429ea8a84d16bc3a3210081077e0fb74f11db40b9367c5fa0b886d139a2c3fa99af69713228885a2dd3e8e40c498ae280d8757abb9da3fb4470d11bd51873fa414bdbd4c6e198620036cbfae666381b83918b7f627879448c07658d7222c4466fc4de6955795212931a8414070e1789bc49d22f4969dfa0d4fdf1a1862d875301d85b58f1967e237449807c41f57ab7673008ca0b574773e922137f11bc6f2b49e75966e07e155c856df2354731b046bc532c4628a7f289573ca3e394487fa0fefc901dd69d7fe7d96105e9b5766a8bb09f14c2c12e2157de56ca7f76079b8d2c380e5cc4aecff316e6d2cab79d14d340adf090c4356ff6def84e9cadf81f0e7823711dc547aec0f190208558f19e186225ed9ae63284e98dd4ede6d0ffd81631953a8b020fe7b1f54c72f2aeeb3d003c5f4b4104969b5ca917aec8ba89a526cd724537753dc01423ecd169ef078d78ab2a3e58ca255798345f0702705aa46b009098adefdd34306a25b9922c415fb47a7efddf32fe1d8dfa7adc5efd2ebbc04be2c08f9031479c9ab33dbfeecf0469f5960d1440aa3c82a9bf2f076533c823f70f0bfd6dfb89ff38385dd7d31afe11aa5564700f304d79d4fd8939d24542e7f2f8c336b2139b1e9a0a38e9f7f889c8fbf7c81a3db9c0d574802b77f927a707fa35aaf097d1425c5c1ad9938de30819abc2cfdf9cf7a532a18aea5fb885cc9ca35747d6565b95458266889d2ec23763900607248efdd007e7554c9fe2182c12fb66becbb7b80775fdb6a8dbdf1d2a58370c8f0a3ead081648e20f79722150ffb712e160394f093e19d1438a811fbfd199e532419a6905818402358a7116f5fd3835abd560ac0f378af9d1a6288bc37c9863dda4894a2fe610390de0996a54f5a19c555f80a691a5fd69b4f844c1800c3aa2c33bee8caf4c6734be2f8982c6f483befb2e7f25e4224f306e439640d6935f54dac42d9c4b7c8d47d1bb3520c75d8394463eb126e884bcc2b2ef99493514cac7156111492a3ca92c60a98a15372d07fd83d09cfd59c687b85a5e46524ba960ea280d878d840e0749b9a96726db79ff0b52357999244966c2a8773dc3d6a5e68660871482d9c03b544c1a9237852137ff01352646016e2740a3a607b447ff6b0a3ad00a7e8756c57c6872e4221bdb3b7345b041b1432eec82dd9420116d2600434dbe1a250d2cb04e2dac3407ece2c3a85f36363049f6bdfb388da95f51d8b3ccf0dd4d2ed90e45ef9fcb1d4722191a9d39989f6f5f5b4f5b469e589d9312ab9ec4cea317e86026274a7642c390d6e094204f05a43370302dab91e7e693551723969b187a912eadf75ad50fc534ec2aa99810c8e35527b1914b1d30d77ea239690f7d200a8dc5fafcb820429bbf69aa5766645856872730b2695e29c42d64f516f20ca55e4f9a7547ed907fd80e282b9950fa1edbadb93dc6a1313f9e986c8abc80b7d8283ade22c6d06222c1d777340d5c894f80a6e408bc383ff9519827ecec57cd814aae0a35ef84a20cfcd15542f385a5a7f0ae94699e10b6f1a51eed048f19f0c3a1edb451e7553ee2807c99ef57ae447257293ce11edfbe299e5644194a252f98839e4bdaf33fd78c5a5016ab51e39e0d5fc3fccda0f5719ed74f3b09db0bc2d87e9ca7bc93bb408439818195cda617b92ac0dd70cb1d732c542114f4e791d054315a0139d1f22571f896a96c918c1200c10fdb7fce56e340a11c26304fff97d053a2fa4d10a21f2b4bdf839ceeab0bf3f4bf549fb8164ff6703cd7ccacb2cd77b429a3179d18420f06406a787f11f826ae751c81e1cadb946ba6171c7ce9fca8e23d7cb44687de65eb0529fd5614da5b2fb5b1d0292cce8339408c7e9c907e98c5333a70599b3c3a555157a50387ffba88c85bd92f115ee34b25ab77bafed1850102eba79c20963763e32285ec4636b88d59004d24ce2ebc0ee7809ebcf3fbd9498b89746c6f5702b4d110f70cc58af91049660b41d8d4645c73faa7b4004d007a12817cd3a9359ef131c2127354e37466da3feb3c94536e6ec6b4166fb4c9f9820b28f2ec640d67be1f58c1096ea628df9e746cda5c564803a097a582e52b9fcd31fad0e150b783649f38def2cc5eebb47cb85838f59f7bacd7ddc473bb96c128edcc3bcb90afec75164aba47efd47821ec75473a5747cb60aad198444665a86dcfacc4088ae2326edb0360955328c73863678349710be64a5dba9ced8c310370ad59469ca4268f37d79a5f37f55d712a69652b9fd24e7108c6a0487fc1e6ecc762f38e5e42b7e14a2d66505b3fb6a2fbf0a96fb088015dc60eff0fd1215483a84e5253345e32370378db1358eafa0d006d6766004e3b4229687c1f0d4047f06be0edfb0e3cafcbd7b440cd32307c528e6e45a107c054bafddf3cc0ee9a87b10d0af7f4e340dc397f0b25812714a44c49d0ed02182989d35e65966b074e4be2cd67615fbc634444c32134e8f857eeed424468a25f39ac9ec279d7a3a882e577c54c6284a94ae82900d50bad21d98f8969348b6c65c0a6d1659bd75223382af05f02b8147cc7b0aa78aa28c7d16104bda360595f1aa236aface8b84c2573b9224969bd315202c4731fde649a6f4ccd031a3d15465b28e1150660a9fbd44243af38a0aedf8e4c879ce34402dfe6e064c7525a9365d865edccb89ee7b875645683e430b6d588035cbdac40a4d57f3fd69771846fafb4ec486f3fed3a1e15318c7bac32e144de0eb0b22559e36fac4e7f367f2944f5dfce58718562b6bdc73544487f131ec65a3ca3ca51c19392104245e8ce169d53ef7f8d11be0cce1ffcb8d44beefe67550c6a0e4caf8209220d000a52124162cc070ebae3b1a7c938ac0ea61999c10e5928bd8bf6aeaa8da8e27bc4175401ead4e84d2dd84d6bc3884e4953ca2cef356a85997774212edf8db7af3988882cfaa3dbe7922c65d836846aeb83431edd8ddcec5df4b927e5564de64b0c8452f7fea1e846dbd18d6beeb071bbbc34ff5cb02e50e5433c9d7137ca3b4e3548485f74fc833b0716e255f9ee8ba4e645bb8a5c86aa76500320e84897ef2d23bf6b82dd055eff2e8f081266f5a918c8ed2030c6f4c459dc9874b3c80ef6c59e3effea01a7ac3bb9b086d7f8877c54a3455219b157602d870fad546b9bcb597b05cb1528dba7ab5475b75b5d0d9d08e0c923e5354c95f65f7f0fc2c13ee05241ac211817124d75be27584897521b97435df6f9b44d7a8dbf4f060313e84b8f4fa30f4c0f365a7e50866ee3eb48f67058258b63239dafb04c8d824e5002f02d33e4f9c0feec2481ee4c9aef7d9eeaac24813859a1da8130689ff5849e95e42264afb334d4ed0920c0fdcda2551a2b7cf5cd49a7c6d122dc439e611ea0ef1b78460dc221406e836f446889c395073f1ccc289999f9131ad679d416df668668fb3d81f1ab75c374c15665bbcbad96fc08abfd3b59fb4136ea57fbc2e132f1721158109fe25a12469ba2206a93bf6a4bebd13daacc16fb8f589255df8d183229e5c9a590417a7b929aea71fbbcd81500946c69dbb18ac21d14b073aa0cad4d429682ff68ee912844c5eb018d4c09c17d478879f67328f4bfe50966b230d18accb910646a97dfebc574e58552a1b89751970de5cbdfb8dd9472971e36e8a3d0638f5c5d2266968086c756200944d6a5206bb7d901296818ded2a98c309e15547e8587dcdc34a5749fccadc1ed53550994ec69c22cde19550601358701a5ca2acd04a76e19b27da6b577caa16cb15bc09a4d2ea215934f15055112da835035417e47042b358cd42a4c90c9547ce0f8a016d6a9216d379ed54f1de75234952fa927a49458267539f534895cff4cad6e46ddd514906add853dcdf128790f11cf5922663053b2fd8e94e068459df7d6441563674d42c9d3782c4e0e43062542dd0b5f40bbfb04d38c2f9257087f2f393c097c72dddb1102ef6bc961875141d50993b74779039bf8040ca829660fe059c9f6117538aa19406b5461cda20ca542630f9f74059cb4aa00a3bba0c6489b5716644ddda8491f8ab26b1ce213aac288d8ae0d134920f9276277733327f506a84c26c573dfc4082fb123e32b09c61a147526dcb04e53633374384a5992b4c021f7a5592dab8903043b57e3a85f921aa2d1143fa1fc8c390556e264ecbf56942e579706893270005b0eaf30a3fcfee79b13320f13e5749bb4ec0fb76fa6118b08252ed5c519bf19b7321eb59b283b7291f437b3ec789d851d000a590281b8c2c6ea4a1c2a04965cd93e8080acfdec03b1bdc967f0d68776e40820b18e1fa224c5c2db2422e71bf450f5bc949100edf37c2b826f52e37449465f2aff9879a9011ec58eb1acb89d2f66bc3a2d4bad15dac956d47d53b284052936b46ed20079e1f7f5b81fed117a431800bbdc021002a116eed9a2f9501e496d9eea3a876a266b8f268dc6ba5cbf28133e1a9a5fca2bd413bcdb5d87a0e56607ace68f7d71052bfb9bf4963ad83bc877d9f773ed9ac2b6ff23ba390f2b1bae0daea6bc46fd09b1c7202ac6c3271b54b104cc94ea7e8727f9e15aca654031f890a270932fd40bacf01a2888b861aa2b694d85eb0fc83410794b388157a3dc1b0de4c363569e27506d6eec1c22234ca0f5147dd8b2877d3e55016d0fd305a1ff1f7d3d082db4657fbdca01087204e11532e15f7eb3254894e6260523e979184153ddefbd3fb9dd823d0512daa3d20fe06d6316973c447c79d7e1b0789c46110cdf735b8ee563f8530d38d5cc9712dc1a5ec5c9e2d966169e7fbd1d8b50989338c0e0bb02703402e857e52e465cfc46dee752e526e4719279e12d275a65f88ce6d6f4c1ff2bc8b2b25f4569a14dde95b8945f168714fbe01ab77ca4249f81afa43fd3c818bf451a2157c20429f5db2d7d03adeffca05b848cb17d888b9fb0fac4361903e8a41256a1d13abd8d4b2b3d8c394f308625e70d5445d721e3b341a2b8d58fa97b5db07ed19d4e271c289319e79a00e479c1449fe2cba5eeac9ac0b2a7d1592e0aa2a9ec3bec8ab087642440468bc8863ddbbf013ab0ce30a9477903116082dd6adde1d9ab174bb125754906706590dcd0da2202fc89601822fb49607185cccaf511844093474f6881e118d4e2bc54172285e4bf802c8433580f1202f77243f0b391e36419f382de10d5a901cf7ba7236dff1432d50d97193e9fa899761a6b09c08767b863a259fe93e5458f8e70d9bb1fd71b4e4f8b6e8eeda1c5ba0f085a244ad54238d3dde04eab5a096a2d88f935ff7374757fab5a0f93ee11572bc0d5da4463c2cab57e5c0bfe2fdb575ef6d2b89ec18d087cc7390258a0f4af48160e9ba708e413efe5cd8324cd28bef003158ab4cdad844eb897236d64106864f16dd7bd550ade5b404a994b7867f88e79f7bfa01befc216a525d516786078d2ceabfc8317d3eaff6a905237551622b3d9a96be998e4cc1abc972008f8f3e1f77bc0f88e2820cb634a07b0405624495bdd0f3278ee014b4f3ffd08749550871d105a13e1ad0e3fc51b3a833666cf505eadeacb943865addcc276803f4ab94a3f5cf3db326795c9ef4d8b0f5fd67d8d55215447f7d1b837a9378f1edc1af4790c5a6bcc3f05ea31f12358b75034123c68f8da344227518af980c795f520412a8d5199e7d2ca799b11e0c0ce0977ed20840380e0b3355d8c31d27272cee65546df03fe239446b1b94f513fadcdb6dd371b3c8a1dedbb56ff01c4fd4d431d2e496ecd0da45c5d3bf58d0cedcfec007549d8e03ba192d761bd1776d7c579e3f2f894901b4fb2b3d635ccc00a059712dc12fea393121aed01007f9cd25c6153b09e9c59f786a49c457a330cead43025f6badc23310ecf1282f989f267a907ddf9ec863a5860b8ac14fcf993e53c0f49b7e74d9a6f8f98618a861e09f4fd1bf96fe7b3feb34944793656d80c06e9460230e6c20fc7c30bd1d5738233465b698154566aa92de18ad82f7923451d42c911d5f010aa8081a29df2d12198f7c432a0b942feb0b494b8449f92141bedc8a2e8f5e7d048b213b5cc5162c73eaa63cd242c2a684fe6106e68fdfd32f7171fb101e2ec450b0f2d2be3b3901f00e80be89fcf111c8d806ea8719e6b934851dec15a677e5f1be64c4de1e0a9a891d6beff7a840f3e4cb727b67943d98ec8cafa1391a63eacb20791769aeba80a830c77e608c190418411f5cafb52b60e6f188be2f48f05b47b9170ac77bffb86bb89c9314c4411a401e2370e3d478f4349ef48e3c0bf2a4da3d609e2351294e047668e2c2b5f021d5cad9ce303cbd1f5c93bb218f7eee951453371ef326557f898edef4afc39e5bb97ac6bcf35a99c16964e7c215191ab0b09fa1aab3e1ef911cde8a7d00214b19436e39b92e75fdd8e4982d50cb73e3f55ee09b1b87a46055e8abcd4a1ff3c39e7317f30e981087c01f34f427f1c05ea3d336e9dee4a992126110ec74b0161a104d1725edbaa003a5ed5c4c20d18821c8c59e19ee048babd3e1ae4634046589c2867aa0192999f1fb8709aab52b3410a2aec3a72b9e929d8073fe6fe8f5d5d8ef176de2f8d7d215871b320c0af80a02f7b54168fee4395ad08e3309422a21e8f370b397457deadc943cd16f9de13c47d816bc82466a7f618d12ffa5e46bcfdba4e73568d2a41cc7d71217a4a4e205cea7d051703e7387d577e5fb606a9d1e03f243884cca1c7bd950cc39cb2d8ebfa7302ff5b1cf0e6516c73f2edf3ceef4ce62a02c9813ec5467adae840d03bca0e13b54ba1fcbae13f7f331613e73b0cbb4e3d781949980fa0416ecd8cf5dc3f14960fd78a35d4398e4c32dc4327c2fec76906ed830d3900aa808f2816b87e591e0352ebbea35945762a5c8027a713857adcc4f3c212589ac633f6e02d39ea57bb3f61bddd164e2e182e9192e6284f6623b08cf4198368c1e993e54067ca8971bd66f5b6f097bb8cc1b1c6a2e09accf25d9f325d77d3b5225104439869e8a1d50536d5ec2455c5ecb14594004b6d1ebe11ee544cf562caf799a41c5d3c608bb0d4a1a93f26819c0a58cda9864826fc7aee365c0548f6f607f9beda365cdd73e575097adfa2c2dbbf59d21cc1c04a721b1b4bffc2e0b19ebefd47444b415130f388b37e89dbe16f2d66613098a68b100630572c92714eba43e71b00dac7bb5fc49b8c4daa9b8bcf82610ecfd5121914505951ace333cc1a929f284990c5b652fadb3c8f1a0e70d760eadc71a6c487480095b32a5c688a1a634d3ccd3bf07a2d6faf723b40cb7a1eb0b148b14dcd9876b42fdd2d3afb3dc963529fddada89a63c1fdb0a9abeb592f3c71573e198fe17f7fc5325052cb712a4a12742c0ca273cf148ed3f86438b704873870d43f8e7914c1a2fbb76e81228193d6439f879d1ca33b2b9016c5f915f0a1b6906867db4251e6ef053915f13963200cff428895f32c217534306ecfae49f5b3135a14115c1695bedb112282862aea152b54fef6bc4b38e72ff7a30ba26e0cafd7b899a51709b2acaea7a024b4081e447283d9658024a2fd9cadcd8e5fd47ca278bea412e010decde58fd441b17f0a6450f61468b890bbd018d65d798cae8c9cb3801f3da4e0a82322b97e07774ca890178b37390f046664fecd01067f23109303475ab8326a0a2e18d42d57191cd5ce1183e9f003f50c898bd7634ddd70a3854122a62b4b641b73e86c2cc4903e481486592ea21d071265b3a9f9be09721c89d2ce141c539a70e977d758f5a59387dd361ce474bd32cac8cc5a63ca1ac677a563a717988a33ff748d001627914cbb2a7bbcdc62f9537783063b23b2eb2f4bee759230e55a841f23cfc3804e7d7e0d4b0c1e401338ce6ad2ffd637aa08ba2e113cdd2fc262a487b506bcb226e98ce37c2faec0d46db60b4b2ce25279a409d9ebf2f558138f6ef8a528d0ebec28efade3a4e7faf1e1a28be228ea50cd8e25fc60dd753d943ba14e51967a6d9a6f01b510cbb3f0c02ab2edfa75bbd6470f31e13845f0023e8e495c2efa674a070c7a74aceb177333006b2bb0ca4b3deddcbbd47aac52576a6c5df6a5719f638743e6fc5b41983ceb9808d37342a7e2c403aba2a8109714d1dbe3a8b57ee300e4a2e78e3241c75522ee7da99e7e583a96805227f6d30f526ccbb2e38f3b4132e59d1e8097a518b94659973444305664269e12297c054c1c4abe6edbbab6e6650331a87a0239e215c55206499605da38de8fb47c4acf3ab889af62ac843171fee46a81db5b4c3f706fcf83c9048274b30b909d8559016771ccca4478617224d4ba5948325e502231068e9d9cad1adaf7b6ebdab95915b9151443c64a35295ecf98c330148a5e4c43a3010c44b1b3733365661d43199df189358f6e6dab2dd534c7861f3d43ecd1e3280a2fc1e465ba8397dc0a18c0291c1360d83f874bc27a82b64274368b8aa6b35df767f8c78a2184b7bd5ef68c79f5a7baaff0fb16f37af434621518824a65a8fbc830460fc91c8262af4f4d195a3a3d731ec979eedaeca8573be78e72ca8652f9b8905e3cb3af3fad8526c4c205384a04d67a30f43feabfa1a0e7505a33793db3c7d92ce1c1f39529b6601dc9028e5f240fbb065a035e57d2943f1f008ec97b57906b50ab1b3750e4b95d774d9c326f6d0e0e86c5b4c08a778450f786a5d9711c1204a1c2837138aea1002ac3a783468c5fa2be9d13a8ddb93125184a07e57c209c0da9046b9da59d3609c13883c1cf86ca5d9a744a624df5d0f31d3e3c8c76839a6346e75fc86511b506e417b17f438290fb53f3df3109647dbeaa7ce253902a386a52812c4c68022500c2b6b33425e88c5059c897ac7ee7ef6dd076c1fffdded12bea40b4cbfcdc361f74672fc4abade2844ba9eb45811b1a416fe574b75c660b88e116b91f843d55d0cb247a02a47f22bc4c5e1f08a806c71385c165f8d76f0e8e38a62c30d36f3c089bbb86977ecfbaee6f08a8df326d193bd7d172144eff401f90a0355774bb646ef443897df6297fa219a41fa570b62a901087b1ad458237d99e141e881aaea49c77cc49ae824c2a60c3eb9b5963d4542a70bc8b60fc551230330fe97938b9459813cf688f17daa550dbf139c6602ef455bdbb9bcbf4089be8d99b1131e284083cafc52e354f12e8f64fcc2896cf1bf63df5a33702cd8243fb81630f875c1a9c32898cc16dfa9645f7ca3e6089c1fcd1a0dd669d5c7144ed3b809dac5c0eb427b3448003428abb01d3c5a7e536b3e8d3262927936c1335434f4aa3f58e812569ad1e7dfecd5b88c38895f3f548474f5034dfcbe4a0de0671b5ff408b01a8affae83ff2aae9daa73a787d54e7c28616320fd4be503d33eebe4cc14a8f6e347882cb5023395bf3b50bf1b01dbcdc068b4c945e6aa59533442af3ab4c898117ed2ca123b449227eab39d629fb796ae26ca8e09711afa2839659ade297c6682b8e392763a33740b0312a489b7f6bd90f4f9c3fab34d9f90162e4ce03b912022058e4dcaaa967023e2866e640951c14d9b37ea999123e560e9c7d4c855266c08aa285fdbd708b9564aa53242a6a5a9e25c0d7de253210e334014762fedaf7e8b480968ae17482ecb65f18e8c08605ac5cf0d5b3ac383f8e991353d11bc450fbc373f1ef2f5363288a3082d051f342911af82ad7aced90af20036f4fd89961cba85db0adb65caebf12f5ece92400b0af902ef3c14c8bf5e5103d78143328987ad624a879aa21a15ca60795459c3b3934a2168dbedd54818c724ace53225a726dca895525ee0e6e238a4a7d29fa610f8368b0002702bb2cd92feee0ebc75e7ad4b9cf82c2eb5150bbebdb1f263075a6</script>
  <div class="hbe hbe-content">
    <div class="hbe hbe-input hbe-input-default">
      <input class="hbe hbe-input-field hbe-input-field-default" type="password" id="hbePass">
      <label class="hbe hbe-input-label hbe-input-label-default" for="hbePass">
        <span class="hbe hbe-input-label-content hbe-input-label-content-default">Hey, password is required here.</span>
      </label>
    </div>
  </div>
</div>
<script data-pjax src="/lib/hbe.js"></script><link href="/css/hbe.style.css" rel="stylesheet" type="text/css">]]></content>
  </entry>
  <entry>
    <title>2023.8.21 - 2023.8.25</title>
    <url>/2023/08/22/week-52/</url>
    <content><![CDATA[<div class="hbe hbe-container" id="hexo-blog-encrypt" data-wpm="Oh, this is an invalid password. Check and try again, please." data-whm="OOPS, these decrypted content may changed, but you can still have a look.">
  <script id="hbeData" type="hbeData" data-hmacdigest="e1503d7c75cbf6a41e943b003b61d45905a266484884bc9554d2601e0feb05cd">a99f2d1cd7f89812758242c57c62a59fe859e32cc19116fcceb1abacce500da0960986acd07eddb3568f524414b51fee3d6a7f7be29b9baac927026210c9688dd5d2208059dc09dbf8139f27b5889ba65098b9d7f586e0b67aa6376e09f72a51a0fa25c7434c0b7f76a452bb30f32b5d9133c9513ca72a0d01bf14efef9cd81fb6182a303ec7b592d8b074cceb70546075bc1a33443394a899cf2f7cfb0c5512f41142250516695705f4f9bdac929d617e3eb16acc100aac5a3ddd9c5998569f2d3d4e62010c21a372da3a9b50a302caa9ac3f14dd79e8c5fbd63c51d587cea5d36f0d301d3d4bfe5b093838c53abe1e0d594f73a44f2242ce5ea0f45e7d091dcb2d5c801c4c46d6f5ec907d86ae9527925892d123af3a2f98456e9b062efa01527fe2707f17aeea50e59c85231bc4c70dde5c6eb2fc63e292dcc35bd1a59dd3a2b0aa7f4679f5e05c5714266c3031d3577b64513ca93e1d4a461c91169df4b4f42799b3cb6a4135d04d8892bcff0a36203b384e0af8fb2ede1902c491f719156d15009c7cef01167382416ae57b9ff526e07b33a8204db209376340bd56da178ac4465b7668378de7dffd7e491e2bf5a3b51d491405cb4ae8f004bf5f19c8374fb14aa79eb05885727c8305b0f781755e8f709faf33beefc08b29787b7689f82c2fc808ba3932e66f6ffae67bb49981a5e8ae05e5022c404baad4dc3cf794ab8405639dc72ed239f44e5e14a28fd0ca23017cd708bfd23b7906066450eb2ed63ba911acbe69cdeea3d199c256bac5850a89ebd042d8c60144d49aa258bacb9be871cbfb57e212341eb499d4a6d32cab5d7f8acdb910cdde228f58921c4178b07e9c5841163d977d4e6be6e12e26cf3270ccda49c96def6ad4a3c4e634daebe2a62a1effce8030e03fc4a939f4fbeb196fb16d1ce6325210b4dbbfbe6c540245bc7b9a787f08ccec0b52a4c761ceb26586951dc55bd6e828d864939485a57fcb37e579ca2796f5d6698904b4fcf7ebeec89cc9e75ac8a6beb6367ab3143e37821ab6b8217618d60342ecf9eabdf50faa818ab610914dbe27f0ec10f1d7229e43706c2a978c0b6e58090aa921e8e1885042858abc10356b76b7a7e01adf4c37e099a3e0633bb9c4109427cb43677126330e76610a4061b3ea3c9a5027003d060d42b88d30f41dc13c304f253c5cd036c5a4431c3e05c3baf69fe9f9d564ec25fc6f043283cec22c167b860b18f57db0e3b672e19637c98fff7767639eccd30d1391a160241e61a55fcfc0d8d3a046fea61ac85cf756eb3ac0d8c31054b8429a8d1d960c53bba813a44cab2b24d86f1e6334ef1ba41357fa7d88102f4a05366336f83b4e3a887d327289236e40576c03737a72a0e9073c83d4573bca53d6e4189e51379983d32455d09bcbdaf8d0335369605ec509e04492b57b04aee05ccab25009236b3bafe299dc406f64e7ebcf841de7ff7cdacedae9d840b593b61da78f8ee03c2b1ff2020e3701bbed1cb94246d05347d8a06dcd665eaf9ddf8bbd69220ee9e2193962da251f70e0bb33c1e02a15f175672dbf59f941aa641cae743e4022a03b1ed69b42c84d6e522cb5468cacc69b2b0e89b7ad414a231b42d82759b824cf378dd08bfb907ee4e150ffaecd14c9ca174ce2c8783cffcedf2b835db79cacaa168868ef1bbc9dea09dc13180e2262f8f33ad91a91d6c32d609f776d97ae6fbc64f551155531fc8811e3c4417e052962ebe5f44807cbd8647f68498acce21f8c1df68c2a422b3d18a7c7bcdd10b2f8d17bd5eaad095a86513d0e80a37a52ea91bd9848ff7e47b2f8e09e464e6658b01e1ad1c7bace0a59e3c8d832d353a4730d90f069d95fb9e5d375a124e2412c9e500e472666a9232df6c274fbbf9c4bc2df9116b6ff041c82dd75ae8c5a2dc655e3b349bf1bc84c5fb87f7a4dd4ebbbdcb6cde7c22d701344dbf6b184dae491446888d62517fb9119f56b40ccb6173cb9cfe15d3c8ef54fe69dd61b698304d31ad78811c32982055bc051d808e8ddd03f7f296ba6842c0f7ec12e94cef45106b26c75d2d3a4d9d7a551965eee5f30ba1a858501e5e2dcb75784c629dc14482d505580bfd59f69ea426427e1367e9f9f394430b6798ae6805cc5b5a211340500a61d5d79702aafc218fc9742dd7e6be854725d4584dd391dedde5ef4d00698b4e752793b284da7536a309c2a4c5cdcfb5e8af957a21e0019671a88bf0cd5ff55e26e97d0e7413964030ad855ab622e044adae7eed3fb018d9b3ddd59be9046133bd80e22b05bc5e526811cbf440f60aadb4b1f832abdd025b7d520b0634c65439bade8ce79f24f0dae21230206446e4ce96877ae24025cd2720efd51982fa89e8bf228f260199a2b536d7272f83e5165ca87df0be0333f87df78aed77656743ea847840e769b0d8c8606ca61077b486e04454915f08b26ad78192793d36c88e21080d77295a65a639408c38a77a382bbb1da36c98714de070a42844554b596cf39eeddddde8fbb4276b07dabf3123795bbbb643d6b7346be31849128bc97cab6b213c423f44181fe5c24c337e90477304b99eeb647c707117bdd25f1b8ddc2db8edd87423d1581815648da1b3a7bcde4eab8dffacf18dbb8569bf1fb3986bf5178f436c28b518d4e280f7487c41dd36349560107b0cd89167b28035eb35293ef0fce6162dcdff9b071dea80c3c456ed877442af2479109e97685ef32c97dfadb790e8c5e2c5403ee32b1c5886f302bff12ce24292f53aced79307f13ebff653a12125d458e936bd5bb0a1993e86e10bcf93e9fccf752814ffc83abeabab3b3a35389a9e733351be2cce44859760e23789b279a0ab3ae163f1fedaed63735aaca66d26bb79ed33ee98cbfa6e4bee197c85cece3e8aa7afae3cc165180194d55e4965b2d652d03b2a33325e05a6c460809b7c2fa4077bf9f035ff3cb3c5abf3b4fcb30a170de21757cf6e677dd59e57cf86c37fa37c1275ef82f9bdd25429537e6045c95ce1de2162c1db0f02a73ea6596994d87dc135fc3d34f0be8bbf56aba27ea005da44ef944ace112af5259d79993018d6b1b254753ffb2fe5fa844e09aba77a351c7fc30f1b75bd095a2409e90b51ce7f162bcb24d5607002ccaacb67523d94f4bdeaa1784e7f90f53dbfbae27ef386c0f339c54b1fac4ef9adce0742471e5431136c0c55d0efcdf65d0d36bccdc46279f09e2882017850794a5e1d2fe59595705973f10ade4ccbf06ea051adaff0111c4894b966fa5b79f8d3542b476019894c87949e1fc047f7878cdd9d70be3f22a39970ea85e42c5ea9885508d778ce80e76455a6d49bd935d761264fbcf48ae2a9f078941795c36a749f648688709f70ba6f1d5de0b1ac5bb2a9e240352389cf6f54f6202f8a0320b0b45b0c250671b0f4d340b583da7c4a664667f7903d8796904c33b04094d3a720facbdf741c149cff792f2901238d3324fe6ab5d2031844c61aefe1bf2ae565f3d9041a5dcd289a2c5a1e20186403144e38b688506aed492a476b3259aea53924c1bb9ab608fd00b2a369d41fc6d59829e90e717137fccc7d1865c06c8d250dd6ee9dde8ecee0db07682cb54cee8ae13971254b4231a415a19fe7cc913ce758cd2cc1c1d4019e3277ec200cc3049c9038f3d2ebbdfe757c5d7b6139bf1a2446435451600453f2f8415b2f2969efb9ad9fca6fab18e77cc14db4b27d04d94e35493259f9e23587fb283180e475c16d084eba37737c539b85d5286d248632025a431119c0bb3f1aa0489bd714287e5495d6efa48b85b80b42b5a05afbace2b850d1a4f9ef25f77d75b8c565f3e72cd7399477c1f23c1cced0148e56f67045f6a07abd0731e495e8a679e55ec106bacabba7bba6c73ebb784f36619ca1a98ad2dee86a08b7516108e061acf0de3043681e725a946f3ba8dca904731f19bb8991de62052e7cf081e6174bd81408e33670ffe39dfa92b3eb1ae8227cd00ccc52447f5273ec8fd744c90aa648fdc0c82392ebfeb624dd6a2232c1919f694e1aecb59c177b053eefeff442264e320f7b9790793464e2d25839c8d6f588e3feda2c956489389fcce4764c1eb2c3c3c65260f3ca34ec7b331dbfe5ee44de6c92f5d9e9cba4ba00c1337c296c08fc0f588e335420b84cd1c02d6bcb43508897e66526650b3e42546f92a99081bd075e827c515750ab791e59fd343993a660aededaa2c30e262250292a939fdc65d224390a1624285226a1688b0994681f4f9b9779aa60521f6013916559c70462c7989e33e477be5c0b0b29417e1b9aa6bd000fd9c9428dc03807581d02541bd8ae928b85305acd25eae4d8bf79ac385c06fac7a2c7fa9773f7f0089de27855ef28412c0ce980c9bbb1f7b1751325c677de701a9c12d26b66747b23035aeb8e2ab01af3c33bc5f52365099ef97317f1dafc02c70c415862f6505edf427f1bc8acd725ccde554616f150f56aa0d0ba434894fd4652db43fb4bb1f7edb469542109d463d5eeb953cc847e1d38aae3bd8534ee436d3d7b9e2034d11e36ab66fdf407eaa0e03d6a3ac13ca20924a190643fe2c295746b2cb86571a286634b4ac1cbb24f1d13bcc1cad51fb87f9de09470e62427e1c52eaf6c7e98d3188d4d710e73f7480597378d6aa1ad1b8607d0911809964edd3d19ec4b08d5121b2ce5ba09f33ea4494b9194426c878ecaabf07a4b430df7fbd2aa9c0dd198072d26c5af97908f065c0668df808d08bf84997698b4fe97c07222dc5048c2e46bb5bd8a33e0f793a7ae6f9094f0d6b14b73c893ea6c2d38aa710ac32210ea6ff52dc31be4ca031a2762b30b277afd18ad149d6c725752548c9c9abd55d1de960a6b66223da1d3bd9b13874dbb73618fc9176f67d7e2a5823c0dae354c4c0dc30488894ec377f1574436cf9c3715540a7b8fb9e1b1e2f9b8d9f344e348b6e38744a5a3b08f5e5677ed11f2c6b5c8540d443af2c5cb896f9fd15b97c55f678f63c49b415b42f420487d8bfb879350f7f93883bb0bc7456cc9dca59ebac20cbec3aed6a9a966789ebfff5e20fa2a95c357c3bf75d5beec34b8ea73a18ce811c22f287e7f0553dd8fb9e0102784509b50bb21bfc3a63360ae2ba0fbd2bf06563812d9aa7950eaa07cddf3369bab8b2d0a469258b0523b46adddf462c53b6204dab63bb77d11ede10c39fd71c523d60b9d6812d6cfa762455e38f11fd4a3e69b0e6f7c8e3c9abd078ea752c5ca51d5c4313e45f9dd73437647c9fb3efcddcff7fa0024afe605663d123c4eb9404b397e6f213e7d8acd8e5c921d77c0fa682332ed202bd03113e19036952f87522d5e03585ef55da34ed676c0ea78c39570bf28f488adbd18a7e09fb</script>
  <div class="hbe hbe-content">
    <div class="hbe hbe-input hbe-input-default">
      <input class="hbe hbe-input-field hbe-input-field-default" type="password" id="hbePass">
      <label class="hbe hbe-input-label hbe-input-label-default" for="hbePass">
        <span class="hbe hbe-input-label-content hbe-input-label-content-default">Hey, password is required here.</span>
      </label>
    </div>
  </div>
</div>
<script data-pjax src="/lib/hbe.js"></script><link href="/css/hbe.style.css" rel="stylesheet" type="text/css">]]></content>
  </entry>
  <entry>
    <title>2023.5.29 - 2023.6.2</title>
    <url>/2023/06/03/week-40/</url>
    <content><![CDATA[<div class="hbe hbe-container" id="hexo-blog-encrypt" data-wpm="Oh, this is an invalid password. Check and try again, please." data-whm="OOPS, these decrypted content may changed, but you can still have a look.">
  <script id="hbeData" type="hbeData" data-hmacdigest="32cca0968a41ce21ae33e898d548a4d39c9c3ccc542aa05e1dd4ab14d9d15e93">a99f2d1cd7f89812758242c57c62a59fe859e32cc19116fcceb1abacce500da0960986acd07eddb3568f524414b51fee328da78c0f98adffa976a94ba2f27a821be6295d3e55476520836ccd3789ca40ab4b12a1a8324e34ff996cfad52984e750d4a2ad18acf59a3afa46cf8bacb44e8f054a585e00fcd57fa04e1b76a69fe19e55555fc19a8f36d7f96fae89c45cebf1f759f823438ddfbe4829fb26c58a01882e7fe27084a15183a1cad50440aceb35e16c8f2441f606f9691f1b3236ae719aae1e5708f267b30849a3174fe857f5bf489f68556b25d85cac5cfcc875b4ad5908d3f7240a803d4d9ddd6fe5863d1a6670dbe9bb48d4372a7b31c2782748ef130ea0f080f0d1a467b41a07221f126b6779f9caa9a0504fcc9636c042ce30b713a51cb04fcb804237a8e4fd4412129419270a72bd15fe314c8a61134e7c87141eb176f0e03a20d3df5504c3adef8645540e8ff2984b010552ec2559d8a6f5955059f6d8d8c76f98b76d82305f91071d1e79765553dc2ae1a069aa7ba81ac47525b271bd8a99ef108f8bbe6da5aab306f083262c2a0880069be208258dd60c766cc62a0eb9dde90612ee3447c1755e2ee048ab394c6a3849554c703f45b07f3a9068827bf6f1319c5ec574d0a11b345463e4de9096ae2851a876fbe20f2c68abe91f6370f795be1729be08f543d77d8e937513b820296f6130d2952d38517e61f88eee58bce73960e3e2c5f3cb1be369673062429e6d6ab6348105956b43d0012b60472cb6bff569d97b2fcf3bb368febc2cf5ee024017d57081f6f95d94591d368238fbd2145638ceea23216a081e6fd6334f6b83a3416dcf74a24510b8f61cc1d1fb217c6a6722283eaa6733dec2a0cc58785656fe02ec3ec75ef613ed7a3f44ebd73f1e2fd7eb8ee59b68edda3d95d27daf1dc1dcdb7b7e7824bb8bb07d93954a164a78d30f4b68df700df90f82b71c2b7c5721b56fbb1bb2b58e1c82df16927846a9dea21b7d0804b3f2ed6fbfb8b208b3cc3db088efe66178317521e565ac62e1a37233b3f8ab5d46d7a792b38c7b08e630ec206ba1715bd3df4b79b2fabde0bf3f08821fbc76dc9db38c8d810eecdbb94ab94f1031fee46d473322d4257751da461c850cebcec97d7fa990ea170de0451262d783ab77c3344d77e2c8855089b26568d2c1c6d9b96a55b59095fd4fee94391a58003582f8b663d496955c56d2f88a1f6cf450a2a8fba26d75eb6c2bcbf2a0e71ee7d32330ff1fabc108dc1e74a0611b2ec76931ecc8e42445c069bb538601ee35a4482bb09862e75844572cf2ceef7e16a8d7e1ea57c92f82fe9433feeaf41b58c910e887b0088940a126a2a7145729855fe8e5c593e72cc5ba87fbd55a473da824f53c2537d4b3274cb00eefdd3f6869c6aa949ed8c025ba16a5cc2b9db84f2f096521cb70247e7f81279b272ff755a2131ba67a0c1243f74f5375b573a2387fb2aaecd06f3167576e150a5afaf3ba6547233a791554466d72e6d72274ec30dd5c9cac367dee61eaab922b6e12bb6b9f2c3b8a45d09fa3cdd758e312cd9f5a7fe345c05f557d240758d4eb1a9e9f56ad1b166a768c67c8cf450faff2f6ea6ec13c56053e23bb4431c6c27dfd80629d306111ada4c740c85bbb499673cfdb9dd916b0b562876138f784cb0acdec6fd84c88ceb199a8f9169430903b137abad89b94151523f2de09dd195ec10fa61b6658382fbbefbc3f5a5242ebe0a02c5fd90a7388efe8c782e43098bda43d6187b3cd5e133c2673de4414aa306c9f08a3d2c453261bfaa37133f5cd21d1396e276fb93f821f17c258544098b0f5217f4a87d36f191e17b5b8123d045ea15b762e9774298f6589e729d109e78aeda24d903c7e2e8da1b0fbeae6dce016b38419d156e79412bfb44d4614205de563147641d483ff49fe26e9fb98c1c7b4b5a2f3dd669150d554e002aa721fce8b30286b31c1ca13b1d41ea485c91ccaf881a02d8eb3a7ad9b5a9d18ba27f3e573e3a836724642b4fb17ad41fd424034bd49cab39386fd9a4b115180ea8d4a98e381b2d5174eddcffa2837e9fe7ad4db72175ed7837b71dd9339bac0802dcc0190c3730d4b82d397a1f50cf24f2c4ccd2ae5a865a0fee208a9b45f165d787df38826c3975927e3846f759e3a69ddeb5f5e26825a6e8e494016802491863875be025ba3a7a4538606ee5a6df3cdf858cbcee1ca19c2bae0d325ebbcb032a186c27f700fd164224ecad312bf1c258e6f6f318526a6bd3f60acbc9a42c4087a841db42cdd4deb82a10109e2e7ef8809038c1f4942cefe5731e264dcf6844ae33fc5c88f465b17e0a5613c442d2600d8e62b79e610bd76a10af9d9715163fb0c18d04a864949a8da5de6e223b6fb3e9faa9d98c5ed5ee055cb76205efb19829d825942bc47d0981136b39d185112ffb39667de9661e32535f09a02affe7ffbf472b8cbc77473269d2eb2c3c72f6805fd37ab77929bf03c3d4f62f849bc8cb399a39ab39f6715acfff8d303a7bbc20ba72a90d6e7d52ce293c4a13e8f0dc8d0dc163ea6eeda7e823c0ff1652625605888fbacbef0b8b3feb626ecbf114fea986d433af2f3c4b2b988cdcecce198b2859ed7e8ee5a6cba940aca4686fe2b0500ab726ba38a4134817635802e4a0bd9b6d707ca53ce1a1599ddaffcdb6536148c55c68d7c52c14b1ef692524e934253a6e24e9df68e45f621a720f66a499cec8ffad0713f454d97905a2c376fdb6a6dee285e0c66e9e82cbf3119b2cf91a0a7f88c5906a5eb9ecfdcb5d55e6a7500e5a2a77105e4752096fd3190c5cded6a96807a47e8ec3043d2de0fd2cb90968d37495a3f88e949a2d3d6d81ef2357ed1adc3926c7cdb</script>
  <div class="hbe hbe-content">
    <div class="hbe hbe-input hbe-input-default">
      <input class="hbe hbe-input-field hbe-input-field-default" type="password" id="hbePass">
      <label class="hbe hbe-input-label hbe-input-label-default" for="hbePass">
        <span class="hbe hbe-input-label-content hbe-input-label-content-default">Hey, password is required here.</span>
      </label>
    </div>
  </div>
</div>
<script data-pjax src="/lib/hbe.js"></script><link href="/css/hbe.style.css" rel="stylesheet" type="text/css">]]></content>
  </entry>
  <entry>
    <title>2023.7.3 - 2023.7.7</title>
    <url>/2023/07/07/week-45/</url>
    <content><![CDATA[<div class="hbe hbe-container" id="hexo-blog-encrypt" data-wpm="Oh, this is an invalid password. Check and try again, please." data-whm="OOPS, these decrypted content may changed, but you can still have a look.">
  <script id="hbeData" type="hbeData" data-hmacdigest="27b97d49dec09d2249c749911cf4c004442ca8f1156d1bae72675e352a60bc6c">a99f2d1cd7f89812758242c57c62a59fe859e32cc19116fcceb1abacce500da0960986acd07eddb3568f524414b51fee0ed28a91269fab3014ec3b89f46435ec87ab152a7f09e2a2c11873fd008cd04e9f0b5c289bee4836ed5bda0c648d3b2ea7ca50679d3ef1347e1e4f98261d4ecac4910378e7ad24e53c63bb3393dbe6aa6ca9f4646564b33d4d5e8abeee5a22178c83a6201957856e76eb0fdda86e034aadfa5e8ed8934d6224a61a6bffbe25c03aa7a265fcccde282d62a97e8b7274cd55025c6feca8e18aa2e38684697c3df64a4f4c7fe0aa14de745992f8df569ef277dd748b05870412a689f23514984f5627ba2fa7faa9e760da1e5387e79ac811477bfce58b113d059cba2580c21a914c4e3c071c45e4e7a5f24a2be1a5c9adcb191abc5a494dd4e7e119f523a7e9add51acffa58299edf9dc123c920d79ef2305b6925def8dd65525ae410da55c5d0db44c93b5965562c6b88cb65f993c74dbc65b5e534d83f94c715a5494c74fcfbaf82b82a52bc86e9529702cb119ee96a292fb1b44178d7beb70accbcd1b3bb4e673f1eb007664032f7ef2de049d5aed58c139589d8e80c7b77cca0ac7261e57212320f7ec363e6836003589aa08442423c987efa644c603e9d2e4f92b5f8beef8691a83bbf15b999bdeb988f28f95459d37718f1329ee613d82a785fee74bafe16f03511cfb2f94a2ce908f3a0de521687a3c5009701d31bde9ecdb0e1f0910759eefd1f9e4da6635e707f8e739f43a61cca19b19cbbaa326107345381cbdf208a281e5e022aaed8f1b429ce0ce3637bd16a2f3b28123ce4a0a0235272a3a4f6aa7c46150e9d870073d265059eaf1acd9f49778c680b0ed1232708100430a4b9b5dd41521fa8552947177f77793c8501eb71dc07bc426acbd51562e632fec54128895c1abf4344f85699c3697d16d87b3a7288a3dd1159fffda30228c4beb0b9f536132a79feeacd212e8c3aef810bedecfd7e18304f15531b7581c9afa0cb77e003681a6278b6ac4f21b12c2db549a76a108ec8a3b5bec23df2390044db9164f3ddc4780321856b9fb7d1db9e2fca03b57c8462d11df0fcd3bb6edad3de67a668c75b1e2300fad9ff7a8412079290c9ed7b52f4b2841f9a99e609ff47fc403801ece916c73f7fc5df5ca4489457b852e53875bcb42fcda2ea1a4882c6f7b1236e84254c63df4caa561040177caa3f408e08eaa870d491c77a11eec9561da10a5c8e4464fbf79537f19b072e9930758680ab18f0d6c7df17c71d259d412082b5bba91b51b485fa7f72e1bf9ea0afd625f873d16420fb5eb7fcbb5529b3f140fd8e1d848b38e6e56df108994921257d70216eb810bb092d35a8a8e869c70f45eb485cd848435e538fabb29ef3d24433b35c842a56cb3fa76686ea71a42cf06225ca7854e796948f15aa29d8a56c3b6e53a97c1f7eba625b1234055021340ab72d13ca849e472d04197efca7e604f43cbfcd23c39d64ff7b1d49a02579d6de2f69262d146d617e8e91f814b38b565d43f66ab685ea1f16d6abe59bd94c4e59ad3ef5f030c9b433b4d121e62a47072de8f8e28f31afab85fa4fa36e3faf3a590fd5f9156145efa406dcfa41df6025e0eaba700d5d64e1e266fc039ee8482b7d24b0ddc4540540ccd7fd9e397f0800db1618e20bf6aad9e1441d4b6b9b959ac14c59897b63a6be9e85b7f7ef32769fff9ba59540431407789c2d487ec4d233764a25f28d4ab74ad372c7a129881f402d8b520286eed5316274364a86bb0298529677402625787c494ac7ae42c7e812e1d7c511d786e52464ad1b76602d887fd7439cd8feb8a892f74349868c88fc5dc1810ffea843131e428aec7db2d0a4c8d04543734f5dcb6ec9f8816243ea7ee7f7c57029a12f22e1f48b6fbf78be211900907770582e9af1d7c805969d30e0542037da942ba710e82b05920a8d49d34df36b23a94baa8896bf3064ebcbf223e40dbb5cfe8e88a71efd2ac2f78942c2f9099bb3797b4f27cda4aa679bc44613c55cc8e6d697b11321bc5bc06a1b8c5dddd3108f0bec7067da54d265c2a04cfc0f429d97dbcb295b5ae1cda846b6dcdb1ef19ee591c8ea9d418f6ac87667b38c5a48599b92df2e551aa502613bd04fc4bf8f4d7c21186d435353830e46e5c7d206c12c4f83ba17b599329aad4a1408c46d900e6797129cc46335f4a7fa884139f538d9a9f7888f07456ba315b44b03189ddc4a1309941f0d9b502351471558b979622c37856adc8ef84ab38a59a9a2cee911c5f7a9a93da75aaf2c93d9ed4ebdd75736d78f7c060d3224a37d8cafa5cad6bb474322976d49252a02742a7dfce1af0fb8a0b15521ad1ba8956c953742e9ae4dbaca76a500b9c374225f865183433ca4591f3b408392b9949a3a4bc33364aab1ca1f0f336aa3c4b235abaf11ae42b8fd34d5a021bc975567bacdc03aa44fe0c7fb7ca6</script>
  <div class="hbe hbe-content">
    <div class="hbe hbe-input hbe-input-default">
      <input class="hbe hbe-input-field hbe-input-field-default" type="password" id="hbePass">
      <label class="hbe hbe-input-label hbe-input-label-default" for="hbePass">
        <span class="hbe hbe-input-label-content hbe-input-label-content-default">Hey, password is required here.</span>
      </label>
    </div>
  </div>
</div>
<script data-pjax src="/lib/hbe.js"></script><link href="/css/hbe.style.css" rel="stylesheet" type="text/css">]]></content>
  </entry>
  <entry>
    <title>2023.8.28 - 2023.9.1</title>
    <url>/2023/09/01/week-53/</url>
    <content><![CDATA[<blockquote>
<ul>
<li>工作相关：Docker &amp; K8S Overview</li>
<li>博客更新：<a href="../../../../2022/09/06/docker/">Docker</a>、<a href="../../../../2022/10/03/kubernetes/">Kubernetes</a>、<a href="../../../../2023/08/20/operating-systems/">Operating Systems</a></li>
</ul>
</blockquote>
<p>虽然 OneNote 写起来不太好调格式，但是格式调好之后看着比 Word 和 Markdown 都好看 ~</p>
<p>就是说摆脱导师和实验室以后写文档越来越随心所欲放飞自我了 ~</p>
<img src="1.png" alt="" style="zoom:80%;" />

<img src="2.png" alt="" style="zoom:80%;" />

<img src="3.png" alt="" style="zoom:80%;" />

<img src="4.png" alt="" style="zoom:80%;" />

<img src="5.png" alt="" style="zoom:80%;" />

<img src="6.png" alt="" style="zoom:80%;" />

<img src="7.png" alt="" style="zoom:80%;" />

]]></content>
  </entry>
  <entry>
    <title>2023.9.18 - 2023.9.22</title>
    <url>/2023/09/23/week-56/</url>
    <content><![CDATA[<div class="hbe hbe-container" id="hexo-blog-encrypt" data-wpm="Oh, this is an invalid password. Check and try again, please." data-whm="OOPS, these decrypted content may changed, but you can still have a look.">
  <script id="hbeData" type="hbeData" data-hmacdigest="81b025dbea4f7ab62f50a540b7cdc34d80f727e8aa1405c48d4393e58c55f383">a99f2d1cd7f89812758242c57c62a59fe859e32cc19116fcceb1abacce500da0960986acd07eddb3568f524414b51feee4ffaa6b3a82f17eea8836365dae233e0e3d8cf8144fefb3f594ac0f7ba182b51af3019d9d33d16454552419ecbf8a72b0d80a01ec14dbb6892691ea9580cf3e2a8dd46b8c8ced93a28f01d120a653bd67b40c88abc586fb808984229ed443cb4225423226dd01471ee537ea557c3e052ea361af65e5332d7d928c076dea6e379409fc452541c00a08eaef8b1f98eba3a1b8f075d9a9261022668571316367f8c213f928aea15c010c6f1137e343250c886fe82244613a03f4ad4083a33f9d547a73c8196e8055d5fbb4c65a0796b947a8673012ecf6600327434c3bc4ce0bd678dc192e48fd6b0e02dc8ecbe85c3e5a90a0e78aeaa216825e4d7fe0ae2c533bff474083eb87de17326f453b45c369b6ee9ba938c9c84e689fad9675aadc0ccc93e29235dcc1567d3d7a1885c517080c1950db7f4fb61a3dcc432f1e70b64542f1ac7754d2754561a23d9a8a606b19fefed1abd9b8caa1c7e0cb3900b945254de191ef3156dac04cd5ce2a91f651373fd5075173ec10f3e22b1c6b4aedd60d2fd8673fb3fdd27305c998c368c3075e06537fb35d3cee4c304c0274095d00464bd8748c4a7560740188ae5f09ce5340b6719a143e2abfe966dcb8a0b300bbed484b5107a832f3c7bf368dca61edaf37b25417bec593e329359ef3b22ea3b34df7307610e33c4ff4e71a5193a29a407e91cba00781240f30f4b75877a08885e87012463226803937c0e943beb0bd8ff2604b45a23d078571fea13b4a1c5a7c6ff94d1aaa210123ad0707ab11de4d75cc491565dab99bb9183158f6a417b4e62e5e6b39cc8133e9d4a68810aa29c9e9078ab454fd2520d2ce2d07ec47d131414c9fbf344a3f974f0b77eedc702ceb0bb3147eb7ab5b2880c0dd3a867317e5e74f001929e116a6015b43c1b5549f9226a7ea1d1f8f4edb457cbbf38f54716fd3158d22913a03c5b3a78840997fa44ee007e74cea1ecb19be45d31e13d318f250aec958662a640c81964c31076a550e695d250d4a543cbfa15b7fe25c2b1789161c2d81f3cfc93550d87b59ff0398af4328728863af8e5214c77362bb416ea3cf211afaed2ccdfd2864b95d4f0b16c4a82173853e13e6aa8f7819b7dabd07c9b5983247ebc601f71a78987386d288f3db6d9e48ebbed4d8fec7a549acee654546ede7f202bd24f9239b6a7fe894f9c38497a4dc1c497ea92ef1d1809b5e15cb4dc5098496a4eef290a8992d77bf14516539a11406823ab4f360d1bd07f427b88b600ae39110a3b641f4edfc51713c49d7fa6015f9e22dae8d21b73c98351868a4749e7a457713b79e12e590151135b7a0fefa77f86abf7cd34006aa7b77dd6328bd9c88633b920569c3558cfc35caaadb23ed7b38608c1b20b8e62a3292f4ce7d5870125ce3fcefb6c29686f027e7f0b9041df9d2d4c5dae484fe8b1ef9be446f2a8bdfa2e0477250c7dc879425c7d90df708acce455f51de85eecc3d9ac84248ed0b29dd41072f7082f9ac1c21470c981b76ba464af9e3425cd650b81945947fe74f47813e9f5f24d547eab682c3e8f6e406b68eebcfdec08565cf00406591a53e8dc54d21a8531910fa939464390b780afb09cbd6419f65987a9d8bb3c9767e9811abb87bc9f7fcf25ac2c312873573f4e832e5e3ec2327f7e25d03131d26ebe1409519c11c437d6039417c22a501b476b5c7142fa5557d9296b2021c23a61d53ceb75400649dc5d33e661cb6ca5833e3f0b64d9fb2ad65db973d325325b45e17af83b58e8f1210feecd9b2405c86e92bd6f220222aa7dd1c42289f70734ed595c3dcc0c6cdae479a2a8b7f89556e71efafd13292a2a881c1ed27504ee287667c740e2e5cff2e74a48705475db2398968e3f1fd999afdb1dc184d809c465071ebc156c1dfbdbf20057c73e4e509dca30aca5fb44049488ab4a531900236f5b6411ad8de64bacf7bdcc3f8323b2fb66789626347587969eb28f5b1cc660aa2c69417fc7f14e902b55633da97413d523b121a0e539e64b42d764a8d1a28be7c6b148ed442b7e37a40f0b8011139e8e5a76cdc33c3f5986bc60e9a03d0dff346c7a5a573f11fb0beb79cb9a74a871a9b6a4e156f797e28d56247a5167b553464316feaeb92891be0a152bfcfb25316c538866a7e5b074e984b8a1ee49ae3c783130013ffe9a0eb0e78536cdf0ee3704e2b9ba7d0983bc33ed9d879d449304f2049b0b639721705f8f440228dfbf448237ed5670fc82684ab23941c3653005dc0bc1a0e3db85aae02e1790dd5142ac2a1ba57f9d4086fc34dcbb655a5faef44aa65e1271e95ebc9fc11eedb086d305edb9f1e4e89b6990db9eab90eed6fc8f3b4394ac7ba968707af54cde49789b0f7db5fabcbb4b2828fd55e7502318006a7dc87493b14c8dd1e33c6e051c56410c97e5545c943a91f712e4d09c5b1f2afa343d271bfcddb438debed89a58c04d2db889fc9d751bbb2dbed6469c202b2be0bac51a2b8aa9057238595c813c714c16d7feada44c77a2b0b272d5d8583b78a862adeffeeca6fe6361dfe815a60f7fccf9669f7895bfe644a99f051fb7c047261498433572b3aba4a57537d66568f580f3cdf61f4426f704584df8063dd3135c35c38350b1520e918b683937ff07519ea451ee10702723eb2e47250f8185ea0756987938c40e087698d41f36ced508686b1d01a709040eba47864a33f47f31752c1af3e9b70319facbe382249e3cfc1af255d935a744138992fd6403be4a8a882dbae0dc6c664cb00aae0997b7add910750bca9ad3df1ca95b18655d95df1577a132072afaa8bb27f139716a37cb3348594eb8dbb64bd0224d9f853c24c81148d6c750292633a7f53b2b8e0796fa65c7d1b7f66307dca0c77cac8496885fffb2a296549605141cc3039110eddb8c7f22e06e0f56bc3440135cc4cdbc43d520e90af07260006e3f11b3a6758a4378b9cb1da7c1abc19609e1bfa7ddb4c2718839493657bf438b2dbdc650cfa4937c99af2a51332b980d3adbaad5fec01b742f14d23cb32f2427afca048614b3b14a1822e94b6d01b62940efb4c196d00cd31587cccb9a1f3242356267f73279771a0d6d86f2468f8486608013ea20c835b091e498f537e29b4945fc7d5bdbafda3987028601c9bded719604b995b264c23ea7c84a4285c80414361f301eaf8ab4deaf7d17e15638604ef8cf2d11524fecca159eed8582aafbef3fa5ae894c64a462ec8d93d3a87bfa44fdd15c514d6a8fc1793205f5d2d4c6ce3a1c077841b194468c087d9fc03368d9fbdd140d5a2ba70b0f4ba24f6c83d2c5e79f4dcfb10dabecfb0d366d47f46b9451e17aee0fac8443f309b4db7eb6bcdeab8b0874a514ae160e0264addae36cc5ec614871b48c53354f30a85a6925a361ddbb42b1d4175882b6dd45959a9a70aaa558906884dd1bfab9769dbe260fb45b04a301afcd193f777c2f8f58267bad00865a0c9e8339f20142f04b841ec6d4f67acee651bb04c4fd8eddc02ab0462c9448354eb342e488a096deaeba7ef93962db2c4dee45571623fb2079b64b116f0042352c61da3d141a45093b4ad765e9936efc05814db5b1c2391508d62793b00e4a9e2567a23b74af69f077a5882e0d7e1cb11f3a60ca329700dd6335f3235fed3d68da7b8c4b95734faee9df087dfaa2eb61d705662c9677c48fb9b6fe033d58640d8f6efb383b1cf49a6c8bba7f5138f36363f38110974f0199ea965f6c7ae245d9245d9f8e568680faa42ab76e42b446b23615841f953589e370c5b0cff4b2540106ee168bfc8eff8efc05fe25e1ec9a9289337c0cae956e2a58e5aa1811bb8a3dd99d8a4463f26fa2002c0a1be910185b3b5adf118cd5b5a33c9382b30a3e4c3325e59a943f5a4e4b27cd499717796d564b570c64041a1f1a2c0af40ba056d94bbad13f78add9b615c2e293e373fa5375fc1e10d4d877a1a29f1d938369eeba392dcef4d22a4914f7db46f816b554593a18d827fb6e8fe117994d332a1fee01bd4f59aecc605aee786740a429f4a111b07de4c596db3e3a2e5507feda450e2ceeec1ba34be7af5c4b3f5a44f4e50e2945c95ad7941362c86fab6290438c754f05104ee5f05027cd07a7b874ff120d889c159f24db408f030fc072ac5ab3ac436924a0554253c28ffdc3003b65f60c9736138f68c7715203bb4bbaf23ee9ca9f3a037e868d112e523e2e38e31761916709186b218be77127c2467e47d175966c971bf22570a207aaf5f7249c5a72134e227076ad73dcd5d6663bf8b6c404906eaa67d5464213a2eabc5fa5fb8d5aca37c770c6eeeacc2c2a9dc6a66faafe870783054a1a42e6a778f6a4431a45d385a00be23cf7088adda10c630c26a2c57d428b7a1dcae33921ad935eba5d077aa2a6b3e2f74bb9848a6d3f1e457b22572d7a5e6159b064da2812c35a8b44da6a5837b207a8cbe162b713bff18a3da7c859d18b3b15c49f577979dc951f82a8063297d1e8a208f1e3365664c9b53c348dc408ccf83defe8823144f3d12fd0fc0a7917457c5a9f91eb99906ddeca4cdfa34366db023f716cd28309b265d6bcd5b597b2d98aabfd718fb3b6fccf4c5c15571f1eac08bb9e902e34c04def0cd397c500ca1bc17a4154ec605541c1149e823129986a2465b6e1dcabf21f823e861889ef5bb6b464b8b55487a5ba8b749c6010d199fdc6896f5083feae4d915a2b4e0ad803d8d121ca019ef784c10e46f017d39fe1f7a65d528aa5d6fc362e22d1b4d18660784226284cd110c0c62544dbcf1f0819e8e70c1073bdd1b1248915ae55089b020bf7286d83ea8149f2246b3ea23098120c1c0c5513532798890aa225c8f3354e253c25c7aea891e71c75ff466adb6578b85b0568794888cb6f72e937c35b170abba24d9dfe07231b62bb4efa3375f168b88a79ab93c5369f42319670dea</script>
  <div class="hbe hbe-content">
    <div class="hbe hbe-input hbe-input-default">
      <input class="hbe hbe-input-field hbe-input-field-default" type="password" id="hbePass">
      <label class="hbe hbe-input-label hbe-input-label-default" for="hbePass">
        <span class="hbe hbe-input-label-content hbe-input-label-content-default">Hey, password is required here.</span>
      </label>
    </div>
  </div>
</div>
<script data-pjax src="/lib/hbe.js"></script><link href="/css/hbe.style.css" rel="stylesheet" type="text/css">]]></content>
  </entry>
  <entry>
    <title>2022.10.6 - 2022.10.7</title>
    <url>/2022/10/04/week-6/</url>
    <content><![CDATA[<div class="hbe hbe-container" id="hexo-blog-encrypt" data-wpm="Oh, this is an invalid password. Check and try again, please." data-whm="OOPS, these decrypted content may changed, but you can still have a look.">
  <script id="hbeData" type="hbeData" data-hmacdigest="698782f0e6a1e4928bd4d345973041ed21f44f9a612d89a0b6c45f0d3ce33444">a99f2d1cd7f89812758242c57c62a59fe859e32cc19116fcceb1abacce500da0960986acd07eddb3568f524414b51feed3332575568d42f2bbfe4dcf99bfddd58eb8a195f30b388bdfa6bcf6aff8996db5ed6d638d8b69d43f02dabea6c338420a259e241afa164af4c0f92da4433b84dc74b117446bc2fd293188647cea355dc99c07e454b2926257c8509a66e94402096a966ca01222ca70cb03cd5d81ca1403d45b2ada7c2608d0bf63caa818ea5ac8d7708abd14fd92bf31a4c9150178fff4b5e21194893191ceae675c4cc25ef45339a1dbe3b24c975ae7e1ef588b77a22478fbf3ab4308198b94dbf6b846cf81ab655919aa79d36a50f88723ea9440a6af89c6a3eb3331d39c9c6db45a849df2bd5e378c75578e3fda7ef96d14432732780604a0fa2e7178e59e3315173ca752d3d89e91ce9e1466a2fed94e846107f28bd98e7930b3e0abfa51403f4779c6a189e4b4dd4e8d199879d8346829b69ca1b7a76263b737d46cc8839ae16e22e78fd9dc87d15db23c08dbcbc10b72c9ed0aa23a231d08dfc9338ddc4894697272008356ea454feb5cb02514f49e04ff2776a834d402b3fafbcdb9df7efda859d1f29e6b0b83dbec1f51101e6c9be7fc2f7c952645d27e43dac2e4fd6e09a426ff1c6bcd98a5138273b69347631889cb7e4dcf53ef76e054aff4fde66aeceec24d04fde1d13bbfd4a73677d19e23de9e4251178cf679d978a5c1937910bf0568ab9774c3c533b9ad7aabc4f940928246f21bdb3e9f13739f4341d1998fc7d5ecfc1d92c199cbe36c61205e8f94c319ce39b8764a6032d40723b05eb7ca5d3dd3a1586506562c901921c1eb8f66f161b88b563e05a6c5e88f80b2241d0ddf78d1e6012dae509f9f571de1415ce0da73926ed0a9b81abcc0604a588c3aa59d74b19c981be6c2b741a3b0c0f2888335d50e73355eb9b992990edfde6d0d417008cdea0212b65537e5ef1a537f98d342c268f0e13b613c5cabd5ba814f231ad075ba4d2598d4a5a3515c888ba160162ce5548eedbc4cdf76318cf2f7d20abb4600e2d73eb21553cb11f198d657ade434d077cc7d3f669e83c2562d4d24b326bf4d3f9abe1e533d752b57831010b2912ff60d03f43ab5708bb1e36a89db4862498932f2e36d3cf437cdf7e88d8ee5f13efbfaf4fedc6cb81c3e46c8d27e63cd360be3e81d3566991c3d4ccdb3d557ebae4d58e75a0ec85b2c7436804933ed4985f2eb3b23c5af5f9f6d1cd7fc5ede51952fc24fc2f50c42d94095d22af2263529b1e4be21ba8c35173bcede23cb0209ed948687a6c567b8f2c3e44452dbc0c09fdb3c052780683cdcf630496fee0d87fe393917077eaff29b56d4219332f49da5cfd5715c45375121704b095398d9a7429beb2d8554856cd88111126021d342b4ca2ddc4e9b77d0b61228b80db7c488d124e99ed4</script>
  <div class="hbe hbe-content">
    <div class="hbe hbe-input hbe-input-default">
      <input class="hbe hbe-input-field hbe-input-field-default" type="password" id="hbePass">
      <label class="hbe hbe-input-label hbe-input-label-default" for="hbePass">
        <span class="hbe hbe-input-label-content hbe-input-label-content-default">Hey, password is required here.</span>
      </label>
    </div>
  </div>
</div>
<script data-pjax src="/lib/hbe.js"></script><link href="/css/hbe.style.css" rel="stylesheet" type="text/css">]]></content>
  </entry>
  <entry>
    <title>2023.9.4 - 2023.9.8</title>
    <url>/2023/09/04/week-54/</url>
    <content><![CDATA[<div class="hbe hbe-container" id="hexo-blog-encrypt" data-wpm="Oh, this is an invalid password. Check and try again, please." data-whm="OOPS, these decrypted content may changed, but you can still have a look.">
  <script id="hbeData" type="hbeData" data-hmacdigest="4c27a407d0febd4cd08abf30458336912f693e6703066dfc4889841029b58c4d">a99f2d1cd7f89812758242c57c62a59fe859e32cc19116fcceb1abacce500da0960986acd07eddb3568f524414b51fee7ed7b54158f7292a138b43d7bd33d9225698620c8c987000c510d4f70839899412ef3a365e73531fcf23097b7a76cdcb4cbbc826d067db8d7935a9b01cd8cc13e9786f5fcb13a556457ef2605cde131c6c53fcff3b4b850e36d64a1b89f4ab7ca72b385bfa9a33c0eda71ec86254d04d3f68ae3cd070781c2c1f0c66400ef267c3f9dbbd409cbf37274472812bc72f3a75d71747ed6c89fcb33285e5ff157b26b7c0d834c89deca346f00281c5f3be10df8b2efe876d89e486b12a512878d609dced722ea797b31c46836595fc454a429cd2046df614736e944b52ed69c9bb9f9e2ecfdc6b5a7bc919475206ddd379dae1ff55d690cff9c99f63d962197b23ec808a7584a6fe637cd360246e0c1716d2c4986f27a85012a7fc6414816de03dd1fd5c7206a1842ed8d72054efee0b7b6a21d4140688efce286f8e7a99de4d596e6489f5bfe27fab9ec8d0f886ba18ba3349dbc787c6ad7034544df661fe2fd75bc39aa1b051bfdb8ea90f25f505d32fc41f4fa910841ecf29f58d75aad3403cfb85320ff352229406e2f1c3d96572dbcc71ff5255febde9393fba11e0dbfe42b6376682b5a69ba78827d351c95699b653d83275801c0070abc0ddacf51c3f048fe9a42739a1fb439e5a2a190ca0854c8780d59c2adc0cc6ddfc90c0d5a2fe89a309886e9c73811efea4958dfd3af98bd737b5c7fa1de27ec015d7fe095e787eeb5caeddf8578ee100c07318ac1bb651f1fc4c9ca6a98538a85591102d479f8af541a57514b35030ea651a79704089c9097d55d22254d5d3b0d5ccf67e702f8b66fad65e94aa895ed643dc960f7fc8705e35c89dba24976de1bcf5e925c2ee18783516dd2d68479aa3ca55dbc2e2800b2d25d59ccd9883344ded270d8f066b5c27024aa10b094959b095566dcb315089696a806a4ee980b1bc33292dd15dc79f4ad052e4ff5785eadbcd986b8a68251e5f6656bc2e8babd02acb6d0b8287e16abfa7e17416deee732aea513966358dfcecd13ce880fc5c7901d679fba014552dc1c0c3cc327f9082cd63a040d090142497af23b349a2d642b098ca7b97290571fd27e7200bffb2a2c590a7c8294cac5ba81ed9370fb2a3a34b4baa35757a877ba6db18b6cebc2b170f62e2e15e8ffd52946529b69b53576f3ec19908ae58a16971d600a967ac84a071bea065404cfde4b9df17f5154eb32405aeb9c7fdedd18d736fb6a37dfe8617c3221140d65bcb85700aaa1c8f7387bc68be04b3f31a6e46ea51f63c2434f848f554731d7d3978e65820a7a7e958f44256619cc0190a4713a6d5439bb79ed6863085bf51bd9b07a71a7d01ef9583886a53aeb07208578cae31e39bc11685210f4685bea856affc0897ba1ea908b8f4b814e8103e5c830b9f1a43bad749daf2ddb75a3e96c34d27cb65d2e1f3f0e269c70a6a625bc15cd7e6dcecd9d0e99508f9fbd486e3890c6c641bda491e70271949bf2e655266648408e446a7c1796abf2525c92a8e1070c7f166d4ba7f41647471023779b7dd7779aa4464d579f02e4a486251340df6db1279441b0da8c6049c2dc9cd1a60ca3cda51304dd1b578888db7edb13a393078e882d976b3924b4697a8f5924c47e0b918fab9b1ff7d9d87195755979e29ccccfd46ef53f09eef40d272ebafa3b554388f41073e8f325a1207ea77bb8ce607a4d6db9eb33fd84d9155606ab719b91b7c34d18e38e57832aee75bb33cd06974e9806ee8c5c84bc3c19d6d3b8a690a3ac62b83d1216a449b697c372a8f289d885b7c745c75df94601d9c30ed6899deeb074a4031b7b675fdca7b7acd8b6d9db339c08b3724201a13fa4b4024fcbe10beeed56fc30428e9920334b32883c85897e9cc5daaa413346b648c2b3863bf6d7f4415b3d40d9cde706046a32a2544bb1cabab9e38c245265910eb1b5fcba3ac74b5bb0a5f6ae245d44b3b85a0aea4c0ccc14cc0b11a546f8d790702526f19848ec00f2396a42a1902821b99ca302f22469248c3897e7336ef2355277d6e28df7c215cbfd9ddbc7e46f6b1cb31323562c65370e6dd70f28664c855b4873b3f227f2c889d211f80281c8c6eda724f89a172a8e993e9b4a45604ec940379cd1161618c2c898db64513637d96e89fc044c309ce2364f42b9a61b5caf0396b8ad1a4a38afa29f34fd946a5979540a74b3eca97d6b05450760b5275c9a3cf660c0e3b9fdfb4d7b19029cec6cf4980fc67b1ce9e070bca97f74834a09c0a991a4568953205bdc90f815065eea3d279f2b9f68084d9abc57bfda5f858701d020d88534fc507e248a11320bd5c4242c79edfe97ec5f8e3f190e22845b261382a23804a1205e0214f18c5bf5f197e9061eae2af86daf26c5aff5b314eacedf39e4560ee5dd4098fbf46a56180bca8536de36680f8603c76f8c20ca8f6093bf4739cba3b2ee3fc514c81946d926029d74de59ec3e65e603a590251c59c3407e3be104f485bbadfd3062daedfe0dc8dfa71d3dab75b8e362f0f8536041224ee8e0db57e776d2e0db37073d20dda1e4373d8634f67645c587d8cd6ec9224aeab0470764a447118943d1329a0908aad945308c4474d509fc88c83fd54ba2ef6f60912dfc645c360045a0eace9d127c3afe4c33a813521e405a517f31726158fa71a21a4a098ea20a4714fd89c8b207bb131f31c7a4d62d55062a0f1f887a785464077223741f17682a35b69e379fac0d2677ca1291018f90f26db0655f479656259e9e7b483b58ce2fd3d0cd975237af4d2b692a00edd15bf93f384a014fd78b2acac5e264cecba2796241c9f72b3efda1d7d5b495ee507922425adaddf27f5b2040604078b8138a48b06afbc486cb14c3dd7207e97048b876e67408cf22b153e049a749a25477e75c8a4c5fed52158a1de6b6d7e2990aed64a2a2ffcf8f1265a8d81c65c8e33aba0d8eb4624456117f53e4d53df1064b987fac7b0ae11dfe9ece6439b143bd4e73cff0943773cca242b40e0c44ad48f9b94b70a5d4129663164a2f572882de6a666ecb76ed6b0d616ee210775a39a8518592ccd791367c0b5f9077b95382e4c8fe98650cfd00a4a5906aed68966907f8e115d43d35da1329e59c738f52d0605a8ea84d902654475f0c2d7b0b12e2946f3f799610528aeca4657ffb57a61ee98b98f3cf4d2dc3f0fc1ff03035d7affe278a3a19d3784d9484578e688cf62477ecb65c52c647017e42a647722a4e5445981ac98f1138040b49b1647afbb6797418c059439cf02f868bcb73add9853baba1d3b7a689865dcaebfbfb789a0d4dcaa05522656bea0532034c93b75dbf887449056a495c1b226c57caf78c99b4a8cb3249b3fe6f8b8afe60d79c059f90ac7859910356cc201d65cbf8070e91bf2673a0fa36bb8cf090f388a286bbf122152dcb0d255afe12728ac139aeed365d98a76f3b61fde4f056f00d6813ca5849897cc19ba48e2de68e43aec688bf5a9cdd8b0889ea7bf5d7869cbb002a8c083bfdc27cba46a84d925d2c832a4b65a2a6d4509ec8c0ba3c433ec5f2aee5e4f825035c758d8d15c5eeb859648df93805d45dd0c5839b34ce7f9eac257495a54213bf5ce91fcfe1dc2c850b4fc378d7932e635d461d0d4747d02245f6413405e88c9a7ee5593cd60d41becb45291fd782a406bc496e0bbfbd6f1160e2eb5d945ed0da58824134bacb3fbb9d98bef643a84c1b944c5eb2652343486b97fa44bb4261f07c0f773a05d167c87939fe051c67693391ccd6cc052bb9a496ba392ae1b6a1d7c3d3040a7cef1412e0fa779e83f15a4d4bfcaad40301c645554a09868b03ddd42991dcfb67d590b362bd47663e6396f701da7a2579b711e5c0d006a4cd85aa26be44f33cd3682099af498c813d8315bafb485a652b9681ce46b9e510bad50932252352534097e138aad815abb3ab44f86b14f654e84c04d71fe7cf133babbf6466751e02e2dd41fe3d58c94603633f46e47b173928d394274117287a853055c752ef4f401feed47225299032d55ab90f6c75f36960b371b9860d94714e2ec5155c2f775db47bddb5bbec0370ad5e9e0c9a287ee9a6cc11d99b2415f64f584324cd622d140a90657b081a083ac261b76934948d9b9cd1d829313a80d2168d22326d9450db71bcd2dfc1d7ba4f4b33bab363df46bdde47d2a9b4e85907894a9293ea2623a49a6e6f9dcfce1d69bf588f46031c218b6c4e4f1b63806eaafe89071c9fb505224b20ce3c1ac82406935619fa38471fe7123eb768807737576c778e52a75fcaa1045ebbb9634c49324384c5d98a9e6c91ac0927af0509ad15bbc950fd16434a6b00ad82dc697add23d802044eee5e9460373194e437e3c9e3a8c9f344bda6fb5f1a7ca0847645764966e8a7180943b1ba310d6353ca14e80bfa4f09686d7a6b3ac1f904f949d1a74453e75a8b521398d99ddd86be562de0ab3ae493c644470afc4f768ef31cb109d5bb87a9898f82b85ad5ddf9f1e10f0d9a6542f54038d26446e436304a580a961ba6cdd0a0bf6af35d6394f8e5af94957ef6ef4516d2fbe035364bf5987dbebe01013feca1dc2ce1631c11751d6a8c07e5f9f227d94a2597491e58d9076b7f86e65fc15b94fdcfd4b29f0acd741e35ac3fc611f20b7237bc4cf4eef17d4dbb7944555dcfc491e00ef118b9cb39b1c9f3829c938f59eab68c8d91d3b86868bd56e4ff46b9424982edf5e62127682b941635c51a335112e0e2c45ec4bf93a3cbdea968433f61035b9f7d489e3ceba9a2da7d738e5081a456adf58f450d6f1d15fc1df9cb737a6f7d344ada905fbcd07663e6bf2042c727b47dc77f4db9b118f7b94ac23b1ca3273528e0d62be3450ec3d660cba06cffd0db93920e3d43f424856035d4af6b922a076cc0ee8d1332a4b664759562999940c75901f81101b66614ea43524ac3f9e24237ff61cc9cc0f171eca4cd223f03efe22338fb8538449629b11f6eed4efb15e868fb26414b227d6007de64e25d483d8b22746de64a63d092fa5bb68ffb02c1d479610ed6d</script>
  <div class="hbe hbe-content">
    <div class="hbe hbe-input hbe-input-default">
      <input class="hbe hbe-input-field hbe-input-field-default" type="password" id="hbePass">
      <label class="hbe hbe-input-label hbe-input-label-default" for="hbePass">
        <span class="hbe hbe-input-label-content hbe-input-label-content-default">Hey, password is required here.</span>
      </label>
    </div>
  </div>
</div>
<script data-pjax src="/lib/hbe.js"></script><link href="/css/hbe.style.css" rel="stylesheet" type="text/css">]]></content>
  </entry>
  <entry>
    <title>2023.12.18 - 2023.12.22</title>
    <url>/2023/12/23/week-68/</url>
    <content><![CDATA[<div class="hbe hbe-container" id="hexo-blog-encrypt" data-wpm="Oh, this is an invalid password. Check and try again, please." data-whm="OOPS, these decrypted content may changed, but you can still have a look.">
  <script id="hbeData" type="hbeData" data-hmacdigest="69e3d1d85be5f204e321bb2a502d366e1289212de203b628b9a2f48e04872f62">a99f2d1cd7f89812758242c57c62a59fe859e32cc19116fcceb1abacce500da0960986acd07eddb3568f524414b51fee4eae1f2d89babe34509d3fa1df95b4363aee381debf042b0eb9cbcf843074cb212d90c00417978bdc27a2cd15becb3e7f063676d558486ca55f1643ebc5a01f99e33eade75ce21c8760c47e43fa969c89a19cec8f7fb1b209705e23dd1014419edaa0f831400cffee6f215ecd476ac74043cb5923050d5cb975532ef6e5879145d519883beb0e907899d940ed3c4d61edf2f7623c15171a9cde3506fa22b7a7ef03a4a7282b61c08ce62340c3f0a6fcd9909fa4fc4aee28d7b0acc5c16f8b94709fc23e5e662f9230c8b9fa0b5abe7f904b6dbd9dd16309fa4c9b1677e1a5818b05f927016a02f924fe5e004cd1e0e881f63e0b6b58bf53fdedcd1c8a7f3bfec0e154fba5375f6fbd4c76969624cc2d3c932ab855ddbb40c1d3b8d4289bad0ae3bc23add4a3ee4a88b0f7a7a9485adddcd387ba9246b44c0a1d74d003a541935e023b6a506955de164eb811ce41569e88c1cf1ffe1e5f020aaf4173bc0362a5f32f9e98a61e0ae589ee50e0ed6c2a6cf8dcda355f265afd6206691db5bc946649e7c69f01aa33288a88f957d8542daa9aff09b311bdf40260913448811ebfc508642fa670c13cfc62495daa0fa59b790bd99cfcc6673349d24cb5ede789cba95f295f6245bbd3536cdcf1bf2e373dd4b5698b501d0fe4e545b0dda7ce625a7949af9a42e38a87128bab91cbf005ac7791cceb4dbe17264ee86234a4d309505410924db0f72a474d575164a66776df0fe000667721607d32ea35d2809877a41bdb548f965967c05ceca4aaf62c54b526fc44e6b67943921f2acb578bdc235f4f3da22ac0b0f0f7e129d33cf64688d05c9a53a073862a13a093f6b391d921d75467b05417fa018f64e9241a4102f8b0c8baf835046ec278d7ff75391f6d9362ecd79167f4e010b1c1edbeb08857160bdb4ba144c0f35bd09d9ba4db0f965dea5920cb91b24b6b84d76757987b40b5d50c36b7c33c615791a53536c62cb1b02b976c7191158c5b0d8cd33d24f94808832b9b4b0f36ef1de2049146e898e59f285f7e38d303dcc4a3fea70a19a9af4a87383214a245871ba1393284a46fe28cdadfe1e2a3067975ca4727cf2f7377525423a3fff755cc51d86bceab9f9307465f256fc9af214208f90b2d395d2fb2d91fcd0206d86a466b4596bdb1ceeeedfc4f2951b19d9bc1dc3dfaa935214357d15265b75165347cab30be8677082960bf2dd8724b4a10dd0f5429fcf69a2f322d2fecfef1fc5597edab8149fa6524b356d18d6fc42f77e17e9c70fe91182805d493518b24dc5a765a524c489241e53de8819769a7e4aa6621abd79a41f788784d035d7df97b49e9a019e3dd7457a00ae56e031c80260b4cd4187a2720f1a4f431875d4ef079711214da99c4d97a8abb7914e4ef7d91885bec86fc7d063fa3dac5347fee1e40537c8937984aa8734d6c42ba7f5acd17c397f597c02d677cf2616a731b6de5bcbfcff6868649944c1ed8d0afa584268b389823f65517f2e419e84c3e205010487155df990d79a91ab9827958bcc6c019f770185c2ccee4396cbd0814e7fb411e1455e4c74f9e66cb2258e5b5eb933d5039bc42c208eec0a170c85063ee31ffa04d2e420de2b2504bc57f78247b44147ed110a986e6abfbe1c8b0f6dac54ac38add2cfc077889f4771b8d63e257d8069e387ccaab902db900e2540637c4e5a4866c5189022db9c245bcf84209c3c04a48f79bb04582ba88a11e52993d3e325212989aaea7d31e767f8b64f6ac8a386bbc5cab41abbd71b2d17979566a595eb65338251fe5006cb8b6a2b2ce40d578992fb9935c5c52b6152eefdd60b5252c080bc58c9101e32d197dc4e93b69fdb629b28aa7dbc36800fd37270e3bc3bebb0848e3c70270536997a97e7e809b0d779cf1d3d7ec0c141fa461c60b2e574c21f803cd64af7f783cd3755483bc9878203bbee26daef5e19877b620d41d75d4480c1759517c0296529cb14c403e61ef2e56ebabd280dc41692da3645c8d948df11eb5b943437df043ad298a3659ac69403164be33e954c3b131ca4299361fac7</script>
  <div class="hbe hbe-content">
    <div class="hbe hbe-input hbe-input-default">
      <input class="hbe hbe-input-field hbe-input-field-default" type="password" id="hbePass">
      <label class="hbe hbe-input-label hbe-input-label-default" for="hbePass">
        <span class="hbe hbe-input-label-content hbe-input-label-content-default">Hey, password is required here.</span>
      </label>
    </div>
  </div>
</div>
<script data-pjax src="/lib/hbe.js"></script><link href="/css/hbe.style.css" rel="stylesheet" type="text/css">]]></content>
  </entry>
  <entry>
    <title>2024.2.5 - 2024.2.9</title>
    <url>/2024/02/18/week-75/</url>
    <content><![CDATA[<div class="hbe hbe-container" id="hexo-blog-encrypt" data-wpm="Oh, this is an invalid password. Check and try again, please." data-whm="OOPS, these decrypted content may changed, but you can still have a look.">
  <script id="hbeData" type="hbeData" data-hmacdigest="83d300b95df966b03b5365c5681101a0b80cf19f1826adc873de22ef2caa1b26">a99f2d1cd7f89812758242c57c62a59fe859e32cc19116fcceb1abacce500da0960986acd07eddb3568f524414b51feef7d878439b554f231841d62be4a76860065e5e3cd3a31fe6af186f82f01433053131c39aa67176a0efb1f80cd75900ca13609325cbfd84bb893be17d21d9de0f4a7d796121634d2a35ec65e22893f600799e8241a36e772270236b319a2d10fa9427e85c3c4f15f505641b25ade9cfa445b66faf5def14a0f06d3a511d4efc03dd85ca0cf3241d703786d8ce053e807014943a287cb83561b47d08e1416a9e76e84d9e1844b1e49d13a7ff61062f775855e50dc9d557fb577199b28d53509d1ee84431a3cb9f0c941586348fa551b0c877ae07980a594254c65642c9d463abc2dd40d3a5d6b1358887ef1f4baf08f2c15f290d2fd8155389138001f616a2a5b54832ef191132ed3bfcfab5db06e9bd1747e0ed6e2f51dc0b2e72c14ee228c7b3b3c1dac540b575d8dfa3eef3aca860636fab02d7d3ff3ef1d19971bd40d9a19f6b5e2a3a620838655824625555a30bb76d7d7659d4d78a26b46e7234419efcb8d06f10ce4334e04b1c026d38d0fca61b46742eb79e91e9108394549e5fb202734e8c4b0757f14dc46d0f6039eff308abfeda6a439e9a2e4ce79a692a69e4b7ef662a1b05310d94e4283780ce5b99d24b2395108a4ec175cd752137c4a533e454bf62eba77fd7cde8513cb4460d65930d7f5dfd3780c6b24b499189ab37b9a5c304aef68079cb480f4e015ac093b01614041469faa8163001eb429554388d39db805e3ac8870363a83f2b9f77fe56904180fa2299ff552f7b413a95dbc9d11d0422e40b98f89a0184a69d4e1e28a7f4b0e14090e0255f6487c214edd581b36393fa90ac08c9ee087cd69b63cafe09eb7f27a8403c9bdc478bfab84017faee430f41da887901c59fb5ccc3582905e47faa6fc32b9511633a9eaa94cf7176bed8507ed40df15427792823c17053b6c49fa3ac785260213fa9975f67ab72737bb219adb213f27bae5063614f52fdec9f0c7a7131949263dd9b29b4371a6bfb07fea46019b545ab8b89af24bf1818adf9cac8a8a756c44b0bcec18ebd48a83e89e6f2cda107bca887292bf0ec8fc099a31bf273a02bc41d9185f366aa76637560b5c3091cfc12784241ca5b8733efeb78beb66c8387d8c0cfd7253cd230c2cd302d3cdb4f29bd3c4db2f315597297eb4dd7f33231068f47a42f20b51d802b1dfc0f9119c2fee8374029eb8c226d6485ef6d24d054e31db06327f6c886d29b2445d25cc8a299854ffa408d9fe779cfe49d78e30d330a96e26dd9699d241920391900fc22939f7663857b0c0388a5158cee2e859936307e0c1437c43dae31258de14dc64a3a21f58aa14a60fc4c6caff6c8ac01e5031e9e89cdd598f91c4b6e612b236bebbc2ead6771ff0a749d35264be355086641388f45ea67a2510707ad1e259549007ab7c21878db78d72399421ae91810e6c0a4756eec12fa1672d2d6e1d506d1f233c9e8024458561fbcfff40e3228dc93572496d02cf7721076b801a4c824c6da48d8b4814c56c0de3c7437bb8fcaa1bf1e825a0442e73986bd927efe0d8e770ed5afc7b972b452cfbb1ae4096c3378c661f1bfa81e551ed5669c5c81098e2cea2cf8b6a96fc9900827c3bb099987f2da20d34142eeb0e23498a51be4405bcfd7c9c4d4cc80c705d451202cf5600cf49d278d98abe77bbfbdb5338bccd4e5d7dea0197e81b40ed20c452a9322d8bf43c93ab2975039512246eaa65e39e57c0c577dd7e18d747d03f412d017c8ed7e271c0f689198906d7a27f662ad65f95c7e38dd9af5a72d98c8318bca83253cba1576707719c81e8e81c61f12e3aab1b5b278c473c7c3000ad7c388e3ccf9c391780e56ca64fde94f219812ed0237af40db6577d5f142d259a5490d4750f3a9a85cae942114e8cfc9ebbabf12b25fff218a64877c9bc7c3f494be395126abcfc88413dc63d921a3286ed20d67c1e0324649ead8a1e9ef5add8f3a6ab5531cb2d517e07237408bd82462755f665582af02130039f0a451bc3e489db715491a1317ac5cbe03f7d2ab513ae29301471aeeac26989bc3139cd270f9c792642307bd815112123880610084c9a70965b79f33b7f5138dc52bfa9a863a8551ecfad11da817feb4febf349a7ccbd5544c9f98c19153e74a1be8b47822d7c5eabf1be236697adf29661c6b840d585d9cb980566848f21aecef2bf56c84baba3a81d2e43cc8c249012cbb08fff2239ed22eed41d07ea6e02616800da2b3b3cbf9c1f42f53ac1db9184453e2df8416fb19dd1bc24f3e04517b7a372743736c4e4fe8dce370423b8dfea7abf09c36efa9ee86e7284a07bedd8cff285b266a7441c9dc4727e01176</script>
  <div class="hbe hbe-content">
    <div class="hbe hbe-input hbe-input-default">
      <input class="hbe hbe-input-field hbe-input-field-default" type="password" id="hbePass">
      <label class="hbe hbe-input-label hbe-input-label-default" for="hbePass">
        <span class="hbe hbe-input-label-content hbe-input-label-content-default">Hey, password is required here.</span>
      </label>
    </div>
  </div>
</div>
<script data-pjax src="/lib/hbe.js"></script><link href="/css/hbe.style.css" rel="stylesheet" type="text/css">]]></content>
  </entry>
  <entry>
    <title>2022.10.10 - 2022.10.14</title>
    <url>/2022/10/10/week-7/</url>
    <content><![CDATA[<div class="hbe hbe-container" id="hexo-blog-encrypt" data-wpm="Oh, this is an invalid password. Check and try again, please." data-whm="OOPS, these decrypted content may changed, but you can still have a look.">
  <script id="hbeData" type="hbeData" data-hmacdigest="707387aa4e7889e53f2265afecc48f6c4179dde214f86002a41a25457c259836">a99f2d1cd7f89812758242c57c62a59fe859e32cc19116fcceb1abacce500da0960986acd07eddb3568f524414b51feef24d0c1358255279b996609dca1b86f9c0ae8931aee08a787f8fe9e25c38d9549f473d682494f9d61b5882e35b1fe7300401bae97a017d2362cae54b4f08def7daf27c39c91a659924a3f0432e2824be5e17afdca1f742fcc6c56565f42eccb7e34d161914d3a7c2baec2bcb25f538f1f07294552d393c3d9769a7041ca4d51c28e71a71e46baaab58afb4a7573ba7b74267ddbeb6450a0adf9400f59b6fbc659e478e75679c5a57d46dd52269ed7f1d49165b6304cc7475815475bf5d844c8a4e16ae9699cf2cc86a6789cec2d9b70049ec1b35014bd10bdd5951e503450bd9df87fd3db1c7b2375145d38363349665fcf30095cff5fa55932bcf57a7c317abb7e52a1056efdfdcf5caac8162f9d614472d4785032c12fe4b09da129b7074b5b68144186b2238b7c6b27a04bd6764ab2a0e88c366cacdfee84a0467ea8011d04dce5cd28e234b868714f5d2034275ca1e94f699eaf05c403e6b335d79d636f3437eb5cfae11a9fb2c6d36ee8dea05ab967f9ecea21f0c131024398c151bff0be5b7ffe548091bd746cddd8024ca1edfe05b5e5cdedd6b0b3925517ad810bc00a88429ffc4799c01e1da71104e6ccba2a04b4477dd4e2aaa4c9ca60d63fc374100872aed6613ec3d86d07060fed3828bce13746a03cddd4c4b0ceb8fa5ce5ed7260c9ec257480accdd365093eeefedefca530772fa402186458b685f82dfad6df29f9575400980f4b0395f98f9480a3ec7ba7d5e238616de9a39a058be5aa7cec7467e823c0099521a0183001f3c11c2d8267553cc269d11a13fd2e3009e0212ce3056e64a6650c4c79e9f8812464588f79c09f4553ba5264a851a661d2d64d0fe01176cc9409ba44eb6761bd1bc7891f7801fd7750430133462ddd42b52c9b116dbc19eb6bad185379e06b4c79dc0e73eead9b0203b08cfbf70b305299add6b4bcd0b23d02d7eac763c00f6e641cdd1d44529ea0918eea20b5dc5c9f845c92a201b8e8038e55589afa413e704c743ec2373476dd525bb96e0b22bd2d2131678f10327eaa37c3e22fceed0db7d9ce97b3050e27a6793d90e02faed9e91b79954d7f76f6186ee69a4a28b28bf011f28f9c640bc192c48a7e62444bfc0eede63507e86c425d45791e6d5a78d611680c17da6bcfc1da3f870655b6d52087420d2d2e87c69106db95a70b2272eaaa192beff4e38689838f3c02ecc1c131850aa179056ccd192d63adb2c7e494e169dc6ab55c8b274a8400e84eb7b06e08d9b75ff77fafd039e67535f41fd7b601023bf234c15273fae139af35c8aa407d67de7725ae8f18f0c6de92ae1452583bdb71dde63b15e412ca09f668f8309e1aa9ed4cec52a938bee059a1b6f42c4fca28a136ba70581e7484ac4144209fff2239180b7aa03f5d7708b1a846303966b723eccef0a74e78f0cf1b31432a3d538d5393f423b3cc7757dd9e65d735b8e9b7bf45167b4a16f40b09aa09197df6b2879bbd6a5765d23b2937dacf262225962639c1ef50b15ef40c55c2e2b5f9be3cf0f74446b063ad74a3e9b0883be3f36d429e1821edb8efd93c1240a6401d51168c35f997489054dd7e2c376596fe240b02b38b60d67c9467e245cb34355ace62a8549e807eb4206605229316b3e4cd699786937698553ae6e416e56875c9ea34659cb64aec41d3f49a809bb3b7d72404413cf2f2f39825a89fbedfc90276dba9fa8fbb2bc66135a58a64ed74b1013217e2b0e37d03ae4bd07c741d9ae81b6983c7461ebb148173bf93982061b5d12723fdfdbca9152d4c69c35a1278e67fa8291a9821c17e698574d42db68397182fb04788022822f7543e3a6f44cd344fef530897e5b747640928de8937d0900c684990db0999fac3c93753269bda194f46adff53d9b7b27b40ebd8cab8f6a69fb626506ed836f8362bebbc1cbd3ee7b6a8a644c8822fdd69948f7bc4ce1088c4a50ceb136f6f0af75a5ceab07f252c9958be4c67d718c6239c96edaf7e6b9f99ff5b834c7bcc57f4df4c07e621a32d232fac723f5f8e378177fb9cff44570d556551617a1c5ce2eda4f2d33ef3dbd8b24514a7056150822de3db72812ca55d200b704fb8c6209396de1b6f3919c0ebe67099ad5596e75f21a41de231828297f6cb2bb7a392cca8973657ffbcc1865ea43d240cf23e5efa8cdfb175b3769554bff66a9615db290de4d1292dc132eff52fa93c0c003740853fffc06d8ab77b315dd227760e05c0402ebe4c99c0bd27fff5daedf302081eb1caa114dbae588b0f7e3e0ed47ed8bce7d84c89ec1640e307b38d62d9b2f3a811059b89baaf44d5fd0f6a34d1ec52a5ebbdc8acc21d5a73d5bd5a2a1beb4e93577bc40ff2830f79c8409c8ec9d200756c94e990fe3fbb10e37b86557cdde9379f37efdffb8b41c8d1df7ddd966bf2a6d21ec3302e4a1d1212b3df8377d93b3ee7588bcfca0355e5552c739ac073bbdb5e26802072c15470f414de3426cce68c1590151cdcb11958ee21a391cbdd21e127b0b034ced42b8220b7629eaeb7511e5fe800b1276419dfb006c8d13b26f5f95bf743a42a193c4043c2a210d8ca86c4d17c890bb4bf9160cb744946cbaf893f665c579cc6e76d321ca0039bcb3aa091be6f5bd696d3d736d7675ff208f6e0ea9ae1fdad6611bb24ecdbd023ef8b98d282f26a5722205083110af5c0f94fb035621d1c0602fc3230bd2515e4d9e45c6f41e5ca31f9036488f3d1b48bc446ae1eba1b71dcb4245fc43bcc3e21dca7258c917c9717065d4b6f9815ba016f2d47ba9223606fb27c286bba36c04c374896b4d65186e85cb8a62bdaf54e5116ad8f9a6dc761d230ab35f37780784babac6a75a6bc3f7d0112cf0a3193917441bc7761830bd49f4be2af4b1ca350a8ab4b2bbc8a556455244b046234e2905b62764ce84ae7384cafb7c9ccc00ac980c1dfb2fdda22769a8832e78564019972bdbed38ac82bc691ac00c0b7634c69f3119228722726824feca4818b7b7dc4b5bbeda0dbdbb0777692f97cdbba547966ab9a6e8751b44d9a1126a999af568603b92e362183b83d495d70792043f421db4c5ba262264b3b3f23c5786b2e005337f72a5e875ed737d36b4521beeddc7d1bedf39b924db64f3b6ba2fe48dd6f73153e970e01bf87c5b523b02808752b3821e9fc482b76d78dbd9325da9fc87785b3521d7aeae15b13cfdf23e87ca639d76ac5135c270860f6a055469dc810f70faa4aaf48c7f5a8a27bb2d55d8c67b663ce0bcfef13d3e1cd652346e29d60231d5e2d9db9053db52611fb5d6fbd8575083b039930c7084d93e361de90df4b40f8d8e9881ad795f9e1991fbf4b305bd2ee580b40f57da9d5da78d940bb20b45f6acff0aeec98b1c23455472598d323962ba53794c1da4192ee934646165e7497ba3bc46bfba048ba70adb6c6834986a1bd3150f7a573915b899277da26874ecc9904c608ea87ba4a08d79c51e6a6255d39c5d54cf5c778b5268556ad52ed466f6badaa2c96259efefc8d68036b943cf8858c382e98c788108162610d8e3d0aefaffc692170916582ef29cf0f3d4d798174d480aeede83a956a3ea8c76d6fba9f079ff2618d136ce5b13b5dd5749ba5f4d60cda9b1de9d155e553cb8c231f4757e92bafbbe97e6ff42677bbab25480af2e9d17db7970acaa1ac6382d01ac4909274e1e6d993db5d7382b12d661ea5d1e6e6505ceb0cd32778e4a3f8c3008e9b68aa4644be9da53c8523280455a7e3ad2b6f4eb7624e8d59f3891942dd9cbb8a28d62449614bcbf96aba7e5868a51433ab747544ae0a3e12540a350987df068fbe85772bd53e1fcf607289a325cd9a6b0666b6acaa2c2405c83c77add0e4d716414675a7a0752ab74a34b6a7028117599fe06104bc8e31ad862f4b9339b187a6fab150bafbf88cf0bea088dd8fe54c64179e9ad4d065e102adf67bba5005c40efaddeb85d76a3ea46ef1d90b910979441e84b0a9b5fd34799de30983c22117a562a5b85bda8ea765fd786878250ae165ccb3939d88542289a482295c600a16a551f97ec1f09caa91ac48e4fd7810547fa8b195d128c61f340be7097d9c7abab2c3eab689189cd9a1d557f699e443de098fea5d1c3f8aa37e6c2fbaddc7c4b183405caef0fb43fa3ef5be5b81ae23c1c49a20be4eef3c1aecffe987c572e014f933792a795849840af958f662e84156f8d8903d1cd51a3e1846c6dd1b0c6e9da2b2d42d07fc8d6f58c2d3d8045a510857fa193efa3685ef67bf1ac392733bc1167593c0f88e04bb05a0d9773dd75c48678facba07bc9a1954594a3c94b4554cde3bfca92759df6d15d40292e9dffcbb1bc57a3bc08dbb906b9410afc69fd472de72280f54d693004cf273671b329037d8eb3d340a722a9d7bbebcfa9ee43c51f1572db25d321b3bbc5c8176d3ff4b1de9c06248c39f491fa74bd5e777e460c24ca62f12dfdf158651cbfcd82524cab90f782f43bcb2cdc8f69abb952cfc115f7d725d5524d276954361294b1696e3adeb40879fdc027062968f3f197f29288c5bc837438bcf844dc8ef1df14e9b26ce090a951a4ef9ab9da70d2f52c221b77a72454574d38b0934e7c1b582f22cecd73cec51126801702c6bc8c6b649888915e59d1558010c2b01a1e88aef855e1ed8cce09b9ba5cd3e30aa9e58e3679da636725a21f4b7d78e9c61084098463dce95c4e9d6e4f14abf00555e78052e95291fbe78195c7088d4d1039e69746592f46862759845651c9e05c59815cfcda391658460a2902bc69beb82e78a8c25165aec842a35d788a1bffd687e65a3b673996bd8824ba7cad8093089c382defb626c8482d169ff8e8d0a8fe11f69ad2a1539b7b3cbfa705cf931f2c1f1a5b9cea3781ecd9207a11317640d6e8956afabcd80cd9c26e0884d34af7db0ca12a19d392347a02ee4ad6d421849401d0852bdebf024342b5085e7bce12d6e8ea8fbd17d54d086d2c93b569524c350040daf5da00f860d8974309a1e6c93b663cef5958ba1debfec284aeaa7368d68758a84113d9311a63dd67947ad0258a825653f849d3eec981f3e431563bf9440ccd51baff59f402ed2a916122d810bdf3118f34a655a99e196bd135f02ccee90f7b1ddab98f9fb8cb95e397dd013b882f144efaa016c9dfcf75342bb03cb5496fb57c5ad3fc5316e83d50b3077b2f31d79c3c9f1d1b0896a9652f1e55ea1f7ce0ede52e1c45617e25b5bae063e5c2d64a32c5015525046862a47ca1a41666021d558825628e804354ae7bb66e21cb4f424c127a83367d9941f51fa1d3ee76e0dada641a46468e7351e4163c227eab402ecbc3058b8f44d6bb5a9b0983f8ab8eb55a64295c4be12fe7475f41e32dc25f4a7cc9989600277646dd5b5d34cd00643cb758c908013a5c8316aacd5c7faddc05b1c35e37448ec381a1f29569b69d150d8c71a19647230a21b10f6f1bdf6971b48f8b397565eb4c18b848e76d65fc29fa0700396e553410e932aa5ec46ea3e6734b8e93178b8126d548964b1ccbe4e8ecb51fd94172cae6f5404803811c92373b32ad8e3e7dccb95d8a080201978404037934346ee89de905d7db94a19520ab10689670c1aee5d95f185f5539d3a48aebd6c4957a25b546234035bd27be699c0473a491b696ef79fb5fc5214fda06c007c13e920cc78241566e4a82295a7462761563970a110ba283ad1146461f6587a4fe142c3968a37624baa4b61ed205908c9a4411d4f232d471e9c1a85ca0be0a7a0fad9305d242522b0e33368bdfb8328c249fb5d6a03abef73f7673b430923deb749aa025f403fdbe2b1662ea9ce9e30fab1fb7e869722c40b4ccf861104c5e87f57ca5cf63242fe8a4dd71b33c0960dff409a4906f2da328222cfe4d723170a1025a77faa1897ea588756fbcfd968e34c144e565c179f306399bdade3a2ac3e3a27b8fba255f822c107251dbb86d6a84a2dc8b93a133228eb7742df0589e4a38f4ff6452d7a74092575c8249ce6fb1e71c5121592b414835d734a41edbbd4fd3adc3477566d2be693654b1b236909b9cb8d8d0d940262752e9706bb03be86241989df6ee5ba60b71427cd0df2841c9276187500c490b950d71943b84e8373a5a316b399bb2c1cf18ae66a44af2e586f51ebf977c0e664f437f1fa93cac5a5a3e094e2e4ff09b6dae173e6dfc87bfe5a1090e07ff97dbb73a1361141e068205d1a99b7f35c17123f19396eeea9d571a83517d45feef66636e1a058fca4c3ef8e699ad0f05be5a3f0d9ca26150e17fd952aab82a3a679f1616e0144161bcb81edb8a3be1b72df6a99a4a87510c7ee8f823511fd2bdc47a036a11e378cc734b7e7a23e1af209c2df0393647a2fd52650dfc2c8216dcbb72ff202716a1edbc2a78a468788fe88fc90b0970b374b216f57f5dbad328f7aea6af950a8c806738e4133f31dc14cb53113b206bc6f64b7bc7e2c48614b1cb2e4db2bd07ef172ad6078b6632bf6c7c33524e5ce211c2bd8aca31ff6b08814d8500f057c1707c86519ce443cae2808fb427f55ff61754fbee0f11ac8aba6728c6b0fd5b0d0e683c30c5c91e3583cf6de51b9d43edcf62de963c978e2b521747a5084dc30ec30866cb50630fe8b8cab29ee5ec2fd810fe17f3a5b4478004dc3c7f7bc35cfae861ac95a37a3d1210cc83a283c864766b4734788e92f282de54a3b2bb329277520a8381a6e014fee6a8c9ac166b95e58edfce619175321a9202fb569fb11478376fb26ab34656617c39d67cd5359daf4c32b10cf88eb133dd683c688ba0735d331cca2093679bfe6a4c974ebbe1a6cb5214bc14f05e81a2b21fd823eb2670cf017119f34a91f08c1e856ebb1f0544a74dc9b3ec2cf60a822c4f0fca5736f0e234411de49496a72d3bdfe2cd1847530313dc8575e0b65377042dc02bb42d7b1d36765ace281291a44a69079bbd91fb68dfd3903c4e2d5dd88d4fd420adc9d33a3306f5be4f4e65902b24cf0e1869ff9f83db42fd6fc9405cf0af63334427e3ffa42b7aebd367e2c0032054dc2a0399c06e43a77ec523d9c4d00dcf67bf6ec4f81f6df1b2610430623d5c2836f70b92d49d38d7bf9535da5d7581e61bbf8c5d61b9c8f91abbc4d48a27c3dbcc495b3b04376db6f97a3bb2cb9a65bf4b6def95800079e9a63f3e824912e29c8bda7e265f0d77fbae73cb5ac8483c511f31cb0bf9f8d839f1567ff05dbbec953ea726087583f65bbde9be144308c7988d647dfa9d7c3344ac060e33a3793978c3ebca4f3c436dd106eb9cbe27228c24796efa12e5f484151287b263d9d1a1225156410e8a343ee7d74ffb2a429c47f8cb76d888a9aff9afbd748fdf12da5b35f6ed3853f9fd2ba182585cf290b6b7e4297f8889733ac7c9d4ce9eb27f5e44736e5110b0db48569a71ff3b348143d45a1dc5771a5365f976453158c69ed3a08c762ec2b545735d994cf3525ebd61759f1ffe916b3152b9129d36232b8b21122608ebbc8c0a81eda140b5fc80bf87552f0e9cb07ff649edeaa0c9a7d9b70ec93eea9f9bce14a4dd5aa1c66a624b584adb96565cfe04117e8cc4cabc54126efa456c70a85987d6dfc80c2fcf52eab7613b0d8acb34983765e0ffe02fe541fedf0ea596734992be23a1991b144c3e0d9bd69e49f4e6314b35cc4fc165fc97ab0f3a85909f0cfcab22f357c1f449ca4434924450bd20f485697922a3cf93625ba03b74d2937eb16cbb5584ecd07f21f5c113428ae3205578c98f8be5dd4f4dece41cdebcf65071b62720bf22dec15383cbe498877d2ee8fc9313bac725af8252be7d76d8e6154e3f44afbe674f2831abf8104491b3e10655788bf0e349807b3242235d31028948330d17f2966b1d937da493b2a52968c6dedae7b337a2893614796ac4255a49f62a7a9f42ef04ef3d8375757023827113d888ffaf8ddd3cf2dcd6a10adc48344e05ea059e1ef619bb6f63724dbcf4825eb94b91b89869494f0bfc749f40fe3917c83bb97fbbdd42d6bd8b7a787b8d06df91f491bc45e1509d50d2c0f5028c4e55c03e6dd37df7c9014198ffa732016ea73840544e6bb9eed1a4c73904afbab6b277145fb47890e8ed9f0458d9064f1032a5c890e45855580f2e77de68f89b3c1172f5b6f66c23b7606e5a852f72f005ef840495c5c25a92efe8f6b06a6de157e0e0ada7c5a78ac42cf613608244e938167eb67e2693e86b863752f085bec372ce32d98e889d03b0561bf330f8c2fae7f263b705862d59c74dcd3bd00430600bcb11ba3975af49469d53f78dcb5a1e3759f1ccc65b90424cbc8b062fbf6d3515eabb70ef9c6b5caffb67926fbe121fceeba207d9d02a519af632599a3c991807f7b5df35217a3ba603965ef3537339ff67bb5bf8fa24bb6fb35e9a5e386d257aff7b09a6b6691a73ce9c3120540db1896fac97afca816e4f62e9f782eafaedec45d1f17547a3b77a4995a6065ddd1f31cd73e425f8615731c1ca2a3c8b5d6d76779490678a201bef74399f7d661ca72ca0e6213b0b568a119da626560f1272790bdcb0388f913d456c6c2b6e8e36c9708f85e6253fda43c9826671a1e2d4ce7d213534623bbe60d811e2d00653567984a9ef8734630ba0922a98e0ead25053d17d50ee4a98eecc8a65d29940a0612ba124bb6fc5e60bbe089302598b03427d5c449ae6c718f3f41eeaf7fada2ed4f195dfe1b4bfdc679b2459462357ee037cb0c228898da6d5ed4018bf4af87252ad7f5b994be748811cd6736ab447cd885f2cf62c53201c53d2ba10f11b0100965de7f0966b8fbcf032128cf0d7861e95f89989f76dd2e8a5ae1df9d52e0d55fae718067097dde2fb59130115f542780ac3747542121d15518d081d582c1e8d72ce6ddbb3f17f51055cf3006baf406ade6db373ee12d01dcdd19b07727e25d2f9895c7b1e0de8df5f8d321fb7a19b2c1eeaee3dea334dbfb626b1c465c4ff4b852071a6bde3804a7f547237a190dbe9c1cb757c2e7975030be3fb9d4f3e487bd64640fe83e6345efd4abc6b91df67787a7c7ee51e459f5f2bca5ee1d257d6703d8344e6d2b080e5b0b7863a7f5ebbd71a486cbc115821a6a95ae1bd42a6343a0be38728164bcb20fa2b7d311db9a5a6d04b80a4743bcff13749b335eae512d86d84c3f5cd87a9fa66ecb55e682f641091111e42477cae9720c266b152007ce566f36ee85c1cafe5be58264500aa491686a1dbadc3e253e350a9e57457c3d429bb85c9ee32720a3039121afcc52924d26a9bb2152bf43d0cb5dda52c4af682e7237a7c67f14a22296a6da6975639a4b1ac04356aed4e928a5f05060816b7cfa121e244938c5fb3c5dcb620181731fab9c5fec4fc5533d4139097f775eb29aeb6a2f8ed7587c8a02c8846ab1f3736b27d5b5d20f84a5883afb8695553246cc6e61b3580b823cccaebd7486368f1517421cf7ee8e7dc1f91e2ce1f6a10076dbdb07ea010964e571e4cb7df4cdac827d6d6bd8feb81247eb86a0418ffe65b410d6045cf783f0804c9331c2d55271438ea6a2d42e7902b2f36f884ba3d1e2af900cc34bbc37fff2fa9bcededdc4248d2229bdb7fb34f5d93c5c06c84e0860d2758f209e2e54e22306bbc08f38d8a8981dc9cf7fac315e2072cb1ae02fc2e0e0071c584b3bc0aaecba9c4ce05240edf3491e8bb5df86ab38a871d9d27d03d7940b913f144c871aaa60d65112a2ebf7910c1b997a232f730c6adef218c8341bbc3baa374f4b830769521af482ed61b0404e9e7c0bae1d1df5e9eebb42d8d3538e06b9711f4aca514b2f5e4010b1c81fa1f602d80f88a67d2379099d59999809d09c39a111f265d262376805fc53b9fadb16d4a351fc2449a1a9c7588088bb086667ad0fdee4262d502bb38386efa0731b93c58d3484dca9d2b599d5b203d22294efd33e3992c7df9f1d0e08030ce5a44dc9d1e2566b164597b5f44211fa3d0d5bc1aa6a1f21c33e0a03030e2e646b1456d4c66329a4486a1b3dfd833d982120fa6b60ff3135a65b010ac39b1b61a87c54ed068c7cf8df8faf5a8258e3d35aebae13276f2e8269964c23e145a26698c7e7aa11bc2cdf6beade7fd5e5cd464cfc3eab6a242f453416ff155fcad70affbb85e8d3b0e321bc858858a397fc94f7cc0816ddb68333962880ba7fcb01ce8e1b80d219028f4d0417b7cbc8f89cc43640d0fff58d7e381ecdb71abc8f6bade560d908bcb0243c089585b72bdf0abe2d7da0f0758701d71efbf1caebbd79a6e9c6979b488574a3438a4f76a4f6bac32cf24b7ad918cec5b6453bad359dcdeadad70bc01e0ee94ecd8aafde6e335ae87322d6de4c1cbfdeaa2a2142c985139365a549dca96613b1645c7a30eb9c6aa0f9c0f42cc7eac6a42bcacf6ba8e21c6658cba7433deac15101489e0c891ae195c5b657288d3b55dd5842ec67e0d1af5f984413fd8891995b7b5ec29cd3758e94fc851d6291e15faf463b2daeb533f5522e23c65c0ee391e1d2bc7993d6639569e2ec268c4817bbbd4e32aacac81025440861ae349eaaf045a3b3237ed2e88eba6064ab7b98719e65a20008d490d884d8d38deba2861f19a74ecb70bc98231503ab032c55e8d51bd44a3f0e7e6f4d6c2e159433578f3bd5deaad31296f037c71fd7d21f0f4df86c1079defdeeb3d6efdaf32ead1960a6356e5802594e7c5e7f17e1e1507580fc7602aecddfec269c5a6de7467cfc1b7a04dddbcdc8c25e90a547b2a1b64a96bea466929c1eef55ef8d3e30f83b80ed3a54a21ecb891391557612b0c8964c416dfd650b055615345103a4284315ff3c6bee40f6880feb8077df8ec9c5da2f34675be79736152cc5f838ba3d6199275492752f37bd7dd52330df90346fd2c9aa6c4a0b3ab5a412679ac23468d4a834d25eee8155a1545d49691c7c174bfbff1aff2c72e430546a2cd3353a31c34a864c64dc0fe26676debc2645aeff9e8f7c8091d43fd67432d74150083eb03c6ab434e6b3db283e90c0a9ee1f9e3e3bef775f22021dc3c71a75e63a3cea067ab115b221b4bf7c2a09d003b7a4e9f7a6cb9b3d53a9950f109644bff99eb5c1a651c6d7696f7fe3608283ea813c49686f2c07d1a0d297f5e08acde8adf28b9db95a10789ed80f43aa3681ed2d3521674f7ed78b1c2d3037823caaa69fa1cb8eb7b77d646dafe53e9d5292805d14a47a8fb827009fa16b1249afd8d4d55c6c45091ff010d2c14f7187c1739bc01ef336924741514f22ad31a564b71d299e7968b87799591a5317229f2c4fe08ff843a0d01b15157b896c52ea389f76840bc81f7841b0305ed786a50745a5558e8621defdae4657621df64650a35eba0f53f961adbea2b1f647c41a7f1ed7398d11ab72801197cd185932759a0710ccfa093cd199be1bda8dd895d908ed1bd4bf8b042668bd5e6fc85ddb8e0c7ef0172c903124afeb334b6e5a8838c380b16f9093dc25df087cc334a02653d96b36b5f119768fbf16711795943a4d531ae609f1f4727c04f89e7dd076ec0c58210b6a42e322efddff9a7c44aae15fd72bcdab25b55b5b14f04f2c61dec963b558529d54ffb73fc78a6b4d44e248ecaf18455fb321d5ec35a8a046d0af82a260a889ebea0a4ab1e25787fb632be904b33f299a754721d4ab862ed59cb376144fcb3fcb39697932a5a8bdb7ac9e3ae7731093233c64025653891e32dcba9d63b795d18a77bde13dba2967e40bb5674e00f387affb28314f5ca18039e221ec4d2d88a1c51b7815dad5ef637528d87afa9481e49acde1b2cc83a9902b7aab9ff76ea9967f0e8f5a548ff53643adf9f6a23dd520332bfd55d4cfe6d3aab9f27f3a3665fc087f587fd8e2a176e5bc9f18892e7d4ed1a62a39d8db1fbf20fd16313e0b2c4c84a55783b9dc2b4e67018d266d2cf2c42468e7a0a10bfb87e5abcee79b74662fa24339833febea451cf99a27df28c11faf1b778cc5587736b3604185e90ad09927bbc9c0a167bb87ca83ed737aec131deac958522b987965d47eb213f94aeb159d9f2938afcd5c9cab243f65e351b4175b396eec29b62f0fa4a742b32f67eaf2f51f6bb4e4022eecadb0812685ac050e0f9fd76283559330ced181d72593c39f601d08b385f76f4f6549124b21020a498bdff059f23a04dbbf5d73eef74111a1dc7fefa780b4f3bd04806aec39d9320043ca8769c2e6a9eee6f9dfc4522b8f5d4af2772395b59c021c83ebdc71c4df0c65ff1159abbb2d5a5668c252b62382b44bc82e416f28dcc51276965bd938007c00a01dff7bc7f2dc61ff27b8cb841a0c7a53c0715c7058f02e843416dce616d93d28f493f556c8f47cdaab4b38e5593045c7d1e44a43b33c7a9ab309d8e3487ea4222d9461dfa9d76d8e4c1e8cc60c67a27f075b0e853c784dd52ddc04984897b7e50b68e5be11abc2d66c625667b41959465317af3abe817bb5f00eab545fcc2b000d62dd1a71c135bafc309f2d1fbada8135366cfb0529f130e7cf11840a7b1ff4583ab2cc6a3d6d08ca7c75db5c6f3fb6b7dc17ed821aa0573befbd22a22da4864134d1359627cdde71ec1e900b5d41e4d58d44a1cff34bf4291f521f9a92b2968f885601095235534e93eb288a5223a1ee9debf81bdbb7caa9aa97ce9ae3e3c5f866f88932f772a4ef4aaab45503a5d6ac137782adb434d3c6b17e854f6b239889e20cdd5a3672d5c91d1776e737308bb04c78ac92a39295de2c2f1ea72581910d856dfdec016e75844164fa9f472188aebce1d1d4884ef1a873ce4f2b15c07902ecc72565581712b7c111a74f43b5df47a29b02c364fc6fd2f78c621c81b438dccac0ca75d7bc1df762b100d98ebd701b0d3c52e4d62e682c67183dbc2e6dd4ffc608fca5d27f2728bf3bd81679793a4b4371a8ea6fb5f573d86c11a5daa7271bb73455843ca84163c5ee6141dacb532f8d97604518fbf7a25932e3defafb73308e30f30447482877b9c00fd73f2c46f58d764706e00b4fc0564c8aba4bd97248c401184eb030eb98b31db0fb03bf6ff8a9902316830002c466158c6492968fc8e62c05b14493ea321f135ddaafdfff13730f7600d828c726234fd07ae06f88261d50b4f334255c63e7a3413d2b1f21470249d3c3f9eb5a349e665dae445bb1c988fe26c093d2c2719c03b99c287d3c719be20b7aa1e9876879e2168c1ca2f305480458116ae9b8896a997a249dbbf6a62e2f83d57f9c9a7d14627b60acf952b0c708f8e3526ed210103653447f3ad927e7b4ef9c14fde3f52ff65259dcfcb9892205c1c6f2599d7069f20adb95fbf34d330dee98428ef8af6df2619a9cd8f72bf0b8380024d4a550e5b0677f085bc16141c9a5250d69163b87769403ef5ef864261cade383e3d8c048fd945413c42db9b861bc7ccf478f0c45306725d3ef1fb80c022d70fb475725cc00c206f4a64ce7cd535a6c3a9ed14d51eb2b5527cee37f5cfe0d56c5e401b94d109a3b6014c94b1531fdbd36290e19f68e5f0b30f26d45f6b4dfd3452c3e2f85802d129a30cb10fcc0569bd806036270f91e2a888e3a80f1d9bda9f065558a9a1b9c954e3a94f5db2e6e55651fc09971757a9ac56141f0af80e216022793395cfaf3675c9fb22170254a0cfc0d5e3966cdcaeb7ced449b17e8706f9761f495a472cd2c3ee8f999dbd2c2dbc0d21a475d3402ff1c5d34bd8bddb6c241b15904f29d4c8e2120a4acf4af45c9a3abf0aafe3914372c55905e388d13c5be45c59a6ca5b2641d0ec3b767dd1c19fb47e0eedef5e104d48c49572a2b1ceaef466c4cadf692223429c0b1cbd1e868ed8a7c8322b933c02294906cd39062fd4578e416f5b3451c24768b36bfb6d4b4d923c95e1a277a641a3da31881381f855154804ef82ad45120f2dd7f0865d35447836a4ad19788d3bb7f0d35eea69bfebbe5e94a8c1c0c2a03a6bbaeb9942af9c7c095bd86a8df6366abd3ab262015dedf584793090391e5337c1dacfa1454d821311c08dc47f234d979a112c401c7fc12c5f9a9f91551931721cbc32c06fe44d7905d4d242223605618405d724ea36dd9360d3b06dd4420cd5bb3abe50424a3a9abe19dc7c59ca48658cc8b9411d93df7c6b88b17d467218d677e66f74f0ceceae38e90471c8ff66d1a4635a4b65c5ab3cacdd525dac80a4e8e2725056d8e43f81155846b1f363d8b3c68b544e8284a27a73edc07b064b294a6eddfea6fb13b3a6d940616a6238845f00dc93ec8afdaf52cd93acae7e3a970f03cc7aeb3bf061513b42801777f170fa21a014eb7a8c4b3c33789499b12b66f48eb3c9c772fdd3673d64f9580f10d05f53a79cf12aa69aefb3d688948f1fcec9761a808a906583c4f4af4342dadcb57c70e4559d9f4b000c6906d3800dc53434caea57805e4ac6f5d068779ad2415fe89b510b1767d17abcff1cee5806ef70be7f506ec8f64624acb90a0c61ac0a3669f057adf77a851c24c10701d0d0b1d05794a8b3c403db0279b50ece8ac448aece0f6ad7b1f041ffa9ed847651c6d2238f9aefb94e115d5ec547a3e1b341ae06233d949c352b4451fbb2ec589b096fb5dd14a97517e3ca771345b6783c6e900b3857e1774a245a6a74f4ad6f704ed8e2ff6fafd38fdaafe4ec4da78d40b1cfabd27bec93e358b0227257de68eed929b5f9cb8d4119f26acbc37c5d0419686e3037a1be3fd2efd12523a51e7ea193da6b318e9a362c7f236674ff580b0ef2cbf87e7dafd17b182ec1fb44e2b5ba5b4a2a7bf9752bd26d4236a0f23309d55e96c7b2cca4d7c8f2eec1dfcba95ed71043a635b4366a6adc745bbe6a14b1316abf051a7fad87a7faeec4ab8c1a6e2cbd6d26330465e7c2ba783296e53df7230f5b17856e45e3c8eb3af530f2feba83815791e4df276a1e6acddcbc8d33c43f2f481bfd56f75fd9ece99fd2899a215d85c37c20df8efdcae7f6a80f3ce2a3e26ceb7ecfecfd93f6d98c600adb4d9c85a4cc677cd7a8bb516ea0298491174c94867b9d68879b96fc6b9d818058fee8efb1fe602d26dde70d76265d5c7979482ee81372eb07c338c492e8bf5dbc5323a39d081195aa63a31d2c3ba6ed40566822227859fc521abfe8027d3443e3c146a78b7b5e12b736553ad67a7dc68404d1ea2b505b40da73e51341ff76b9da48e23c8b195d035c896b04b65681ac1bd41e14ea8bb8a851bcffb77a86f854dfa46cb831f2aaf394304d9e77ee81b724220e0b833719d000055d335ebef27ba85ab0c88e76b5fa98e9898c207cc276edddc877b0342d2e0498f6b69214836e040059f972192f0356cfcc048d1e2a94d45a566e154e290193275c3dbc0851d3b95b61538d20ba9278a38dff15b2de2c3b56f3fd11175b5607fa72fdc523e2ddbeab753afff48b3643f1395a9236fa22b8f320c9a38e917e9c9d21b915dfe26b71d77030af550e3f55dcd76d73f18565268894c5d27d08375e11c9eef4a474f45ebad359612ac6752ad6c0cd380c7c00dea71c1793ae9d5b8b904a84f1b93fe95a607f76d0ecca329320b57244ab9140a0e05b026df301ea17b98dfd89708d79b52c712747bf55145db9b49eadbb816c09ccc890998a773b6060e8eb30c4443753f0bd9fdae04078b5236b42e360538f662920e9fb7f61f97cc06b690cb6971aba38636fc6d055cae2b32d118e9d87c7fdbfc086a4028b2102e0fb6562eca7bc080f332e5f634f2e04505a5d776a49e2cddacbe5970d9ab5546c26726bc1e09f103b18b6c8c2333bb2e532bd636499d40b8af986495beb3875012c3ccae266e525c6138dfda96ac8e54605ca09fd6fd848587b527b2ea328cdb86714e847e88eadb265b81f676f45c7418d40d4836cfbb819d472c91de00ed682f2b5ca9349fe511cd42b9d0fbfd742ebd6fb7b9ddbd4c8a5d5e3a9c95fb69b8e152d62be0f905f4eec45be2e7842257c81793bd05c5a3f0c7824dcd413f9e45581bab4e25ae13dab4a273e171d583c02efa114c4114e69d0badf8d52cd5177def4484c6172c679cfb2a1b96b147fd06c663fec5d80355ff65171e337e813a06ff9fc12171e43d2ea461617c58065120feb7a4bb5e25b964b6c9a5970e878327a552673b3cb1f011eda95e1acab1a2369b7c8f49d39d813b617c2ec045fbfca8d4eab43a6dc5e6976ec06f6ba45ebbda41d86c20c8a2d320fc8c697242b702f965aa284652ab2cb03c8ed80d5fa432cc6666dc9b7d30b5fe906c01b47f2e2a155b4b94e8c97038de398c4b86b489eee78982d8acce5955d1a112edc484410df6c98f6d3600da828ad72172d21bca0febb98f4d00ee678046af9e1c48b1a2f58ddad6c5f6ee55cca1e6be60fa5028f199f976e35be8924661b00a47d4a2a3bea19d6958baf627a4a18649eb5f67d4ba391436315e45c5c1132ebd394ac41643209aa3556afc77897d4c737021f9fa0c9da47fde06fd60a6d85daea9fe8a132b4be26cb3a582200debfb95f07bd9b9ffd9303c01a3d2e51d40cd61f58b0fa21298a3bccea440abe45c43c6a01f65d6f1ffe47c62a38e3e90f1fccebd244525fdcfc647b8ae68fa28a3214199059b959cf2640e5f1ad721c07d4744c214f70e4873b9cae2fd3e394de92a627c6338182995daa527a315ac8f13e6acc62af64177f6b110de387e54d6fc3710b62a9cf41e4d247d89503b7d722879ebb057ec41c213f6b16789623d46f0e3c74fdb9d7ae0cb7136ad8963aac58f9519eee1b09def14457bb4cdb2d3b91300001ed4150b1056d3d9a35dcfe444ecc294eddd7613e3d08e65e9086b420ec720664fa2ec3ac203beb18261439b0bb2cd329ad6d354f5949b3cdbc4ff7b3bb384e5da57b3f8f2012ab0a61defbd5406ca0e34e30a57b425ec0bde00fd666c42b9bc48268ee39a185c6e262d7fe3ac11aa657dbf7b3d7b6087ef043ce47d651c7073004d39f8558ab054e42f5216cc45990fa2f003c4f7650471844b25933cf0590ce6f7798319ea035a876e4bdaf7863e0853202fef6f0356fc775240d6324b34caebcdccad9f4d35e3adf6d2b7e8f04f2cf10e34ce0ef7b3fb4f92d096feb27dcdc6c2fbec94a23b3a1ba8dc5e3f69957ed2bcce07276922a2e046ada2515899d8b9189d33ff293ef7d32aa3b76a59afeba23f6f336c91e90374e6c581c3e43066937007695b61f237d7e32e6b3a6a90c20651078aecedd7718f48e075f8100629d77d57a39670de9f39785c02d2941663e44208e08276872ceef51158b59eab71d67733174c06ae4bf6051f5c85d4f1b67c9a296b4b01adde0cb352ac445c10542c56695f16b53f528ffc12f755eed1bfb5d5d20bdf5b75d169501483970c35370833b8d54caec933a58e446ae087f686103a62e540f27eaefec596b5eb4df577d58d2f36735ae37967cb858ac7f2f5d5c4002e80376180211324b4532fd03de4a086c80da041f20e971a212334c5d8f79dd280d5b12319cee891c0e0d660d843a386bbb654302b7f2af9ac648bbc24d05c1400629636ce476a7548e9a0136d837fc36f187572e57fe1815258e882590b1b83a8ebf281fe65603ceeeaca37f5ecdb42d881c1a2dbb51d98868b92146f9309bc84a376c7861990de0b4ed705e264feb9ba31b61f1a194a4cdca5188c48a1833e7eacb55217e8c0aeb6c3924905bb3e893a6f6d212a0ae5a20dc2b1afc6652afaa22140b5c5c8644479382be88273b4425ca1ad6ac60144a8733a90e871e8689e0984b6a7a9726ce9a8ba65a71a397f30769a8dd7405a544b5a04f70a64d4215c5a11db22a463fdef243391e428c81198c6d5b908f7bb51621da81eb0646278024a252a5a823bc834e5ebdb8f8dc6a47898b499ddc6980d0db3c9802c4f192f68e35c34f1989ed7a1584ef3aa043b5f8915e02fd81661d2ee05373995103bd77c21427a7fd80dc6c73bd7a84263beb6a040261711588eb4dec7afeaa77e5565788050d45003ef4576a9c47f11f092215fc9b4fd250ce566e086b17a3484b8a5823ed2cee9a7772bbfee28ed5f199a11949cf3f2d3edb1fa9e3aeff26212b09359a071962fdb5742c47abf225692ae76f1031a4b929637ea83a8df1a9a37ea3d238054bb141c98f5de622a8d35390cd543f0b3fa726c50e2058f30e8617b60cddacc8919c8d0360179ad8f70410dd03d643bd6946c909e9385c1fb1a2bac0d46bc99727d18eb5af052d2145fb93870ac9f905c10e2a18cea9ee0d8d9b3c354b24fbe5bc479e326f737165b856d2b914a8d6ce6f422180f404f9626d7832b19e819c03a6542bcf4d5077ebac7be52015d8e3e38b8f3b9e85709bbd211074bbd831827375f9d9cf122cfafd3c321ec467ae4b7124b460fc9219219439767821f71d635643433d28cecdf4f8767eb85d814d48a7e1b6d003141a56723cd72819a97823f904f83dc709b95c55ac66dd21acff390b6e16fa4da0298b7ac6ca74264e2032666c7bd6829b2391ac5efe1c3d9a4300164714d438cb869aadc357fd25cdb2e9d99e0ba0c6b9cb42f778bdd6166360a1f3775e0903fa2a79669073bd40a66e7fbe28dccbd48c81bd2b3c129598d70fb99f4d9ecea6a62c1eece60432aa6836db58fd9ad4d040f6a6ae3eae5b50477421e31778848e40f26bea06a6d3e793448eca31a3f9cc49a2fc2c78451c1bdc683e39be60f38fa56fee8531917e872776a70fc8bb601630d80297a8ef52cc8cf2a91d638c7092695ffd930472d78a7ac04e8948fae3538f9b453b8c3a252abdf559ca2cc53ca6f8df624835d9f3cd58aedbcdfedab6f8a5bbffbabdba66d632919217d9e82d614845bb501b0916dbc8a76d6d8199a2ab8658ee355584cac5b1a3fff38782db46969a8c9c1db126e0e4e388be2873c979e579527489c6cbe9ba800051c792047bb241b1ca961e69fdd37dc6eb16f9d653a65b79d0dc4336b85e5805dbcf5c87456a5a59970fc899e63bb455c967ed37cb3d2f0f8e2d226a5cfc13d6c2e6ceb45ada3e8aa3fd9069b953e800237831a6f43786095ea4b27c8a0b6b740a37d81a0fd33e45a5967e9d4752e12d969c3fdfbcfa5d268b3dba74bf4aac417b224d7a05396aa2b09fe7b77aedfdcea5333ebd3a974741d2a096c4abe4e804df9b68dce94e0e8341557ae94e70cd826118b87d3cc301f684afc58d9d8056ec9f2fdcfb44c08d2294b351b3c46cdf106ba01d0f1200e887c33a517ac99072e9fe6837067feeb99909926a7949336ee05166000e68050ceb1654a1b8a0266768c1d497781ef17a06ad1e740f63fb23bbfad3a8523d70a153bd2da6ef7f77db3134ef62242d7a28e4cbd1e79b68dde2961db84ff2e4479c4a37d121551d2c09b397c05fabf1b1948bba92e6b0eee33779e6bcb22310a993ba72013a98aa8f8b947d69e111914d3e6ce6747114fd2cf7db1ca420bc7f4ac6ad0315c1963536c5057864b091716f4c10a830a9fed1d09265686836975ede8a9002fab9df8e9935424b4c5ee5437d1b95b92930ff4dc1ed10ccaa929f3a253ef58d5fd638ada05035de6c2c7bfb9bde849d8269883774c7d590707f28c4c8a60a8a9e4663bb334c338be3fdbb79875f6c39dde7f32208a08668fcb5a34b79fda886345e2770795056fb5b0fef6cfea7b80f496895bbb5672663606d0722b29c4db92aac0ccd72b87be38e26af00f9de66ca4d6a729d0a7b9cb194189b2fc60873d08ed26f1c275585572db5439321474abcfcc813448ad6464d420b22f265852f7085c278b22314f63113907ca14275b22b4ccb59334ef8e3e914940f8674b737f6533063a6bbf44e6421a03ec10ce4f99bedddb9e0247ec6fc1ddb35a86e67da7cc02c665fd2b83e7c5089b0306125ce35ad6f0a21c136b0004c5a30c0adeb7500303919e63be66cc31c672b6410607944209e3f5b1a919dcf78df600ba21f89cd185978b55940ca52eb4543ef3b9cd604ab4b84d48c878b8fdfbd9d41182908e6b9d069517acc757cbd097f7d3fec4476d9b610c480aeed587fc52f22c140e514d4540262a4c8a60f4805a7b57100b4963f5a7bf04520da97dd6782fb5f86dfcc4fae1418e8f8dfda0c9c7092b086a6280b1bf0cb1b50656644e309686c556bc14ee9c7f39ec86b3993f394c1e4ad42a210aea6f74795d819f3a301718427bd9f4786b2ab583994d7a1d0fd47b56e4ff580e02cdd5713b2c8d0809e5e3c37f6206135695c357e50753aa5dbe611b7c8337f9aea9d774794f05c4226a4ecac4020bc2b8aa37afd38e7987c6ec9e91ed69fd67e48c52466b7703bb7a53660ffb788f5200d5b9fca044eac617e313cb031ebe8641e50b84b23a8bdcf902480496f676e4b06807ad623289b2dcbd34a046ae503151f2a6f548dfc8d1733e982b5412864412b43a72d87023b061baf0d73c97e4ffcc68e508bbe983523f7a1998b89190736e3ce7158e88ea426b01f70b71272880c418c9f96108a716ac4f762632e8e5efce34d8ddd7e639174eb19bb3f850eaa5d9a36ad291826919bb510d37a4f8e8b8f1247e2437071bcb99e43513e7353dafb18278037ed7fc2e4dc7e5b026318f0da190aae827dfc83a1795c23027a0a9b5b29b4d7a09bd4d3054c7dae1e35477be7f31d3e01d67516ab27177fcc2b735ac6f7cc1f49df5616d86436ff659b9407e4713759b0b2983c6ab73b1c0ee59afcc011f7817144d54714aaf495eca706053ece32a08af41d8b94ceed195da2658eb9eafe815272e658deada968c88c5d3927cfcd8dd2dde388ef50e1a6da71caf46e8bff59b9aef5e90d4fc6d054afd734adeffece937a3ec0b5a968a5f2eac540e04838ad638c01a576d13ed60cd050d328d01dd033f4c54e1134d232d9665cb8f570fa9a2d38dd8566ee226074a7922b097e3a2aa7c53e8c51894023dbac3856fcd29a77d5fa2a24f57409c4e4f04f62eba26d04673906043413729e98f54be886bb580bbe8b58500e21e3159766aaa07938a6a37db73a684717b0174cd7ad1d98c81d1e0f6bca169510b1f7ed53bbf48608e646e930a74274fecbf0b7051bbc0fb23393d1737ab0de1d55c9a97e25a7b8f1920061498e516f7879e9a2855c4f848d230b2b1ff0342e01e3a6</script>
  <div class="hbe hbe-content">
    <div class="hbe hbe-input hbe-input-default">
      <input class="hbe hbe-input-field hbe-input-field-default" type="password" id="hbePass">
      <label class="hbe hbe-input-label hbe-input-label-default" for="hbePass">
        <span class="hbe hbe-input-label-content hbe-input-label-content-default">Hey, password is required here.</span>
      </label>
    </div>
  </div>
</div>
<script data-pjax src="/lib/hbe.js"></script><link href="/css/hbe.style.css" rel="stylesheet" type="text/css">]]></content>
  </entry>
  <entry>
    <title>2022.10.17 - 2022.10.21</title>
    <url>/2022/10/17/week-8/</url>
    <content><![CDATA[<div class="hbe hbe-container" id="hexo-blog-encrypt" data-wpm="Oh, this is an invalid password. Check and try again, please." data-whm="OOPS, these decrypted content may changed, but you can still have a look.">
  <script id="hbeData" type="hbeData" data-hmacdigest="5646b3149d0e0e08c583940843e18be81d671f04726147b176e6e4e19d4e760c">a99f2d1cd7f89812758242c57c62a59fe859e32cc19116fcceb1abacce500da0960986acd07eddb3568f524414b51fee17e4d6bd35088912fa4af175c2bf91d76c22a22fd06e9569d37952749a7f1bc51760e0406bf7bb302dde7f51ec702a9af2a779a938fec7c2efb68e32772dff83d15644818397a15f08f742eb4d464f65bbb92eea548df1670dbbfecca4c5f41b707e7be6b1e15d9ad00742a0e7b4ac150bc52bf786e8a5a6334fc66d5c5f236ba0ad41da7272a46ba3aace27774722e163acbc7bdb469e2408cceacadd53be2c55fd566edbd0e462463e1f50a7e588617163fcc6d5a81210a0917e494957dcf200c568cf0ca3ca27a7cc49469c9b61358382fec7ebe61454752960baa625e8f6e89ad466ad1ee53e4afe51b8901741430b0332b28caceb5971b89845c9bb8c5e3b973ae3e603eb346628ebead55b659fefd749a8a710ae72ade98789b4b92d5395d042594b9689ee732a0d18720b1630b33703f712a08d95477480b12e7687ba8d759a53f9dfe63e5f443122ea09f3c24b17bc0ec6557f1491ea0aff49921bb343faf9b4fb3c771afdd84bce429ab8bc1d0a0272cb9cd85154b0b4e9f0dc0fa87f954e2b089969d3bc138da9886d31baba024be0fefcff94956c2c8b635567a793b1ca2accacc9e41b7b56f97a18ff3a3e85491cc4a720e20ee62a8ce8602f5b70d4c3a6c696b45f729d9182292e223972b8d5ba0b510a96429505c533ba72fc808fe6808bb54f7a6d9b1645144cdeb585274c268ca581689c8a43f7999e3eae3f726c21636d2fc5aa82805e1a54efb174d2f52ad42e0f15b753ec28c2e5e063f94c176dfff095f81d9e6bb21e53abd779640db86570f48f4aa0a1f00ff7ae1bf22608cb38900c0088dda95819d2b2e0ac67724e94ba5271502ba138b793c100d57c52f2f1b9417dd4cc60061f7375c52c5bf89f23e6e6e51d3dd4d4e560936a9b5727a5c74168719b63fd4a9e984d091b9b84d0d068b0596c61595ae2fed157318ef7575c020ffbec0787e5a97799be20c8579701c1050c81ac4c3e1eaa84e46f09b087665a1d12bd218bc2ccb611180ef8ab2fb965a656383e7ca71b4deb66b87cd4f4324c6f808019f6db7fba619022385116ff80666fd39afb4c796e9d1e220c564ed445413a4b8d33485d41d08e6f9f141bd58ad354471b39f33ea97f88f7f3303a15c21b9d0ea91c425aae9aab7340ed0bf0d4edc901a589ae19932a7b6dfeb50b270376e3e7253d428985b719c3eb0219a5e9b751e2a291e9d2c4f7a2839b0746bf2c65d62ca4116b358d0380f15b7b09b0bf5c549298fe8d33a71a55a4202315147ed1b40d3815bcd5068601b1b8bb416025b398b267eb76ba8c52796363fce2c63619e97dfe4efa4ec8ee447d3cd58811a3c83cf5e90a3dde4be8593bd52d2e6c164b81b7035f687cc1018248acb8639c37630f096bea31695093f91668e2fd3a7c4adbc54ca9b7e94b21a317dcbcbdd92b27c7b1419214819a3660ba7be7763dfb3c1af32490a786956741a6714b77b37effd018e3af1c762b106b87668a9fb69f83310871655770d3ac4413c97aec624997d97b8c555d1fc0663644f8b11bd6f280f9658534e5a686c5f8473388d207237029d28cd8ea64305c135f98fb9f1a5fa7e58966d31f88cfcb1bf43c54ce0a827c21d2a251edc9439e914490c9358f3323b88b24a35a36e9662a7ca722ec70e3ed3f145af9d9db38cc2d982116af146383d84cfc0c4cec10032778b6623826f9e5a4b4900e509fad6c984f4cad2936c6c08013e426c9153db8dc6bb7ff8d1971a436c95fa614619ec460303d24d2e98a59d24eee2ae195646444d482bd312c9864a706e173773e0457b47bb684c897718b41e69dbb5ce9fe141c9317a0a280ff87b3bc21dc9d855538883208c9b09363a51a49cf57b573c7f0fc96786926b565f5f1c507ce0718debe392ca81ba412029cf045f843faafcaad166d135f6a7b0d9c6af5226401e998fd3b0053ef4ab14a8ac591684156cda44610066af34a84d4ef9c8f8f1e9ba0c5c82a5b43d1a37e9652d44df40c23b745e6764b38a2ab2b47b816d5479faee193a423edd9043b159794dc35517007dfb122333637478aedd67c15501011398d3056d21c3ba3415845edba98b9444dd1634b8c73c574f9ea8a7c51d5d071e73b7916bd514c5326b3e9a2217b007154275b9f44f95f950e87695043014ae5a0c557dc06d5f33d39e5aecdeb4038125be0171aa066be6a8fb809c69763a73cff145213993059446e0f32fa032703fa7adf371ba9e90fb11f486e81a86c9bd38c89264a34362b2cc5e93b0886b6584e937ccafd2adc09af2d257fdfef270c958d141b91a1b7b4472ca3032a3a797e1f66b52cf593c3f34abceb4cc2ff8fb3eda22890839080814722c6e53705f2d1fa6bef66665017a414df472d6ed2b645f54418946842b12f28cc6bf3834b18490d5ea6fb6ba922e089ea37ab02e7dd3d2f0bc9a692708fea8aebaa19c88d6cfe2b1503da70f76b170f92b0f9079fc43c7196ab755f6e568fd8ed41176e2614e05dd28181d53e4db8de91c84a872459e5129f06b64c6dd3867010cb14bbec6ac12efa5bfe9d91e27a0421802bc0f4e23626e7100ac9ea44383f6b3e972fc9d5b5cbfef853044b1f75e4cbc57934d323fbabf2a234b5a89907b2f7efa3121ac33f0399143b03a3b6f3f2d9463d4b20cb1e2a57f8b639d2d549a13e3ae306faf54468f30430d56aa1d5603ef88e3c4316bb03eacf6af4b2c0e9786d86dd54b433113320cbba6eb549338bd22c0ae5e292026de73be30aa2666838ddd0a805c34f6c111b0cd1ddb1ef49945755bdd807f989ec7df2df21efe1371204bc137fa0468bb44d36ff0faec9695b9369ecd5cd8fe7ab55928d0eb85fd4c31c1a2291defda2c2510d2d8494bf7ce7ecb077ea4415443d42da56866cf2abdb7ab1a79e9094e6c2243533a8ee1fe38dd34814e0eb843569892b3582d66b0a47310b0c57cfed08b8a621667c4ff267f306344cc661994b4bdfb8b72519eb64f4d8643661065f14e5b5e0975d0684caca08cc3510d7f2820ba6803047fbcec3b6904d98cab5ae4ae87b7a7993be5a04c525c0c08d864345827f64a77796ee92d62bbcb858e662bd52bbdc4153605daf5504a2592b458e9c7f97e512539e40a6b3a672a15faeb816347c156f98b1df0a4fdff73a8b4b6547efaca649ad363f98693ef0f1303e0f30e0fbe86efa0244bc241ad7c86d1756b87c16b6f37a33ba668bd5e946b6c763bd6be62ec6d8e8ee135820463257bb60640158dccb7a72a5c960e54a38a92ff089a0102868fcdd997837e89e5b02162101328e82ee15abf4cf2cf901a5e8d9bd67d0eef9b77c19584557e80232ec48bf3428250f74bceb49563580312797b923fb07b137cb4eec3b88901f803dc8e76ee0656ce2ec653a06668be6cc2a24591c0a71c3ada40f05421f8938f4f10ed4891031f674545a1260da83be53e13b24797af7ed03c5cc84f2f01d4d727b25bcfd5ddea4adb21aae221eb48fc63a12208d477ad1b4f43f6635ea392426fe79c62e06bbb95f1c55b2138150b6abbe4143e9a6c8727af9a6d206458bc6df476ad1bdeb05054515bbe39c604ed76bf5cc40eb817d5d52197181a79400c9f5806ad837b062f70258b20d6cf270f4f66752703c4193582286b68603989e4b2e6790d919609c4f000ddea9c407dad6f17ff9ecf0fb0869ea679a69e7f5a222fe9fa5822eb89a5dd7d871f13ec886924920f05f3828ca1ccf6ea78c4f3bd348478c5660b1ef2f8d82d07a94755230a55c09ba39f298484766d24f6bb688f25df5ea12e5288cf1f44c96cf0b8617de2dae77fafe6710095a9a0204874fbf586b6f0624d992e04e0f7c1e7a9b8654c131cc22408c641843760753107b5d30b2347e276f98176a4f58028b9b850940c6a4131facad668c36e18ca0e34cf36cc2238c295d089b30e10e431d77a6ab773793e1239948f97126034dd910894c8f5806aaedb21ecaedbcbcfea2d6dd3c0ede80a37060af71bbde3ae54685420b6a752a183a986389c7717e083001bdfc4e41dc58a18a79a0df123d0199b6b099882fc16bf9f9f1529df12501df9ba8334ca050eade4c5cf1fa72fd6613cb2a206deaf8f11dc426ae214c02f0060f17c3341c26b6d0a0efb68fd7332d0fbd5d85f44a35b26fb44b440337f1c558ab37e77d0fac54e5e1d271d523751af270771e6ff8232d9e4931632ae9e6df9461459abc56c24086488cf8460b078fe2832de5628b71ca29645167ee195bb6029e1c9cd95f8efafa760ef6fd5560e3ea60bc58f103e086697b1c627df69762bf5ab1970e4509f914f5afb0aa197ce1800212fb8da98978894d91ac697dc4699ae29cd73380ac52ec44d1a4191f55fe7923a75ecdfe503b6dae874a3a2031050c0307be2cc2c4a6465b1fd6de854de1669c63f4f3e385b97392e550b605d2485775ac47b0fd5adc8546b013a03a38c7aad954203803d8d72e59199bb797fbba822695fb89a535fa309d73deaa293518213b15f6e68107b1d14f7e637dfce58494833679430d45893c586b5298bb7312ab18ba581563f3ae19a36afecf90cc79ff64f419247412abdc0a85f67734da2ab33a122f214bf08e624743f35575b48f8bb0b128076b7d6f3d82159d48a7020412942a1ad800d1319c367cc87e0351762342ca35f69133e67f2da9253cb4fe751b473f7f538f97e05b3add6eea4e56cb2acc4e7c97662e1319627fd0903c5fb2073c5b13d3a085c8b2f50409ff4d64cafaa8737de2d6f9bcfd6fcc3226fca7912599a48afec4d4afaac562b1aab6eeb51327c0c9d4c4ca06f950b0e9ea6d1887858e7492f258789cc0c59b2438c4ce05cbdc679e19a5eeecded54dd975acded98dfed13342ff2ef48ad5be04dfbfe6a087bf9ec6713b6970168763b02251ba1f412fd18148a485794a5f81e481b2619ef9b677687b859f33e4d477e233292b8115102d0f4bab265eea393b3529ef33057ab116d4d02c4a513f568d0d1799bc04ca6936a6bf43f42eda734dfb127eff0eb82f2b6f68e6e6e15fa6433c95e1bcfbd811edf4b9dfb286c21f1271e67bee3644ee9ae60e73f55890355e8ee05a9f3a58c21912efcdeb2c75b2deddd4ea84805766af1a8f586bc80c553fd034e879147da8818d03685c76d5e965469c3795acac9cd37cffa091887d10200d710d6042a83da1ee2b359aef14294a8b718648c6d4f8c549850bb7959a4ea82b6cc863adcaed2fdb2ae49377a2ba8435e6d73c118e75b467f116b68e61b676c346a16b01a8489701cfea4484b077630bec78fb0fa23eb8967a8365d5f66bcc7cccbcfbea12491c632b303b5cf6d2d7212cdbf0b44af1144e104f42e0059ae62a420e71725ff1b949b77035007df62f8fc5b7607b64498b29f531e37b613f3e8573cdf98df343c536697899d77f4f4c1005e56f69d655fc4dbf795300952916160a27f632fc36d9799266cb24f93d3e225af80ff00075d467bbf76778ed40cc98be61d063177ed0a39f8b31d7831ac2debc41bed15e433f0edbd7ae1ba308c608238a483924497000ec288a31a0da4923602a80930726e676697fa277bab591c36e93856864a7c0005e389bcd6c7a8034474e25fea3b9568ea60c8eb20f412841a6adbca8af3adef1a9fa08c950b83ffa14597ecd6a8061cf7676d11a6a23c06e20e21275ee7721eb4ac04f5ef0ba11375df2cc4f1f111374995a1dc1615b787a8d0e913a19eb12f0ffa6d2d64b81f0595dc9f2b279deb56e787b67d206144b1921902ba293f8866645760d309eb6d223880b016dde349739f1a69f0a74af5f853a568bc06a3103b87a03b2eea735cf5f1ad6192e350fc2885ba09f95035ef1ffb8d34b532a9d0e78065cfcdc180e1f1651763aac2eaee26ed75e3e2c5cd3cc40da82004eb1d171b720127b06fac5ecfaf52ccb54e5fa41be6dbdc8360a4d214e7d65f1a878bb58f3640cd15b14afd88ec3ae3501788ff2d014f7bb96ecd877a1f9a8e0ece478c5a9d6a099dcc4c2cd571eedfc16819309b35c0c65721cc0c3aa772f0ca8579979233e06a2c4728708c32f22b54b6bcc49323dfc2f09afe94124b00e06b83915b687248099182001dfea81a81437cb5895316213d8f7cfb60559b3430c8ce65285bfe8ee54fb48a0e4880edd957a0fc334b3b2fb932dd3e6c4625bb734bcf5d5d9e187f63e8f13cae390dbb04c6123ed42734018edc749d59fbaa6bfb75ad34c465b356b4a4fa222b11ec7119036de7c6350687d710b5f66ad82b7065d0b3b5d02dc57cf454bf3ea32804de87966d8d70d9e180848a9ee1e1533d0ab8d7585689a784c8f724386c523e9bab155028761ad1ebad85f33df532d32c77a8f9097bce870bd6de4cdcca5198cec5fa3ba496607e84b2c54282f580e4c84a976cbaac21d5104e601aaf2e3a8db95b8f56ac5003dffd77491cd91a32679bfe2acd4364db698efe29bad9692b25ebf18a3bb21035250fc21173128b720ecccb69c2f57fc9d0af2fa4684de2c3c5f58e2c64c6834a4a0d49d9c22a3d1d2bca3990094fb77bc338128ba1b6208cdd46b01b41f94e486f2932feeb21e742946e07df4f6a3c8dcf42d65871c739ec7594985257aad1f3f5ef9f14cf9b3301f939834eb45e1d031d4739af89e334abb69d6bf46b19a5316b9550598ca1ff234c05a54efc2cefeb9b3083bdee475aa621d73599066976807e6366d8ab0ac94801dc4815b4d04bad2d8b1ceca8a28df08ac08a63ce132ba3f97626f4bfedf5702052ee7ebf6c58244fa7ece68e96c25b7eaac6a87188d0741d038134794953f0e7e53029916c0ef87f674bb9d97c15b74d61e4fecc7bd2c68d2a98389ad884cb746d276b6f7fe36e6d621da791e2b21d4b6cd44759ffb508e7afeef1130c35daf508a742017066ecce69eae6bc27160b4822826790547235caf0ba8a6b177ecc7a5c49aabd7279d836135cc26fa6bdfe2c29cb074f1def8f7b2c2b55bdc535d7779969acf5f12d5d6dc943c2e7b8458531f433d3594378cbf7a584f5dd30aa148114b3db31275f4576ecfb2700d104c69968384028dc2628060660dd07db79a1232d99e8dbf73ab307605377aa1b35aa10e45a2d0b5e1c40333baffbd48f47a06880309737dc0e5dbd26ba05af5ec883b8e3f2d32ee937f6bf12908d3f4a524a2c6d17d3fe28d5e6b15448c793dc03edf24e57519ec992168898b572afdbfd908ca0d8a60dbe457edbbea61dd47edcc0b703ea75f72a16429e312f108e308b609f36c3e2b0ff0229726b789d78cdbff920f43a1dbac221e75d5158aeef050adce935519c4ac86922d824bd282f042769d8c77df70e360193668dd273b18702ee2a1cad421b5fa8ba93f0b2e2ae4aef1f79d3a83f6212434145993b17c18ffcb83ede885954a2e21e7373fbaf8b42ee8db8903373c2d228f685d2452c3ccd854cb62854b465d1a7d14eab6fa8419f540cf28874ccb9923aa4b7c22fe803645c897f778ddf06d638c931c3361a90e4c266e3792cbd5838698b99ce14b9f2eac4b01b8662f871c44a597286483812bbc805bad0b2dabdc677eebc888d1455129f73aa975b34c64507a26428f70d1d954229a5f7b1362987c4a4cb96457c7d96ef8cbc5a88944b0a7bb3f42d0bb4e73b48216219844bb8b4995e3714795f32607edd7d0ccce16b577f0a67d182e07eff5bacb5197cea4ed054f712436784d1ad38e886eea2dfe74bdd5b0283b30e58976e043e5736f0c97cedc445408b65f002c762682a83df0395658284a879f52781bd35b97a9c2f6ff1733724064f27f5dac13e00d560dd4a28a00ce0be601e1da3980bf769d493477ef37085221423a66e0896afe77f8c600992c8b94d5fbe5122b302dd526fc1fde69ab320b9cadfd26c56d4cc45bcbe991a7313738af39d2075f5b268339860332fee7e7a4e60257eaed342def42087dea731a45d411224639c3c4a787abbec2b0b9c127eaf41f8507a8c3e569b3178ab0a46eb07cfe96deb4f96a9f7c5ec3247dccecbaace58ec173fb762c926b5bb91c80cfcc3dcff6c7977c59db9395d5bb0a2ea7f23c0ff8c48735a7f0f07daebcd33c63dfa1aa0bb23049f91fb83a65f9cea823dedf58ebee8404f5bf6a8592f042da44da982d85605709d1989479adc5cd718c5b71b2dd7142ccf2284ab7f46e197e81c66e6ed96aac1d42a8a4c91f6756460656be6890d6f0bd0534161b1a014570d08cf2ee4b4314330f056929a67e03708fc7eeea28a67f7e4e4a1b37e75dac1e09eae412a0f54af42541e2794afdaa7585ae12f1f5ca58c62e76f0414b5d9dde587383d93a7af186dba6a683db2a803839c815c4345f35d50ccb29e6d416402714ab3c00fba9957d98171f93e2c70241333d463b0b9ca3081aa34ec4f6c1cb2608345beadad3ad4681cf0126344263c01ee6eadc1d73adffc4c4cbff35df14eeacc990c1d979cda5905e59a0750907042192f24f9deaa7650eb6f186ef482720db1f18a8abfad1ff789921924d91235663acdb3ceca4200961ed5f8e3f085ecc9500c9eeed7a84ab2c428aefee073037f01be0802f39e8fb1ab356505f68001a2d7e3b478eea6f56428eb9935ac7ab6ae0d47ae19818b2d2a526382af36e6689b34ff86ceac87ef2593304551bb2885d4bb70ad1dea9d63b94f19f1ab8b6e70a48ac662273ab5ab3e50971190c0e1d2503c04a4510e6db73b08855d0a3fdcd7877d435ab02fcd3ddb389cce520d134c28c82a2b11caf7adbeac88147788090dd6827a5f85487e82efc0397f4ad04e593dfe4a92654546586387c7b397163ddfdb4085ae27cabbf5079482936f34e6c2b53364d2501e63dde64ec7bfa25c9612a14a282c1a0534495afd1614e9f459c6bc97b8d9142d003796ede79a4ca9102eb151cfc0b2a52e5109f1dd1e18b8bff1368f0c2b804b120ccf95afb8db6061d8928cbfb0152db2176c1d3ab6c0c575f8e9fd6e27c1b9d61475d9d511b94beacc75841065150e3df7e7ba4fb111b23d6bac4e394505e0e4ab93a6b39c9f0b8b0d4b1a346ad852774e1206691c3d92f3063cc76d03d40722cc0a495bf7bfc4dc5b74e10d18931c8e509fdd8de29c05bb31ab5fbfc85192feb3cb5f5edcc346d77654ae7161c4e4e78bbb0b99e23606322dba20a1760dbda1d320e3c5905827c2389f0f0bffa80e94f56b4caaf2c82c851afd756ed0666b458da74047bddb8b605928c4a6f4659ca817d3f3e2304f8a9d6ab3e9e977374574cda731c92576570f5db3737c744d9ebd2236e1d31c7ccf1e9f4b1cd41e1fc92c173732fe9e37d627a1132800d530b3bdb440603f46553145cd49255e18b2ca76d0fc8dea1bbf42c1679bc47c6a8bc4b68f46dcf81089df91bf302f2bce7fa36adce0c6e7a293eaab26c05420b9d9f0421207068f720d99af74cc2b91d7891bd7e568990de5f4fd35d78c15803433172e666a7223c4eca47eaa9ab4b13a77916fbb6f62ffe925196997d8423244a2c4c5a8b8c5a316430bedb35211326952e2b55f267862bac2c0cdb98e21934e30e71cd9a93054fe1e82f8b190fab4019506f8e9c59e4864169b127a09950e1f34438e2371896ce93d731f30a8eafeb2f8ad5fcc9ce7ab733a31ea4d721d8942b7997c7c8009467cbdbc52d05601b337bf6a20dd30b9d538d020920d3da8e9da7ebf25eb515e4dd71de1af1ed0e0dd4899fbb2c636509a02cc504a6b26de49ea5fdac98c2a318e331148384a178b84fcd031b7ee9cd2f04f45426ed9debfbcdca3889aeef79f86a3d1308df66b83b5e0a7e8129afc5358557b40ace028858e32edcc8b1c81eda5d08c0410a60c93d1a2e387da7c11d55cce580eb3abf31b77798f5bdc4eb5b5a9c975ba111468182e1b2eeb383268f2e7679105e2da035f588eb5ec3f9277e46639057d35081c7777229757566d5f85e834c7e169754130953c86d33fbddb1e6fe60458ed346ac3160170717f9519745aa1e7968dda3888dad894247f08ba58d0d88b25d4bf4dff91c82bca0ffcdc35355bc93a71c6d7592c7202ca527f8a523765592ecd4a9d8ed7f7c89658852e453287fec1daee93525986dd430f7edece88f8053497b9231f0bc0b248bada05de473d0c7a4508216ce20f4e20b0d93ae0e0faa951a67298368dc160cfe3bf608abe80a7a399528b80d182f5f26ff74e11b66f52a2283302c2ffabaae75e8870d86ed00971ed723a209ba5a091c751fc4d6fcd581bcae3e2281e020fe737f5154508534c0b9ee263cbe3099d7fed1a9426db65766a70fc38c9bbdc72900f75d33ca7d7022043325ae86eb11a00b5b89522d67005354c6c4c80016ff2d4bf4be7584bfacdad56d2f053345f06388fe62d90d28e145f78e46a7ead31bbc72aaff2cd1cc682c7f3fa2f654b7e4d283eb73b900705794c3ee2ca9aa518f08ce2e448aba59a5ee8c775571a9385972879ccad0e6a1a2e98c88b872cf70e55ba85b8734eb5256f40237b1c537dbbfe9b0c9ccb15323d7d3ff484974690569a20dc5eea83664d3414744935247c7ae90a27c991c792d34f6a89879d64984e65961ec6e97c84707f7f1c2a723aecc6c8d1c39c93f9592fc0ebc03ab0512b88bf3e3e6ea6bf0cb314541656f1f119b1f905576b00ba010c80a7398937d6a9a821a2e6bbb9ab75ea360d1ba1de4e847341b99e1d730bfac74acbc832185797dae544a81dc434445e354e7b16717dca17902b01b1e8294eb9f248174b6de8d1758f1fc8f8d000e5a1aef01877a23278d37556900f6278639f8baa9ab083344e1b45c9e72c036eeacb614f86c66d8e14a6ea80c67b943a1dd1d32cc1db65750cb2e6b0eb775825dd4d9f43bd6d6a907b992d3ed5cab5e4736a6f6388f24ae60b735554dacc18a7057d069517aff47708a1e23a380ef2480285a4874dc7c000e458108078cf2807f7b90965496a1bcc231a71540ed17971717bfb8fa471d369adae0abc51925370761805a5dc0e44091c7dbed12a5949d65d0c6e053820bf4a6af005c0065358a3d408e3076c107eb130f77b9dd008fa1681a7fa263014485da2d8a4f757e4c0c92c8566ed404a09c1703477e499f786f9bf4e37c9c3260ae83f2aec120c873d159eea11d217dcb3b0500c870246d84ed9024a79ce718f20f11d4a97b9e8182987061c59c9794899831dd627fe0229efb41beaa5eb2cb432623b53542dc4e82f4a35c360dd07ea7c7b1e00b5c4049f0ac723588f5c863313c1d709786aae2038e3939775b2b2e85708ab093a02a7d6f6104118001f96e737a9ae36ca920496e28244dabd6751321e770aec45a4d1541446b7e3454905c8f59c6a7607bda3acc4f157daaaf875abb50f8250b04b052d55dfa68a1c41c51d8240d6aca8b8e0cd497129a4fe79d562a5c657a0c8b4fceebc606ff1a6fc04b6d212461060dc1e67a2fa1021f091531d07555249cf7309e86f3d15e83fddf11b95ffe12773758f3b73a4f52c4db7ed4057bd1221ec06a2558be3edeb7bb077490af4bb846f53fdff67bf42dc1d7d40fa20c3739a4ceb3b16053b557093883e2a6a01a786aac9ab0841e312ff55043241f3423c183c07c7a6107421a585511712256900f3a026be13f6d6f0a5e5e10203597e161365096a86e14565fcda32f51566491eff4cde5e5f0c7c5336cb6b7a54611579220a89d5348f66f31180a984bee4c2bbf805ff16ec275ff4b004efcea15c97a2fedeb531b50b36b7b9361f2d62150624f33bb088538af3bc5870652f541b49f7c2f01ddc0bc32caafd6c367007a5bb5694c3baaca0e53544c844ab1f7d04c22cb69e1f770a7540157ba531cc7508bf942d940fd10f081f9e6bce2b79e06c785a305fb3fc9785e25e15066d8d5325b1a545d203133f26629079d561c472c1905f9dc2ab2957e1b3d07f7d32dd6ebca87ffeaf61ce018e5d760a0fe6f54fa6836842f1ab846da92e0c74c217db8c8d2153908289c8921c1f93be41145175d4c688a41fcaa67098b232149e021301449e1e0e9d35af1ad9d13e0565fbda814c37d1fe64a18c753725db9e848ea2708b167c0ad9f4915edd80611af101040a4cdaa240137a40aa6926313e24da07cfdf9a52bdb5739499390a64bb58a0aa4489b1997f4bf14990d2939a633c3f377dcd3bec99efb05f2829707c1524944ddabbbf9609dd2930eca49f2f05a8a81b8d863691f7eb7d5a5b22f583aa3b6b33c474b601c2159cf24b18f06cce571c23a16c287ea40c0f8ad2e6781f0483455448416f118e80be904e6240a575426065acdcabaed467c28f3c0a2fe82a43d165fbae4cbd48433a211ad4f3064e01c50ccc3f3aaf1ef4d6e07886236f11f3522167b93db36444fee2d731b8215edd639f804f70a234e93e8be00975c9dac4e6121741ad7502103fb0ac039141ce3c38b5b211d7d5ace65ee1ee05d4d0557a099cdb2f6d65317ba08dc8e575af8d11668cd60610f7ff858ee161ebe765a6abe44eaccf287f24b675fe17854cdf8724adf92e548473fc7dc27c768d0dac1df563d7d3df986a70ad8a4748568cc8235ce627b6b5b285753cce74b180c117c1ebd74475754676a5e126c8a7fbf4a11ffa9d4254a6527536a118ce884ac18a9ad60512d446a3f49eba462dea90b349e21db5b3f5deb8a6b2a1bf4303672bf9f355a6482c122114a8b8b6003175676fe1bc66bdc82b421935d6641d5c56c30589d38b8a02895c61109e218da489b82b794b677fd942ba573c68a5be717059db6616d69ebc06d8b6344966d0b5aa54d744d9e875290e9e27bb70467a972364bde8d17c4acf412af2c3d52963dcbec4e5e5b265d5f9c7143a91efb3d23c27d28dc54be2bb011652aa2f3ac04d8de62e6963d367e026b4d554bff65c6f2d2c93a7c8abf6d9c9596efbc0eadbf60208dd7dbe73f38acfd63cb007d420da41b7d4795bfd126703c12e3a428f47644f62717a18db58b6c04f80bfae2b660aec885ed3a69a467d1ba8979594b4d5766434813a1e125914f53aa7767df73b1d80c145de51f503ea11ea22ff168bb06cce558c69c5a26c7df87a119a906ac24404193cb9a5eb6b584aa9f83f5b25d691c8fa10f8f5d1f836b75ce462471e4c8e5ca3986fe6dd7698d7346bfeb0c19bc0f4da746a955f9e2e6c1b8bcd940077fbbb3e3cd40a8580871c5d012718f3e36ddfdd87bbbf3177923b560acb877106d02628f4bcc83e6c61366d986791fe2f377f184353bc880b0dd67891d01432dc1ae21ba20b8d3df0a65febc0d4142bac70fd961c65087ec355bf7b34a18ca6f8c3f5c4a1a4281c288d7d8b285265cc0dbe8e4f044879e57b077dc73a4994b3372cac24e53dde4ce7cc77c5577a2ea36f3f02153f5be34b6dfc692f149379aa711cf5421e25a7b888cc71e7947b5699f79395fc12e80ee6b73e8b85b1c0c652713070d979a21c1d5b865de40a29972b082fcc01bd7f83c0acfe27c662523ec3a7014cd2ae1cdd9321ab02d80d60ddcd663130cea3b08c7b47541fcb2871794a6262c68f4be50420a1cf9a540846a65bd8ae4b2e620487ce27d23daf4c71a2d8a77504f96d981646d75351a37cbc0c8556b9b4165f90355628a183f1846688b4e4e660ab6d82d79eafd94fc0c99c71284b0cc1486ce600506f63fe46b358229b23af1f941d4d485108c566f81e287fe9bfac5efcb0a001d89d3f186822558a380a66346361a8b13777d6b78163f459295398511aceaab7dde9431023c7b80d80f62d5849ca27defd99002377933b827ab2b5b8655f632f7179d48c18f871f64ef5c4ab34f255a5588a5dfdff726a90a134ecf28bb979aa21816dd8d61086ea48176bd80a6c35313ab424328b8a67ad546665e50b084afae9f63b0d5f7d05604257267ca8a01efc5757f8add129826d746611a2dd04ce4fdc038e4450b773360595f62063b7832dfd2b537e85550af8f1db5303bfe4da04066eba7cc62a2ba1ef10b0a022f5efcf8fbcf4a458abe376a9a0c3aedf25941ccec6090f68c160a40fe96b9a8badccebc034a0f8f6eeeac99817e6849a9a7c66aed9d6ea1ed3cd3fd1a08f77d1813affa28b0314560c555a46617870ccaa00ab62d9920db00ed78845438e8b4852bd2f734487592dd6399d880b3edbe6aa98c5e754747619230c04bbc9af92674b5d914a02ee1b72eecd602bfe91ace007b8a226953ac95c76e8785044ea6ccc4628c5a6cac8f7b60de5592951e6e7f068632d9bb12775e8db6d360ea31d70e418ea21b378bb331d058e11dd97da7747e8c4fe003bb1a37c0dd9466716fd55bba817750cea50733a63434c8c2bcc17817514bab456503bff594b7082ce1b75a714fcc2ab51ebedae5d7e4475a06afbea384bab88596c3a66b0aef72a8e0abe451cf94e579435f0dc6c016acac3f45f0eac20e3c284c35bda5d8156d9981e97901fedccce424337f54683f5b5a6ce2ff7a507085f16fd83ac410eb22a77d3401f92f2d06bb4af47db6d3fc751ae0438776fa7fb2e85e8e5c2f13e4798be1f3f5d6fc371fa31a1fe7cf9b244a940dfc17c4eaf96d0cb2795a52f50de23de0045ff670b1a53f94e362e0fab7d7614290d1706c10585b64e7fd08f13e17fc0e9ffd14f6ff96fd22b01f144198ab92e9a0d1bb62bb76a577f30d17f2166060bd00aa39a04615158e4130761a01c99035791ea5ca9bc8d321819cc4f4199cbf46ba7b31ef803fe5e0c93ab2b9e6d59e05eab1ebba6879ef4ee75d08c1204e811f28c601c6e0ee151253dc01ef503064295d00588b304b08011e0776310f5822d2df76bd8e3b070305705371f9c48df7f30abaedb8e3fc17de12ea78291c4ba664220ce27fef1efd0461b4745d85137844298755269326a1f990538e1f40b9167fc4800aadc09913d857541904770388baa879d8ac33c836427ea5c31318cd8b1b7cf983ed8ca7e7963de3dc47fe5aa39211bb03c82e346b71c7cb5aeefb458a1c1054921131cf0487222dd30c4a8a86f848759bc32358773f61740c3d673f07784d682c35d1c07fd61af7a81bb6383be8676772f207d633c7ea6734623818e94d018b9f38014fc1d27eb96511efd115c10482f072329e1bc08a5957752bed71da35cbd84534069d40eb10f151bd97ef131f42ba9cb4865d83eccd09cd1627555b42f0297815c2a59d273b7ea3189697883090bef0ad4e7069bd03ca9c8f508ed91d1b7cd04bda0a3d6d250f1d647b10585af08111ee437f13c3ee7774a3bd43b02d0773e53d1d7d1f6f6cc7d3806a88194745f0afefd3e0ae3400957766285cee0e97ffd9db83901b0c2d156694314ae759782aa2fe1b9e66bbc30e172a3c406a7378194bc1c4288d882595ca3c80b5e9045c245b5057f177fa08159ebd8a366e6650f57d3a6d0eedccfadae3475be0b0a0326c0a4fc76dda42055a2fbc8e24aaa8a4a18cc4b51f15aa4733fb08dfc67c691e3341754326260f8fca4c9bff8491c3022bdf196d041ebf1eca5606982e138fac18de107e02ce30008927d23a5bdbe5a286ecb1f485c37bc51a31ece9fa5bcdd49ab95e70f91aafb6228b1cde94183d5e63142653f1e688037f9cb49a2c28e4a3a8aaec43270dc087ee76e8f3b73e0fd091b4aa0367e73911d866edcfc42c4aa3a45007c58f84a2133abc28b333a6081071d4a0baf59236cfd886de5fc2908e4181eeb36bf9f9a5895192f8f06b0fc9e1fb51271d688b2cc7b512b673736ba797157541634a1926f09f7c3ea395cded5c63e07b17fc1c722ffc610bdc81414e31a9dbd10a59cee90a2a31566d3e56011abf69190f58d7625a10e383bdbe249d2eddcaa7db405e3fd27e55cd997848770381d03e276bdb9384e0898683435bd6b9b262576ea71adf39d7d3b22c4ab42f3a3e3ba2f209e4f0ad1d5103873eb8534d72862cb3cf1b6c7982122332e66a75a3242c3515ee44efb3958a4649749e6130b00ac1518d66b05206a11013c3c2dc778712a6a127fe3942d64909a93178bebe1c889a970e77b7b528c46cf0be499f3c7fcb16383ccfa586f84db47e7ba4d1d44e3519ff8f6602c6cbba2e94504549f13bdbe8ffff7f5d9fd23783dfeef57fd61a17e2cb5b9204c76f4d2d2389f420267fdd8a3268858d11857ebefaa4d15cb782950e3151ce518a15697bddf5437a633300c3a95708097bac994224760e16b633814da5f5906730d8377a0e38ebb79ae07f2564ea82e91e7589452c2c8068e396abbd530ae63f4a615938c500bed44406091c408cfeea07ef1ec5b5bbd13141854a34c3f2a292fa00149f2fa023d230557e6a1dde0b92f66e24f01cff3dadd1930c21f17d071d5f476efce4dc436b4ccb15dd2d2897605ae2c1343ab7cc17a88a37c02ca8f5a438c6ea2b893dbbb9670db542e9fc26bd19d7de4718a4629455682b07e755c0b63d6c565d36a6dc1507ceea65efc31b45e44a14fcc35ad254d96639b38a74d93182a64f60f5bdef7e354737a90bfc13cd741208db7dc441548c043ea5234f171d1071926194981a55f1cdad793d0fc43a9f057610cccf8e23c2c9b801291858364cffebd4cfbd08c4c9a2a5a62899b6a1cf6802e12ea015564c6b35ef75ea58b09276656bdf421e1c4f081bff5297859bbbd4eb57c43ca7a831fae6dcf65040e2692def8e5b2323a64609808272aa25ac0db7fedc34b16e5d3ab3ee9279b3ba0ba1e1f73ecbb73af1f20a8fdb56a20357cbb289e2c460428eaaa07f4da905e652da69dc04e18cb71a976bcff3dc2a1698efff151ffeadf92472b45805784f5a708aee946b9b56765deec444b811d6c7ed6a00e980808674eceff34a0f06cb0b89f08ba6096a8e5723038307a9874087a5541fc7c25af5e42ca9652c109c2ea198f1bef96ffc47880b86861a90a3224068f3118dc32cd5775f5dfee6d04805522d4dc3dbdb194674d4aee630504ff208cf0db84afaab09df64badefd0714bab8d9a9184e0a359876e96205ed8af9dba01f3ed734923dfb8208a287b31ffd9ddf2e9ee8362b86ab209c0b5c32a58b6fe57e5013e5f7d2dbf701272700ada5127006921dab0283911a7535937fd16d0924dda8ea8f9936406308d67609c41de8b95a72d143d7c6898fbeb46ffde0fde8a4adb8e2f37de90e7f119b6ba7090787b1887dd1136c9ae4c7c65b2524fdf4596aaf2cec0184e2ffe0e051c65ccee405a0486d27aa92fd0346db75d2ca67b89cf526d25f1467fdfbcd6855332e33a0e6f054e930bcae9cddbba90b13c9ea3c8c882ce2296cd5a30eb8a9c5b54a540e8ed3429c225e4404a7b17548c0442c5e3df739001ae8409e2b85a4bf27b60ffda3f89efcd3ff82994be24155488cd6e177c8748f9183223fe6ffa7ab64a957cae33cd3082a15417bf145aee32116af9e4250387b005ab7f9f111f7f1b19f973c5f13ea89b3986a410bb98c31257d4b2183d8361bf9d1f7c4bc35078dea13f03c995707ef390a8dbc02323b6a5e7aff14ecb02347c691d36bb60f7faf31d315d06797e4db9bcf29cadc6a7d7f939e3a0f59398041acfa614302b62383d924ff452e5f14a3dc7dd889c04384408434ccfb565a1a159e2c165189d29a43dc985dc7f82086971dc051a5936167904968cdf0894808239b9448f117598b188ac14dd312b806f9e840445bddae71057d1a1fa01a714eb64400ed81b7a705adae07318219943e73982d37460d0f6bbdefaf207979c92f17a61a5bee2830907f6dffdfc5411824dcc190eec52680d176cfafafcfd89ce39ef4945fd9a998c72df5014241fa682b84f5db4259a5e4c2ccba843abd122b8330b5f309e38364674fba6d5bebcdc2cbb3afddb9f32c9f6fb6ae3b68229567f6d42bb5bb952666f3ab0898982100e469f1efb45138ee132133270402eda3ac8e8c9cd88f3fb412eada57bf26d0f2fe1f8e83ac4ee9aa37891deafc4ff19eccc0b2fcddedb98b769dc924f8bf4946c79209bb7ffa5b0186361d7f300c8d80e96fe6ceed154bb81ebdb314b6fc5d39f655b27806b9b4744ff54124c295e3f498da9942698a0eb58213556950c530142a73a282775eb41b33e7d9da2213891119d1a77fa7f5ccb528ef6515fdab9b49f6b758b5207c7869cd898032268ef7c870c272651caed0b299b7f4cff4b1d20fa8ade697a3b96d8c1b5ebbf0335259522b76b62219a53f901cd72f0909788d6805e0ea4905c578ab701ed6886864407dbb80628b02a67bb6c1d280cd72cff3f0268b8f01bcb9bab985cc3da8e28330e8e1e2dc3058df6ee76439a87c3e95afa78bb71950d8ff278aee150af41665397fd8e2420168764e8a0761d2b4875c71a75ce1200b45d74847b2da5ffaf76db15638af2b887385ba444e6f01fdaed7142c8fe9ec4054838ee465db1fea144f426b8ad06f22faab1a27e40cd0504c7d4748436c33ab3877271e0fbcfef062bdf6bfef04802e26b05f694fc3f14aa43151cff71ecb319bb0907a637f1d9e4a479bbb153ff6ebd8bd7b13ea8e3615e33925195b34f304cba97e702a5b5f83618b72c73c4459dbe32b4c35b362a62bfcd208f458e86794400f5bc47aead8c745a2eb896b836cb27582db463b569b6e95f8611a8036469983c9d6e8484416e8f14f1cc2d9e610105f48a8b7fa1c3380290e3bd455a5d34f96c79dc5d608cc3cfc6a84d229e58b47d05b55e83d733584356e3d7c3cbbcf5c49d0624df389b7070975454f3918603facf3930349580d529d2cd8d05052dd6b4b8646e507b131b73801df2121a149fb4817ab0b2744932e3e60e9ceebae40ce8c72e2cb7d00103425150ef6b0e9a4232461f1fa42b6b102d4bbf37bec1c6deec4183a825fbae7acc2ba04b5c697a43c4aed7ecc1e19d65a77de1a76dceb33bcb242b3840fa8900a0c5e0827b94a02e342f8de38c24f30652a9b460ac5e667d50ab44c513e9f436ed65f5d00ca172e0bc26f615796faa34054c50cf6a8e56242c846da73af717f8eddba473b981eab6649a7db58863714ef79fca3a9b07ad6b2c1801856cd655082b4d75bd8b88643fe6f0bb3ba2c5dc6a5eaf4f1f9d6c168f3b418dd99c8474e074d625ec63fb64ce261e4d9129064f9584f7a88566f3223558f501ac6e8dbcafcbd274b4817028269664339736b4c9961ba984805d9a9c2c092490ae379568d0bcb16d29ad22fc82440a7cee90c6df8ec9af2474684166380d1a4ab325477218ae0db6b61b7a6c1d626d1627a80b5b7c91f892b7a4bae43c9dafd06b3f4a1aaf6e9463732c253fb55f51c62ce59033bf9c37b0815b51cb3bde89efd1da22da676168bcd4e26473178a40911de04f01e0d6834b9638000567493dfb79f33fc2c3317d36831f5818ada76634e74f5e3303bd84b3e0cbde9f7e5ca12919d3f5089c199e5eb40c08a9bab8066166bb30de9581a994aea322651b74b5e5248883186efc012dba86cd9b6101ffc3c4a46e97891dd99e26ef050801a2772534d8b0178d8c8a86f8d47dd4e3c9e2b35cf44e6c1058fc7ee1ec02625a22f465daa5727207ec9f7ffcd533cc131ba8072de8e8d8892a388be2c5d15bad82982a5ae9a8eb2e659a7c6dc4d3a0fda6a3605a6a6c3c3f6b0a60715bcba1906d470e6da789c267f11e92e0b9b1845b18eaced74d948b2ecc3c4d77002011d404e0b7a024168434c96408fa669c4b7bf860e3654881d8c9a186bb8909b7c9401dda189c5f2c686d2a78ae7f6b3ec53e8611f28d0e7f6414a220b6513edde24ee26b52911330ad34ca710bedbfe8c6e6ff679baf949f845558d4b7f29d8dd33e40b8fa220bae089285fba0ac6da7e09368fc1ce6b59efd8c5c9d4fdb51621dd564abc7b176801d3a5884079f884551e4103525745d33156c2bd7a30a8951f57bee81c5c41fa2e390ecdbf2346dfed47d66b5462b9b2f515d7716bece44582a2ca24ad2cd47ac9e49f4d35f1226f76ae0104033493969ff3b015a728686c61d0b8247f52ecb0d0169c696ac203d42199f8c79d289dd29e9165307cf731ea03e6ba9ff9f485b810adc7f22264c9047479f9fd57025d2f4b87695b371c96f94d624ca3f720445d7631819a2720926879f30aeb8f054a68a466ea770250737b40bdd9e463cd161eeaddb312b98127cdb236b5e5db3e012e5277aaf9ecebb6e807a3ff1241e10107b5acf982ff47100ee8cf89f014f541edbcfbac6d83a8e2237f5e1456edb0acd1fe7dc544f1c89ba4d73d7962d3a7a3fe7efc9637ab3ef68e3a6d53de53a2425473f5080fde46297fb0e14d3c6f32f3a91a917289b5ec52f533da8f409d8e58114229df3d899bfeea88bb23746b834acf565a045477b549627fd2af312a94fd36c12e3dfbcb32edb6ee3c31e7eb9f26c53670ecb66d4409946ca6f8c77327a9a74b08a1944730ce0983cac0c79ab8d4c86f61d4b5b9983dd252ea7ef76208f8517fa312e2b19496666ba148ffc21659a6ba9334e7a0abf33eab702b2a2f0f50b12ee07924d5bd31c00cf1518be7996b085bd437216fa56550188c4aa43e26803558252a0ca86a9a4151081334fcf90224e3c6a4598a347d7de9ce703bf8d5209b363402dcf101215992ed9e651e0ab33e530b3b3581131f6e7d37a827579d1c2048987b32104d7be839dde3596f5515e12f75d93ea7877b95f1f2f18eecad021eb025a2f7da9af9403d6f59e53d829240a6d53101f87dc85680337bf8083a0992d8e896f7743d57c4d131da05591248824c3f539fecccb4edff3c46fab409ad65aefbd5e830c6637c1745b6a188210451e2261212b67e35aa1f1c6d1ab545983a7f8fd82c89bc6300be9bedb96171afd65f60eb6531be6a92b77e64104b31e7aad11445f7fb033e9e9965dbeee7dd39316e7d99c397c4f3c07e9d7025e8b614103ed57f5869d746ab37146b97f3be7217c3e53f2b0dc0a210425a4945a8acf6655fb006f3b1ab3891ac6a3b77a21519e8a338af4a78a080d63280414d165fc0d0c46194f8c32fe9869a1762ab1685f2d4c0ffe0749604ffb1d0094208800e4c24ce076e4911750a8a10af45856ba065dec238cabb53a23af81f5a6e318e6c4af8247e480b3d7826ecc93b9f27acbbc60bf7b3343823b5b614f0cad1c6026d057285a73eb88695ca2c9fa7cdb8599f968362f790c57d8320a9da99b893a73b4ba712a2b14ee4a6a8f5850026c3e3050d2cc4ac783a6b60a76e67959728dd7510f273af039feb40bf1364b048c707d1c3c1ce09c9016fef02afad9f88b338904e615d0dcad6104832ea38301e0c55dcf8913096322ba0afbe64136277bec2d6c760ae08a785996cdcfef1658e602a33e915005a6693b18e1291915632e44aae16b863620a1adf0b55567b9669746484927eded26bcca361fcc2f504e572c0eb9f3f5b72b9aa9ba77e2d845d41da2140188c708eeb7105f420c0fa83b61132da055b683aa59bc54bc55891a58193490b0d597ad3f8f8ea3b0c72aa6992d60460bce55c6a469948407533ef99c01bf6796b305285f21915b28c67c5a2bf689b10175d4013eab75430575a5a1810252670409cdf4a73221a68d7e5caf576948dea742300e5414769b20f2f2464638a9d981a646ab18030c0668bcde3ef4d25db51e75303d7652bc50c1089e765847ab06c5742d3bd9977dd26b03db1edbcd9bf8118e25fa9351931c02376fd6c9bdea732e1a610aba59d83a5d099f28b05af982c362b5bf21d9e0876fdc083cf2ba7fb071fc58672e55591e9566fb3e68c6e4b15aa377b8714550d54b0f9aea3591658165f4a98299f95d795fa1a5b8ddf4ef0aa222f5632d02d7aedff4a0c3195a9eb406aeb9b45f8dbdd43c5beaf05829ed30010e0899e9690125ad60621628e9b9afd5a15b741e6515c42d599c303fa865f16f7c3ff77e6732f66138fcf6e4f68aaa3b29b9b054d6fe97bdf76523efe54f5ecb624bf3147eb7a62139ed7b2530d07812e97f693e0c1fb546b9aef2adc2596654a61b1db2167b09a9b8875668a90b4865af3ef9e3b76b508462d52c7508010e1335ea19ecdd7a514f88efe8b23f749704ca7f74c959acdf2b945f596b7c176b809f7bd7f3158d47224078b26b8c2442c8b2e80ada61730cc91f333006d53886a73e8eba4c8ff7d8af694fad99ffa65f4a23e8303aff3ce10f292432a778c211282933000e4a83dc1ff4c1401d5b65d3c4633e59e543ccd199a6149cbe6b4fb4dda0270d5f6bcaf90676041a92d1fa7bd7ea9a082d1851694a00a40316bf6496eebe310add831695dec54456a7bebdd222aa551a6276c14bc2c1363fa7f20f56be98bf223635fada808129ba8c4b2bee0e8aed8e86910d750b4b62aa2c6acd48935335290f1fddaa74b2ca5089898347f6b52046f3f3215382be6a30c4d28659788a645259473f46e429fc73fd83e5aaf8231829c2f4b21ca5aebe2638131b2c1c4d0b635e0a111d840f94695aaa46870e1546dcdd3c10cf53973d6765e66bca48ebecc83951639f25c6bffb1ef3f2e49812ca57ab9b4c2e8bd4d3405328dfea829a782725cdee31bdbe78be1666f54e38d833d483504bb7f80d641190119213673659d34d7a0bcb251a65249847e2264929e06f3f508b681fd57b89de54c5c6c7327ba0b2dd3a07cf5d45855479cacbabf5ce0b97af6cce87774c2419194afd8a5daa2bf3fe80ea8542505a5d44e9c66782c216fe5e89a5a02a1bcd4e0d4a5230f7607bf1d091f146a67cb9b6d71ccea14ecc1359e26c39f036e08fa1051b6596268e66040a5f82db188980514011da1e336fda264769428512c6d7c15ef839c3222a03c8103ea3b0267bfdb80734e62c84b2ae83d505ad24c81fcd3239bec2b39ef1076dc23e55d066d60806718d12279a209809afbf448056cf71821dec7ba4cfbff86cf790d4908f90b93fed09798d010fa28bcfe936e7490983227d6512f0c2cd76b8fba4fa7cbebeae1be6397f74a653d07fffcb268655591cbc77d4df46827eb5ffb7d19e921c64eead28c939c83771b139b23220ed411e3c1ccb46d3d47fa8a1d7c0f9084d58626fd6a3498c378ffedb5d1735c04662756bb9e3ac839a7b59207e82249282a5b35d71a5c7dc9e44a33182f17bd26ed0f8f73113fa3e7e475128c392ce8ba82e407da735d514a3314c18ede2b87f11dafddd3e7f28d6238cfeb716c2b9c917415bc6b05e38b8a6ff3648120ff882292c1764ea08257815fc49e2049c959b85695513745b37ffca2cc10af4411e91e157e7b5d8e9ff798d0622f576e1c1238a63afb15ddc751598ab928c8c29f809060f007a74e97d2bcd53d5953185bced333c5706b976373629de5339828d969a9584c3ac57594a63cec860e2a168efcf27a997f51859d0fd9b4aa4f29addbd8ca8b6687ab1f4763c830221f0bfd65ffc02fb3cb24fc34390c7151acf81d1e5d8d1a1f38e7c732345b2b9c4a8fbc45f3812c4e1d73912c252688cb859dfa3939a63c90189d431d4b8789fd6e256dd1c9c1fc9c440fa41841a94a90c0407b232defb935847529e142d6ec147edf883375c15973a61f7d2bf25be58aa8c5e9e80748d997bbc59e331322d60c4d53ccf3076c5e35ca44d547d0b85fb519a6cf1617d550b293c2f6b0b3c7d76ae691062410445763d9f7d630d92faba65be3657f17e4535a8a951ccdd26936a3d4fd53d8e388fbe103716c857781680712cb26deb5b5534d93193cb3038bdf1b353b39cd5db6fe570a78a4b9c57010a33b19f9e73a194cf7ccc2d5aa4cd759145386685dc572e1432e005c3c57d7a456d8165c22c52a88c74d9bce176d056c8f7526d203173341c3d76285c30c48d61bbcc5e6d2a6393041cbd85d41cd4e53d490329ec7f60c7a3a25076aac77858dc858c18474456bd84f4f9da20f5af6f0984ecff8ec93970cf4cc1d51edbff9514f1b1391d59471f71d5ffafa1f923acb3f69d1db13f63f1594d72fb420aacb341f61db0186b1b35b70c1fbfb4e81bcfb05a7e0399f52ad036b25e2479e07d70796e205ace316c52b09616b686b011a4d3e5346e90c41c0397f162c586e3ddb0c01c2402484166a3920ed7b56133c4967068a5f46d9de836d0c27c8725f97aa97caaa4d623b627f21b6fea898d298d12464aaaf435c0a0a7090e10f00109ca471b88a4b990849c340a9b998e99533e7fcc68e117e6398ef56372807dc892bc0d4d5a0f9c392ffb4651bd51a46ac0acb632881164c93ecd1da51dd2c1a4c11609f7882030018dc879dccbfbec6e11f58532cf72b565f71b475962a2e24aa4c882433c96aff4108a60052aa2ec569a7e57d5d9eb96f5a9e39ac299575b1b93513c4b24435bff7a618307d0dc2f54615da5a2b45e76f58985180d69397f6ca78dd03168da737828883ec59a425ea368e744ddb8efa6cdb2e0a3b49274a8cc0fea4444111720b17637a4ec59c79ba603f69a54c3ed022df702580432b50aa2f0b06db96571fdc01b35a1c28167a6bfa4e6d9a6ea34435a43fcc259261ab81f9da05fe31c16cb0e652d7980820cf8556ce45a1f57ad3a7299a8787b1b5a2522148e878986c49b155a215a9f5dfd256cc38712d95c58c28cc77370ce50530e9df9fbe832e625206485343ea0187e9b672f8c696a0b00bd34fee63ddb00643045c08f71d27382553dec314148ab4d38b4b8ae73a869efc11502565f4baf7e550b345b09d620204a5c0a731af3619dd66834fc6f33cd78d84a7102fab3bdb9e3149c1ef6d5831521c8e5b648273bfb7b120e27ead02d7ee6a4dc7d77b248db797ab739790286927a395bb3efe820913dfe1a1336d10736afd42fef29afd08df8245cbccbb1dd37a5d47cc622401c1dde846a293835c583fc4d9e311e73759198a49749c04229289bbe56b0450090aad226640899e00302e8d5801c6d978a7bd472d3465ebce43d592c82e9d5bcbf31f1a02e9a80b37ebdaa10a1476fd2cf3d641da7e7e74fb629a60500f6dcf314e5232a86b090a99ec99faa6f7e467584087fda8985ce3194aeba25349820c17e9eee00238fdf89b40b42958fbe2c94653b0c20d8055bc333adaed343c5864e70595fabe4ac811d51d12ef808b6861738fecbf7b7cbbaa7436b1a25147fd9ec263a2d939f34c26a46e394c16eff7f0e37b86337ad8c00cf72348713b06c9c369b00975fcbd3c2dc7366aa73f9d510ce17fd80af253f2f1cc39767e180811964339a2127ea60bcdc769810d714542b65fe6967cfdced9c2d12d38eb1c92ec1b2398f602f6a944557427689400720b502b86e00e30948703a0ca9d04010f223031f4a35783caf0c9e4ad5549c437ec85b9ae6eeeb6ef5c07e8b80cb32f4ae8f19402eb35749e7e798b68579f72ae3454e1cd32056e47c0622bfbee99ecec8001c825eeac7fd5094cd112228063c4e88e969b55141c0629e5465b64be42171a14da18c03c703dcc5b5c6d3d3643bf71365d789fe7029e9cce04d8648e9593468b0552b725ab87748ecff92e37d2df8611c039925a8980c73e949798c27ab0226b568aec615bb3b5318d9384c33359d6a3a61a8486ac8987c01b495626101440a79df5238202102745bb2cab553bfdde0c9d3ffbf42952c576035a7ad260fc84a899aaca862b88e1c2a5f9fc608dd39d2ffdc8f256f3ecb18d776de32b10a9d43b7593a932082f9a53ffd06bf80ea74020c742c92abf9b8dc5941915ddb630635a3a8f60afd9c5c75e1f6c3be9d3e7d30433c53d9957e28229c2a2cefd7a5d8196ba6474964c2c68d70da9f6ce067743796a881ebb2a977c0041fd8698df35f661c3c81f9760ebec1f097ae68624b2e6c0aa5888cf207e8e7b16d98b844eabdc7e97c3b4223f4e25e94ac1adcc8cc7f35d541e0528d57af35f72652187dd7e8bc007e633dc91830399cb16fb1dcad56ae08cbdc2bd8d4de0f5199a2a4cc93b2b2800dff1d902e77ae72e02cb3c457a25e3b4f8879fd1c67af87860b1ce2a2f35cf35216073e0</script>
  <div class="hbe hbe-content">
    <div class="hbe hbe-input hbe-input-default">
      <input class="hbe hbe-input-field hbe-input-field-default" type="password" id="hbePass">
      <label class="hbe hbe-input-label hbe-input-label-default" for="hbePass">
        <span class="hbe hbe-input-label-content hbe-input-label-content-default">Hey, password is required here.</span>
      </label>
    </div>
  </div>
</div>
<script data-pjax src="/lib/hbe.js"></script><link href="/css/hbe.style.css" rel="stylesheet" type="text/css">]]></content>
  </entry>
  <entry>
    <title>2022.10.24 - 2022.10.28</title>
    <url>/2022/10/24/week-9/</url>
    <content><![CDATA[<div class="hbe hbe-container" id="hexo-blog-encrypt" data-wpm="Oh, this is an invalid password. Check and try again, please." data-whm="OOPS, these decrypted content may changed, but you can still have a look.">
  <script id="hbeData" type="hbeData" data-hmacdigest="0adb8eb9ff977a716e36b1c971336c59dd851ac7529d352a4e2120e7101d47f1">a99f2d1cd7f89812758242c57c62a59fe859e32cc19116fcceb1abacce500da0960986acd07eddb3568f524414b51fee17e4d6bd35088912fa4af175c2bf91d707d28626ce04406e2d0a9a2d2a331aa4308d0233625a01deb2de48d796dd406468d088e254ceaf3066e2eac5ff1705c2ee6ecc7b2e1397cddfe386cab639b6f893ea56b6991848c2baf12441bad465375b23aabc3a621bd0db59f1a35c33bfa0eb186d66d2611e0b14e3b7bafdd7649a7df00d446050658cb2a78e7032de2991ea21d22e4994ef83d94650659034293fc50d0d2020822fe2a03780b259f1d9c3d666bd2157c278cbbe9fe5666bbf1c538968a79c573b9e7d549a268346846f5ea0373b81d4f995d874cd14b41c8d0caf6e0b4a224eb9112ad3f0a277fe0c67d133666ded15bc89a449272174244574d161163634edcfdd797bab2e9ff677629906424ad78b6e9f4ec7877e4324df023fab2e0c5f1ba5d8596466a56f00ab215ddafabf64532c36c99e408a5899a1b0c992b8956c2ab422a3799087ade81ab7eded84f1727fb4461358e96ec9c88dfca739d5d5345a6f8c1d4399759f83a6e72cfd411c99b7ca3dd94373faaa13f9a68ef1b380d9b8f41b9499b334c792746087486bcfd93acd91e4edb4b0ef3212853d64c0601e4abc1007fdb25dec798b4e6c8859be73babc619656b06de563a1d643b631e6ae7559a44e4dbd5f991e6cb66c9a52391fe5fb77472b6e78b31ca14e8e368b60babbb60c2ab7d2c7bcdfd8e62f51b6410b5993784c4c42498e5a2631db3362470cfb7a64d08dfdf60a9152cc021a3d15047e2f0f562ea997410793aef2d38ee83dc217c9fd6ed967619302ea95f1c1c2e9cc9b7780bf7d86b504f962d7527135e3b0892e12f9a9877bbd5940b779bf5de481f70d8bf287ef028e5368d0a6d2ec0635221c1d133589826ed44b043801f0a9283a87e228accf4612468abea73cc117ff80425297f421cc7a78979d0eaea8357d7e88e021e54330932f1ff43ae90029e7cdcffe4c7ef85a36785baf436bce7c69139c1ade831991c64df300919b57f4ef4a2f8c7e875aaee8efaf93da2bfb5505b5359f4083daf8d23830c20e9fd171cb0a1a12a4d8daf13edde8c3f1329e040b53583376d369b9dd383687d56d6029e4c783ce3db8915cd50f58b61688d48c538761556e2262f0d3f1b83af4aa857e0d5debb31e9d93d07f4d13d06f600406ee68522dc2804a5c360adb7d81eea19f49b17d59a9f3182caab79820afce0ced733a2c0213d1f90546e41d6f1917ea1ecc50306bbd7ad441e581b5a62a68d83eb94dd22e44f46aa6d4b6e4312306b6db9eb7adf7861631a9c40e448d19d67cae24ad5f96c90307efe1d594eb2fab6c403644cc296ea343ec1700fd16ce5beba89224ab4a3c89eedd86154850b0fccbef785784e1a94cd2ac7b032902cef362b0727c8100332067969f0c39ba7a79c3e9788b18816a739224e069c2c3530ee869666f540330bf761088a99e96301d27e560129137762702bc89099aa02b96a67cfd5ca7007a823810c31d1cd36bce85256e37c85453d3a9ce0da54bc7603f3f04006eea2f05751c10f8c701d6efd317bdbf15096390cd78d15cb6fac3d9aa8c55c67c29ac456352b722f26d5e662e11ff4ac7e5bf4d38eea9163693ef98802a3f639f6f388f2c4b5590d0690de32bb27737fc8bc21f3863587f4d97facb255f73e1f8c3e4f6835568bb10be62bf49869fa59ae542af7a9feacf5429624ab7bbfc762421b5fcdc6657b58a7f40276d601d8094b6a4e8b653be38185220754dfecda7c8afff1eba65168aa80972557a67916b13d92deb7e2357a61314e080fb7292ae1a81ad51bc2b6099ecace2f7d0bdb3dd9febbd2cfe49b1c51263dbd090b017e5a4edcbe888637be518895b141af2080121c72167431748cb11638220c2347177ee1985b18369d99e02fda7b3146171c13e1154e6116d3334622236d8e0fcbf54397fe3d9404f85e5a6053b4b47467117cfbc75722ee6638f535be0ef00f60df570132856a71c03c06e208e39094537535d9499e0c6bc0bbb0ec2cfd67119c1f0b539ab0d4dfba6870b7c5c7199f976eac2295d25f48b74b28bbe3878737ddea7358a57f04e4f8ab2f279b5af6971bf82252fd18bc34347f065367df833a4d761a3be06a073207654804dc0d64b2d40883cd9f15b900061b81934cc0859ffa23cc8a95ce4381954a321a0403370d3bf644077816620baa5c9d0305a106f09e15c4a0c539efe31d25e14e27ed642c9ae0c57b47f4e5e7868ea0d8077478ac08840c9bf160083a6fd023010e4e75d0e4043d1f882ae040a6282d7f4d0b1c133169268ee13ed1d1e51d4c0cf4d7acbdf6aeb1253733f5fb9caaa2388fcb46a3fa6788c7a2c10ba7deadc49f305670dc50218977e44e45f72774ba5973eac74d8e8b985e002183fa9ab8d33fb3e5394a2ccb006c56c9a566445b1a9eb3ec2fab66a93bb6712baf2313d9b5d8b0d7463d8497a1663375b3db18d1072b22efbfa4c95caa2b5b5e7731623b759eadc6910c005033b8b3238b8a218cfa25ddecd4e43507215c94a4d8d1a1345cd141729cb11e8728adca81fe57d18d09d0ab5d6b074d8c59897f545ace775f3816e48c80bf65bd1d14d614bd8a28a06ab9f951e9fb1f13902276a61db48805c7b5a7f68f0bee2e232d8e3f6f74b43b2b78f2908fa24796850e30d01cd708bb67f900f9492d8a16089801ba37066224b491c7c70be765b3198e513fb748da518103fd06956938be7e7d6226ac44e9a38609fd43a8e4552b6e3d14f275d53dd1bec3d8ef40e4782da0ca706d5c83b7cef48fd7f12303158c3a300734adcf5dcc1e52a0e5543cf54969a6f3cef630805d1c9ef5840139a2e6ce1f2323d0ea456e99bd4f9f124964c10a81cefcfd1a8cec0f7ae202c7c968331e647e548b4e7a95497df20f68d13e4d4353eecdc22d5c364b06f23e10bd4cb12ec7685914a3ad1cba296d60b1581eb4fc92ff93c2ad26159466538078cd77aea1ec9c06a81574cfecb4f9f01bb57e81b2d282fb75dcaf47c02d5f39e69a5e7ec4f58aad80d2c0f63520daca36a4fb86a1107caf422bff85d2ebbcde15f748b49e1b3732324bbae6a78c249629855dbbb9dfcaa3b88abb600d74052553729e5a797c1c4a1b26454996bca601d53df3134317fa5d68d323261a12654ed5a6ba93496b04d7e60be66e585ba9e2e9b8217b0593dc8849ff213ac45ea73a88b2c8ae78b3d92374654b43cd81a21b8e50b630e03abffd4a771f89777c5c12c59ee48e3caac6126c2fcf476fd768bae22b71c9aff69a876143b48466359466ce7364b0c6866e00daa845f70a3b05ae5712a0db71311ad4ba85822bcbc682f66c93cd94bbbb8bdb86168d398a72155a2748286809e1c773ff093723ea016ed83af4ad8401381b06ad4c8783cb5be6ccbd03d56c258f8bce48cd606287b9b73ebe93f3900d1a9fe16d84108317a52dab8eccd43347660f18f59680a6745e46fe455d276df706f3220fa750614828fc4cfada7a1b0f0dbca3880a4ca4555c1fb351547c64b6bd095ed051cc505f6996ffe098e63867e147ccd67de1bc1f63afb754547cee4f21f400684dd02307cfc84fe3b096edc83241660eaa37c9d197cf18d9f70afb0df5e26f3078c9204baefdb109b9c0ae947144716ed09d5f2e0f124571794164404df77eda68e44ab446d4e5115d95a79ef52849b898e6e19c31da7d7a5242ced0e82d3be756d6cd18fc70b1e4ff5cc4651371b71b4f9ea7ba36c84ffbe9703fb71e75ab234199a86fae5ef900066b3259f286ff13f4a520331a3246e52be5cdc84bd0eb68ef31dd1bfb096094deeb8c94941727241a5251920651adb403d93493f032da8b2b942da7baf50cccae1447f4a7a05e4732c81c965b05eee87dec4718a14f16f23821d78935f6344c8add221a83a38a8f259ccdf898dcedd82262b8ff593d59b2b3c9f75005bbaefebd691b9d24999e0d2bff13bed2aa013bb43736967bc4c374fe883a9e841be65b62fa07eaa71654897201b49b07c37</script>
  <div class="hbe hbe-content">
    <div class="hbe hbe-input hbe-input-default">
      <input class="hbe hbe-input-field hbe-input-field-default" type="password" id="hbePass">
      <label class="hbe hbe-input-label hbe-input-label-default" for="hbePass">
        <span class="hbe hbe-input-label-content hbe-input-label-content-default">Hey, password is required here.</span>
      </label>
    </div>
  </div>
</div>
<script data-pjax src="/lib/hbe.js"></script><link href="/css/hbe.style.css" rel="stylesheet" type="text/css">]]></content>
  </entry>
  <entry>
    <title>Zookeeper</title>
    <url>/2024/02/24/zookeeper/</url>
    <content><![CDATA[<p>Zookeeper 是最早流行的开源分布式协调服务框架之一，提供了分布式配置中心的功能，以顺序一致性著称（CP 设计），可以用于分布式配置管理、分布式同步、命名服务、集群管理、Master 选举、分布式协调服务、服务注册与发现、负载均衡等应用场景。</p>
<h1 id="主要组成"><a href="#主要组成" class="headerlink" title="主要组成"></a>主要组成</h1><p>Zookeeper 中的主要组成部分有</p>
<ul>
<li><p>领导者（leader），负责进行投票的发起和决议，更新系统状态，为客户端提供读写服务，只有 leader 可以进行写操作</p>
</li>
<li><p>跟随者（follower），用于接收客户端的请求并响应客户端返回结果，在选举时参与投票，为客户端提供读服务</p>
</li>
<li><p>观察者（Observer），可以接收客户端连接，将写请求转发给 leader，但不参与选举投票，只同步 leader 状态，作用在于扩展系统，提高读取速度</p>
</li>
<li><p>客户端（client），请求发起方</p>
</li>
</ul>
<h1 id="选举机制"><a href="#选举机制" class="headerlink" title="选举机制"></a>选举机制</h1><p>Zookeeper 会在集群启动阶段以及 leader 失效时通过选举机制来确保 Zookeeper 集群中有一个 leader 节点，从而协调和处理客户端请求，选举机制是实现 Zookeeper 分布式协调一致性的核心，Zookeeper 中的每个 follower 节点都可以成为 leader。</p>
<p>一次完整的选举大概要经历以下步骤</p>
<ul>
<li><p>初始化，所有 follower 节点都处于 looking 状态，每个节点都会监视集群中的其他节点，以侦听 leader 选举消息</p>
</li>
<li><p>提名，当一个节点启动时，会向其他节点发送投票请求（称为提名）</p>
</li>
<li><p>改投，节点收到其他节点的提名后可以选择投票改投这个节点，也可以不投票，每个节点只能在一个选举周期内投一票</p>
</li>
</ul>
<p>Zookeeper 以事务 ID（zxid）来标识数据的新旧程度（zxid 越大代表节点的数据越新），以数据的新旧程度来标识节点的能力强弱（数据越新代表节点的能力越强）。在投票过程中，节点首先会认为自己最强，先投自己一票并将投票信息（包含了自己的事务 ID zxid 和唯一标识节点自身的 sid）广播出去，当节点接收到其他节点的投票信息时，会将其他节点的 zxid 和自身对比，若其他节点的 zxid 更大，则改投其他节点。</p>
<p>选举过程有多个轮次，每个轮次是一个选举周期，在每个选举周期中，节点根据投票来选择新的 leader 候选，如果一个候选节点获得了超过半数的投票，那么就成为新的 leader，如果没有候选节点成为 leader，那么这个选举周期失败，所有节点会继续进行下一个选举周期。</p>
<p>一旦一个节点成为 leader，会开始处理客户端请求并向其他节点发送 leader 就绪信息，告知其他节点自己成为 leader，其他节点会与新 leader 同步数据（也包括同步未完成的客户端请求），确保所有节点在一个一致的状态下运行。</p>
<h1 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h1><p>Zookeeper 中的数据以目录结构的形式存储，每一个存储数据的节点都称为 ZNode</p>
<ul>
<li><p>ZNode 不支持部分读写，需要一次性完整读写，每个 ZNode 都有一个唯一的路径标识，每个 ZNode 都可以有子 ZNode（和目录类似），ZNode 中可以存储数据和状态信息</p>
</li>
<li><p>ZNode 有 PERSISTENT（持久节点）、PERSISTENT_SEQUENTIAL（持久的连续节点）、EPHEMERAL（临时节点）、EPHEMERAL_SEQUENTIAL（临时的连续节点）这种四种类型，ZNode 的类型在创建时确定并不能修改</p>
</li>
<li><p>持久节点会在创建后一直存在，直到有删除操作来主动清除该持久节点，而临时节点的生命周期与客户端会话绑定，一旦客户端会话失效，那么该临时节点就会自动被清除，临时节点不能有子节点，顺序节点在创建时会自动加上编号</p>
</li>
<li><p>每个 ZNode 都可以配置监视器来监听 ZNode 以及子 ZNode 中的数据和状态变化，一旦这些状态发生变化，服务器就会通知这个 ZNode 上的所有子 ZNode 的监视器，使得每个客户端都能很快知道它所关注的目录节点的变化，从而迅速做出反应</p>
</li>
</ul>
<h1 id="分布式锁"><a href="#分布式锁" class="headerlink" title="分布式锁"></a>分布式锁</h1><p>基于 Zookeeper 的临时有序节点可以实现分布式锁，当多个客户端尝试对某个方法加锁时，Zookeeper 的 leader 节点为每个客户端在该方法对应的指定节点的目录下（并发）创建与客户端相对应的临时有序节点，有序节点中序号最小的那个节点会获得锁，删除这个临时节点即可释放锁</p>
<ul>
<li><p>如果获取到锁的客户端宕机，那么该临时会被自动删除，即自动解锁，因此可以避免服务宕机导致的分布式锁无法释放问题</p>
</li>
<li><p>当一个客户端通过删除临时节点来释放锁之后，下一个节点序号最小的客户端就可以继续获得锁，因此可以实现阻塞的分布式锁</p>
</li>
<li><p>客户端可以判断自身是否已经获得锁来区分是更改锁的重入次数还是创建新的临时有序节点，因此可以实现可重入的分布式锁</p>
</li>
<li><p>Zookeeper 实现的分布式锁在创建和释放时涉及到节点的创建和销毁，这种操作只能通过 leader 节点来执行，然后将数据同步到 follower 节点上，因此性能会差于基于缓存的分布式锁</p>
</li>
</ul>
]]></content>
  </entry>
  <entry>
    <title>2023.4.17 - 2023.4.21</title>
    <url>/2023/04/21/week-34/</url>
    <content><![CDATA[<div class="hbe hbe-container" id="hexo-blog-encrypt" data-wpm="Oh, this is an invalid password. Check and try again, please." data-whm="OOPS, these decrypted content may changed, but you can still have a look.">
  <script id="hbeData" type="hbeData" data-hmacdigest="bba551d319c13273d0bb8f700ab84839298ff51fb55b7751580d3b729a7c875d">a99f2d1cd7f89812758242c57c62a59fe859e32cc19116fcceb1abacce500da0960986acd07eddb3568f524414b51feea94ed3a8842a2a7cb58681a02b461bf770f84ee1401d0da18103907eac52ca775c9e6918f4a56e9ff0f2347f47b29979b66ababcd129ad2bcd5054d4baf07ce3eea083882de9938db42522bd1f086c0154fae24abd7f70144e6f7f822cc0a5695cd170cffb122f5858746c96d2857bcd97dabd7f6a66d2ba9a6ba6620e9e666c5acc90b0ff9c6a1768d2c1c347ca25e63e1cda61ad9f9a6d7e23f52ca783556a8651fdeefc92aa9e090c2fd3ff8c94ae63b8a273872b06dc2b82bb8bedc6348611eebf4208cb5c2acec62b35422a70365b822621d0ecf740cced3e830d12aac7f735d223f382202d34af4f585f04be5e267635e28263e1bc0cd03f14f8a1b84aae40665b4aeea590e09e50d584ba1f0f9714137c050c229a21e688d3c24c9942a5dece907a527f00d7b25f0343413c427e03a597989e9a02621062dc978907e0d765429215e6013ad857b4bf170557b7f0050685a898e01489934c72646daec089dbe114d8b1fd2a010df35cfa441fc4e90133d92f271034df5d7284622a0bf3ad0e26addfcdfaa8db5d6b534cccec8c7d1dba836baf0de650f9780614ed5bed7cedc216bf487b6bcce5955ae4d44563666da357bee9fc9d50ba093fc620dee9ec162db3e346a3a605a495723bc40aa49e7854a1e68fcfcd623fd10b45402235c45c0569be0eac976a46cac9301746a2d1dbc09114fc8da8edea0d07d5fcaf2f867c20b17ceee8f58bbb66d71fbba7a27fe4383ada7fc1b1d4ec687b9b9ae2fa5485455aaa2ba26148d2aa0bb2f1b7d26720f1ac38c5f64a985c564c5d4e588711356f30747679a9e37de9965822e1b8650d2220aa7bf79a0626193eee2c608e934149f45b58d4229c566998f0980b14322d0e536f0458b1312ea4c72775a921edf2aa00c585a35a93bc34fb4a393f13159e7144f33bb5f6b493fdd48a9c7c8f92417d4bce3a51ebc51a41c1def9dcf2bc46598b55d760a735577a54e36ea6e1e07a0e7c293f83c6e191342b2b31f79b6c379d02e982f118f3c02cecb2940d791a1c6c225729b7e602af3f5873dbb3911f553658b7b42d4a14dd77adb1afa6796bd2e2247a230e1380bb03dfeefbaa3c1ee7e6591bc35c75f77b5c4ae6264f56506fc896434dabc23b23ea3a93141451dd07d19a13f367f5e01db3fd3bb4a375184915ace21d0b2bbbb2758b22467585787987b7c7b39924602d7b65d769e4d50051d8cfa597d751b1819b7712ce71688af600912615c1b2021af33917d6df9d23490039fa2d091318abc159b3d39b144eb6e1e0a7da9e5092a65ed44d21000e46653402b2b1f441948a947794087ba8c4f432a5911624cf333682171c415cee8b6278f28d3aa8ecb69e29d91f23babf329bca94a1c6bcf688d0e2abaddb4f3504df561fc72c09368679bf84972360653003a2ecd703a192b1203237b09671ed323585ba277fce3b15b986c08576e41617581a95612688983874eb48a4c07219ef87d9e64e6bda14a185207d820b7b16227423afc2d04179c251edc9ee41df64bdc2326987a7437004ea65a5860108bd37dcd0ae290508cf26e8022a10870471574e83a3c7c863666f6009c227fa28b5f172fe532ae94b795d67cc303723e1b6287f0d63741e15c280def4ede118f9e6aa3eb5bd60f78738bb372c57d2b225d0f365e79c2a2c28d0cf54381c5cc7eb4b9dd0cf55de0d88444a939d6aceb275cc2b9fbcf71414254441145c80fd5701161e342da9a629f30b975d81779323f4b21e63e2c6b9953e705770e7c9c53549ebc4f2a612ac66ef16254ad6c9a29238338df45a00e314455b1827752be7d801cc6f36183e648f831ca874967e04d3a76441ff7c14a3b5e143d1a48ea2d9dffabde5dc474e706aecf42d7139bd20387a611d9c9933d875e5004aa258b526cc3663dd3f691ec8dee2c83273f1b85b84cb030dfccb6c453b006c3020b5c86f031ee6bd51edfbca3e730683b29cfa4317902ca14a6dd8b0b3fc8935f6319492d77be4e59f9b7c713f23e25814f8eb0959c0f00eb2c6c4d4cd563503d6903b34c02db548dfc1608a3aa2038ad3fd559eb52b94f80bcb661cd2954352ae815f689d60e27dfd047c2405f71361165f4a2f7277613de364062ada8a06b4d4e997b77919538ddeb7265bf0fb7d5ed9314ebd3471813845486785c9c88a31eeca316c6f50da727d9a3a74c60e6b967077c732478feef63c4435af3715449e431325364fd6c2d782a66a7adf8f9831492a4af91a97110b7c463d7238ff3089d5eed4e62cd3657667a8cea9c0897774898c2c83ace8915d2deffde85f00cb0027a3f0d581640b</script>
  <div class="hbe hbe-content">
    <div class="hbe hbe-input hbe-input-default">
      <input class="hbe hbe-input-field hbe-input-field-default" type="password" id="hbePass">
      <label class="hbe hbe-input-label hbe-input-label-default" for="hbePass">
        <span class="hbe hbe-input-label-content hbe-input-label-content-default">Hey, password is required here.</span>
      </label>
    </div>
  </div>
</div>
<script data-pjax src="/lib/hbe.js"></script><link href="/css/hbe.style.css" rel="stylesheet" type="text/css">]]></content>
  </entry>
</search>

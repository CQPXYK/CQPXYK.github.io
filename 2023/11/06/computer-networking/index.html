<!DOCTYPE html>
<html>
  <head>
  <meta http-equiv="content-type" content="text/html; charset=utf-8">
  <!--<meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport">-->
  <meta name="description" content="要有一个从输入到输出的过程">
  <meta name="keyword" content="">
  
    <link rel="shortcut icon" href="/css/images/logo.png">
  
  <title>
    
      Computer Networking | CQ&#39;s Blog
    
  </title>
  <link href="//cdnjs.cloudflare.com/ajax/libs/font-awesome/4.7.0/css/font-awesome.min.css" rel="stylesheet">
  <link href="//cdnjs.cloudflare.com/ajax/libs/nprogress/0.2.0/nprogress.min.css" rel="stylesheet">
  <link href="//cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/tomorrow.min.css" rel="stylesheet">
  
<link rel="stylesheet" href="/css/style.css">

  
  <script src="//cdnjs.cloudflare.com/ajax/libs/jquery/3.2.1/jquery.min.js"></script>
  <script src="//cdnjs.cloudflare.com/ajax/libs/geopattern/1.2.3/js/geopattern.min.js"></script>
  <script src="//cdnjs.cloudflare.com/ajax/libs/nprogress/0.2.0/nprogress.min.js"></script>
  
  
  
  


  
  
    
<script src="/js/local-search.js"></script>


<meta name="generator" content="Hexo 5.4.2"></head>
<div class="wechat-share">
  <img src="/css/images/logo.png" />
</div>
  <body>
    <header class="header fixed-header">
  <div class="header-container">
    <a class="home-link" href="/">
      <div class="logo"></div>
      <span>CQ's Blog</span>
    </a>
    <ul class="right-list">
      
        <li class="list-item">
          
            <a href="/" class="item-link">Home</a>
          
        </li>
      
        <li class="list-item">
          
            <a href="/categories/" class="item-link">Categories</a>
          
        </li>
      
        <li class="list-item">
          
            <a href="/records" class="item-link">Records</a>
          
        </li>
      
        <li class="list-item">
          
            <a href="/scratches/" class="item-link">Scratches</a>
          
        </li>
      
        <li class="list-item">
          
            <a href="/archives/" class="item-link">Archives</a>
          
        </li>
      
      
        <li class="menu-item menu-item-search right-list">
    <a role="button" class="popup-trigger">
        <i class="fa fa-search fa-fw"></i>
    </a>
</li>
      
    </ul>
    <div class="menu">
      <span class="icon-bar"></span>
      <span class="icon-bar"></span>
      <span class="icon-bar"></span>
    </div>
    <div class="menu-mask">
      <ul class="menu-list">
        
          <li class="menu-item">
            
              <a href="/" class="menu-link">Home</a>
            
          </li>
        
          <li class="menu-item">
            
              <a href="/categories/" class="menu-link">Categories</a>
            
          </li>
        
          <li class="menu-item">
            
              <a href="/records" class="menu-link">Records</a>
            
          </li>
        
          <li class="menu-item">
            
              <a href="/scratches/" class="menu-link">Scratches</a>
            
          </li>
        
          <li class="menu-item">
            
              <a href="/archives/" class="menu-link">Archives</a>
            
          </li>
        
      </ul>
    </div>
    
      <div class="search-pop-overlay">
    <div class="popup search-popup">
        <div class="search-header">
            <span class="search-icon">
                <i class="fa fa-search"></i>
            </span>
            <div class="search-input-container">
                <input autocomplete="off" autocapitalize="off"
                    placeholder="Please enter your keyword(s) to search." spellcheck="false"
                    type="search" class="search-input">
            </div>
            <span class="popup-btn-close">
                <i class="fa fa-times-circle"></i>
            </span>
        </div>
        <div id="search-result">
            <div id="no-result">
                <i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i>
            </div>
        </div>
    </div>
</div>
    
  </div>
</header>

    <div id="article-banner">
  <h2>Computer Networking</h2>
  <!--<p class="post-date">2023-11-06</p>
  <div class="arrow-down">
    <a href="javascript:;"></a>
  </div>-->
</div>
<main class="app-body flex-box">
  <!-- Article START -->
  <article class="post-article">
    <section class="markdown-content"><h1 id="1、概述"><a href="#1、概述" class="headerlink" title="1、概述"></a>1、概述</h1><p><strong>因特网</strong>是一个世界范围的计算机网络，互联了遍及全世界的数十亿计算设备，是网络的网络。因特网所连接的这些设备（不一定是计算机）称为<strong>主机 host 或端系统</strong>，因特网应用就运行在这些端系统上（分布式应用涉及多个相互交互数据的端系统），端系统提供了一个套接字接口，该接口规定了运行在一个端系统上的应用程序向运行在另一个端系统上的特定应用交付数据的方式。</p>
<p><strong>端系统</strong>通过<strong>通信链路和分组交换机</strong>的网络连接到一起，通信链路由不同类型的物理媒介（同轴电缆、铜线、光纤和无线电频谱）组成，这些通信链路能够以不同的传输速率（以比特/秒 bps 度量）传输在端系统之间交换报文，发送端系统将报文划分为较小的数据块（称为分组 packet），分组交换机从它的一条入通信链路接收到达的 packet，根据 packet 的目的地的 IP 地址和转发表找到对应的出通信链路，转发该 packet，packets 在目的端系统被装配成初始数据。</p>
<p>大多数<strong>分组交换机</strong>在链路的输入端使用存储转发传输机制，即交换机在向输出端链路传输该 packet 的第一个比特之前，必须接收到整个 packet。分组交换机对于每条相连的链路都具有一个输出缓存，用于存储准备发往该链路的 packet，因此，除了存储转发时延以外，packet 还要经历输出缓存的排队时延，排队时延是变化的，变化的程度取决于网络的拥塞等级，此外由于缓存的大小是有限的，当缓存空间已满时，新到的 packet 或者已经在排队的 packet 就会被丢弃。如今常见的分组交换机是路由器和链路层交换机，路由器通常用于网络核心，链路层交换机通常用于接入网中。</p>
<p><strong>接入网</strong>指将端系统物理连接到其边缘路由器（边缘路由器是端系统到任何其他远程端系统的路径上的第一台路由器）的网络。很多公司、校园以及家庭端使用局域网（LAN）将端系统连接到边缘路由器，不过以太网是目前最流行的接入技术。在基于 IEEE 802.11 技术的无线 LAN（又称 WiFi）环境中，无线用户从/到一个接入点发送/接收分组，该接入点与企业网（很可能是有线以太网）连接，企业网再与有线因特网相连，无线 LAN 用户通常必须位于距离接入点几十米的范围内。用户在移动环境中采用广域无线/蜂窝接入网（3G、LTE 4G 和 5G），即通过蜂窝网提供商运营的基站来发送和接收分组，用户仅需位于距离基站数万米范围内。</p>
<p><strong>因特网服务提供商（ISP）</strong>是一个由多台分组交换机和多段通信链路组成的网络，是端系统和更大的因特网之间的桥梁。每个 ISP 网络都是独立管理的，ISP 与 ISP 之间都是互联的，较低层的 ISP 通过较高层的 ISP 互联，较高层的 ISP 通过高速光纤链路彼此直接互联，接入网就是位于最底层的接入 ISP，各种接入 ISP 为端系统提供了不同类型的网络接入，我国每个城市有接入 ISP，再往上可以是区域 ISP、省级 ISP、国家级 ISP 以及全球传输的第一层 ISP。较低层的 ISP 和较高层的 ISP 之间是客户和提供商之间的付费关系，除第一层 ISP 以外的任何 ISP 都可以通过多宿（与多个提供商 ISP 相连）来增强稳定性，位于相同层级的邻近的一对 ISP 能直接相连实现对等，从而避免它们之间的流量向上层传输，多个 ISP 可以以因特网交换点（IXP）作为汇合点来一起实现对等，对等的 ISP 之间无需付费。</p>
<p>计算机网络必定要限制在端系统之间的<strong>吞吐量（bps）</strong>，会在端系统之间引入<strong>时延</strong>，且不可避免的会<strong>丢失 packet</strong>。所有的 packet 在每个节点上都经受了几种不同类型的时延，比较重要的是节点处理时延（检查 packet 并找到出链路）、排队时延（排队等待传输，过大则丢包）、传输/发射时延（将 packet 的所有比特推向链路）以及传播时延（比特从起点到下一跳所需要的时间），这些时延累加起来是节点总时延。吞吐量指端与端之间交付比特的速率，为了避免流量在某一个节点上堆积，因此比特从源向目的地的流动速率/吞吐量取决于所有途径的链路中的最小的链路速率以及链路上的干扰流量，今天因特网中对吞吐量的限制因素通常是接入网。</p>
<p>为了处理这些吞吐量、时延以及丢包问题，所有的因特网部件都要运行多个<strong>协议</strong>，这些协议定义了通信实体之间交换的报文的格式和顺序，以及报文的发送和接收等事件所采取的操作，从而控制着因特网中信息的接收和发送（主要协议统称为 TCP/IP 协议，因特网标准由 IETF 研发，IETF 的标准文档称为 RFC）。网络设计者以分层的方式组织协议，每个协议属于这些层次之一，每层协议通过自身执行某些操作或使用直接下层的服务来向上一层提供服务，各层的所有协议被称为协议栈，因特网的协议栈由物理层、链路层、网络层、运输层和应用层组成。</p>
<p>应用层是网络应用程序及它们的应用层协议存留的地方，应用层协议分布在多个端系统上，端系统的应用程序使用协议与另一个端系统中的应用程序交换分组，称为报文。运输层在应用程序端点之间传送分组，称为报文段。网络层负责在主机和主机之间传送分组，称为数据报。链路层沿着路径在节点之间传递分组，称为帧。物理层在物理传输媒介上移动帧的一个个比特。一个协议层能够用硬件、软件或两者结合来实现，应用层、运输层这样的高层协议几乎总是在端系统中用软件实现，网络层通常是硬件和软件实现的混合体，数据链路层、物理层通常在给定链路相关联的网络接口卡中实现。主机实现了所有层次的协议，路由器实现了网络层以及以下的协议，链路层交换机实现了链路层及以下的协议。</p>
<h1 id="2、应用层"><a href="#2、应用层" class="headerlink" title="2、应用层"></a>2、应用层</h1><h2 id="2-1-基本原理"><a href="#2-1-基本原理" class="headerlink" title="2.1 基本原理"></a>2.1 基本原理</h2><p>网络应用是计算机网络存在的理由，<strong>虽然网络体系结构是固定的（为应用程序提供了特定的服务集合），但应用体系结构由应用程序研发者设计</strong>，这规定了如何在各种端系统上组织该应用程序，主流的应用体系结构是 C/S（典型例子包括 FTP、电子邮件、Web 应用等，服务器一般设为托管大量主机的能够保证提供服务的数据中心）和 P2P（典型例子是 BitTorrent）。</p>
<p>网络应用程序由成对的运行在不同端系统（可能具有不同的操作系统）上的进程组成，这些进程通过一个称为<strong>套接字</strong>的软件接口向网络发送报文和从网络接收报文，从而跨越计算机网络交换报文而相互通信。套接字是同一台主机内应用层与运输层之间的可编程接口（也称为应用程序和网络之间的 API），应用程序开发者可以控制套接字在应用层端的一切，但对运输层的控制仅限于选择运输层协议和设定一些如最大缓存和最大报文段长度的运输层参数（此外，应用程序开发者对该套接字的运输层端几乎没有控制权），一旦应用层报文进入套接字，该报文就脱离了应用层控制并进入运输层控制。</p>
<p><strong>应用层协议</strong>定义了交换的报文类型（例如请求还是响应）、各种报文类型的语法（例如报文的各个字段）、字段的语义、发送和响应报文的规则、与该协议关联的周知端口号等，公用的应用层协议由 RFC 文档定义。<strong>应用进程的地址</strong>包含主机的地址和进程标识符，在因特网中，主机的地址为 IP 地址，进程标识符为端口号。端口号是一个 16 比特的数（范围是 0 ~ 65535），当应用使用由 RFC 文档定义的公用应用层协议时，应当使用与该协议关联的周知端口号（范围是 0 ~ 1023），而当应用使用专有的独立应用层协议时，应当避免使用这些周知端口号。</p>
<p>运输层协议需要为应用程序的数据传输提供<strong>可靠与否、吞吐量、定时和安全性</strong>这四个方面的服务。比如电子邮件、文件传输等应用要求可靠交付，但不要求特定吞吐量（属于弹性应用），多媒体应用则对吞吐量有特殊要求（属于带宽敏感应用），电话、视频会议、多方游戏等应用有严格的时间限制。因特网为应用程序提供 UDP 和 TCP 这两个运输层协议，<strong>UDP 提供尽最大努力不确保可靠交付服务，TCP 提供面向连接服务和可靠交付服务</strong>；TCP 和 UDP 都<strong>不提供对吞吐量和定时方面的保证性服务</strong>（但通常能够为带宽敏感和时间敏感应用<strong>提供满意的服务</strong>）；也<strong>不提供任何安全性服务</strong>，<strong>安全性由应用层的 TLS 提供</strong>，TLS 有它自己的套接字 API，类似于传统的 TCP 套接字 API，当一个应用使用 TLS 时，发送进程向 TLS 套接字传递明文数据，发送主机中的 TLS 则加密该数据，并将加密的数据传递给 TCP 套接字，加密的数据经由因特网传送到接收进程中的 TCP 套接字，该接收套接字将加密数据传递给 TLS，由其进行解密，最后 TLS 套接字将明文数据传递给接收进程。</p>
<p>在应用程序研发阶段，开发者需要先确定应用程序是运行在 TCP 上还是 UDP 上，对于基于 UDP 的应用来说</p>
<ul>
<li>发送报文进入客户端套接字时，应用程序代码应当显式地将目的进程地址附上，源进程地址则由底层操作系统自动将其附上（无需由应用程序代码显式处理）</li>
<li>在服务器端接收到客户端所发送报文之前，应用程序代码应当显式地为服务器端套接字绑定一个接收端口号，那么该套接字即可接收到任何向位于服务器的 IP 地址的该端口所发送的报文</li>
<li>客户端套接字在连接结束后关闭，服务器端套接字始终开启不会关闭，UDP 套接字是由一个包含目的进程地址的二元组来标识的</li>
</ul>
<p>对于基于 TCP 的应用来说</p>
<ul>
<li>在建立 TCP 连接时，客户端创建一个 TCP 套接字并指定服务器“欢迎”套接字地址，源进程地址则由底层操作系统自动将其附上（无需由应用程序代码显式处理）</li>
<li>服务器端会为每个来自客户端的 TCP 连接请求生成一个“新生”套接字用于后续与该客户端进行通信，运输层的三次握手令客户端套接字就和服务器端“新生”套接字关联起来，后续传输数据时无需再由应用程序显式附上目的地址</li>
<li>客户端套接字和服务器端“新生”套接字在连接结束后关闭，服务器端“欢迎”套接字始终开启不会关闭，TCP 套接字是由一个包含源进程地址和目的进程地址的四元组来标识的</li>
</ul>
<h2 id="2-2-Web-应用"><a href="#2-2-Web-应用" class="headerlink" title="2.2 Web 应用"></a>2.2 Web 应用</h2><p><strong>Web 页面</strong>（又称文档）由对象组成，一个对象就是一个文件（例如 HTML 文件、JPEG 文件、JavaScript 文件、CSS 样式表文件、视频文件等），每个对象文件都可通过一个 URL 寻址，URL 由存放对象的服务器主机名和对象的路径名组成。Web 应用使用 C/S 应用程序体系结构，Web 服务器总是打开的，具有一个固定的 IP 地址。Web 应用使用的应用层协议是 HTTP（[REC 1945]、[REC 7230]、[REC 7540]）。</p>
<p>HTTP 由运行在不同端系统中的客户程序和服务器程序这两个程序实现，定义了在 Web 浏览器（实现了 HTTP 客户端）和 Web 服务器（实现了 HTTP 服务器端）之间请求和传送 Web 页面的方式，并使用 TCP 作为运输层协议支撑。HTTP 是一个<strong>无状态</strong>协议，即 HTTP 服务器端仅仅只是向客户发送被请求的对象文件，而不存储任何关于该客户的状态信息，这简化了服务器的设计，允许 Web 服务器同时处理数千个 TCP 连接。客户端可能以规则的间隔周期性地或者间断性的发出一些列请求，若所有的请求/响应对分别经过一个单独的 TCP 连接发送则称为非持续连接，若所有的请求/响应对都经过同一个 TCP 连接流水线式的发送则称为持续连接，HTTP <strong>默认使用持续连接</strong>，但也能通过配置使用非持续连接。</p>
<p><strong>HTTP 请求报文</strong>的第一行叫作请求行（request line），请求行有方法、URL 和 HTTP 版本这三个字段；请求行之后是一些首部行（header line），首部行可以指明请求对象所在的主机（这是 Web 代理高速缓存所要求的）、是否使用非持续连接、用户代理（即发送请求的浏览器的类型）等；首部行后为实体体（entity body）。GET 方法的实体体为空，POST 方法的实体体为一些和请求相关的内容（所请求的 Web 页面的特定内容依赖于该实体体中的内容），HEAD 方法并不请求具体 Web 对象，仅仅只需要服务返回一个 HTTP 报文进行响应，常用于调试跟踪，PUT 方法允许上传对象到指定的 Web 服务器上指定的路径，常用于与 Web 发行工具联合使用，DELETE 方法允许删除 Web 服务器上的对象。</p>
<p><strong>HTTP 响应报文</strong>的第一行叫作初始状态行（status line），状态行有 HTTP 版本、状态码和状态信息这三个字段；初始状态行之后是一些首部行，首部行指明了发送完报文后是否关闭该 TCP 连接，服务器产生并发送响应报文的时间、服务器代理、对象创建或最后修改的时间、被发送对象中的字节数，对象类型等；首部行之后为实体体，实体体是报文的主要部分，包含了所请求的对象本身。301 代表请求的对象已经被永久转移了，新的 URL 定义在响应报文的“Location：”首部行中；400 是一个通用差错代码，服务器不能理解该请求；404 代表请求的文档不在服务器上；505 代表服务器不支持请求报文所使用的 HTTP 版本。</p>
<p>HTTP 规范中定义了很多<strong>首部行</strong>，这些首部行可以被浏览器、Web 服务器和网络缓存服务器插入，客户端和服务器端的具体使用产品、版本和配置都会影响到首部行的内容。</p>
<p>HTTP 作为一个无状态协议可以通过 <strong>cookie</strong> 在允许站点对用户进行跟踪，用户首次访问一个站点时，可能需要提供一个用户标识，站点会产生一个唯一识别码并以此作为索引在后端数据库中产生一个表项，接下来会在 HTTP 响应报文中定义一个“Set-cookie：”首部行（包含有该识别码），客户端系统会保留并管理一个 cookie 文件，当接收到包含该识别码的响应报文时，会在其 cookie 文件中添加一行，在后续的 HTTP 请求报文中也都会定义一个“Cookie：”首部行（包含有该识别码），针对后续的请求，服务器端通过查询后端数据库来获取该用户在该站点的历史活动（购物车），因此 cookie 可以在无状态的 HTTP 之上建立一个用户会话层。</p>
<p><strong>Web 缓存器</strong>（又称代理服务器）有自己的磁盘存储空间，并在存储空间中保存最近请求过的对象的副本，可以通过配置令用户浏览器的 HTTP 请求首先指向 Web 缓存器，若 Web 缓存器存储有请求需要的对象，则直接响应该请求，若没有，则由 Web 缓存器向服务器发送 HTTP 请求，得到响应后在本地存储空间存储一份副本，并向客户浏览器响应。Web 缓存器通常由 ISP 购买并安装到该 ISP 网络中，将该 ISP 网络上的用户浏览器配置为通过高速局域网直接指向 Web 缓存器而非通过低速公共因特网指向服务器，由于客户和服务器之间的瓶颈带宽远低于客户和 Web 缓存器之间的瓶颈带宽，可以大大减少对客户请求的响应时间。HTTP 允许通过<strong>条件 GET</strong>（请求报文中包含“If-modified-since：”首部行）来证实请求对象是最新的，当浏览器请求的对象在缓存器中缓存时间较久时，会向服务器发送条件 GET 请求执行最新检查。</p>
<p><strong>HTTP/1.1</strong> 使用持续 TCP 连接，允许经单一 TCP 连接将一个 Web 页面从服务器发送到客户，由于每个 Web 页面仅用一个 TCP 连接，所传送的每个 Web 页面平等共享网络带宽，但此时同一个 TCP 连接中位于请求队首的大对象会阻塞后面的小对象，为了避免该阻塞需要打开多个并行的 TCP 连接，此时，小对象到达并呈现在浏览器上的速度要快很多，可以减小用户感知时延。<strong>HTTP/2</strong> 通过将每个报文分成小帧并在同一 TCP 连接上交错发送请求和响应报文并在接收端将其装配起来，允许客户为正在请求的响应确定优先次序，此外还允许服务器自行根据用户的一个请求内容来发送多个相关的响应而无需等待用户来发送其余相关请求，这些设计避免了小对象阻塞，减小了感知时延，摆脱了 HTTP/1.1 的并行 TCP，减小了 TCP 数量，服务器的套接字数量被压缩。</p>
<h2 id="2-3-视频流"><a href="#2-3-视频流" class="headerlink" title="2.3 视频流"></a>2.3 视频流</h2><p>视频是以一种恒定速率来展现的一系列图像，图像由像素阵列组成，每个像素由一些比特编码来表现亮度和颜色，可以用比特率来权衡视频质量，比特率越高，图像质量越好，用户的总体视觉感受越好。在<strong>流式视频应用</strong>中，预先录制的视频放置在服务器上，用户按需向这些服务器发送请求来观看视频，流式视频最为重要的性能度量是平均端到端吞吐量。</p>
<p>在 HTTP 流中，视频只是存储在 HTTP 服务器中作为一个普通的文件，当服务器在响应报文中发送该视频文件对象，客户侧不断将字节收集在客户应用缓存中，一旦该缓存中的字节数量超过预先设定的门限，客户应用程序就开始播放，流式视频应用周期性地从客户应用程序缓存中抓取帧，对这些帧解压缩并在用户屏幕上展现，此时，即便是拥有不同可用带宽的客户，客户接收的都是相同版本的视频压缩文件。而在 <strong>DASH</strong> 中，视频编码为几个比特率不同的版本文件（具备不同的 URL，对应不同的质量水平），在客户与服务器建立 TCP 连接后，服务器会先向客户发送具有 URL 列表的告示文件，客户即可动态地请求来自不同版本且长度为几秒的视频数据块（在请求报文中指定 URL 和字节范围），当客户可用带宽较高时，客户自然选择来自高速率版本的块，当可用带宽较低时，客户选择来自低速率版本的块，这种机制允许客户使用不同的接入速率流式播放具有不同编码速率的视频，即在不同质量等级之间自由切换。</p>
<p>为了应对向分布于全世界用户分发巨量视频数据的挑战，几乎所有主要的视频流公司都利用<strong>内容分发网 CDN</strong>，CDN 管理着分布在多个地理位置上的服务器集群，这些集群中存储着视频的副本，一般被安置在接入 ISP 或 IXP。CDN 通过 DNS 来截获用户请求，并根据用户的本地 DNS 服务器的 IP 地址来试图将用户请求都重定向到一个将提供最好用户体验的 CDN 集群节点位置 。</p>
<h2 id="2-4-电子邮件"><a href="#2-4-电子邮件" class="headerlink" title="2.4 电子邮件"></a>2.4 电子邮件</h2><p>电子邮件是一个异步通信媒介，使用了多个应用层协议，因特网电子邮件系统由用户代理、邮件服务器和 SMTP 这三个部分组成，<strong>用户代理</strong>允许用户阅读、回复、转发、保存和撰写报文；<strong>邮件服务器</strong>上有一个邮箱，用于管理和维护发送给自身的报文；<strong>SMTP</strong> 是因特网电子邮件中主要的应用层协议。</p>
<p><strong>SMTP</strong> 使用 TCP 可靠数据传输服务，运行在发送方邮件服务器的客户端和接收方邮件服务器的服务器端，这意味双方的邮件服务器必须使用保持开机。SMTP 不使用中间邮件服务器发送邮件，而是发送方邮件服务器和接收方邮件服务器直接相连，这意味着邮件并不在某个中间邮件服务器中留存。SMTP 限制邮件报文的体部分（不只是其首部）只能采用简单的 7 比特的 ASCII 表示，即在用 SMTP 传送邮件之前，需要将二进制多媒体数据编码为 ASCII 码，并且在使用 SMTP 传输后要求将相应的 ASCII 码邮件解码还原为多媒体数据。邮件的环境信息（双方地址、日期等）包括在一系列首部行中，首部行和 ASCII 格式的报文体用空行（回车 CR 和换行 LF）进行分隔。</p>
<p>发送方将撰写完成的邮件通过 SMTP/HTTP 从用户代理传输到发送方的邮件服务器（邮件放置在邮件服务器的外出报文队列中），通过 SMTP 再传输到接收方的邮件服务器，邮件接收者可以调用自己的用户代理通过 HTTP/IMAP 在自己的邮件服务器的邮箱中取得该报文（取报文是拉操作，SMTP 是推协议，故不能使用 SMTP）。当发送方的邮件服务器经过多次重试失败而确认接收方的邮件服务器存在故障时，发送方邮件服务器会删除该报文并以电子邮件的形式通知发送方，这种确保交付的机制必须依赖于发送方邮件服务器这一中继，因此邮件不能直接由发送方用户代理直接传输到接收方邮件服务器。典型的用户通常与其他用户共享总是保持开机的<strong>共享邮件服务器</strong>，在本地 PC 上运行用户代理程序来访问共享邮件服务器上的邮箱。</p>
<h2 id="2-5-域名系统"><a href="#2-5-域名系统" class="headerlink" title="2.5 域名系统"></a>2.5 域名系统</h2><p>因特网主机可以通过主机名或者 IP 地址进行标识，DNS 是一个能进行因特网主机名/主机别名（人类好记的名字）到 IP 地址转换的<strong>目录服务</strong>，此外还基于冗余服务器（相同主机名对应一系列多个 IP 地址）提供<strong>负载均衡</strong>分配功能（返回不同的 IP 地址）。大多数用户不直接与 DNS 打交道，而是通过其他应用间接使用它，比如浏览器需要通过 DNS 将服务器名转换为服务器 IP 地址之后再向该 IP 地址发起 TCP 连接。DNS 由 DNS 服务器所实现的<strong>分布式数据库</strong>（是分布式数据库的精彩范例）和使得主机能够查询分布式数据库的<strong>应用层协议</strong>组成。</p>
<p><strong>DNS 服务器</strong>通常是运行 BIND 软件的 UNIX 机器，大量分布于全球并以层次结构组织，该层次结构中存在根 DNS 服务器、顶级域 DNS 服务器和权威 DNS 服务器这三种类型的 DNS 服务器。本地 DNS 服务器（又称默认名字服务器）并不属于 DNS 服务器的层次结构，但每一个 ISP 都有一台本地 DNS 服务器，当主机与某个 ISP 连接时，该 ISP 提供一台主机的 IP 地址，该主机具有一台或多台其本地 DNS 服务器的 IP 地址，主机的本地 DNS 服务器就是“邻近”DNS 服务器。主机的 DNS 请求都被转发到本地 DNS 服务器上，本地 DNS 服务器会首先与根服务器之一联系，获得请求域名所在的顶级域名服务器的 IP 地址，接着与顶级域名服务器之一联系，获得请求域名所在的权威域名服务器的 IP 地址，接着与权威域名服务器之一联系，获得请求域名所对应的 IP 地址，最后本地 DNS 服务器将获得的 IP 地址返回给请求主机。</p>
<p>想通过 DNS 获得的 IP 地址一般缓存在一个“邻近”DNS 服务器中，<strong>DNS 缓存</strong>有助于减少 DNS 的网络流量和 DNS 的平均时延，在一个 DNS 请求链中，当某 DNS 服务器接收到一个 DNS 回答（包含某主机名到 IP 地址的映射）时，就将映射缓存在本地存储器中，由于这种映射并不是永久的， DNS 服务器在一段时间（通常为两天）后将丢弃缓存的信息。</p>
<p>共同实现 <strong>DNS 分布式数据库</strong>的所有 DNS 服务器存储了<strong>资源记录</strong>，每个 DNS 回答报文包含了一条或多条资源记录，资源记录提供了主机名到 IP 地址的映射，包含 Name、Value、Type、TTL 这四个字段。TTL 是该资源记录的生存时间，决定了资源记录应当从缓存中删除的时间，Name 和 Value 的意义取决于 Type。如果 Type = A，那么 Name 为主机名，Value 为主机名对应的 IP 地址；如果 Type = NS，那么 Name 为域，Value 为知道如何获得该域中主机 IP 地址的权威 DNS 服务器的主机名（用于沿着查询链来路由 DNS 查询）；如果 Type = CNAME，那么 Name 为主机别名，Value 为规范主机名；如果 Type = MX，那么 Name 为邮件服务器别名，Value 为邮件服务器规范主机名。注册登记机构是一个验证域名唯一性的商业实体，会将域名以及域名所在的权威 DNS 服务器的名字和 IP 地址输入 DNS 数据库，对提供的服务收取少量费用。</p>
<p><strong>DNS 协议</strong>运行在 UDP 之上，如果没有接收到响应，则要么试图向另一个 DNS 服务器发送查询，要么通知调用的应用程序它不能获得响应。DNS 查询报文和回答报文具有相同的格式，报文中分别有首部区域（标识了该查询以及当前是查询报文还是回答报文等信息）、问题区域（包含了正在进行的查询信息）、回答区域（包含了对最初请求的名字的所有资源记录）、权威区域（包含了其他权威服务器的记录）、附加信息（包含了其他有帮助的记录）。</p>
<h2 id="2-6-文件分发"><a href="#2-6-文件分发" class="headerlink" title="2.6 文件分发"></a>2.6 文件分发</h2><p>在 P2P 体系结构下，受用户控制的主机彼此直接通信，无需依赖于总是打开的基础设施服务器。在 P2P 文件分发中，每个对等方能够向任何其他对等方重新分发它已经收到的该文件的任何部分，从而协助分发过程。到 2020 年至，最为流行的 P2P 文件分发协议是 <strong>BitTorrent</strong>。BitTorrent 将参与一个特定文件分发的所有对等方的集合被称为一个洪流，在一个洪流中的对等方彼此下载等长度的文件块（典型的块长度为 256 KB），每个<strong>洪流</strong>具有一个基础设施节点，称为追踪器。</p>
<p>当一个对等方首次加入一个洪流时会向追踪器注册自己并周期性地通知洪流它仍在该洪流中，追踪器会随机地从参与对等方的集合中选择对等方的一个子集并将该子集中对等方的 IP 地址发送给新加入的对等方，新对等方会试图与该子集中的所有对等方创建并行的 TCP 连接，所有这样与新对等方成功创建 TCP 连接的对等方称为邻近对等方，每个对等方的邻近对等方会随时间而变化。对等方会随时间逐渐累积了越来越多的文件块，下载块的同时也为其他邻近对等方上载块。对等方随时可以离开洪流，可以离开后重新加入洪流，也可以一直留在洪流中。</p>
<p>对等方会周期性地询问每个邻近对等方它们所具有的块列表，并对自己当前还没有的块在邻居中决定出最稀缺的块（就是那些在邻居中副本数量最少的块）发出请求，最稀缺的块得到更为迅速的重新分发，从而大致均衡每个块在洪流中的副本数量。对等方对于每个邻居都持续地测量接收到比特的速率，并确定以最高速率流入的 4 个邻居（被称为疏通），对等方会周期性重新计算流入速率并可能修改疏通，也会周期性随机选择疏通以外的邻居（被称为试探）并向其发送数据块，除了疏通和试探这 5 个对等方以外，所有其他的邻居对等方均被阻塞，这种关于交换的激励机制使得对等方能够以趋向于找到彼此的协调的速率上载。</p>
<h1 id="3、运输层"><a href="#3、运输层" class="headerlink" title="3、运输层"></a>3、运输层</h1><h2 id="3-1-基本原理"><a href="#3-1-基本原理" class="headerlink" title="3.1 基本原理"></a>3.1 基本原理</h2><p><strong>运输层</strong>为运行在不同主机上的应用进程提供逻辑通信，多个同时运行的应用进程分别对应不同的套接字（也可以令同一进程的多个线程对应不同套接字），发送端运输层通过发送端各个不同的套接字接收到来自发送端各个应用进程的报文，将这些报文划分为小块并为每个数据块分别加运输层首部从而转换成报文段（这称为<strong>多路复用</strong>），将这些报文段传递给发送端网络层，接收端网络层从数据报中提取运输层报文段，并将该报文段向上交给接收端运输层，接收端运输层从接收到的报文段中找到套接字标识，从而将报文段递交给特定的接收端套接字，报文段由此被定向到接收端特定应用进程（这称为<strong>多路分解</strong>）。</p>
<p>运输层的多路复用与多路分解源自于单一的<strong>运输层协议</strong>需要为高层的多个协议提供统一的服务，这也要求每个报文段都有特殊字段（源端口号和目的端口号）来指示该报文段所对应的发送接收套接字。运输层协议只在发送端系统和接收端系统中工作而对分组在发送接收端以外如何移动并不关心，发送接收端以外的其他端系统以及中间路由器也不识别分组中的运输层首部。虽然运输层协议所能够提供的服务常常受制于网络层协议所提供的服务，且网络层协议往往是不可靠的（比如丢失、篡改、乱序等），但是运输层协议依旧能为应用程序提供某方面可靠的（比如确保交付、差错检查等）数据传输服务 。</p>
<h2 id="3-2-UDP-和-TCP"><a href="#3-2-UDP-和-TCP" class="headerlink" title="3.2 UDP 和 TCP"></a>3.2 UDP 和 TCP</h2><p>由于不能保证所有的通信链路都提供差错检测，也不能保证数据在某台主机或者路由器的内存中没有引入差错，因此需要由运输层协议提供<strong>端到端的差错检测</strong>。因特网为应用程序提供 UDP 和 TCP 这两个运输层协议，UDP 和 TCP 都可以通过在其报文段首部中包括差错检查字段（检验和）而提供<strong>完整性检查</strong>。UDP 只是做了运输层协议能够做的最少工作，仅提供进程到进程的数据交付和差错检查这两种最低限度的运输层服务，并不确保完整无缺的数据交付，对检测出的差错报文段直接丢弃而无恢复能力，也无法控制流量。TCP 在不可靠的（IP）端到端网络层之上提供<strong>可靠、完整、正确、按序的数据交付</strong>，此外还为整个因特网提供<strong>拥塞控制</strong>服务，防止任何一条 TCP 连接用过多流量来淹没通信主机之间的链路和交换设备，力求为每个通过一条拥塞网络链路的连接平等地共享网络链路带宽。</p>
<p>网络层及以下的底层信道模型往往复杂且不可靠，基于差错检测、肯定确认以及否定确认的<strong>自动重传请求（ARQ）</strong>协议可以确保完整、正确的数据交付，即由接收方根据差错检查的结果返回不同的反馈，针对出现比特受损的情况，接收方就可以通过发送 NAK 来要求发送方重传，当发送方收到含糊不清的 ACK 或者 NAK 时都会重传当前的分组，发送方只有准确接收到 ACK 时才能继续发送新数据。此外，几乎现在所有的数据传输协议都会在分组中添加分组编号，因此，接收方可以通过检查分组号来确定接收到的分组是否为重传从而处理冗余，发送方可以通过一定时间是否接收到某分组号的 ACK 来判断是否丢包是否重传该分组，这也要求发送方在每次发送一个分组时便启动一个定时器。</p>
<p>为了提高数据交付的时延，发送方可以在还未接收到 ACK 时就发送新的分组，这种发送流水线要求发送方发送的每个非重传的分组必须有唯一的序号，发送方需要缓存那些已发送但还未接收到 ACK 的分组，接收方也需要缓存那些已正确接收的分组。此时，可以通过<strong>回退 N 步</strong>和<strong>选择重传（SR）</strong>来进行流水线的差错恢复。</p>
<p>由于 UDP 不具备拥塞控制，会将应用层数据处理后立即将其传递给网络层，而 TCP 在传输数据之前需要先经过三次握手建立连接，在链路拥塞以及丢包时会拉长数据交付的时延，因此 UDP 发送数据的时间控制则更为准确；由于 UDP 是无连接的，无需像 TCP 那样维护众多连接状态信息，也不跟踪各种收发参数，UDP 首部开销较 TCP 更小，因此运行在 UDP 之上的应用程序所在服务器往往能支持更多的活跃用户；此外，即便 UDP 没能提供某种可靠服务，依旧可以通过应用程序自身来建立可靠性机制，此时，基于 UDP 的应用程序既可以进行可靠通信，也无须受制于 TCP 拥塞控制机制强加的传输速率限制。综上所述，TCP 并非总是首选的。</p>
<p><em>网络层为不同主机提供逻辑通信，网络层将报文段封装成数据报并向目的地发送，网络路由器仅作用于该数据报的网络层字段，而不检查封装在该数据报中的运输层报文段。因特网网络层的网际协议（IP 协议）的服务模型是尽力而为的交付服务，但并不做任何确保。每台主机至少有一个网络层地址（IP 地址）。</em></p>
<h1 id="X、参考资料"><a href="#X、参考资料" class="headerlink" title="X、参考资料"></a>X、参考资料</h1><ul>
<li>《Computer Networking, A Top-Down Approach Eighth Edition》</li>
</ul>
</section>
    <!-- Tags START -->
    
    <!-- Tags END -->
    <!-- NAV START -->
    
  <div class="nav-container">
    <!-- reverse left and right to put prev and next in a more logic postition -->
    
      <a class="nav-left" href="/2023/11/05/history-vocabulary/">
        <span class="nav-arrow">← </span>
        
          History Vocabulary -
        
      </a>
    
    
  </div>

    <!-- NAV END -->
    <!-- 打赏 START -->
    
    <!-- 打赏 END -->
    <!-- 二维码 START -->
    
    <!-- 二维码 END -->
    
      <!-- Utterances START -->
      <div id="utterances"></div>
      <script src="https://utteranc.es/client.js"
        repo=""
        issue-term="pathname"
        theme="github-light"
        crossorigin="anonymous"
        async></script>    
      <!-- Utterances END -->
    
  </article>
  <!-- Article END -->
  <!-- Content START -->
  
    <aside class="content-container">
  <div class="toc-main">
  
      
          <strong class="toc-title">CONTENT</strong>
          <ol class="toc-nav"><li class="toc-nav-item toc-nav-level-1"><a class="toc-nav-link" href="#1%E3%80%81%E6%A6%82%E8%BF%B0"><span class="toc-nav-text">1、概述</span></a></li><li class="toc-nav-item toc-nav-level-1"><a class="toc-nav-link" href="#2%E3%80%81%E5%BA%94%E7%94%A8%E5%B1%82"><span class="toc-nav-text">2、应用层</span></a><ol class="toc-nav-child"><li class="toc-nav-item toc-nav-level-2"><a class="toc-nav-link" href="#2-1-%E5%9F%BA%E6%9C%AC%E5%8E%9F%E7%90%86"><span class="toc-nav-text">2.1 基本原理</span></a></li><li class="toc-nav-item toc-nav-level-2"><a class="toc-nav-link" href="#2-2-Web-%E5%BA%94%E7%94%A8"><span class="toc-nav-text">2.2 Web 应用</span></a></li><li class="toc-nav-item toc-nav-level-2"><a class="toc-nav-link" href="#2-3-%E8%A7%86%E9%A2%91%E6%B5%81"><span class="toc-nav-text">2.3 视频流</span></a></li><li class="toc-nav-item toc-nav-level-2"><a class="toc-nav-link" href="#2-4-%E7%94%B5%E5%AD%90%E9%82%AE%E4%BB%B6"><span class="toc-nav-text">2.4 电子邮件</span></a></li><li class="toc-nav-item toc-nav-level-2"><a class="toc-nav-link" href="#2-5-%E5%9F%9F%E5%90%8D%E7%B3%BB%E7%BB%9F"><span class="toc-nav-text">2.5 域名系统</span></a></li><li class="toc-nav-item toc-nav-level-2"><a class="toc-nav-link" href="#2-6-%E6%96%87%E4%BB%B6%E5%88%86%E5%8F%91"><span class="toc-nav-text">2.6 文件分发</span></a></li></ol></li><li class="toc-nav-item toc-nav-level-1"><a class="toc-nav-link" href="#3%E3%80%81%E8%BF%90%E8%BE%93%E5%B1%82"><span class="toc-nav-text">3、运输层</span></a><ol class="toc-nav-child"><li class="toc-nav-item toc-nav-level-2"><a class="toc-nav-link" href="#3-1-%E5%9F%BA%E6%9C%AC%E5%8E%9F%E7%90%86"><span class="toc-nav-text">3.1 基本原理</span></a></li><li class="toc-nav-item toc-nav-level-2"><a class="toc-nav-link" href="#3-2-UDP-%E5%92%8C-TCP"><span class="toc-nav-text">3.2 UDP 和 TCP</span></a></li></ol></li><li class="toc-nav-item toc-nav-level-1"><a class="toc-nav-link" href="#X%E3%80%81%E5%8F%82%E8%80%83%E8%B5%84%E6%96%99"><span class="toc-nav-text">X、参考资料</span></a></li></ol>
      
  
  </div>
</aside>
  
  <!-- Content END -->
</main>

<script>
  (function () {
    var url = 'http://example.com/2023/11/06/computer-networking/';
    var banner = ''
    if (banner !== '' && banner !== 'undefined' && banner !== 'null') {
      $('#article-banner').css({
        'background-image': 'url(' + banner + ')'
      })
    } else {
      $('#article-banner').geopattern(url)
    }
    $('.header').removeClass('fixed-header')

    // error image
    $(".markdown-content img").on('error', function() {
      $(this).attr('src', '/css/images/error_icon.png')
      $(this).css({
        'cursor': 'default'
      })
    })

    // zoom image
    $(".markdown-content img").on('click', function() {
      var src = $(this).attr('src')
      if (src !== '/css/images/error_icon.png') {
        var imageW = $(this).width()
        var imageH = $(this).height()

        var zoom = ($(window).width() * 0.95 / imageW).toFixed(2)
        zoom = zoom < 1 ? 1 : zoom
        zoom = zoom > 2 ? 2 : zoom
        var transY = (($(window).height() - imageH) / 2).toFixed(2)

        $('body').append('<div class="image-view-wrap"><div class="image-view-inner"><img src="'+ src +'" /></div></div>')
        $('.image-view-wrap').addClass('wrap-active')
        $('.image-view-wrap img').css({
          'width': `${imageW}`,
          'transform': `translate3d(0, ${transY}px, 0) scale3d(${zoom}, ${zoom}, 1)`
        })
        $('html').css('overflow', 'hidden')

        $('.image-view-wrap').on('click', function() {
          $(this).remove()
          $('html').attr('style', '')
        })
      }
    })
  })();
</script>







    <div class="scroll-top">
  <span class="arrow-icon"></span>
</div>
    <!--
<footer class="app-footer">
  <p class="copyright">
    &copy; 2023 | Proudly powered by <a href="https://hexo.io" target="_blank">Hexo</a>
    <br>
    Theme by <a target="_blank" rel="noopener" href="https://github.com/yanm1ng">yanm1ng</a>
    
  </p>
</footer>
-->

<script>
  function async(u, c) {
    var d = document, t = 'script',
      o = d.createElement(t),
      s = d.getElementsByTagName(t)[0];
    o.src = u;
    if (c) { o.addEventListener('load', function (e) { c(null, e); }, false); }
    s.parentNode.insertBefore(o, s);
  }
</script>
<script>
  async("//cdnjs.cloudflare.com/ajax/libs/fastclick/1.0.6/fastclick.min.js", function(){
    FastClick.attach(document.body);
  })
</script>

<script>
  var hasLine = 'true';
  async("//cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/highlight.min.js", function(){
    $('figure pre').each(function(i, block) {
      var figure = $(this).parents('figure');
      if (hasLine === 'false') {
        figure.find('.gutter').hide();
      }
      hljs.configure({useBR: true});
      var lang = figure.attr('class').split(' ')[1] || 'code';
      var codeHtml = $(this).html();
      var codeTag = document.createElement('code');
      codeTag.className = lang;
      codeTag.innerHTML = codeHtml;
      $(this).attr('class', '').empty().html(codeTag);
      figure.attr('data-lang', lang.toUpperCase());
      hljs.highlightBlock(block);
    });
  })
</script>
<!-- Baidu Tongji -->


<script src="/js/script.js"></script>


  </body>
</html>
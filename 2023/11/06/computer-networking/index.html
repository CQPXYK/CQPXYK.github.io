<!DOCTYPE html>
<html>
  <head>
  <meta http-equiv="content-type" content="text/html; charset=utf-8">
  <meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport">
  <meta name="description" content="要有一个从输入到输出的过程">
  <meta name="keyword" content="hexo-theme, vuejs">
  
    <link rel="shortcut icon" href="/css/images/logo.png">
  
  <title>
    
      Computer Networking | CQ&#39;s Blog
    
  </title>
  <link href="//cdnjs.cloudflare.com/ajax/libs/font-awesome/4.7.0/css/font-awesome.min.css" rel="stylesheet">
  <link href="//cdnjs.cloudflare.com/ajax/libs/nprogress/0.2.0/nprogress.min.css" rel="stylesheet">
  <link href="//cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/tomorrow.min.css" rel="stylesheet">
  
<link rel="stylesheet" href="/css/style.css">

  
  <script src="//cdnjs.cloudflare.com/ajax/libs/jquery/3.2.1/jquery.min.js"></script>
  <script src="//cdnjs.cloudflare.com/ajax/libs/geopattern/1.2.3/js/geopattern.min.js"></script>
  <script src="//cdnjs.cloudflare.com/ajax/libs/nprogress/0.2.0/nprogress.min.js"></script>
  
  
  
  
    <!-- MathJax support START -->
    <script type="text/x-mathjax-config">
      MathJax.Hub.Config({
        tex2jax: {
          inlineMath: [ ['$','$'], ["\\(","\\)"]  ],
          processEscapes: true,
          skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
        }
      });
    </script>

    <script type="text/x-mathjax-config">
      MathJax.Hub.Queue(function() {
        var all = MathJax.Hub.getAllJax(), i;
        for (i=0; i < all.length; i += 1) {
          all[i].SourceElement().parentNode.className += ' has-jax';
        }
      });
    </script>
    <script type="text/javascript" src="//cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
    <!-- MathJax support END -->
  


  
  
    
<script src="/js/local-search.js"></script>


<meta name="generator" content="Hexo 5.4.2"></head>
<div class="wechat-share">
  <img src="/css/images/logo.png" />
</div>
  <body>
    <header class="header fixed-header">
  <div class="header-container">
    <a class="home-link" href="/">
      <div class="logo"></div>
      <span>CQ's Blog</span>
    </a>
    <ul class="right-list">
      
        <li class="list-item">
          
            <a href="/" class="item-link">Home</a>
          
        </li>
      
        <li class="list-item">
          
            <a href="/" class="item-link">Categories</a>
          
        </li>
      
        <li class="list-item">
          
            <a href="/records" class="item-link">Records</a>
          
        </li>
      
        <li class="list-item">
          
            <a href="/scratches/" class="item-link">Scratches</a>
          
        </li>
      
        <li class="list-item">
          
            <a href="/archives/" class="item-link">Archives</a>
          
        </li>
      
      
        <li class="menu-item menu-item-search right-list">
    <a role="button" class="popup-trigger">
        <i class="fa fa-search fa-fw"></i>
    </a>
</li>
      
    </ul>
    <div class="menu">
      <span class="icon-bar"></span>
      <span class="icon-bar"></span>
      <span class="icon-bar"></span>
    </div>
    <div class="menu-mask">
      <ul class="menu-list">
        
          <li class="menu-item">
            
              <a href="/" class="menu-link">Home</a>
            
          </li>
        
          <li class="menu-item">
            
              <a href="/" class="menu-link">Categories</a>
            
          </li>
        
          <li class="menu-item">
            
              <a href="/records" class="menu-link">Records</a>
            
          </li>
        
          <li class="menu-item">
            
              <a href="/scratches/" class="menu-link">Scratches</a>
            
          </li>
        
          <li class="menu-item">
            
              <a href="/archives/" class="menu-link">Archives</a>
            
          </li>
        
      </ul>
    </div>
    
      <div class="search-pop-overlay">
    <div class="popup search-popup">
        <div class="search-header">
            <span class="search-icon">
                <i class="fa fa-search"></i>
            </span>
            <div class="search-input-container">
                <input autocomplete="off" autocapitalize="off"
                    placeholder="Please enter your keyword(s) to search." spellcheck="false"
                    type="search" class="search-input">
            </div>
            <span class="popup-btn-close">
                <i class="fa fa-times-circle"></i>
            </span>
        </div>
        <div id="search-result">
            <div id="no-result">
                <i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i>
            </div>
        </div>
    </div>
</div>
    
  </div>
</header>

    <div id="article-banner">
  <h2>Computer Networking</h2>
  <!--<p class="post-date">2023-11-06</p>
  <div class="arrow-down">
    <a href="javascript:;"></a>
  </div>-->
</div>
<main class="app-body flex-box">
  <!-- Article START -->
  <article class="post-article">
    <section class="markdown-content"><h1 id="1、概述"><a href="#1、概述" class="headerlink" title="1、概述"></a>1、概述</h1><p><strong>因特网</strong>是一个世界范围的计算机网络，互联了遍及全世界的数十亿计算设备，是网络的网络。因特网所连接的这些设备（不一定是计算机）称为<strong>主机 host 或端系统</strong>，因特网应用就运行在这些端系统上（分布式应用涉及多个相互交互数据的端系统），端系统提供了一个套接字接口，该接口规定了运行在一个端系统上的应用程序向运行在另一个端系统上的特定应用交付数据的方式。</p>
<p><strong>端系统</strong>通过<strong>通信链路和分组交换机</strong>的网络连接到一起，通信链路由不同类型的物理媒介（同轴电缆、铜线、光纤和无线电频谱）组成，这些通信链路能够以不同的传输速率（以比特/秒 bps 度量）传输在端系统之间交换报文，发送端系统将报文划分为较小的数据块（称为分组 packet），分组交换机从它的一条入通信链路接收到达的 packet，根据 packet 的目的地的 IP 地址等首部字段和转发表找到对应的出通信链路，转发该 packet，packets 在目的端系统被装配成初始数据。</p>
<p>大多数<strong>分组交换机</strong>在链路的输入端使用存储转发传输机制，即在向输出端链路传输该 packet 的第一个比特之前，必须接收到整个 packet。分组交换机对于每条相连的链路都具有一个输出缓存，用于存储准备发往该链路的 packet，因此，除了存储转发时延以外，packet 还要经历输出缓存的排队时延，排队时延是变化的，变化的程度取决于网络的拥塞等级，此外由于缓存的大小是有限的，当缓存空间已满时，新到的 packet 或者已经在排队的 packet 就会被丢弃。如今常见的分组交换机是路由器（网络层设备）和链路层交换机（链路层设备），路由器通常用于网络核心，将各个局域网互相连接起来或者接入互联网，链路层交换机通常用于接入网中，用于接入组建局域网。</p>
<p><strong>接入网</strong>指将端系统物理连接到其边缘路由器（边缘路由器是端系统到任何其他远程端系统的路径上的第一台路由器）的网络。很多公司、校园以及家庭端使用局域网（LAN，地理上集中的网络）将端系统连接到边缘路由器，以太网是目前最流行的有线局域网接入技术。在基于 IEEE 802.11 技术的无线 LAN（又称 WiFi）环境中，无线用户从/到一个 WiFi 接入点发送/接收分组，该 WiFi 接入点与企业网/链路层交换机（很可能是通过有线以太网链路）连接，企业网再与有线因特网相连，无线 LAN 用户通常必须位于距离接入点几十米的范围内。用户在移动环境中采用广域（WAN）无线/蜂窝接入网（3G、LTE 4G 和 5G），即通过蜂窝网提供商运营的基站来发送和接收分组，用户仅需位于距离基站数万米范围内。</p>
<p><strong>因特网服务提供商（ISP）</strong>是一个由多台分组交换机和多段通信链路组成的网络，是端系统和更大的因特网之间的桥梁。每个 ISP 网络都是独立管理的（比如希望按自己的意愿运行网络中的各个路由器），ISP 与 ISP 之间都是互联的，较低层的 ISP 通过较高层的 ISP 互联，较高层的 ISP 通过高速光纤链路彼此直接互联，接入网就是位于最底层的接入 ISP，各种接入 ISP 为端系统提供了不同类型的网络接入，我国每个城市有接入 ISP，再往上可以是区域 ISP、省级 ISP、国家级 ISP 以及全球传输的第一层 ISP。较低层的 ISP 和较高层的 ISP 之间是客户和提供商之间的付费关系，除第一层 ISP 以外的任何 ISP 都可以通过多宿（与多个提供商 ISP 相连）来增强稳定性，位于相同层级的邻近的一对 ISP 能直接相连实现对等，从而避免它们之间的流量向上层传输，多个 ISP 可以以因特网交换点（IXP）作为汇合点来一起实现对等，对等的 ISP 之间无需付费。</p>
<p>计算机网络必定要限制在端系统之间的<strong>吞吐量（bps）</strong>，会在端系统之间引入<strong>时延</strong>，且不可避免的会<strong>丢失 packet</strong>。所有的 packet 在每个节点上都经受了几种不同类型的时延，比较重要的是节点处理时延（检查 packet 并找到出链路）、排队时延（排队等待传输，过大则丢包）、传输/发射时延（将 packet 的所有比特推向链路）以及传播时延（比特从起点到下一跳所需要的时间），这些时延累加起来是节点总时延。吞吐量指端与端之间交付比特的速率，为了避免流量在某一个节点上堆积，因此比特从源向目的地的流动速率/吞吐量取决于所有途径的链路中的最小的链路速率以及链路上的干扰流量，今天因特网中对吞吐量的限制因素通常是接入网。</p>
<p>为了处理这些吞吐量、时延以及丢包问题，所有的因特网部件都要运行多个<strong>协议</strong>，这些协议定义了通信实体之间交换的报文的格式和顺序，以及报文的发送和接收等事件所采取的操作，从而控制着因特网中信息的接收和发送（主要协议统称为 TCP/IP 协议，因特网标准由 IETF 研发，IETF 的标准文档称为 RFC）。网络设计者以分层的方式组织协议，每个协议属于这些层次之一，每层协议通过自身执行某些操作或使用直接下层的服务来向上一层提供服务，各层的所有协议被称为协议栈，因特网的协议栈由物理层、链路层、网络层、运输层和应用层组成。</p>
<ul>
<li>应用层是网络应用程序及它们的应用层协议存留的地方，应用层协议分布在多个端系统上，提供应用程序之间的交互，端系统的应用程序使用协议与另一个端系统中的应用程序交换分组（称为报文），提供应用程序之间的交互</li>
<li>表示层负责数据格式的转换和数据加密解密，确保应用层数据的格式一致</li>
<li>会话层提供会话管理功能，负责建立、维护和结束会话，实现不同计算机之间的会话控制，为高层协议提供一个数据传输的会话环境</li>
<li>运输层在应用程序端点之间传送分组（称为报文段），提供端到端的传输服务，包括数据传输控制、流量控制等</li>
<li>网络层负责在主机和主机之间传送分组（称为数据报），解决数据在网络中的传输问题，包括 IP 寻址、路由选择等</li>
<li>链路层沿着路径在物理节点之间传递分组（称为帧），包括对数据进行分帧，差错校验、链路管理等处理</li>
<li>物理层在物理传输媒介上移动帧的一个个比特，规定了传输介质的传输方式，包括电信号、电压、光脉冲等</li>
</ul>
<p>在每一层，一个分组具有首部字段和有效载荷字段（上一层的分组）这两种类型的字段。五层模型就是在七层的基础上，将应用层、表示层和会话层合并为应用层，四层模式就是在五层模型的基础上将链路层和物理层合并为网络接口层。一个协议层能够用硬件、软件或两者结合来实现，应用层、运输层这样的高层协议几乎总是在端系统中用软件实现，网络层通常是硬件和软件实现的混合体，数据链路层、物理层通常在给定链路相关联的网络接口卡中实现。主机实现了所有层次的协议，路由器实现了网络层以及以下的协议，链路层交换机实现了链路层及以下的协议。</p>
<h1 id="2、应用层"><a href="#2、应用层" class="headerlink" title="2、应用层"></a>2、应用层</h1><h2 id="2-1-基本原理"><a href="#2-1-基本原理" class="headerlink" title="2.1 基本原理"></a>2.1 基本原理</h2><h3 id="2-1-1-网络应用程序"><a href="#2-1-1-网络应用程序" class="headerlink" title="2.1.1 网络应用程序"></a>2.1.1 网络应用程序</h3><p>网络应用是计算机网络存在的理由，<strong>虽然网络体系结构是固定的（为应用程序提供了特定的服务集合），但应用体系结构由应用程序研发者设计</strong>，这规定了如何在各种端系统上组织该应用程序，主流的应用体系结构是 C/S（典型例子包括 FTP、电子邮件、Web 应用等，服务器一般设为托管大量主机的能够保证提供服务的数据中心）和 P2P（典型例子是 BitTorrent）。</p>
<p>网络应用程序由成对的运行在不同端系统（可能具有不同的操作系统）上的进程组成，这些进程通过一个称为<strong>套接字</strong>的软件接口向网络发送报文和从网络接收报文，从而跨越计算机网络交换报文而相互通信。套接字是同一台主机内应用层与运输层之间的可编程接口（也称为应用程序和网络之间的 API），应用程序开发者可以控制套接字在应用层端的一切，但对运输层的控制仅限于选择运输层协议和设定一些如最大缓存和最大报文段长度的运输层参数（此外，应用程序开发者对该套接字的运输层端几乎没有控制权），一旦应用层报文进入套接字，该报文就脱离了应用层控制并进入运输层控制。</p>
<h3 id="2-1-2-应用层协议"><a href="#2-1-2-应用层协议" class="headerlink" title="2.1.2 应用层协议"></a>2.1.2 应用层协议</h3><p><strong>应用层协议</strong>定义了交换的应用层报文类型（例如请求还是响应）、各种报文类型的语法（例如报文的各个字段）、字段的语义、发送和响应报文的规则、与该协议关联的周知端口号等，公用的应用层协议由 RFC 文档定义。<strong>应用进程的地址</strong>包含主机的地址和进程标识符，在因特网中，主机的地址为 IP 地址，进程标识符为端口号。端口号是一个 16 比特的数（范围是 0 ~ 65535），当应用使用由 RFC 文档定义的公用应用层协议时，应当使用与该协议关联的周知端口号（范围是 0 ~ 1023），而当应用使用专有的独立应用层协议时，应当避免使用这些周知端口号。</p>
<p>运输层协议需要为应用程序的数据传输提供<strong>可靠与否、吞吐量、定时和安全性</strong>这四个方面的服务。比如电子邮件、文件传输等应用要求可靠交付，但不要求特定吞吐量（属于弹性应用），多媒体应用则对吞吐量有特殊要求（属于带宽敏感应用），电话、视频会议、多方游戏等应用有严格的时间限制。因特网为应用程序提供 UDP 和 TCP 这两个运输层协议，<strong>UDP 提供尽最大努力不确保可靠交付服务，TCP 提供面向连接服务和可靠交付服务</strong>；TCP 和 UDP 都<strong>不提供对吞吐量和定时方面的保证性服务</strong>（但通常能够为带宽敏感和时间敏感应用<strong>提供满意的服务</strong>）；也<strong>不提供任何安全性服务</strong>，<strong>安全性由应用层的 TLS 提供</strong>，TLS 有它自己的套接字 API，类似于传统的 TCP 套接字 API，当一个应用使用 TLS 时，发送进程向 TLS 套接字传递明文数据，发送主机中的 TLS 则加密该数据，并将加密的数据传递给 TCP 套接字，加密的数据经由因特网传送到接收进程中的 TCP 套接字，该接收套接字将加密数据传递给 TLS，由其进行解密，最后 TLS 套接字将明文数据传递给接收进程。</p>
<h3 id="2-1-3-套接字编程"><a href="#2-1-3-套接字编程" class="headerlink" title="2.1.3 套接字编程"></a>2.1.3 套接字编程</h3><p>在应用程序研发阶段，开发者需要先确定应用程序是运行在 TCP 上还是 UDP 上，对于基于 UDP 的应用来说</p>
<ul>
<li>发送报文进入客户端套接字时，应用程序代码应当显式地将目的进程地址附上，源进程地址则由底层操作系统自动将其附上（无需由应用程序代码显式处理）</li>
<li>在服务器端接收到客户端所发送报文之前，应用程序代码应当显式地为服务器端套接字绑定一个接收端口号，那么该套接字即可接收到任何向位于服务器的 IP 地址的该端口所发送的报文</li>
<li>客户端套接字在连接结束后关闭，服务器端套接字始终开启不会关闭，UDP 套接字是由一个包含目的进程地址的二元组来标识的</li>
</ul>
<p>对于基于 TCP 的应用来说</p>
<ul>
<li>在建立 TCP 连接时，客户端创建一个 TCP 套接字并指定服务器“欢迎”套接字地址，源进程地址则由底层操作系统自动将其附上（无需由应用程序代码显式处理）</li>
<li>服务器端会为每个来自客户端的 TCP 连接请求生成一个“新生”套接字用于后续与该客户端进行通信，运输层的三次握手令客户端套接字就和服务器端“新生”套接字关联起来，后续传输数据时无需再由应用程序显式附上目的地址</li>
<li>客户端套接字和服务器端“新生”套接字在连接结束后关闭，服务器端“欢迎”套接字始终开启不会关闭，TCP 套接字是由一个包含源进程地址和目的进程地址的四元组来标识的</li>
</ul>
<h2 id="2-2-Web-应用-HTTP"><a href="#2-2-Web-应用-HTTP" class="headerlink" title="2.2 Web 应用 HTTP"></a>2.2 Web 应用 HTTP</h2><h3 id="2-2-1-HTTP-特性"><a href="#2-2-1-HTTP-特性" class="headerlink" title="2.2.1 HTTP 特性"></a>2.2.1 HTTP 特性</h3><p>Web 应用使用 C/S 应用程序体系结构，Web 应用使用的应用层协议是 HTTP（[REC 1945]、[REC 7230]、[REC 7540]），Web 应用通过交换报文来向 Web 服务器请求 Web 页面，Web 服务器总是打开的，具有一个固定的 IP 地址。<strong>Web 页面</strong>（又称文档）由对象组成，一个对象就是一个文件（例如 HTML 文件、JPEG 文件、JavaScript 文件、CSS 样式表文件、视频文件等），每个对象文件都可通过一个 URL 寻址，URL 由存放对象的服务器主机名和对象的路径名组成。</p>
<p>HTTP 由运行在不同端系统中的客户程序和服务器程序这两个程序实现，定义了在 Web 浏览器（实现了 HTTP 客户端）和 Web 服务器（实现了 HTTP 服务器端）之间请求和传送 Web 页面的方式，是一种用于分布式、协作式和超媒体信息系统的<strong>无状态</strong>应用层协议，以 ASCII 码传输，使用 TCP 作为运输层协议支撑，默认使用 80 端口。无状态指 HTTP 服务器端仅仅只是向客户发送被请求的对象文件，而不存储任何关于该客户的状态信息，这简化了服务器的设计，允许 Web 服务器同时处理数千个 TCP 连接。客户端可能以规则的间隔周期性地或者间断性的发出一些列请求，若所有的请求/响应对分别经过一个单独的 TCP 连接发送则称为非持续连接，若所有的请求/响应对都经过同一个 TCP 连接流水线式的发送则称为持续连接，HTTP <strong>默认使用持续连接</strong>，但也能通过配置使用非持续连接。</p>
<h3 id="2-2-3-HTTP-报文"><a href="#2-2-3-HTTP-报文" class="headerlink" title="2.2.3 HTTP 报文"></a>2.2.3 HTTP 报文</h3><p><strong>HTTP 请求报文</strong>的第一行叫作请求行（request line），请求行有方法、URL 和 HTTP 版本这三个字段；请求行之后是一些首部行（header line），首部行可以指明请求对象所在的主机（这是 Web 代理高速缓存所要求的）、是否使用非持续连接、用户代理（即发送请求的浏览器的类型）等；首部行后为实体体（entity body）。GET 方法的实体体为空，POST 方法的实体体为一些和请求相关的内容（所请求的 Web 页面的特定内容依赖于该实体体中的内容），HEAD 方法并不请求具体 Web 对象，仅仅只需要服务返回一个 HTTP 报文进行响应，常用于调试跟踪，PUT 方法允许上传对象到指定的 Web 服务器上指定的路径，常用于与 Web 发行工具联合使用，DELETE 方法允许删除 Web 服务器上的对象。</p>
<p><strong>HTTP 响应报文</strong>的第一行叫作初始状态行（status line），状态行有 HTTP 版本、状态码和状态信息这三个字段；初始状态行之后是一些首部行，首部行指明了发送完报文后是否关闭该 TCP 连接，服务器产生并发送响应报文的时间、服务器代理、对象创建或最后修改的时间、被发送对象中的字节数，对象类型等；首部行之后为实体体，实体体是报文的主要部分，包含了所请求的对象本身。301 代表请求的对象已经被永久转移了，新的 URL 定义在响应报文的“Location：”首部行中；400 是一个通用差错代码，服务器不能理解该请求；404 代表请求的文档不在服务器上；505 代表服务器不支持请求报文所使用的 HTTP 版本。</p>
<p>HTTP 规范中定义了很多<strong>首部行</strong>，这些首部行可以被浏览器、Web 服务器和网络缓存服务器插入，客户端和服务器端的具体使用产品、版本和配置都会影响到首部行的内容。</p>
<h3 id="2-2-4-用户状态"><a href="#2-2-4-用户状态" class="headerlink" title="2.2.4 用户状态"></a>2.2.4 用户状态</h3><p>HTTP 作为一个无状态协议可以通过 <strong>cookie</strong> 在允许站点对用户进行跟踪，用户首次访问一个站点时，可能需要提供一个用户标识，站点会产生一个唯一识别码并以此作为索引在后端数据库中产生一个表项，接下来会在 HTTP 响应报文中定义一个“Set-cookie：”首部行（包含有该识别码），客户端系统会管理一个 cookie 文件（小型文本文件）并存储在客户端浏览器中，当接收到包含该识别码的响应报文时，会在其 cookie 文件中添加一行，在后续的 HTTP 请求报文中也都会定义一个“Cookie：”首部行（包含有该识别码），针对后续的请求，服务器端通过读取 cookie 并查询后端数据库来获取该用户在该站点的历史活动，从而进行用户信息识别以及一些个性化处理（购物车），因此 cookie 可以在无状态的 HTTP 之上建立一个用户会话层。每个 cookie 都会绑定单一的域名，cookie 不可跨域，无法在别的域名下获取使用，一级域名和二级域名之间是允许共享使用的，每个域名下的 cookie 的数量也是有限的。</p>
<p><strong>Session</strong> 是服务器端创建和管理的一种会话机制，当用户首次访问网站时，服务器会为该用户创建一个唯一的 Session ID，通常通过 cookie 在客户端进行存储，会话标识符在后续的请求中用于标识具体是哪个用户，通常情况下，session 是基于 cookie 实现的，sessionId 存储在客户端的 cookie 中（如果某些网站禁用 cookie，可以将 sessionId 作为参数附加在 URL 中，或者在页面的表单中添加一个隐藏字段来存储 sessionId），session 存储在服务器端，因此，session 较 cookie 更加安全，此外，session 允许存任意数据类型，而 cookie 只支持字符串数据；session 可存储更大的数据量（但是会占用过多的服务器资源），而单个 cookie 保存的数据不能超过 4K；session 一般失效时间较短，客户端关闭或 session 超时都会失效，cookie 则可以设置为长时间保持（比如默认登录）。</p>
<p><strong>Token</strong> 是一种代表用户身份验证和授权的令牌，常用于 Web 应用程序中的身份验证，当用户成功登录时，服务器会基于某种加密算法来为该用户生成一个 Token 令牌，客户端在后续的请求中将 Token 包含在请求头或请求参数中，服务器接收到 Token 后，会进行验证和解析，以确定用户的身份和权限，是一种无状态、可扩展、安全的身份验证和授权机制，可以轻松灵活地在不同平台和设备之间共享和传递，而无需依赖特定的 session 机制或 cookie 支持，非常适用于现代应用架构。虽然 cookie 和 session 也可以使用身份验证，但在一些不适合使用 cookie 和 session 的场景（跨域请求、分布式请求、非 HTTP 的 API 请求、跨平台应用）中，就需要使用 Token</p>
<p><strong>Web 缓存器</strong>（又称代理服务器）有自己的磁盘存储空间，并在存储空间中保存最近请求过的对象的副本，可以通过配置令用户浏览器的 HTTP 请求首先指向 Web 缓存器，若 Web 缓存器存储有请求需要的对象，则直接响应该请求，若没有，则由 Web 缓存器向服务器发送 HTTP 请求，得到响应后在本地存储空间存储一份副本，并向客户浏览器响应。Web 缓存器通常由 ISP 购买并安装到该 ISP 网络中，将该 ISP 网络上的用户浏览器配置为通过高速局域网直接指向 Web 缓存器而非通过低速公共因特网指向服务器，由于客户和服务器之间的瓶颈带宽远低于客户和 Web 缓存器之间的瓶颈带宽，可以大大减少对客户请求的响应时间。HTTP 允许通过<strong>条件 GET</strong>（请求报文中包含“If-modified-since：”首部行）来证实请求对象是最新的，当浏览器请求的对象在缓存器中缓存时间较久时，会向服务器发送条件 GET 请求执行最新检查。</p>
<p>Web 缓存器是一个<strong>正向代理</strong>，即代理服务器代理了客户端去和目标服务器进行交互，目标服务器并不直到真正的客户端是谁，代理是由客户端架设的代理，帮助客户端访问无法/不便于直接访问的服务器资源。<strong>反向代理</strong>是指由代理服务器来接收因特网上的连接请求，然后将请求转发给内部网络上的服务器，并将从服务器上得到的结果返回给因特网上请求连接的客户端，即代理服务器代理了目标服务器去了客户端交互，客户端并不知道真正的目标服务器是谁，代理是由服务器架设的代理，帮助服务器做负载均衡、安全防护等，比如 NGINX 负载均衡就是一个反向代理服务器。正向代理和反向代理均能提高访问速度。</p>
<h3 id="2-2-5-协议版本"><a href="#2-2-5-协议版本" class="headerlink" title="2.2.5 协议版本"></a>2.2.5 协议版本</h3><p>HTTP 协议的主要版本有 HTTP/1.0、HTTP/1.1 和 HTTP/2。<strong>HTTP/1.0</strong> 规定浏览器和服务器只保持短暂的连接，连接无法复用，服务器不跟踪用户也不记录历史请求，浏览器的每次请求都需要与服务器建立一个 TCP 连接，服务器完成请求处理后立即断开 TCP 连接，由于 TCP 三次握手很耗费时间，因此 HTTP/1.0 性能比较差。<strong>HTTP/1.1</strong> 在持续 TCP 连接上使用请求管道（在响应到达之前可以继续发送后续的请求），允许经单一 TCP 连接将一个 Web 页面（涉及多个 HTTP 请求和响应）从服务器发送到客户，由于每个 Web 页面仅用一个 TCP 连接，所传送的每个 Web 页面平等共享网络带宽，但此时同一个 TCP 连接中位于请求队首的大对象会阻塞后面的小对象，为了避免该阻塞需要打开多个并行的 TCP 连接，此时，小对象到达并呈现在浏览器上的速度要快很多，可以减小用户感知时延，HTTP/1.1 一直延用至今。<strong>HTTP/2</strong> 在应用层和传输层之间加了一层二进制分帧层，在二进制分帧层中，HTTP/2 会将每个报文分成更小的帧并采用二进制格式的编码，对 Header 进行压缩，在同一 TCP 连接上以 stream 的方式乱序交错发送请求和响应报文对应的二进制帧并在接收端将其装配起来，允许客户为正在请求的响应确定优先次序，此外还允许服务器自行根据用户的一个请求内容来主动推送多个相关的资源而无需等待用户来发送其余相关请求，这些设计避免了小对象阻塞，减小了感知时延，摆脱了 HTTP/1.1 的并行 TCP，减小了 TCP 数量，服务器的套接字数量被压缩。</p>
<p>HTTP/1.1 的请求管道要求服务端必须按照与请求相同的顺序回送 HTTP 响应，存在 HTTP 队头阻塞问题（如果个响应返回发生了延迟，那么后续的响应都会被延迟），HTTP/2 废弃了管道化的请求方式，而是将 HTTP 消息分解为互不依赖的帧并乱序发送，避免了 HTTP 队头阻塞问题，但仍然存在 TCP 队头阻塞的问题，且相比于基于多个并行 TCP 连接的 HTTP/1.1，基于同一 TCP 连接的 HTTP/2 的 TCP 队头阻塞问题会更加严重，为了避免这一问题，<strong>HTTP/3（原 QUIC 协议）</strong>采用基于 UDP 的运输层协议，通过应用层协议自身的数据包重传、拥塞控制、传输节奏调整等特性来提供可靠传输（UDP 是不可靠传输协议），实现了无序、并发字节流传输以及快速握手，还采用了 TLS 1.3 来提供安全性相关的能力。</p>
<p>HTTPS 和 HTTP 是两种协议，HTTP 是明文传输的，数据在传输过程中并不加密，容易被攻击或窃取，HTTPS 经由 HTTP 进行通信，但利用 SSL/TLS 来加密数据包（因此被称为 HTTP over SSL/TSL），需要使用由信任的第三方机构（如 Certificate Authority）所颁发的数字证书来验证网站的身份，而加密和解密操作所带来的计算开销使得 HTTPS 比 HTTP 的性能更低一些，因此对于不涉及敏感信息的静态内容来说，HTTP 是比 HTTPS 更好地选择。</p>
<h3 id="2-2-6-HTTP-请求"><a href="#2-2-6-HTTP-请求" class="headerlink" title="2.2.6 HTTP 请求"></a>2.2.6 HTTP 请求</h3><p>当浏览器输入某个网址回车之后，</p>
<ul>
<li><p>浏览器对 URL 进行解析，检查长度，查看浏览器是否缓存了该页面</p>
</li>
<li><p>若无页面缓存，则依次通过浏览器缓存、操作系统 hosts 缓存，路由器缓存，ISP 缓存和根域名服务器查询对应的 IP</p>
</li>
<li><p>浏览器将请求封装为 HTTP 报文，与服务器建立 TCP 连接，并将报文经由网关和路由器发送给 server</p>
</li>
<li><p>服务器如果使用 NGINX 做负载均衡，则 NGINX 采用默认的轮询算法将报文发送给 servlet 容器</p>
</li>
<li><p>servlet 容器解析请求行，请求提，请求头，然后交给 MVC 处理</p>
</li>
<li><p>DispatcherServlet 接收到请求后，通过请求路径返回相应的拦截器和 Controller</p>
</li>
<li><p>Controller 通过调用下层的 Service 以及持久层进行数据的 CRUD，并返回 Model 和 View</p>
</li>
<li><p>ViewResolve 对 Model 和 View 进行处理，返回 View 视图，对 View 进行渲染之后，产生 HTTP Response</p>
</li>
<li><p>浏览器接受到 HTTP Response 之后对其进行缓存和解码，并渲染页面</p>
</li>
</ul>
<h3 id="2-2-7-网络安全"><a href="#2-2-7-网络安全" class="headerlink" title="2.2.7 网络安全"></a>2.2.7 网络安全</h3><p><strong>拒绝服务（DoS，Denial of Service）</strong>指某个攻击者利用大量合理的服务请求来占用服务资源，从而使得合法用户无法得到服务响应，<strong>分布式拒绝服务（DDoS，Distributed Denial of Service）</strong>是指大量身份不断变化的攻击者都进行 DoS 攻击，DDoS 攻击可以具体分为带宽消耗型以及资源消耗型。如果能够识别出攻击源（如攻击者的机器 IP 等），可以在防火墙服务器上放置一份 ACL（访问控制列表）来阻断来自这些 IP 的访问；此外，针对带宽消耗型，可以增加带宽；针对资源消耗型，可以增加负载均衡，多地部署等。</p>
<p><strong>跨站请求伪造（CSRF/XSRF，Cross Site Request Forgery）</strong>指攻击者盗用了正常用户的身份，以正常用户的名义发送恶意请求，比如发送邮件，购买商品，转账等造成个人信息泄露，财产损失等，防止 CSRF 攻击的方式有：1）验证记录了 HTTP 请求来源地址的 HTTP Referer 字段；2）在 HTTP 请求地址中添加 Token 并验证；3）在 HTTP 头中自定义属性并验证。</p>
<p><strong>跨站脚本攻击（XSS，Cross Site Scripting）</strong>指攻击者向 Web 页面中插入恶意 HTML 代码，当用户浏览该网页时，嵌入其中的恶意代码会被执行，从而攻击用户，防止 XSS 的方式就是始终不应相信用户的输入，始终对用户的输入进行过滤等处理。</p>
<p><strong>DNS 污染</strong>指一个 DNS 服务器被恶意修改，导致该 DNS 服务器不再返回错误的 DNS 记录，<strong>DNS 劫持</strong>指攻击截获 DNS 请求，并代替 DNS 服务器提供错误的 DNS 记录，DNS 污染和DNS 劫持都可以将用户错误地引导至恶意站点，需要选择可靠的 DNS 服务商，使用 VPN 来保护网络连接等。</p>
<p><strong>水平越权</strong>指攻击者尝试访问与当前用户具有相同权限的其他用户资源，比如对于以自增键为主键的用户信息，可以尝试访问临近自身自增键的其他用户信息，可以通过对关键参数进行加密混淆，限制单位时间内的请求频次，避免使用自增键等方式来避免。</p>
<p><strong>对称加密</strong>指加密和解密使用相同的密钥，<strong>非对称加密</strong>指加密和解密使用一对配对的不同的密钥，公钥加密后的数据只有通过该公钥对应的私钥才能解密，私钥加密后的数据只有通过该私钥对应的公钥才能解密。</p>
<p><strong>MD5</strong> 是一种散列函数，不是加密算法，作用是对数据进行单向不可逆的压缩，生成一个固定长度的字符串作为该数据的数字指纹/消息摘要，以验证数据的完整性和一致性，但无法对加密后的数字指纹进行解密得到原始数据，由于哈希值的长度是固定的，因此 MD5 算法存在碰撞的可能，因此不能保证安全。</p>
<p><strong>SHA-256</strong> 是一种密码散列函数，常被用于对数据进行签名或生成信息摘要，同样不能逆向解密，由于计算中使用了大量的位运算、逻辑运算和移位运算等，计算生成的消息摘要非常长，因此结果具有很强的随机性，发生碰撞的概率很低，是安全可靠的。</p>
<p><strong>中间人攻击</strong>指攻击者与通讯两端分别建立独立的联系，使得通讯的两端认为他们在于对方进行直接联系，实际上整个会话都完全被中间人攻击者所控制。</p>
<p><strong>SQL 注入</strong>指攻击者通过在应用程序的用户输入中插入恶意的 SQL 代码，进行未经授权的恶意数据查询与操作，因此应用程序应当使用预编译或参数化的 SQL 语句，从而始终将用户输入的参数视为数据，而不会解释为 SQL 语句的一部分；尽量使用 ORM 框架来尽可能避免手动拼接 SQL；始终对用户输入的信息进行验证过滤等处理；为数据库用户分配最小必要的权限；避免向用户泄漏敏感信息。</p>
<p><strong>撞库</strong>指攻击者通过收集互联网已泄露的用户和密码信息，生成对应的字典表，尝试批量登录其他网站，找到一系列登录确定网络的用户信息；<strong>拖库</strong>指攻击者通过技术手段（SQL 注入等）窃取数据库中的信息；<strong>洗库</strong>指攻击者通过技术手段将有价值的用户数据归纳分析，售卖变现。</p>
<h2 id="2-3-电子邮件-SMTP"><a href="#2-3-电子邮件-SMTP" class="headerlink" title="2.3 电子邮件 SMTP"></a>2.3 电子邮件 SMTP</h2><p>电子邮件是一个异步通信媒介，使用了多个应用层协议，因特网电子邮件系统由用户代理、邮件服务器和 SMTP 这三个部分组成，<strong>用户代理</strong>允许用户阅读、回复、转发、保存和撰写报文；<strong>邮件服务器</strong>上有一个邮箱，用于管理和维护发送给自身的报文；<strong>SMTP</strong> 是因特网电子邮件中主要的应用层协议。</p>
<p><strong>SMTP</strong> 使用 TCP 可靠数据传输服务，运行在发送方邮件服务器的客户端和接收方邮件服务器的服务器端，这意味双方的邮件服务器必须使用保持开机。SMTP 不使用中间邮件服务器发送邮件，而是发送方邮件服务器和接收方邮件服务器直接相连，这意味着邮件并不在某个中间邮件服务器中留存。SMTP 限制邮件报文的体部分（不只是其首部）只能采用简单的 7 比特的 ASCII 表示，即在用 SMTP 传送邮件之前，需要将二进制多媒体数据编码为 ASCII 码，并且在使用 SMTP 传输后要求将相应的 ASCII 码邮件解码还原为多媒体数据。邮件的环境信息（双方地址、日期等）包括在一系列首部行中，首部行和 ASCII 格式的报文体用空行（回车 CR 和换行 LF）进行分隔。</p>
<p>发送方将撰写完成的邮件通过 SMTP/HTTP 从用户代理传输到发送方的邮件服务器（邮件放置在邮件服务器的外出报文队列中），通过 SMTP 再传输到接收方的邮件服务器，邮件接收者可以调用自己的用户代理通过 HTTP/IMAP 在自己的邮件服务器的邮箱中取得该报文（取报文是拉操作，SMTP 是推协议，故不能使用 SMTP）。当发送方的邮件服务器经过多次重试失败而确认接收方的邮件服务器存在故障时，发送方邮件服务器会删除该报文并以电子邮件的形式通知发送方，这种确保交付的机制必须依赖于发送方邮件服务器这一中继，因此邮件不能直接由发送方用户代理直接传输到接收方邮件服务器。典型的用户通常与其他用户共享总是保持开机的<strong>共享邮件服务器</strong>，在本地 PC 上运行用户代理程序来访问共享邮件服务器上的邮箱。</p>
<h2 id="2-4-域名系统-DNS"><a href="#2-4-域名系统-DNS" class="headerlink" title="2.4 域名系统 DNS"></a>2.4 域名系统 DNS</h2><p>因特网主机可以通过主机名或者 IP 地址进行标识，DNS 是一个能进行因特网主机名/主机别名（人类好记的名字）到 IP 地址转换的<strong>目录服务</strong>，此外还基于冗余服务器（相同主机名对应一系列多个 IP 地址）提供<strong>负载均衡</strong>分配功能（返回不同的 IP 地址）。大多数用户不直接与 DNS 打交道，而是通过其他应用间接使用它，比如浏览器需要通过 DNS 将服务器名转换为服务器 IP 地址之后再向该 IP 地址发起 TCP 连接。DNS 由 DNS 服务器所实现的<strong>分布式数据库</strong>（是分布式数据库的精彩范例）和使得主机能够查询分布式数据库的<strong>应用层协议</strong>组成。</p>
<p><strong>DNS 服务器</strong>通常是运行 BIND 软件的 UNIX 机器，大量分布于全球并以层次结构组织，该层次结构中存在根 DNS 服务器、顶级域 DNS 服务器和权威 DNS 服务器这三种类型的 DNS 服务器。本地 DNS 服务器（又称默认名字服务器）并不属于 DNS 服务器的层次结构，但每一个 ISP 都有一台本地 DNS 服务器，当主机与某个 ISP 连接时，该 ISP 提供一台主机的 IP 地址，该主机具有一台或多台其本地 DNS 服务器的 IP 地址，主机的本地 DNS 服务器就是“邻近” DNS 服务器。主机的 DNS 请求都被转发到本地 DNS 服务器上，本地 DNS 服务器会首先与根服务器之一联系，获得请求域名所在的顶级域名服务器的 IP 地址，接着与顶级域名服务器之一联系，获得请求域名所在的权威域名服务器的 IP 地址，接着与权威域名服务器之一联系，获得请求域名所对应的 IP 地址，最后本地 DNS 服务器将获得的 IP 地址返回给请求主机。</p>
<p>想通过 DNS 获得的 IP 地址一般缓存在一个“邻近”DNS 服务器中，<strong>DNS 缓存</strong>有助于减少 DNS 的网络流量和 DNS 的平均时延，在一个 DNS 请求链中，当某 DNS 服务器接收到一个 DNS 回答（包含某主机名到 IP 地址的映射）时，就将映射缓存在本地存储器中，由于这种映射并不是永久的， DNS 服务器在一段时间（通常为两天）后将丢弃缓存的信息。</p>
<p>共同实现 <strong>DNS 分布式数据库</strong>的所有 DNS 服务器存储了<strong>资源记录</strong>，每个 DNS 回答报文包含了一条或多条资源记录，资源记录提供了主机名到 IP 地址的映射，包含 Name、Value、Type、TTL 这四个字段。TTL 是该资源记录的生存时间，决定了资源记录应当从缓存中删除的时间，Name 和 Value 的意义取决于 Type。如果 Type = A，那么 Name 为主机名，Value 为主机名对应的 IP 地址；如果 Type = NS，那么 Name 为域，Value 为知道如何获得该域中主机 IP 地址的权威 DNS 服务器的主机名（用于沿着查询链来路由 DNS 查询）；如果 Type = CNAME，那么 Name 为主机别名，Value 为规范主机名；如果 Type = MX，那么 Name 为邮件服务器别名，Value 为邮件服务器规范主机名。注册登记机构是一个验证域名唯一性的商业实体，会将域名以及域名所在的权威 DNS 服务器的名字和 IP 地址输入 DNS 数据库，对提供的服务收取少量费用。</p>
<p><strong>DNS 协议</strong>运行在 UDP 之上，如果没有接收到响应，则要么试图向另一个 DNS 服务器发送查询，要么通知调用的应用程序它不能获得响应。DNS 查询报文和回答报文具有相同的格式，报文中分别有首部区域（标识了该查询以及当前是查询报文还是回答报文等信息）、问题区域（包含了正在进行的查询信息）、回答区域（包含了对最初请求的名字的所有资源记录）、权威区域（包含了其他权威服务器的记录）、附加信息（包含了其他有帮助的记录）。</p>
<h2 id="2-5-视频流-HTTP-DASH"><a href="#2-5-视频流-HTTP-DASH" class="headerlink" title="2.5 视频流 HTTP/DASH"></a>2.5 视频流 HTTP/DASH</h2><p>视频是以一种恒定速率来展现的一系列图像，图像由像素阵列组成，每个像素由一些比特编码来表现亮度和颜色，可以用比特率来权衡视频质量，比特率越高，图像质量越好，用户的总体视觉感受越好。在<strong>流式视频应用</strong>中，预先录制的视频放置在服务器上，用户按需向这些服务器发送请求来观看视频，流式视频最为重要的性能度量是平均端到端吞吐量。</p>
<p>在 HTTP 流中，视频只是存储在 HTTP 服务器中作为一个普通的文件，当服务器在响应报文中发送该视频文件对象，客户侧不断将字节收集在客户应用缓存中，一旦该缓存中的字节数量超过预先设定的门限，客户应用程序就开始播放，流式视频应用周期性地从客户应用程序缓存中抓取帧，对这些帧解压缩并在用户屏幕上展现，此时，即便是拥有不同可用带宽的客户，客户接收的都是相同版本的视频压缩文件。而在 <strong>DASH</strong> 中，视频编码为几个比特率不同的版本文件（具备不同的 URL，对应不同的质量水平），在客户与服务器建立 TCP 连接后，服务器会先向客户发送具有 URL 列表的告示文件，客户即可动态地请求来自不同版本且长度为几秒的视频数据块（在请求报文中指定 URL 和字节范围），当客户可用带宽较高时，客户自然选择来自高速率版本的块，当可用带宽较低时，客户选择来自低速率版本的块，这种机制允许客户使用不同的接入速率流式播放具有不同编码速率的视频，即在不同质量等级之间自由切换。</p>
<p>为了应对向分布于全世界用户分发巨量视频数据的挑战，几乎所有主要的视频流公司都利用<strong>内容分发网 CDN</strong>，CDN 管理着分布在多个地理位置上的服务器集群（边缘节点，离用户更近），这些集群中存储着视频（各种静态资源）的副本，一般被安置在接入 ISP 或 IXP。CDN 通过 DNS 来截获用户请求，并根据用户的本地 DNS 服务器的 IP 地址来试图将用户请求都重定向到一个将提供最好用户体验的 CDN 集群节点位置 。</p>
<h2 id="2-6-文件分发-BitTorrent"><a href="#2-6-文件分发-BitTorrent" class="headerlink" title="2.6 文件分发 BitTorrent"></a>2.6 文件分发 BitTorrent</h2><p>在 P2P 体系结构下，受用户控制的主机彼此直接通信，无需依赖于总是打开的基础设施服务器。在 P2P 文件分发中，每个对等方能够向任何其他对等方重新分发它已经收到的该文件的任何部分，从而协助分发过程。到 2020 年至，最为流行的 P2P 文件分发协议是 <strong>BitTorrent</strong>。BitTorrent 将参与一个特定文件分发的所有对等方的集合被称为一个洪流，在一个洪流中的对等方彼此下载等长度的文件块（典型的块长度为 256 KB），每个<strong>洪流</strong>具有一个基础设施节点，称为追踪器。</p>
<p>当一个对等方首次加入一个洪流时会向追踪器注册自己并周期性地通知洪流它仍在该洪流中，追踪器会随机地从参与对等方的集合中选择对等方的一个子集并将该子集中对等方的 IP 地址发送给新加入的对等方，新对等方会试图与该子集中的所有对等方创建并行的 TCP 连接，所有这样与新对等方成功创建 TCP 连接的对等方称为邻近对等方，每个对等方的邻近对等方会随时间而变化。对等方会随时间逐渐累积了越来越多的文件块，下载块的同时也为其他邻近对等方上载块。对等方随时可以离开洪流，可以离开后重新加入洪流，也可以一直留在洪流中。</p>
<p>对等方会周期性地询问每个邻近对等方它们所具有的块列表，并对自己当前还没有的块在邻居中决定出最稀缺的块（就是那些在邻居中副本数量最少的块）发出请求，最稀缺的块得到更为迅速的重新分发，从而大致均衡每个块在洪流中的副本数量。对等方对于每个邻居都持续地测量接收到比特的速率，并确定以最高速率流入的 4 个邻居（被称为疏通），对等方会周期性重新计算流入速率并可能修改疏通，也会周期性随机选择疏通以外的邻居（被称为试探）并向其发送数据块，除了疏通和试探这 5 个对等方以外，所有其他的邻居对等方均被阻塞，这种关于交换的激励机制使得对等方能够以趋向于找到彼此的协调的速率上载。</p>
<h1 id="3、运输层"><a href="#3、运输层" class="headerlink" title="3、运输层"></a>3、运输层</h1><h2 id="3-1-基本原理"><a href="#3-1-基本原理" class="headerlink" title="3.1 基本原理"></a>3.1 基本原理</h2><h3 id="3-1-1-多路复用-分解"><a href="#3-1-1-多路复用-分解" class="headerlink" title="3.1.1 多路复用/分解"></a>3.1.1 多路复用/分解</h3><p><strong>运输层</strong>为运行在不同主机上的应用进程提供逻辑通信，多个同时运行的应用进程分别对应不同的套接字（也可以令同一进程的多个线程对应不同套接字），发送端运输层通过发送端各个不同的套接字接收来自发送端各个应用进程的报文，将这些报文划分为小块并为每个数据块分别加运输层首部从而转换成报文段（这称为<strong>多路复用</strong>），这些报文段被传递到发送端的网络层，网络层将报文段封装为数据报传递到网络中，数据报在网络中途径的所有中间主机和网络路由器仅作用于该数据报的网络层字段，而不检查封装在该数据报中的运输层报文段，接收端网络层从数据报中提取运输层报文段，并将该报文段向上交给接收端运输层，接收端运输层从接收到的报文段中找到套接字标识，从而将报文段递交给特定的接收端套接字，报文段由此被定向到接收端特定应用进程（这称为<strong>多路分解</strong>）。</p>
<p>运输层的多路复用与多路分解源自于单一的<strong>运输层协议</strong>需要为高层的多个协议提供统一的服务，这也要求每个<strong>报文段都有特殊字段（源端口号和目的端口号）</strong>来指示该报文段所对应的发送接收套接字。运输层协议只在发送端系统和接收端系统中工作而对分组在发送接收端以外如何移动并不关心，发送接收端以外的其他端系统以及中间路由器也不识别分组中的运输层首部。虽然运输层协议所能够提供的服务常常受制于网络层协议所提供的服务，且网络层协议往往是不可靠的（比如丢失、篡改、乱序等），但是因特网为应用程序提供的 UDP 和 TCP 这两个运输层协议依旧能为应用程序提供某方面可靠的（比如确保交付、差错检查等）数据传输服务 。</p>
<h3 id="3-1-2-运输层协议"><a href="#3-1-2-运输层协议" class="headerlink" title="3.1.2 运输层协议"></a>3.1.2 运输层协议</h3><p>由于不能保证所有的通信链路都提供差错检测，也不能保证数据在某台主机或者路由器的内存中没有引入差错，因此需要由运输层协议提供<strong>端到端的差错检测</strong>，UDP 和 TCP 都可以通过在其报文段首部中包括差错检查字段（检验和）而提供<strong>完整性检查</strong>。UDP 只是做了运输层协议能够做的最少工作，仅提供进程到进程的数据交付和差错检查这两种最低限度的运输层服务，并不确保完整无缺的数据交付，对检测出的差错报文段直接丢弃而无恢复能力，也无法控制流量。TCP 在不可靠的（IP）端到端网络层之上提供<strong>可靠、完整、正确、按序的数据交付</strong>，此外还为整个因特网提供<strong>拥塞控制</strong>服务，防止任何一条 TCP 连接用过多流量来淹没通信主机之间的链路和交换设备，力求为每个通过一条拥塞网络链路的连接平等地共享网络链路带宽。</p>
<p>由于 UDP 在传输数据时不具备流量控制和拥塞控制，会将应用层数据处理后立即将其传递给网络层，而 TCP 在传输数据之前需要先经过三次握手建立连接，流量控制、拥塞控制以及超时重传都会拉长数据交付的时延，主动降低自身的发送速率，因此 UDP 发送数据的时间控制则更为准确，能够以非公平的方式占据链路带宽，压制同一条链路上的 TCP 流量；由于 UDP 是无连接的，无需像 TCP 那样维护众多连接状态信息，也不跟踪各种收发参数，UDP 首部开销较 TCP 更小，因此运行在 UDP 之上的应用程序所在服务器往往能支持更多的活跃用户；此外，即便 UDP 没能提供某种可靠服务，依旧可以通过应用程序自身或新型应用层协议来建立可靠性机制，此时，基于 UDP 的应用程序既可以进行可靠通信，也无须受制于 TCP 拥塞控制机制强加的传输速率限制。综上所述，<strong>TCP 并非总是首选的</strong>。</p>
<h3 id="3-1-3-可靠数据传输"><a href="#3-1-3-可靠数据传输" class="headerlink" title="3.1.3 可靠数据传输"></a>3.1.3 可靠数据传输</h3><p>网络层及以下的底层信道模型往往复杂且不可靠，基于差错检测、肯定确认以及否定确认的<strong>自动重传请求（ARQ）</strong>协议可以确保完整、正确的数据交付，即由接收方根据差错检查的结果返回不同的反馈，针对出现比特受损的情况，接收方就可以通过发送 NAK 来要求发送方重传，当发送方收到含糊不清的 ACK 或者 NAK 时都会重传当前的分组，发送方只有准确接收到 ACK 时才能继续发送新数据。此外，几乎现在所有的数据传输协议都会在分组中添加分组编号，因此，接收方可以通过检查分组号来确定接收到的分组是否为重传从而处理冗余，也可以根据分组号的排序来确保按序的数据交付，发送方可以通过一定时间是否接收到某分组号的 ACK 来判断是否丢包是否重传该分组，这也要求发送方在每次发送一个分组时便启动一个定时器。</p>
<p>为了提高数据交付的时延，发送方可以在还未接收到 ACK 时就发送发送一定数量限制的多个分组（称为窗口），这种发送流水线要求发送方发送的每个非重传的分组必须有唯一的序号（TCP 的分组号是按字节流中的字节进行计数的），发送方和接收方分别都维持一个大小为 N 的窗口（<strong>回退 N 步</strong>，N 必须小于等于序号空间大小的一半），发送窗口的 send_base 为最小的已发送未接收 ACK 的分组序号，接收窗口的 rcv_base 为最小的正确按序接收到的分组序号。发送方需要缓存那些已发送但还未接收到 ACK 的分组，每个已发送但未 ACK 的分组都拥有自己的定时器，并在超时时重传该分组（<strong>选择重传（SR）</strong>），接收方对于正确接收到的分组，若分组序号大于等于 rcv_base - N 则无论是否按序是否重复均发送针对当前分组的 ACK，若分组序号等于 rcv_base（按序）则交付上层，若大于 rcv_base（失序）则被缓存直到所有序号更小的分组皆被收到时一起交付上层，对于所有其他情况（分组序号小于 rcv_base - N 或分组比特受损）均丢弃分组。</p>
<h2 id="3-2-传输控制协议-TCP"><a href="#3-2-传输控制协议-TCP" class="headerlink" title="3.2 传输控制协议 TCP"></a>3.2 传输控制协议 TCP</h2><h3 id="3-2-1-可靠传输"><a href="#3-2-1-可靠传输" class="headerlink" title="3.2.1 可靠传输"></a>3.2.1 可靠传输</h3><p>TCP 报文段由<strong>首部字段</strong>和一个<strong>数据字段</strong>组成，数据字段包含一块应用数据，数据字段长度不能超过最大报文段长度 <strong>MSS</strong>（MSS 根据最初确定的由本地发送主机所能发送的最大链路层帧长度 MTU 来设置），首部包括源端口号（多路复用）、目的端口号（多路分解）、检验和字段（差错检测）、<strong>序号字段</strong>、<strong>确认号字段</strong>、接收窗口字段、首部长度字段（TCP 首部长度是可变的）、选项字段（发送方和接收方协商 MSS）、标志字段。TCP 将序号建立在传输的字节流之上（<strong>隐式地对数据流中每个字节编号，编号的起始可以随机产生</strong>），一个报文段的序号是该报文段中首个字节的字节流编号，确认号是该主机期望从对方接收到的下一个字节的字节流编号，从而代表确认号之前的字节均已经 ACK（由于 TCP 只确认流中第一个丢失字节为止的字节，所以 TCP 被称为提供<strong>累计确认</strong>），<strong>序号（数据顺序和数据重复）、确认号字段和超时重传（数据完整）以及检验和（数据篡改）是提供可靠数据传输的关键</strong>。</p>
<p>这种面向字节流的传输使得发送方可能会将多个小的数据包粘合在一起发送，接收方可能将这些粘合在一起数据包拆分成多个小的数据包进行接收，从而导致数据接收出现错误或者数据粘连的问题，因此需要对每个包都固定长度（比如 512 个字节大小），每个包的末尾使用固定的分隔符，报文段的首部字段中保存整个报文段的长度，只有在读取到足够长度的消息之后才算是接收到一个完整的报文段。</p>
<p>TCP 使用<strong>单一的重传定时器</strong>，当 TCP 收到上层应用数据或首次接收到针对某报文段的 ACK 时，重启定时器并将超时间隔设为估算往返时间（RTT）。TCP 报文段的样本 RTT 是从报文段被交给网络层到对该报文段的 ACK 被收到之间的时间量，在任意时间，仅为一个已发送且是首次发送的但目前尚未 ACK 的报文段产生一个新样本 RTT 值，进而计算一个估算 RTT。当定时器超时时，TCP 发送方重传最小的已发送但未 ACK 的报文段，重启定时器并将下一次超时间隔设为先前值的两倍（报文段的超时间隔应当始终大于等于估算的 RTT）。此外，TCP 接收方接收到一个正确的报文段时，总是对当前最后一个按序报文段发送冗余 ACK（并不丢弃失序报文段），当 TCP 发送方收到针对某报文段的冗余的 ACK 数量达到 3 个时，TCP 就对该报文段的下一个报文段进行<strong>快速重传</strong>，避免等待过长的超时周期。</p>
<p>TCP 重传率是一个衡量 TCP 网络性能的重要指标，过高的重传率意味着网络质量问题，如网络拥塞、链路不稳定/质量差，进而导致网络吞吐量下降和延迟增加，可以通过查看 TCP 重传率到定位网络问题<a target="_blank" rel="noopener" href="https://www.yuque.com/hollis666/niq4hm/tk8w4sg1gw9cd0gg">参考</a>。</p>
<h3 id="3-2-2-连接管理"><a href="#3-2-2-连接管理" class="headerlink" title="3.2.2 连接管理"></a>3.2.2 连接管理</h3><p>TCP 连接是一条<strong>全双工、点对点的逻辑连接</strong>，TCP 连接的建立会显著地增加人们感受到的时延。在 TCP 连接建立阶段，连接的双方都将初始化与 TCP 连接相关的许多 TCP 状态（比如双方所选择的字节流起始编号），这些状态仅保留在两个通信端系统的 TCP 程序中，在这两个端系统之间的网络元素（路由器、交换机和中继器）没有为该连接分配任何缓存和变量。</p>
<p>发起连接的进程称为客户进程，另一个进程称为服务器进程，客户进程首先通知客户运输层自身想与服务器上的一个进程建立连接，客户运输层发送一个首部 SYN 标志位被置为 1 的特殊的 TCP 报文段（被称为 SYN 报文段），并随机选择一个客户端起始序号 client_isn 放置于该报文段的序号字段，客户进程验证自身的发送能力正常；服务器接收到 SYN 报文段后为该 TCP 分配 TCP 缓存和变量，并用另一个特殊的 TCP 报文段来响应，该报文段的 SYN 标志位依旧被置为 1，确认号字段被置为 client_isn + 1，并随机选择一个服务器端起始序号 server_isn 放置于该报文段的序号字段中（被称为 SYNACK 报文段），服务器进程验证客户进程的发送能力正常，验证自身的发送和接收能力也都正常；客户接收到 SYNACK 报文段后为该连接分配缓存和变量，再用 ACK 报文段作为响应，该报文段的 SYN 标志位被置为 0，确认号字段被置为 server_isn + 1，序号字段被置为 client_isn + 1，客户进程验证自身和服务器进程的发送和接收能力都正常，这就是 <strong>TCP 三次握手</strong>，其中，前两个报文段不承载有效载荷（即不包含应用层数据），第三个报文段可以承载有效载荷，在之后的每个报文段中的 SYN 标志位都被置为 0。</p>
<p>如果服务器在发送 SYNACK 后没有接收到来自客户的 ACK，那么通常在一分多钟后终止该半开连接并回收资源，这就导致当服务器收到 <strong>SYN 洪泛攻击</strong>（仅发送 SYN 来建立连接但不使用连接发送数据）时，大量资源浪费在从未使用的 TCP 连接上，而无法为真正合法的用户分配连接资源。为了避免该攻击，服务器在接收到 SYN 后并不分配资源，仅仅只是根据一个复杂函数生成一个与源和目的的进程地址有关的起始序号（称为 cookie）并发送 SYNACK，服务器也不记忆该 cookie 或任何对应于 SYN 的其他状态信息，一个合法的用户会为 SYNACK 生成 ACK，服务器接收到来自用户的 ACK （验证用户和自身的发送和接收能力都正常）后用相同的方式重新计算 cookie，验证用户 ACK 的合法性，若合法，才为该 TCP 连接分配资源。<strong>只有三次握手才有足够的上下文来让客户和服务器双方都确认双方的发送和接收能力都正常，确认当前连接既不是来自非合法用户，也不是合法用户的历史连接。</strong></p>
<p>参与一条 TCP 连接中的两个进程中的任何一个都能终止该连接，当客户进程希望关闭连接时，会向服务器进程发送一个 FIN 标志位被置为 1 的特殊报文段（称为 FIN 报文段），当服务器接收到 FIN 报文段后，就向发送方回送一个 ACK 确认报文段，接着服务器终止前的处理处理工作准备好之后发送自己的 FIN 报文段（FIN 标志位被置为 1 ），接着客户对来自服务器的 FIN 报文段回送一个 ACK 确认报文段，等待一段时间（一般是两倍的最大报文生存时间 2MSL，确保网络中的所有剩余数据报文段都被丢弃，防止旧的数据报文段在之后的连接中引发混淆）后连接正式关闭，这就是 <strong>TCP 四次挥手</strong>，当连接结束时，客户和服务器中的关于该连接的资源都被释放。</p>
<p><strong>由于 TCP 是全双工通信，在主动关闭方停止发送数据并发送 FIN 报文段后，被动关闭方可能还要继续发送数据，被动关闭方接收到主动关闭方的 FIN 报文段后不能立即关闭被动关闭方到主动关闭方的数据通道，只能先回送一个 ACK 确认报文段，等自身无需再发送数据时再发送 FIN 报文段，所以才需要四次挥手。</strong></p>
<h3 id="3-2-3-流量控制"><a href="#3-2-3-流量控制" class="headerlink" title="3.2.3 流量控制"></a>3.2.3 流量控制</h3><p>一旦建立好一条 TCP 连接，两个应用进程之间就可以互相发送数据了，TCP 连接的每一端都有各自的<strong>发送缓存</strong>和<strong>接收缓存</strong>（在三次握手期间被设置）。客户进程通过套接字传递到运输层的数据流被 TCP 引导至 TCP 发送缓存中，TCP 在方便的时候会从发送缓存中取出长度小于等于 MSS 的应用层数据配上一个 TCP 首部就形成 TCP 报文段，TCP 报文段被传递到网络层，网络层将其封装在 IP 数据报中，然后这些数据报就被发送到网络中，当 TCP 在另一端接收到一个报文段后，该报文段的数据就被放入 TCP 接收缓存中。</p>
<p>相关联的应用进程会从 TCP 接收缓存中读取数据，但并不是数据刚一到达就立即读取，如果应用读取的数据比较缓慢，而发送方发送的数据太多太快，接收缓存就容易溢出，因此，发送方的发送速率需要与接收方应用程序的读取速率相匹配（<strong>流量控制</strong>）。TCP 报文段首部的<strong>接收窗口字段 rwnd</strong> 是接收方告知发送方关于自身剩余可用接收缓存空间大小的指示，发送方会令自身已发送但未 ACK 的数据量小于等于接收方的接收窗口，从而确保接收方接收缓存不会溢出，有个例外情况是，当接收方接收窗口为 0 时，发送方依旧向接收方发送一个只有一个字节数据的报文段，从而确保接收方在出现新的剩余缓存空间时能通过对该报文段发送 ACK 向发送方更新自身的接收窗口（接收方只有在有应用数据或者有 ACK 要发时才会发送报文段给发送方）。</p>
<h3 id="3-2-4-拥塞控制"><a href="#3-2-4-拥塞控制" class="headerlink" title="3.2.4 拥塞控制"></a>3.2.4 拥塞控制</h3><p>运输层向网络中发送报文段的速率越接近链路容量，平均时延就会越来越大甚至变为无穷大，即当分组的到达速率接近链路容量时，分组经历巨大的排队时延，因超时而导致的重传又会进一步加重网络负载，进一步导致时延增大甚至丢包，因此，除了流量控制，在网络拥塞时同样需要调整发送方的发送速率（<strong>拥塞控制</strong>）。因特网版本的 IP 层默认不提供明确的涉及网络拥塞的反馈，此时，TCP 采用<strong>端到端拥塞控制</strong>，端系统通过对网络行为的观察（如分组丢失）来推断拥塞程度，发送方将报文段的丢失（超时或 3 次冗余 ACK）以及往返时延的增加视作是网络拥塞的一个迹象，会相应地减小其拥塞窗口长度，减小其发送速率；发送方将首次接收到的 ACK 视作网络不拥塞的标志，会增加拥塞窗口长度，增加其发送速率（这样也是为了探测拥塞开始出现的速率）。</p>
<p>当一条 TCP 连接建立完成，cwnd 通常初始设置为一个 MSS，此时初始发送速率较小（大约为 MSS/RTT ），接着每当传输的报文段首次被 ACK 时，cwnd 的值就增加一个 MSS，并以新的 cwnd 值继续发送报文段（cwnd 以指数增长的速度不断翻倍），这就是<strong>慢启动状态</strong>。当存在一个<strong>以超时指示的丢包事件</strong>时，将慢启动域值 ssthresh 重设为 cwnd/2，并将 cwnd 重新设为一个 MSS，重新开始慢启动。每当 cwnd 达到 ssthresh 时进入<strong>拥塞避免状态</strong>，每次进入拥塞避免状态时，cwnd 的值是上次遇到拥塞时的值的一半（cwnd 不可以再继续翻倍），此时每当传输一个窗口大小的字节流中的所有报文段都被 ACK 时，cwnd 的值就增加一个 MSS，并以新的 cwnd 值继续发送总共一个窗口大小的多个报文段（cwnd 以线性增长的速度不断增加一个 MSS）。当存在一个<strong>以 3 个冗余 ACK 指示的丢包事件</strong>时，同样将 ssthresh 重设为 cwnd/2，但 cwnd 被设为一个 cwnd/2 + 3*MSS，进入<strong>快速恢复状态</strong>，接着，每当接收到一个冗余 ACK，cwnd 的值增加一个 MSS，一旦接收到丢失报文段的 ACK，cwnd 被重设为 ssthresh 并进入拥塞避免状态。</p>
<p>TCP 端到端拥塞控制方法就由慢启动、拥塞避免以及快速恢复这三个主要部分组成，核心思想是快速增加发送速率至丢包速率（慢启动/快速恢复），接着慢慢增加发送速率谨慎探测带宽（拥塞避免）。其中，慢启动和拥塞避免是 TCP 的强制部分，两者的差异在于对收到的 ACK 做出反应时增加 cwnd 的长度的方式，慢启动比拥塞避免能更快的增加 cwnd 的长度，快速恢复是推荐部分并非必需，如果不采用快速恢复，那么对于丢包事件的统一处理方式（不区分是以超时指示的还是以 3 个冗余 ACK 指示的）是将 ssthresh 重设为 cwnd/2，将 cwnd 重新设为一个 MSS，重新开始慢启动。将拥塞控制与流量控制相结合，TCP 发送方跟踪拥塞窗口变量 cwnd 和接收方的接收窗口变量 rwnd，<strong>并确保自身已发送但未 ACK 的数据量不会超过 cwnd 和 rwnd 之间的最小值</strong>。</p>
<p>基于 TCP 端到端拥塞控制方法，TCP 趋于在竞争的多条具备<strong>相同 RTT 的 TCP 连接之间提供对一段瓶颈链路带宽的平等分享</strong>（特殊情况是如果一个应用使用多个并行的 TCP 连接，那么该应用显然会获得链路中较大比例的带宽），而对于竞争的多条不同 RTT 的 TCP 连接来说，那些具有<strong>较小 RTT 的连接可以在链路空闲时较快地打开其拥塞窗口，更快的抢到可用带宽，享用更高的吞吐量</strong>。当端系统远离服务器数据中心时，RTT 会很大，会由于 TCP 慢启动潜在地导致低劣的响应时间，因此可以考虑部署邻近用户的前端服务器，客户向邻近前端连接一条 TCP 连接，并且该前端以非常大的窗口向数据中心维护一条 TCP 连接，这种基于前端服务器的 <strong>TCP 分岔</strong>可以分裂 TCP 连接，极大的改善远离数据中心的用户感受到的时延，也有助于减少因特接入网丢包引起的 TCP 重传时延，CDN 就是一个这样的执行 TCP 分岔前端服务器。</p>
<p>在一些<strong>网络辅助的 TCP 拥塞控制方法变种</strong>中，网络层 IP 数据报服务类型字段中有两个ECN 比特被用于指示该路由器是否正在历经拥塞，这种 IP 数据报将指示发送给目的主机，再由目的主机通知发送主机，发送方根据接收方的 TCP ACK 报文段中的 ECE 比特得知拥塞指示，做出相应处理（拥塞窗口减半），这种数据报拥塞控制协议提供了一种低开销的类似 UDP 的不可靠服务，在较早的阶段（报文段丢失前）就提前通知发送方拥塞要开始了，避免费时费力的丢包和重传。在一些<strong>基于时延的 TCP 拥塞控制方法变种</strong>中，发送方对所有 ACK 测量源到目的路径的 RTT，并记录一个最小的 RTT（视作没有拥塞的基准），当测量的 RTT 接近最小的 RTT 时，意味着发送速率可以继续增加，当测量的 RTT 远大于最小的 RTT 时，意味着处于拥塞，需要减小发送速率。</p>
<h1 id="4、网络层"><a href="#4、网络层" class="headerlink" title="4、网络层"></a>4、网络层</h1><h2 id="4-1-基本原理"><a href="#4-1-基本原理" class="headerlink" title="4.1 基本原理"></a>4.1 基本原理</h2><h3 id="4-1-1-数据-控制平面"><a href="#4-1-1-数据-控制平面" class="headerlink" title="4.1.1 数据/控制平面"></a>4.1.1 数据/控制平面</h3><p>网络层将报文段封装成数据报并向目的地发送，为不同主机提供逻辑通信。网络中每一台主机和路由器中都有一个网络层部分，每台主机和路由器都至少有一个网络层地址（IP 地址，是可以屏蔽物理地址差异的逻辑地址）。网络服务模型定义了分组在发送和接收主机之间的端到端传输特性以及网络层所能提供的服务特性，因特网的网络层提供了<strong>尽力而为服务</strong>这一单一的服务，即传送的分组不能保证它们的最终按序交付、端到端时延，以及占据最小带宽，这种尽力而为服务模型与适当带宽供给和带宽自适应应用级协议（如 DASH）的结合已被证明足够，能够用于大量的应用。</p>
<p>网络层可以被分解为两个相互作用的数据平面部分和控制平面部分，<strong>数据平面</strong>指网络层中每台路由器的功能，决定了到达路由器输入链路之一的数据报如何<strong>转发</strong>到该路由器的输出链路之一的（是路由器本地操作，通常用硬件来实现），涉及到基于数据报目的地址的传统的 IP 转发和基于数据报首部控制的通用的转发，数据报也可能被路由器<strong>阻挡</strong>（例如源主机是已知的恶意主机，目的主机是被禁止的主机，或者数据报是冗余的并经过多条链路发送等）；<strong>控制平面</strong>指网络范围的逻辑，不仅控制了数据报沿着从源主机到目的主机的端到端路径中路由器之间的路由方式（是网络范围处理，通常用软件实现），涉及到各种<strong>路由选择</strong>算法/协议，还控制网络层组件和服务如何配置和管理。</p>
<p>传统上，数据平面和控制平面在路由器中作为统一的整体一起实现，<strong>每台路由器中都可以包含转发和路由选择这两种功能</strong>，转发功能所涉及到的路由器关键元素是<strong>转发表</strong>，路由器检查到达分组首部的一个或多个字段值，这些值对应存储在转发表项中的值，进而可以使用这些首部值在其转发表中索引，找到该分组将被转发的路由器的输出链路接口；控制功能指路由器可以运行<strong>自己的路由选择算法</strong>，此时单个路由器中的路由选择算法会通过路由选择协议与其他路由器中的路由选择算法通信（交换包含路由选择信息的选择报文），以计算出它的转发表的值，从而决定插入该路由器转发表的内容；路由器转发表的内容也可以人工配置，此时路由器无需自己执行路由选择算法，除了人工配置以外，还可以使用<strong>软件定义网络 SDN</strong> 作为一个远程控制器来控制每台路由器的转发表，此时控制平面的路由选择功能作为一种单独服务，与物理的路由器是分离的，即路由选择设备仅执行转发，而远程控制器计算并分发转发表，数据平面和控制平面是分离的（SDN 可能实现在具有高可靠性和冗余的远程数据中心中，并可能由 ISP 或某第三方管理和改进）。</p>
<h3 id="4-1-2-路由器组成-功能"><a href="#4-1-2-路由器组成-功能" class="headerlink" title="4.1.2 路由器组成/功能"></a>4.1.2 路由器组成/功能</h3><p>路由器由输入端口、输出端口、交换结构以及路由选择处理器这四种组件组成，输入输出端口是指物理端口，而非软件 API（企业路由器具有数量较少的端口，位于某 ISP 边缘的路由器具有极多的端口），路由器的输入输出端口和交换结构所具备的功能几乎总是用硬件实现，而路由选择处理器所具备的功能是由软件实现的。</p>
<ul>
<li><strong>输入端口</strong><ul>
<li>执行终结入物理链路的物理层功能，与位于入链路远端的数据链路层交互的数据链路层功能，还要执行查找功能确定分组的输出端口</li>
<li>输入端口必须对分组进行物理层和链路层处理，接着会检查分组的版本号、检验和、以及寿命字段，重写后两个字段，更新用于网络管理的计数器（如接收到的 IP 数据报的数目）</li>
<li>一个分组的转发基于分组的目的地址和分组的首部字段来决定，对于携带了路由选择协议信息的控制分组，输入端口会将其转发到路由选择处理器，对于非控制分组，输入端口会基于分组的目的地址和最长前缀匹配来查询转发表决定分组输出端口并发送进交换结构（“匹配加操作”抽象）</li>
<li>输入端口基于转发表在每个线路卡的影子副本，在本地即可做出转发决策，无须基于每个分组调用集中式路由选择处理器，避免了集中式处理的瓶颈</li>
<li>如果有分组当前正在使用交换结构，那么后面的分组可能会在进入交换结构时被暂时阻塞，一个被阻塞的分组必须要在输入端口处排队，等待稍后被及时调度以通过交换结构</li>
</ul>
</li>
<li><strong>交换结构</strong><ul>
<li>完全包含在路由器之中，位于路由器的核心部位，是路由器中的网络</li>
<li>接收由输入端口发送的已确定输出端口的分组，并将其交换/转发到输出端口，交换可以通过内存交换、经单一共享总线交换以及经互联网交换等技术实现</li>
<li>经内存交换就像是操作系统中的 I/O 操作一样，由于一次仅能执行一个内存读写，不能同时转发多个分组；经单一共享总线交换，同样由于一次只能有一个分组跨越总线，不能同时转发多个分组；经互联网交换可以看作是有多条总线，只要输出端口不同，就允许同时转发多个分组</li>
</ul>
</li>
<li><strong>输出端口</strong><ul>
<li>存储从交换结构接收到的分组，在排队后通过执行必要的链路层和物理层功能在输出链路上传输这些分组（当一条链路是双向的时，输出端口通常与该链路的输入端口成对出现在同一线路卡上）</li>
<li>输入端口和输出端口都可以形成分组队列，排队的位置和程度将取决于流量负载、交换结构的相对速率和线路速率，出入队的规则取决于具体的分组调度机制（可以为不同类别的流量提供不同级别的服务）</li>
<li>随着队列的增长，路由器的缓存空间将会耗尽，一旦耗尽，就会出现丢包，更大的缓存使得路由器有能力承受分组到达率的更大波动，降低分组丢失率，但也意味着更长的排队时延，更低的 TCP 发送速率</li>
</ul>
</li>
<li><strong>路由选择处理器</strong><ul>
<li>通常是一种传统的 CPU，执行控制平面功能和网络管理功能</li>
<li>在传统的路由器中，路由选择处理器执行路由选择协议，维护路由选择表与关联链路状态信息，并为该路由器计算转发表</li>
<li>在 SDN 路由器中，路由选择处理器负责与远程控制器通信，接收由远程控制器计算的转发表项</li>
<li>经独立总线将转发表复制到输入输出线路卡，即在该路由器的输入端口安装这些表项</li>
</ul>
</li>
</ul>
<h3 id="4-1-3-路由选择算法"><a href="#4-1-3-路由选择算法" class="headerlink" title="4.1.3 路由选择算法"></a>4.1.3 路由选择算法</h3><p>路由选择算法的一些分类方式如下</p>
<ul>
<li>分为集中式路由选择算法和分散式路由选择算法<ul>
<li>集中式路由算法由一个具备完整全局网络状态知识（连通性和链路开销）的集中点来计算出从源到目的地之间的最低开销路径，这种具备全局状态信息的算法常被称作链路状态算法（LS 算法），LS 算法通过令每个节点<strong>向网络中所有其他节点广播自身与邻居节点的直接链路开销</strong>，保持网络拓扑和链路开销被所有节点已知</li>
<li>分散式路由选择算法由各个路由器以迭代、信息交换、分布式的方式计算出最低开销路径，每个节点仅有与其直接相连链路的开销知识即可开始工作，距离向量算法（DV 算法）就是一种分散式路由选择算法，DV 算法令每个节点维护自身到网络中所有其他节点的距离向量并<strong>向邻居节点发送自身与网络中所有节点的距离向量</strong>，节点会根据从邻居接收到的距离向量来更新自身的距离向量</li>
<li>LS 算法无论何时一条链路开销改变时，都必须向所有节点发送新的链路开销，DV 算法仅当新的链路开销导致与该链路相连节点的最低开销路径发生变化时，才传播已改变的链路开销；LS 算法收敛速度快，DV 算法收敛速度慢，且在收敛时会遇到路由选择环路以及无穷计数问题</li>
</ul>
</li>
<li>分为静态路由选择算法和动态路由选择算法<ul>
<li>静态路由选择算法由于路由随时间的变化非常缓慢，通常是人工进行配置</li>
<li>动态路由选择算法随着网络流量负载或拓扑发生变化而运行，同时也更容易受诸如路由选择循环、路由振荡之类问题的影响</li>
</ul>
</li>
<li>分为负载敏感算法和负载迟钝算法<ul>
<li>负载敏感算法会通过链路开销动态变化以反映出底层链路的当前拥塞水平，并趋向于避开高开销的拥塞链路</li>
<li>当今的因特网路由选择算法都是负载迟钝的，链路的开销不明确反映该链路的近期拥塞水平</li>
</ul>
</li>
</ul>
<h3 id="4-1-4-OSPF-和-BGP"><a href="#4-1-4-OSPF-和-BGP" class="headerlink" title="4.1.4 OSPF 和 BGP"></a>4.1.4 OSPF 和 BGP</h3><p>由于如今因特网主机和路由器数目巨大，涉及路由选择信息的通信、计算和存储的开销高得不可实现，考虑将路由器组织进<strong>自治系统（AS）</strong>，一个 AS 由其全局唯一的 AS 号所标识，每个 AS 由一组通常处在相同管理控制下的路由器组成，位于 AS 边缘的是<strong>网关路由器</strong>，其余的是<strong>内部路由器</strong>，网关路由器直接连接自身 AS 的内部路由器和其他 AS 的网关路由器，内部路由器仅连接自身 AS 的主机和路由器。可以将一个 ISP 中的一组路由器作为一个 AS，此时 ISP 可以很方便地按自己的意愿在网络中运行它所选择的某种路由选择算法，对外部隐藏自己网络的内部组织面貌，也具备能将自身网络与其他外部网络连接起来的能力，某些 ISP 还会将自身网络划分为多个互联的 AS。</p>
<p>在同一 AS 中的所有路由器都运行相同的路由选择算法并且有彼此的信息，在一个 AS 中运行的路由选择算法叫做自治系统内部路由选择协议，<strong>开放最短路优先（OSPF）</strong>路由选择协议是一种 LS 协议，被广泛用于因特网的 <strong>AS 内部路由选择</strong>。基于 OSPF，一台路由器构建了关于整个 AS 系统的完整拓扑图并在本地运行 Dijkstra 的最短路径算法，以确定一个以自身为根节点到所有子网的最短路径树（各链路开销由网络管理员配置），路由器周期性地（以及某条链路状态发生变化时）向 AS 系统中所有其他路由器广播路由选择信息，OSPF 报文直接由 IP 承载，OSPF 协议需要自己实现诸如邻居是否可达、可靠报文传输、链路状态广播、路由器信任鉴权等功能。</p>
<p>不同 AS 的通信必须运行相同的 AS 间路由选择协议，用于跨越多个 AS 的路由选择算法叫做自治系统间路由选择协议，<strong>边界网关协议（BGP）</strong>是一种类似于 DV 协议的分布式和异步的协议，被广泛用于因特网的<strong>多个 AS 之间的路由选择</strong>，比如互联数以千计的 ISP 网络（常被称为因特网的黏合剂）。在 BGP 中，分组并不是路由到一个特定的目的地址，而是路由到一个子网或一个子网的集合，每个子网都可以向因特网的其余部分通告它的存在，每个 AS 从邻居 AS 获得关于某个子网的可达性信息从确保每个子网被所有 AS 已知，每对路由器通过使用 179 端口的半永久 TCP 连接交换路由选择信息，一个 AS 可能已知多条到达特定子网的不同路由，AS 会在本地运行一个 BGP 路由选择过程来确定最好的路由。</p>
<p><strong>AS 内部路由选择是面向性能的</strong>，一切都是在相同的管理控制名义下进行的，不需要考虑策略问题，也不需要太关注可扩展性，一旦一个 AS 区域变得太大则可以将其分成多个 AS 并在新的 AS 之间执行 AS 间路由选择，<strong>AS 间路由选择是面向策略的</strong>，比如要求一个给定 AS 产生的流量不允许穿过另一个特定 AS 等策略问题，此时路由性能反而是次要问题。</p>
<h2 id="4-2-数据平面协议"><a href="#4-2-数据平面协议" class="headerlink" title="4.2 数据平面协议"></a>4.2 数据平面协议</h2><h3 id="4-2-1-网际协议"><a href="#4-2-1-网际协议" class="headerlink" title="4.2.1 网际协议"></a>4.2.1 网际协议</h3><p>因特网网络层只有网际协议（IP 协议）这一个协议，IP 协议的服务模型是尽力而为的交付服务，但并不做任何确保。IP 协议版本 4 简称为 IPv4，对于 IPv4 来说，每个 IP 地址长度为 32 比特/4 字节，通常按点分十进制记法书写，即每个字节用它的十进制形式，各字节间以句点隔开，但由于新的子网和 IP 节点以惊人的增长率连接到因特网上，32 比特的 IP 地址即将用尽，因此研发了 IP 协议版本 6（简称为 IPv6）。IPv6 将 IP 地址长度增加到了 128 比特/16 字节，通常按冒号分十六进制记法书写，即每两个字节为一组，一组用4个十六进制数书写（一个十六进制数表示 4 比特位），各组间以冒号隔开，IPv6 在 IP 数据报中加入了流标签（便于为不同的流提供不同的服务），并在单播和多播地址的以外引入了任播地址，任播地址可以使数据交付给一组主机中最近的（“最近的”由 BGP 路由选择算法所确定）那一个，比如将 DNS 请求路由到一组根 DNS 服务器中最近的一个。</p>
<p>IPv4 数据报中的关键字段为：版本号（规定了 IP 协议版本）、首部长度（用于确定载荷实际开始的地方）、服务类型（便于确定流量服务等级）、数据报长度（首部加上数据的总长度）、与 IP 分片有关的标识、标志、片偏移字段、寿命（确保数据报不会永远在网络中循环）、协议号（指示数据部分应交付给哪个运输层协议）、首部检验和（帮助路由器检测数据报首部中的比特错误）、源 IP 地址、目的 IP 地址、选项字段（可选，允许 IP 首部被扩展，这也导致首部长度可变）、数据（有效载荷，包含需要交付的运输层报文段）。IPv6 数据报在 IPv4 数据报的基础上增加了流量类型、流标签、有效载荷长度、跳限制，去掉了片偏移（IPv6 不允许在路由器上对 IP 数据报进行分片）、首部检验和以及选项（不允许 IP 首部被扩展，首部长度固定）字段，因此 IPv6 报头比 IPv4 更简单。IPv4 使用 ARP 来查找与 IPv4 相关联的 MAC 地址，IPv6 使用 ICMPv6 将查找 MAC 地址的功能嵌入到 IP 自身作为无状态自动配置和邻居节点发现算法的一部分（不存在 ARP6），IPv6 使能系统能够兼容 IPv4，即能发送、路由和接收 IPv4 数据报，但已部署的 IPv4 使能系统不能够处理 IPv6 数据报。</p>
<p>一台主机通常只有一条链路连接到网络来发送该主机的 IP 数据报，路由器则至少有两个或更多条链路与自身相连，主机/路由器与物理链路之间的边界叫做接口，<strong>一个接口与一个全球唯一的 IP 地址相关联（IP 地址并不是与包括该接口的主机或路由器相关联）</strong>，因此，主机通常有一个 IP 地址，而路由器则至少有两个或更多的 IP 地址。IP 地址并不是自由选择的，一个接口的 IP 地址的一部分需要由其连接的子网（也称为 IP 网络）来决定，分开主机和路由器的每个接口，所产生的一些隔离的网络中的每一个都叫做一个子网，一个具有以太网段和点对点链路的组织将具有多个子网。</p>
<h3 id="4-2-2-动态主机配置协议"><a href="#4-2-2-动态主机配置协议" class="headerlink" title="4.2.2 动态主机配置协议"></a>4.2.2 动态主机配置协议</h3><p>因特网的地址分配策略称为无类别域间路由选择（CIDR），CIDR 将 IP 地址划分为两部分，第一部分是 IP 地址的网络前缀，第二部分用于区分组织内部设备，同一组织内部设备的 IP 地址共享相同的<strong>网络前缀</strong>，此时无须关心该组织内部是否还细分有不同的子网，只需根据该网络前缀来统一标识该组织（包括组织内部的多个网络），这称为地址聚合/路由聚合/路由摘要。因特网名字和编号分配机构（ICANN）向 ISP 分配 IP 地址和 AS 号、管理 DNS 根服务器、分配域名以及解决域名纷争，当一个组织希望获取一块 IP 地址块时，可以首先与该组织的 ISP 联系，由 ISP 从自身的大地址块中提供一些地址给该组织。</p>
<p><strong>动态主机配置协议（DHCP 协议）</strong>具有将主机连接到一个网络的网络相关方面的自动化能力（常被称为即插即用协议或零配置协议），广泛用于住宅因特网接入网、企业网、无线局域网这种主机频繁加入和离开的网络。一旦组织获得了一块地址，就可以通过 DHCP 为本组织内的主机与路由器接口分配 IP 地址（也可以通过网络管理工具来手工逐个配置），DHCP 允许主机自动获取一个 IP 地址以及其他信息，例如它的子网掩码、第一跳路由器地址（常称为默认网关）、本地 DNS 服务器地址等，此外，网络管理员也能够通过配置 DHCP 来令某给定主机每次与网络连接时能得到一个相同的 IP 地址，或者令某主机每次都被分配一个不同的临时的 IP 地址。</p>
<p>DHCP 是一个基于 <strong>UDP</strong> 的 <strong>C/S 结构</strong>的应用层协议，每个子网都具有一台 DHCP 服务器或一个 DHCP 中继代理，客户指新到达网络的主机，它的首要任务是通过源地址为 0.0.0.0 目的地址为广播地址 255.255.255.255 的 <strong>DHCP 发现报文</strong>来尝试发现一个与自身交互的 DHCP 服务器，DHCP 服务器收到一个 DHCP 发现报文后，使用 <strong>DHCP 提供报文</strong>（包含收到的发现报文的事务 ID、向客户推荐的 IP 地址、网络掩码、IP 地址租用期/有效时间量）向该子网的所有节点广播，客户从一个或多个 DHCP 服务器响应中选择一个，并向选中的 DHCP 服务器用 <strong>DHCP 请求报文</strong>进行响应，回显配置的参数，DHCP 服务器使用 <strong>DHCP ACK 报文</strong>再次进行响应，证实所要求的参数，一旦客户收到 DHCP ACK 后，交互便完成了，客户获得了包括自身使用的 IP 地址在内的网络配置信息。</p>
<p><strong>网络地址转换（NAT）</strong>运行在网络层并具有与路由器十分不同的功能，可支持超过 60000 个并行使用路由器 WAN 端单个 IP 地址的连接，NAT 使能的路由器运行一个 DHCP 服务器，该 DHCP 服务器为该路由器的所有接口都提供一个一致的对外的单一 IP 地址，并为该路由器控制的专用网络中的设备提供 IP 地址（专用网络中的设备 IP 仅对该网络中的设备有意义，不同专用网络中的 IP 地址空间就可以有重合）。该路由器对外界的行为就如同一个具有单一 IP 地址的单一设备，而不像是一台路由器，所有离开该路由器流向更大因特网的数据报都以该路由器的单一 IP 地址作为统一的源 IP 地址，所有进入该路由器所控制的专用网络的数据报都以该路由器的单一 IP 地址作为统一的目的 IP 地址，该路由器通过维持一张<strong>记录着路由器单一 IP、端口号（WAN 端）和路由器所控制的专用网络设备 IP、端口号（LAN 端）之间的映射的 NAT 表</strong>来确定应将流入的分组转发给哪个网络内部设备。</p>
<h2 id="4-3-控制平面协议"><a href="#4-3-控制平面协议" class="headerlink" title="4.3 控制平面协议"></a>4.3 控制平面协议</h2><h3 id="4-3-1-OpenFlow-协议"><a href="#4-3-1-OpenFlow-协议" class="headerlink" title="4.3.1 OpenFlow 协议"></a>4.3.1 OpenFlow 协议</h3><p>路由器的传统转发通过匹配目的地址来将分组转发到路由器的一个输出端口，<strong>泛化转发</strong>通过匹配涉及各种不同协议的多个首部字段，将分组转发到路由器的一个或多个输出端口、跨越多个通向服务的离开接口进行负载均衡、像 NAT 这样重写首部值、像防火墙这样阻挡/丢弃某个分组等、像 CDN 这样进行 TCP 分岔、像 Web 缓存这样的内容缓存等，即在路由器的传统转发功能的基础上增加了一些<strong>中间盒功能</strong>。由于泛化转发的匹配策略可能使用网络层或链路层的源地址和目的地址，所以使用泛化转发的设备被更准确地描述为<strong>分组交换机</strong>（简单但快速的设备），而不是网络层的路由器或链路层的交换机，泛化转发所涉及的匹配加操作是基于分组交换机中的一张匹配加操作表完成的，匹配加操作表由远程<strong>逻辑集中控制器</strong>计算、安装和更新，逻辑集中是指即使出于容错和性能扩展的原因设置多个分布式服务器，但这些服务器从外部依旧被看作是单一的整体式服务点。</p>
<p><strong>OpenFlow 协议</strong>开创并引领了匹配加操作转发抽象和 SDN 控制器功能抽象，是最早的也是现在仍在使用的用于 SDN 控制器与被控设备之间的基于 TCP 的通信协议。匹配加操作表在 OpenFlow 中称为<strong>流表</strong>，流表可以看作是一个用于编程分组交换机行为（进而编程网络范围的行为）的 API 抽象，流表的每个表项包括首部字段值的集合、计数器集合、操作集合（转发、丢弃、修改字段等）。入分组会与流表项的首部字段值进行匹配，匹配不上的分组则被丢弃或发送到远程控制器，匹配上的流表项的计数器会被更新，并对分组执行该流表项所指定的操作，分组匹配多个流表项时会选择优先权最高的流表项作为匹配结果。<strong>从 SDN 控制器流向受控设备的报文</strong>有配置报文（允许控制器查询并设置交换机的配置参数）、修改状态报文（用于增加/删除交换机中的流表项以及设置交换机端口特性）、读状态报文（用于控制器统计交换机的数据）、发送分组报文（用于受控交换机向控制器发送信息，比如删除流表项、端口状态变化以及接收到无法与任务流表项匹配的分组）。</p>
<p>当受控设备只需与 SDN 控制器通信并按控制器命令行事，各个受控设备之间既不直接相互交互，也不主动参与计算流表时，数据平面与控制平面相互分离，<strong>数据平面由分组交换机组成</strong>，各个分组交换机在各种的流表中执行“匹配加操作”的规则，<strong>控制平面由逻辑集中的 SDN 控制器以及若干可编程的网络控制应用程序组成</strong>，计算、管理和安装所有分组交换机中的流表项，通过可编程的应用程序，可以很方便地修改路由选择算法，生成更新后的流表项并安装到受控设备中，调整受控设备在接收到分组后所采取的匹配方式和操作内容。</p>
<h3 id="4-3-2-网际控制信息协议"><a href="#4-3-2-网际控制信息协议" class="headerlink" title="4.3.2 网际控制信息协议"></a>4.3.2 网际控制信息协议</h3><p>因特网控制报文协议（ICMP）用于主机和路由器之间沟通网络层信息，ICMP 协议在体系结构上位于 IP 协议之上，ICMP 报文是作为有效载荷承载在 IP 分组中的，ICMP 报文中含有类型字段、编码字段以及引起该 ICMP 报文首次生成的 IP 数据报的首部和前 8 个字节（以便发送方能确定引发该差错的数据报）。如当路由器无法找到一条通往目的主机的路径时就会生成一个类型 3 编码 1 的 ICMP 报文并发送给源主机从而告知目的主机不可达），用于需要测试某个主机是否可达的 ping 程序就是发送一个 ICMP 类型 8 编码 0 的回显请求报文到指定主机，目的主机发回一个类型 0 编码 0 的 ICMP 回显回答报文（ping 程序并不是一个进程，可以直接由操作系统支持，是一个应用层直接使用网络层协议而不使用运输层协议的例子）。</p>
<table>
<thead>
<tr>
<th align="center"></th>
<th align="center"></th>
<th align="center"></th>
<th align="center"></th>
<th align="center"></th>
<th align="center"></th>
</tr>
</thead>
<tbody><tr>
<td align="center">ICMP 类型</td>
<td align="center">编码</td>
<td align="center">描述</td>
<td align="center">ICMP 类型</td>
<td align="center">编码</td>
<td align="center">描述</td>
</tr>
<tr>
<td align="center">0</td>
<td align="center">0</td>
<td align="center">回显回答（对 ping 的回答）</td>
<td align="center">3</td>
<td align="center">0</td>
<td align="center">目的网络不可达</td>
</tr>
<tr>
<td align="center">3</td>
<td align="center">1</td>
<td align="center">目的主机不可达</td>
<td align="center">3</td>
<td align="center">2</td>
<td align="center">目的协议不可达</td>
</tr>
<tr>
<td align="center">3</td>
<td align="center">3</td>
<td align="center">目的端口不可达</td>
<td align="center">3</td>
<td align="center">6</td>
<td align="center">目的网络未知</td>
</tr>
<tr>
<td align="center">3</td>
<td align="center">7</td>
<td align="center">目的主机未知</td>
<td align="center">4</td>
<td align="center">0</td>
<td align="center">源抑制（拥塞控制）</td>
</tr>
<tr>
<td align="center">8</td>
<td align="center">0</td>
<td align="center">回显请求（ping 命令发出的请求）</td>
<td align="center">9</td>
<td align="center">0</td>
<td align="center">路由器通告</td>
</tr>
<tr>
<td align="center">10</td>
<td align="center">0</td>
<td align="center">路由器发现</td>
<td align="center">11</td>
<td align="center">0</td>
<td align="center">TTL 过期</td>
</tr>
<tr>
<td align="center">12</td>
<td align="center">0</td>
<td align="center">IP 首部损坏</td>
<td align="center"></td>
<td align="center"></td>
<td align="center"></td>
</tr>
</tbody></table>
<h3 id="4-3-3-简单网络管理协议"><a href="#4-3-3-简单网络管理协议" class="headerlink" title="4.3.3 简单网络管理协议"></a>4.3.3 简单网络管理协议</h3><p><strong>网络管理</strong>包括了硬件、软件和人类元素的设置、综合和协调，以监视、测试、轮询、配置、分析、评价和控制网络及网元资源，用合理的成本满足实时性、运营性能和服务质量的要求。<strong>管理服务器</strong>是一个运行在集中式网络管理工作站上的应用程序，通常需要网络管理员的参与，从而执行网络管理活动，控制网络管理信息与命令的收集、处理、分析及显示，发起配置、监视和控制网络的被管设备的操作，一个网络可能由几个这样的管理服务器。<strong>被管设备</strong>是驻留在被管网络上的某种网络设备（包括它的软件），可能是主机、路由器、交换机、中间盒、调制解调器、温度计或其他联网设备。<strong>网络管理代理</strong>是运行在被管设备上的一个软件进程，它与管理服务器通信，在管理服务器的命令和控制下载被管设备上执行本地操作。<strong>网络管理协议</strong>运行在管理服务器和被管设备之间，允许管理服务器查询被管设备的状态，并经过其代理间接地在这些被管设备上执行操作，与此同时，代理能够使用网络管理协议向管理服务器通知异常事件（网络管理协议自身并不具备管理网络的能力，只是辅助管理服务器和网络管理员进行网络管理）。</p>
<p>简单网络管理协议（SNMP）是一个应用层协议，用于在管理服务器和网络管理代理之间传递网络管理控制和信息报文，通常是基于 UDP 的。SNMP 最常用的事请求响应模式，SNMP 管理服务器向 SNMP 代理发送一个用于查询或修改的请求，代理接收到请求后执行某些操作，然后对请求发送一个回答，此外，SNMP 的第二种功能是代理向管理服务器发送陷阱报文（非请求报文），通知管理服务器一个异常情况（比如一个链路接口启动或关闭），陷阱报文是异步产生的，即它们不是为了响应接收到的请求，而是为了响应管理服务器需求通告的事件，代理发出陷阱报文并不要求从管理服务器得到响应。</p>
<p><a target="_blank" rel="noopener" href="https://www.yuque.com/hollis666/niq4hm/us7bsygf7z1ocgd5">排查网络问题</a></p>
<h1 id="5、链路层"><a href="#5、链路层" class="headerlink" title="5、链路层"></a>5、链路层</h1><h2 id="5-1-基本原理"><a href="#5-1-基本原理" class="headerlink" title="5.1 基本原理"></a>5.1 基本原理</h2><h3 id="5-1-1-链路层协议"><a href="#5-1-1-链路层协议" class="headerlink" title="5.1.1 链路层协议"></a>5.1.1 链路层协议</h3><p>链路层的任务是在相同链路或局域网之间更局域化地移动分组（链路层帧），在大多数情况下，链路层大部分是在称为<strong>网络适配器的硬件芯片</strong>（也称为网络接口控制器 NIC）上实现的，但有部分是在<strong>运行于主机 CPU 上的软件</strong>中实现的，即软件和硬件的结合体，是协议栈中软件和硬件交接的地方。在发送端，控制器取得了由网络层生成并存储在主机内存中的数据报，在链路层帧中封装该数据报（填写帧的各个字段），遵循链路接入协议将该帧传进通信链路中，在接收端，控制器接收了整个帧，抽取出网络层数据报，链路层的软件组件会组装链路层寻址信息、激活控制器硬件、响应控制器中断、处理差错条件和将数据报向上传递给网络层。</p>
<p>运行链路层协议的任何设备均可称为<strong>节点</strong>，节点包括主机、路由器、交换机和 WiFi 接入点，连接相邻节点的通信信道称为<strong>链路</strong>，主要的链路层信道可分为广播信道和点对点信道，<strong>广播信道</strong>常用于连接无线/有线局域网、卫星网和混合光纤同轴电缆接入网中的多台主机，多台发送方和接收方使用相同的、单一的、共享的广播信道，<strong>点对点信道</strong>经常出现在诸如长距离链路连接的两台路由器之间或用户办公室计算机与邻近以太网交换机之间，信道的一端仅有一个发送方、另一端仅有一个接收方。</p>
<p>点对点协议（PPP）和高级数据链路控制（HDLC）协议都是为点对点链路设计的，而在使用广播链路时，多个发送节点同时通过广播信道传输帧时就会在接收节点处发生<strong>碰撞</strong>，此时没有一个接收节点能够有效地获得任何传输的帧，涉及此次碰撞的所有帧都丢失了，需要通过<strong>多路访问控制（MAC）协议</strong>来协调多个发送接收节点对一个共享广播信道的访问/帧传输问题。多路访问协议应该是简单的、实现代价低的、去中心化的、节点公平共享带宽且不浪费带宽的，可划分为信道划分协议（TDMA、FDMA、CDMA）、随机接入协议（ALOHA、CSMA）、轮流协议（蓝牙轮询协议、令牌传输协议），以太网是一种流行并广泛部署的 CSMA 协议。</p>
<p>链路层协议提供的<strong>可能服务</strong>包括成帧、链路接入、可靠交付以及差错检测和纠正。几乎所有的链路层协议都会将网络层数据报用链路层帧封装起来，帧的结构取决于具体链路层协议；MAC 协议规定了帧在链路上传输的规则，点对点链路的 MAC 协议比较简单甚至不存在，MAC 协议主要用于多个节点共享单个广播链路（多路访问）情况下的帧传输；链路层同样可以通过确认和重传来实现可靠交付，通常用于易于产生高差错率的无线链路，而对于低比特差错的光纤、同轴电缆等链路来说，可靠交付是一种不必要的开销。</p>
<h3 id="5-1-2-差错检测和纠正"><a href="#5-1-2-差错检测和纠正" class="headerlink" title="5.1.2 差错检测和纠正"></a>5.1.2 差错检测和纠正</h3><p>差错检测和纠正要保护的数据是网络层数据报和链路帧首部，接收方检测和纠正差错的能力被称为<strong>前向纠错 FEC</strong>，FEC 可以减少所需的发送方重发次数，降低时延，通常用于如音频 CD 这样的音频存储和回放设备中，但即便采用了差错检测，接收方依旧有可能没能检测出实际存在差错，差错检测方案致力于令这种可能性概率降低，一般方案越复杂，开销越大，这种可能性越低。</p>
<p>单个<strong>奇偶校验</strong>位是最简单的差错检测方式，发送方附加一个比特，使得初始信息加上这个校验比特中 1 的总数始终是偶数，接收方只需验证接收到的比特中 1 的个数即可（此时无法检测出偶数个比特差错），对每行和每列计算奇偶值的二维奇偶校验令接收方不仅可以检测到出现了单个比特差错，还可以利用存在奇偶检验差错的列和行的索引来实际识别单个差错比特并纠正它，此外还能检测（但不能纠正）偶数个比特差错。<strong>检验和</strong>是指将数据作为 16 比特的整数对待并求和，求和结果的反码作为携带在报文段首部的因特网检验和，接收方通过对接收的数据（包括检验和）的和取反码，检测结果一旦出现 0 则代表出错，TCP 和 UDP 的检验和只用了 16 比特，计算开销不大，是相对较弱的差错保护。<strong>循环冗余检测（CRC）</strong>是现今计算机网络中广泛应用的差错检测技术，对要发送的数据比特串进行算术操作生成多项式，在适配器中用专用的硬件实现，能够执行更加复杂的计算，是比检验和更强的差错保护。</p>
<h2 id="5-2-链路层寻址"><a href="#5-2-链路层寻址" class="headerlink" title="5.2 链路层寻址"></a>5.2 链路层寻址</h2><h3 id="5-2-1-链路层地址"><a href="#5-2-1-链路层地址" class="headerlink" title="5.2.1 链路层地址"></a>5.2.1 链路层地址</h3><p>主机和路由器的每个网络接口/适配器都具有一个与之相关联的<strong>链路层地址（又称 LAN 地址、物理地址、MAC 地址）</strong>，MAC 地址的长度为 6 字节，通常用十六进制表示法，每个字节被表示为一对十六进制数，MAC 地址具有扁平结构，忽略软件作用的前提下，MAC 地址可以看作是固定不变且唯一的（不同于 IP 地址的层次结构，随着连接网络的变化而变化）。位于链路层的交换机通过 MAC 地址来交换链路层帧（这个过程中并不识别网络层 IP 地址），由于<strong>链路层交换机的任务只是在主机和路由器之间透明地承载数据报，主机和路由器不必明确地将帧寻址到其间的交换机，因此链路层交换机本身并不具有与自身网络接口相关联的 MAC 地址</strong>，与此同时，这些帧到达交换机的任何输出接口之一的速率可能会暂时超过该接口的链路容量，因此交换机的输出接口设有缓存功能，这也令交换机的聚合带宽是该交换机所有接口速率之和，提供了比使用广播链路局域网高得多的性能改善。</p>
<p>当一台链路层交换机将一个入帧广播到它的所有接口时，<strong>一个适配器（可能是主机/路由器/链路层交换机）都可以接收到一个并非向它寻址的帧</strong>；当主机/路由器接收到一个入帧时，将检查该帧中的目的 MAC 地址，若与自身 MAC 地址或 MAC 广播地址（48 个连续的 1）匹配则沿协议栈向上传递，否则直接丢弃该帧；当一台链路层交换机接收到一个入帧时（<strong>会在交换机表中存储关于该入帧的表项</strong>），交换机查询交换机表中是否存在对应该帧目的 MAC 地址的表项，若不存在这样的表项则继续向除了接收该帧的输入接口之外的所有接口的广播该帧的副本，若存在这样的表项且该表项显示与该帧目的 MAC 地址相关联的接口就是接收该帧的输入接口则直接丢弃该帧，若存在这样的表项且表项显示存在其他与该帧目的地址相关联的接口则向该接口输出该帧的副本（<strong>交换机将链路彼此隔离，局域网中的不同链路能够以不同的速率运行并且能够在不同的媒介上运行</strong>）。</p>
<h3 id="5-2-2-地址解析协议"><a href="#5-2-2-地址解析协议" class="headerlink" title="5.2.2 地址解析协议"></a>5.2.2 地址解析协议</h3><p>当发送方主机/路由器需要向另一个主机/路由器发送一个数据报时，需要根据数据报的目的 IP在数据报封装帧中包含目的 IP 所对应的 MAC 地址。<strong>地址解析协议（ARP）</strong>用于根据 IP 地址解析得到其对应的 MAC 地址，仅服务于同一个子网上的主机和路由器接口，既可以看作是链路层协议，也可以看作是网络层协议。每台主机或路由器在其内存中具有一个 ARP 表，ARP 表包含 IP 地址到 MAC 地址的映射关系，单台主机或路由器中的表中的映射可能并不全或过期。</p>
<p>当源和目的地位于不同子网时，即便知道目的 IP 所对应的 MAC 地址，也不能在数据报封装帧中使用目的主机的 MAC 地址，否则发送方所在子网中的所有适配器都会由于自身 MAC 地址与帧的目的 MAC 不匹配而会直接丢弃该帧，此时应当在数据报封装帧中使用路由路径上的第一跳路由器的 MAC 地址，即<strong>发送方主机不可能通过一个链路直接将数据报发送给其他子网上的主机，至少应该先发送给当前子网中的路由器</strong>。当源和目的地位于同一子网时，若发送方从自身的 ARP 表中找不到目的 IP 所对应的 MAC 地址，发送方则构造一个 <strong>ARP 分组</strong>，发送方的适配器在链路层将这个 ARP 分组封装成帧并使用 MAC 广播地址作为帧的目的地址，从而询问子网上的所有其他主机和路由器，因此 ARP 是一种广播协议（RARP 不是），只有目标主机会响应这个广播请求。ARP 查询分组和响应分组具有相同的格式，都包含有源和目的的 IP 地址和 MAC 地址，区别在于 <strong>ARP 查询分组封装在一个广播帧中，而 ARP 响应分组封装在一个标准帧中</strong>。</p>
<h3 id="5-2-3-Web-页面请求"><a href="#5-2-3-Web-页面请求" class="headerlink" title="5.2.3 Web 页面请求"></a>5.2.3 Web 页面请求</h3><p>客户端主机通过一根以太网电缆连接到某个以太网交换机，以太网交换机与局域网的网关路由器相连，NAT 使能的网关路由器运行一个 DHCP 服务器，路由器还与一个 ISP 连接，ISP 中存在 DNS 服务器，因此 ISP 可以为这个局域网提供 DNS 服务。</p>
<p>客户端主机与网络连接时，运行主机本地的 DHCP 服务器生成 DHCP 请求报文，包含 DHCP 请求的广播以太网帧是客户端主机发出的第一个发送到以太网交换机的帧，该交换机在所有的出端口（包括连接到网关路由器的端口）广播入帧，网关路由器接收到该帧并从中获得 DHCP 请求报文，路由器上的 DHCP 服务器分配 IP 地址给客户端主机，以太网交换机通过自学习的方式记录了客户端主机所关联的输出端口以及网关路由器的 IP 地址，主机接收到包含 DHCP ACK 的以太网帧后获得自己的 IP 地址、网关路由器的 IP 地址以及 DNS 服务器的 IP 地址等。</p>
<p>客户端主机在浏览器中输入 Web 页面的 URL 后，客户端主机生成 ARP 查询报文来查询网关路由器 IP 地址所对应的 MAC 地址，接着向位于不同子网的 DNS 服务器发送 DNS 查询报文（目的 IP 为 DNS 服务器的 IP，目的 MAC 为网关路由器的 MAC），封装了 DNS 查询报文的 IP 数据报会经过各个路由器转发后到达 DNS 服务器，Web 浏览器获得 Web 页面所在的 Web 服务器的 IP 地址，并向服务器发送 TCP SYN 报文段（目的 IP 为 Web 服务器的 IP，目的 MAC 为网关路由器的 MAC），由此生成 TCP 套接字建立 TCP 连接，浏览器生成包含要获取的 URL 的 HTTP GET 报文，通过 TCP 连接被交付到 Web 服务器，包含有所请求 Web 页面的 HTTP 响应也通过 TCP 连接发送到 Web 浏览器。</p>
<h2 id="5-3-重要网络技术"><a href="#5-3-重要网络技术" class="headerlink" title="5.3 重要网络技术"></a>5.3 重要网络技术</h2><h3 id="5-3-1-以太网技术"><a href="#5-3-1-以太网技术" class="headerlink" title="5.3.1 以太网技术"></a>5.3.1 以太网技术</h3><p>以太网是第一个广泛部署的<strong>高速广播局域网</strong>，为网络层提供<strong>无连接</strong>、<strong>不可靠</strong>的服务（直接将封装着数据报的以太网帧发送到局域网中，不需要事先握手，也不需要事后 ACK），并<strong>可以以不同的速率传输承载着不同类型数据报的以太网帧</strong>，使用具有二进制指数回退的 CSMA/CD 多路访问协议来协调帧传输，是目前最流行的<strong>有线局域网技术</strong>，是链路层也是物理层的规范。以太网帧的负载/数据字段是 IP 数据报（以外也可以承载其他网络层分组），以太网的最大传输单元 MTU 是 1500 字节，当 IP 数据报超过 MTU 时，主机必须将该数据报分片，以太网帧的类型字段运行以太网复用多种网络层协议（除 IP 以外的其他网络层协议，比如 ARP 协议等），适配器接收到一个以太网帧时根据类型字段来判断应该将数据字段传递给哪个网络层协议。</p>
<p>基于总线拓扑结构的以太网将所有传输的帧传送到与总线连接的所有适配器并被处理；基于星形拓扑的以太网中，所有的主机和路由器直接与集线器相连，集线器是一种作用于比特（而不是作用于帧）的物理层设备，集线器始终将自己从一个接口接收到比特的副本发送到其他所有接口，那么当集线器从多个不同接口接收到同一个帧时就会发生碰撞，因此，集线器后来被无碰撞的链路层分组交换机所替代，交换机通过<strong>存储转发</strong>对接收到的帧进行分组交换，绝不会在相同的网段（即相同的接口）上同时传输多于一个帧，且由于现代交换机是全双工的，一台交换机和一个节点能够同时向对方发送帧而没有干扰，因此，基于交换机的星形拓扑以太网中<strong>不会有碰撞</strong>，那么也<strong>无需 MAC 协议</strong>来协调帧传输，此外，交换机还是一个可以通过<strong>自学习</strong>的方式建立自己的交换机表的<strong>即插即用设备</strong>，不需要来自网络管理员或配置协议的任何干预。</p>
<h3 id="5-3-2-虚拟局域网"><a href="#5-3-2-虚拟局域网" class="headerlink" title="5.3.2 虚拟局域网"></a>5.3.2 虚拟局域网</h3><p>支持虚拟局域网（VLAN）的交换机允许经一个单一的物理局域网基础设施定义多个虚拟局域网。交换机的接口由网络管理员划分为组，每个组构成一个 VLAN，在每个 VLAN 中的接口形成一个广播域，在一个 VLAN 内的主机彼此通信，将其他 VLAN 中的主机看作不存在，来自一个接口的流量仅能到达该接口所在的 VLAN 中的其他接口，从而将位于单一 PLAN 中的不同 VLAN 彼此隔离。当不同 VLAN 需要彼此通信时，就令交换机的一个接口与一台外部路由器相连，该接口称为干线接口，干线接口被配置为属于所有 VLAN，那么不同 VLAN 就可以通过干线接口和一个路由器来彼此通信（使用一种扩展的以太网帧格式）。</p>
<h3 id="5-3-3-数据中心"><a href="#5-3-3-数据中心" class="headerlink" title="5.3.3 数据中心"></a>5.3.3 数据中心</h3><p>大规模数据中心不仅连接着因特网，其内部还包括复杂的计算机网络（称为数据中心网络）用于连接内部数万至数十万台主机，一般是包括 CPU、内存和磁盘存储的商用主机（称为刀片），每个机架一般堆放 20~40 台刀片，每个机架顶部有一台交换机（称为机架顶部交换机 TOR）。TOR 一方面与机架上的刀片互联（通过以太网），另一方面与数据中心的其他底层交换机互联，底层交换机与高层交换机互联，高层交换机与负载均衡器和接入路由器互联，接入路由器与边界路由器互联连接到外部客户所在的因特网。所有的外部请求首先被定位到负载均衡器，负载均衡器会通过交换机来向主机分发请求从而平衡主机间的工作负载，此外还将外部 IP 地址转换为内部适当主机的 IP 地址，也就提供了类似 NAT 的功能，这可以防止外部客户直接接触主机，隐藏数据中心的内部网络结构。</p>
<h3 id="5-3-4-无线-移动网络"><a href="#5-3-4-无线-移动网络" class="headerlink" title="5.3.4 无线/移动网络"></a>5.3.4 无线/移动网络</h3><p>不同的无线链路技术具有可以自适应的不同的传输速率、传输范围以及比特差错率等，无线主机（可能移动也可能不移动）通过无线通信链路连接到一个基站，从而连接到更大的网络基础设施（通常是有线网络）中，基站负责向与之关联（即主机位于基站通信覆盖范围内并以基站作为中继来与更大网络通信）的无线主机发送数据分组和接收来自主机的数据，并协调与之关联的多个无线主机的传输，蜂窝网络中蜂窝塔和 802.11 无线局域网中的接入点都是基站的例子。当一台移动主机离开一个基站的覆盖范围而到达另一个基站的覆盖范围后，将改变与之关联的基站，接入更大网络的连接点（这个过程称为切换）。无线网络在链路层和网络层与有线网络有着重大区别。</p>
<p>IEEE 802.11 无线局域网（也称为 WiFi）一种十分重要的接入网技术，使用 CSMA/CA 多路访问协议，CRC 以及链路层确认/重传（ARQ）。802.11 体系结构的基本构件模块是基本服务集（BSS），BSS 包括一个或多个无线站点以及中央基站（称为接入点 AP），AP 通过交换机或路由器之类的互联设备连接到因特网中，部署 AP 的无线局域网称作基础设施无线局域网，每个无线站点在能够发送或者接收网络层数据（获得因特网接入）之前，必须与一个 AP 相关联，通常选择多个 AP 中信号强度最高的 AP 进行关联并加入该 AP 所属的子网中，进而获取在该 AP 子网中的一个 IP 地址。</p>
<p>当主机无法与任何一个 AP 相关联时，也可以选择更加迅速普及的蜂窝网络。蜂窝网络覆盖的区域被划分成许多地理覆盖区域，称为小区，每个小区都有一个基站向小区内的移动设备发送和接收信号。2G 蜂窝网络是一个电路交换的移动电话网络，只是用于语音而不是数据服务，3G 蜂窝网络支持电路交换语音服务和分组交换数据服务，是语音和数据结合网络，4G 长期演化（LTE）架构是一个全 IP 的架构，在两个端点之间建立具备唯一隧道端点标识符的隧道，用户数据通过隧道进行传输。</p>
<p>蓝牙网络的工作距离非常短，功耗低，成本低，被称为无线个人区域网络或微微网，采用 TDMA 和 TDMA 多路访问、随机回退、轮询、错误检测和纠正，不需要网络基础设施，是自组织网络。当主节点想要组成蓝牙网络时，通过邻居发现来确定哪些蓝牙设备在其覆盖范围内，接着通过蓝牙寻呼来邀请覆盖范围内的潜在客户，建立客户与蓝牙网络的连接。</p>
<h1 id="6、参考资料"><a href="#6、参考资料" class="headerlink" title="6、参考资料"></a>6、参考资料</h1><ul>
<li>《Computer Networking: A Top-Down Approach, Eighth Edition》</li>
</ul>
</section>
    <!-- Tags START -->
    
    <!-- Tags END -->
    <!-- NAV START -->
    
  <div class="nav-container">
    <!-- reverse left and right to put prev and next in a more logic postition -->
    
      <a class="nav-left" href="/2023/11/05/history-vocabulary/">
        <span class="nav-arrow">← </span>
        
          History Vocabulary -
        
      </a>
    
    
      <a class="nav-right" href="/2023/12/09/java-virtual-machine/">
        
          Java Virtual Machine
        
        <span class="nav-arrow"> →</span>
      </a>
    
  </div>

    <!-- NAV END -->
    <!-- 打赏 START -->
    
    <!-- 打赏 END -->
    <!-- 二维码 START -->
    
    <!-- 二维码 END -->
    
      <!-- Utterances START -->
      <div id="utterances"></div>
      <script src="https://utteranc.es/client.js"
        repo=""
        issue-term="pathname"
        theme="github-light"
        crossorigin="anonymous"
        async></script>    
      <!-- Utterances END -->
    
  </article>
  <!-- Article END -->
  <!-- Catalog START -->
  
    <aside class="catalog-container">
  <div class="toc-main">
  
      
          <strong class="toc-title">OUTLINE</strong>
          <ol class="toc-nav"><li class="toc-nav-item toc-nav-level-1"><a class="toc-nav-link" href="#1%E3%80%81%E6%A6%82%E8%BF%B0"><span class="toc-nav-text">1、概述</span></a></li><li class="toc-nav-item toc-nav-level-1"><a class="toc-nav-link" href="#2%E3%80%81%E5%BA%94%E7%94%A8%E5%B1%82"><span class="toc-nav-text">2、应用层</span></a><ol class="toc-nav-child"><li class="toc-nav-item toc-nav-level-2"><a class="toc-nav-link" href="#2-1-%E5%9F%BA%E6%9C%AC%E5%8E%9F%E7%90%86"><span class="toc-nav-text">2.1 基本原理</span></a><ol class="toc-nav-child"><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#2-1-1-%E7%BD%91%E7%BB%9C%E5%BA%94%E7%94%A8%E7%A8%8B%E5%BA%8F"><span class="toc-nav-text">2.1.1 网络应用程序</span></a></li><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#2-1-2-%E5%BA%94%E7%94%A8%E5%B1%82%E5%8D%8F%E8%AE%AE"><span class="toc-nav-text">2.1.2 应用层协议</span></a></li><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#2-1-3-%E5%A5%97%E6%8E%A5%E5%AD%97%E7%BC%96%E7%A8%8B"><span class="toc-nav-text">2.1.3 套接字编程</span></a></li></ol></li><li class="toc-nav-item toc-nav-level-2"><a class="toc-nav-link" href="#2-2-Web-%E5%BA%94%E7%94%A8-HTTP"><span class="toc-nav-text">2.2 Web 应用 HTTP</span></a><ol class="toc-nav-child"><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#2-2-1-HTTP-%E7%89%B9%E6%80%A7"><span class="toc-nav-text">2.2.1 HTTP 特性</span></a></li><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#2-2-3-HTTP-%E6%8A%A5%E6%96%87"><span class="toc-nav-text">2.2.3 HTTP 报文</span></a></li><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#2-2-4-%E7%94%A8%E6%88%B7%E7%8A%B6%E6%80%81"><span class="toc-nav-text">2.2.4 用户状态</span></a></li><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#2-2-5-%E5%8D%8F%E8%AE%AE%E7%89%88%E6%9C%AC"><span class="toc-nav-text">2.2.5 协议版本</span></a></li><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#2-2-6-HTTP-%E8%AF%B7%E6%B1%82"><span class="toc-nav-text">2.2.6 HTTP 请求</span></a></li><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#2-2-7-%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8"><span class="toc-nav-text">2.2.7 网络安全</span></a></li></ol></li><li class="toc-nav-item toc-nav-level-2"><a class="toc-nav-link" href="#2-3-%E7%94%B5%E5%AD%90%E9%82%AE%E4%BB%B6-SMTP"><span class="toc-nav-text">2.3 电子邮件 SMTP</span></a></li><li class="toc-nav-item toc-nav-level-2"><a class="toc-nav-link" href="#2-4-%E5%9F%9F%E5%90%8D%E7%B3%BB%E7%BB%9F-DNS"><span class="toc-nav-text">2.4 域名系统 DNS</span></a></li><li class="toc-nav-item toc-nav-level-2"><a class="toc-nav-link" href="#2-5-%E8%A7%86%E9%A2%91%E6%B5%81-HTTP-DASH"><span class="toc-nav-text">2.5 视频流 HTTP&#x2F;DASH</span></a></li><li class="toc-nav-item toc-nav-level-2"><a class="toc-nav-link" href="#2-6-%E6%96%87%E4%BB%B6%E5%88%86%E5%8F%91-BitTorrent"><span class="toc-nav-text">2.6 文件分发 BitTorrent</span></a></li></ol></li><li class="toc-nav-item toc-nav-level-1"><a class="toc-nav-link" href="#3%E3%80%81%E8%BF%90%E8%BE%93%E5%B1%82"><span class="toc-nav-text">3、运输层</span></a><ol class="toc-nav-child"><li class="toc-nav-item toc-nav-level-2"><a class="toc-nav-link" href="#3-1-%E5%9F%BA%E6%9C%AC%E5%8E%9F%E7%90%86"><span class="toc-nav-text">3.1 基本原理</span></a><ol class="toc-nav-child"><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#3-1-1-%E5%A4%9A%E8%B7%AF%E5%A4%8D%E7%94%A8-%E5%88%86%E8%A7%A3"><span class="toc-nav-text">3.1.1 多路复用&#x2F;分解</span></a></li><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#3-1-2-%E8%BF%90%E8%BE%93%E5%B1%82%E5%8D%8F%E8%AE%AE"><span class="toc-nav-text">3.1.2 运输层协议</span></a></li><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#3-1-3-%E5%8F%AF%E9%9D%A0%E6%95%B0%E6%8D%AE%E4%BC%A0%E8%BE%93"><span class="toc-nav-text">3.1.3 可靠数据传输</span></a></li></ol></li><li class="toc-nav-item toc-nav-level-2"><a class="toc-nav-link" href="#3-2-%E4%BC%A0%E8%BE%93%E6%8E%A7%E5%88%B6%E5%8D%8F%E8%AE%AE-TCP"><span class="toc-nav-text">3.2 传输控制协议 TCP</span></a><ol class="toc-nav-child"><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#3-2-1-%E5%8F%AF%E9%9D%A0%E4%BC%A0%E8%BE%93"><span class="toc-nav-text">3.2.1 可靠传输</span></a></li><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#3-2-2-%E8%BF%9E%E6%8E%A5%E7%AE%A1%E7%90%86"><span class="toc-nav-text">3.2.2 连接管理</span></a></li><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#3-2-3-%E6%B5%81%E9%87%8F%E6%8E%A7%E5%88%B6"><span class="toc-nav-text">3.2.3 流量控制</span></a></li><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#3-2-4-%E6%8B%A5%E5%A1%9E%E6%8E%A7%E5%88%B6"><span class="toc-nav-text">3.2.4 拥塞控制</span></a></li></ol></li></ol></li><li class="toc-nav-item toc-nav-level-1"><a class="toc-nav-link" href="#4%E3%80%81%E7%BD%91%E7%BB%9C%E5%B1%82"><span class="toc-nav-text">4、网络层</span></a><ol class="toc-nav-child"><li class="toc-nav-item toc-nav-level-2"><a class="toc-nav-link" href="#4-1-%E5%9F%BA%E6%9C%AC%E5%8E%9F%E7%90%86"><span class="toc-nav-text">4.1 基本原理</span></a><ol class="toc-nav-child"><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#4-1-1-%E6%95%B0%E6%8D%AE-%E6%8E%A7%E5%88%B6%E5%B9%B3%E9%9D%A2"><span class="toc-nav-text">4.1.1 数据&#x2F;控制平面</span></a></li><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#4-1-2-%E8%B7%AF%E7%94%B1%E5%99%A8%E7%BB%84%E6%88%90-%E5%8A%9F%E8%83%BD"><span class="toc-nav-text">4.1.2 路由器组成&#x2F;功能</span></a></li><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#4-1-3-%E8%B7%AF%E7%94%B1%E9%80%89%E6%8B%A9%E7%AE%97%E6%B3%95"><span class="toc-nav-text">4.1.3 路由选择算法</span></a></li><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#4-1-4-OSPF-%E5%92%8C-BGP"><span class="toc-nav-text">4.1.4 OSPF 和 BGP</span></a></li></ol></li><li class="toc-nav-item toc-nav-level-2"><a class="toc-nav-link" href="#4-2-%E6%95%B0%E6%8D%AE%E5%B9%B3%E9%9D%A2%E5%8D%8F%E8%AE%AE"><span class="toc-nav-text">4.2 数据平面协议</span></a><ol class="toc-nav-child"><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#4-2-1-%E7%BD%91%E9%99%85%E5%8D%8F%E8%AE%AE"><span class="toc-nav-text">4.2.1 网际协议</span></a></li><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#4-2-2-%E5%8A%A8%E6%80%81%E4%B8%BB%E6%9C%BA%E9%85%8D%E7%BD%AE%E5%8D%8F%E8%AE%AE"><span class="toc-nav-text">4.2.2 动态主机配置协议</span></a></li></ol></li><li class="toc-nav-item toc-nav-level-2"><a class="toc-nav-link" href="#4-3-%E6%8E%A7%E5%88%B6%E5%B9%B3%E9%9D%A2%E5%8D%8F%E8%AE%AE"><span class="toc-nav-text">4.3 控制平面协议</span></a><ol class="toc-nav-child"><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#4-3-1-OpenFlow-%E5%8D%8F%E8%AE%AE"><span class="toc-nav-text">4.3.1 OpenFlow 协议</span></a></li><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#4-3-2-%E7%BD%91%E9%99%85%E6%8E%A7%E5%88%B6%E4%BF%A1%E6%81%AF%E5%8D%8F%E8%AE%AE"><span class="toc-nav-text">4.3.2 网际控制信息协议</span></a></li><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#4-3-3-%E7%AE%80%E5%8D%95%E7%BD%91%E7%BB%9C%E7%AE%A1%E7%90%86%E5%8D%8F%E8%AE%AE"><span class="toc-nav-text">4.3.3 简单网络管理协议</span></a></li></ol></li></ol></li><li class="toc-nav-item toc-nav-level-1"><a class="toc-nav-link" href="#5%E3%80%81%E9%93%BE%E8%B7%AF%E5%B1%82"><span class="toc-nav-text">5、链路层</span></a><ol class="toc-nav-child"><li class="toc-nav-item toc-nav-level-2"><a class="toc-nav-link" href="#5-1-%E5%9F%BA%E6%9C%AC%E5%8E%9F%E7%90%86"><span class="toc-nav-text">5.1 基本原理</span></a><ol class="toc-nav-child"><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#5-1-1-%E9%93%BE%E8%B7%AF%E5%B1%82%E5%8D%8F%E8%AE%AE"><span class="toc-nav-text">5.1.1 链路层协议</span></a></li><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#5-1-2-%E5%B7%AE%E9%94%99%E6%A3%80%E6%B5%8B%E5%92%8C%E7%BA%A0%E6%AD%A3"><span class="toc-nav-text">5.1.2 差错检测和纠正</span></a></li></ol></li><li class="toc-nav-item toc-nav-level-2"><a class="toc-nav-link" href="#5-2-%E9%93%BE%E8%B7%AF%E5%B1%82%E5%AF%BB%E5%9D%80"><span class="toc-nav-text">5.2 链路层寻址</span></a><ol class="toc-nav-child"><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#5-2-1-%E9%93%BE%E8%B7%AF%E5%B1%82%E5%9C%B0%E5%9D%80"><span class="toc-nav-text">5.2.1 链路层地址</span></a></li><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#5-2-2-%E5%9C%B0%E5%9D%80%E8%A7%A3%E6%9E%90%E5%8D%8F%E8%AE%AE"><span class="toc-nav-text">5.2.2 地址解析协议</span></a></li><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#5-2-3-Web-%E9%A1%B5%E9%9D%A2%E8%AF%B7%E6%B1%82"><span class="toc-nav-text">5.2.3 Web 页面请求</span></a></li></ol></li><li class="toc-nav-item toc-nav-level-2"><a class="toc-nav-link" href="#5-3-%E9%87%8D%E8%A6%81%E7%BD%91%E7%BB%9C%E6%8A%80%E6%9C%AF"><span class="toc-nav-text">5.3 重要网络技术</span></a><ol class="toc-nav-child"><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#5-3-1-%E4%BB%A5%E5%A4%AA%E7%BD%91%E6%8A%80%E6%9C%AF"><span class="toc-nav-text">5.3.1 以太网技术</span></a></li><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#5-3-2-%E8%99%9A%E6%8B%9F%E5%B1%80%E5%9F%9F%E7%BD%91"><span class="toc-nav-text">5.3.2 虚拟局域网</span></a></li><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#5-3-3-%E6%95%B0%E6%8D%AE%E4%B8%AD%E5%BF%83"><span class="toc-nav-text">5.3.3 数据中心</span></a></li><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#5-3-4-%E6%97%A0%E7%BA%BF-%E7%A7%BB%E5%8A%A8%E7%BD%91%E7%BB%9C"><span class="toc-nav-text">5.3.4 无线&#x2F;移动网络</span></a></li></ol></li></ol></li><li class="toc-nav-item toc-nav-level-1"><a class="toc-nav-link" href="#6%E3%80%81%E5%8F%82%E8%80%83%E8%B5%84%E6%96%99"><span class="toc-nav-text">6、参考资料</span></a></li></ol>
      
  
  </div>
</aside>
  
  <!-- Catalog END -->
</main>

<script>
  (function () {
    var url = 'http://example.com/2023/11/06/computer-networking/';
    var banner = ''
    if (banner !== '' && banner !== 'undefined' && banner !== 'null') {
      $('#article-banner').css({
        'background-image': 'url(' + banner + ')'
      })
    } else {
      $('#article-banner').geopattern(url)
    }
    $('.header').removeClass('fixed-header')

    // error image
    $(".markdown-content img").on('error', function() {
      $(this).attr('src', '/css/images/error_icon.png')
      $(this).css({
        'cursor': 'default'
      })
    })

    // zoom image
    $(".markdown-content img").on('click', function() {
      var src = $(this).attr('src')
      if (src !== '/css/images/error_icon.png') {
        var imageW = $(this).width()
        var imageH = $(this).height()

        var zoom = ($(window).width() * 0.95 / imageW).toFixed(2)
        zoom = zoom < 1 ? 1 : zoom
        zoom = zoom > 2 ? 2 : zoom
        var transY = (($(window).height() - imageH) / 2).toFixed(2)

        $('body').append('<div class="image-view-wrap"><div class="image-view-inner"><img src="'+ src +'" /></div></div>')
        $('.image-view-wrap').addClass('wrap-active')
        $('.image-view-wrap img').css({
          'width': `${imageW}`,
          'transform': `translate3d(0, ${transY}px, 0) scale3d(${zoom}, ${zoom}, 1)`
        })
        $('html').css('overflow', 'hidden')

        $('.image-view-wrap').on('click', function() {
          $(this).remove()
          $('html').attr('style', '')
        })
      }
    })
  })();
</script>







    <div class="scroll-top">
  <span class="arrow-icon"></span>
</div>
    <footer class="app-footer">
  <p class="copyright">
    &copy; 2024 | Proudly powered by <a href="https://hexo.io" target="_blank">Hexo</a>
    <br>
    Theme by <a target="_blank" rel="noopener" href="https://github.com/yanm1ng">yanm1ng</a>
    
  </p>
</footer>

<script>
  function async(u, c) {
    var d = document, t = 'script',
      o = d.createElement(t),
      s = d.getElementsByTagName(t)[0];
    o.src = u;
    if (c) { o.addEventListener('load', function (e) { c(null, e); }, false); }
    s.parentNode.insertBefore(o, s);
  }
</script>
<script>
  async("//cdnjs.cloudflare.com/ajax/libs/fastclick/1.0.6/fastclick.min.js", function(){
    FastClick.attach(document.body);
  })
</script>

<script>
  var hasLine = 'true';
  async("//cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/highlight.min.js", function(){
    $('figure pre').each(function(i, block) {
      var figure = $(this).parents('figure');
      if (hasLine === 'false') {
        figure.find('.gutter').hide();
      }
      hljs.configure({useBR: true});
      var lang = figure.attr('class').split(' ')[1] || 'code';
      var codeHtml = $(this).html();
      var codeTag = document.createElement('code');
      codeTag.className = lang;
      codeTag.innerHTML = codeHtml;
      $(this).attr('class', '').empty().html(codeTag);
      figure.attr('data-lang', lang.toUpperCase());
      hljs.highlightBlock(block);
    });
  })
</script>
<!-- Baidu Tongji -->


<script src="/js/script.js"></script>


  </body>
</html>
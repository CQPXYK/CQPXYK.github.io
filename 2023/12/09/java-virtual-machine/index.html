<!DOCTYPE html>
<html>
  <head>
  <meta http-equiv="content-type" content="text/html; charset=utf-8">
  <!--<meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport">-->
  <meta name="description" content="要有一个从输入到输出的过程">
  <meta name="keyword" content="">
  
    <link rel="shortcut icon" href="/css/images/logo.png">
  
  <title>
    
      Java Virtual Machine | CQ&#39;s Blog
    
  </title>
  <link href="//cdnjs.cloudflare.com/ajax/libs/font-awesome/4.7.0/css/font-awesome.min.css" rel="stylesheet">
  <link href="//cdnjs.cloudflare.com/ajax/libs/nprogress/0.2.0/nprogress.min.css" rel="stylesheet">
  <link href="//cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/tomorrow.min.css" rel="stylesheet">
  
<link rel="stylesheet" href="/css/style.css">

  
  <script src="//cdnjs.cloudflare.com/ajax/libs/jquery/3.2.1/jquery.min.js"></script>
  <script src="//cdnjs.cloudflare.com/ajax/libs/geopattern/1.2.3/js/geopattern.min.js"></script>
  <script src="//cdnjs.cloudflare.com/ajax/libs/nprogress/0.2.0/nprogress.min.js"></script>
  
  
  
  


  
  
    
<script src="/js/local-search.js"></script>


<meta name="generator" content="Hexo 5.4.2"></head>
<div class="wechat-share">
  <img src="/css/images/logo.png" />
</div>
  <body>
    <header class="header fixed-header">
  <div class="header-container">
    <a class="home-link" href="/">
      <div class="logo"></div>
      <span>CQ's Blog</span>
    </a>
    <ul class="right-list">
      
        <li class="list-item">
          
            <a href="/" class="item-link">Home</a>
          
        </li>
      
        <li class="list-item">
          
            <a href="/categories/" class="item-link">Categories</a>
          
        </li>
      
        <li class="list-item">
          
            <a href="/records" class="item-link">Records</a>
          
        </li>
      
        <li class="list-item">
          
            <a href="/scratches/" class="item-link">Scratches</a>
          
        </li>
      
        <li class="list-item">
          
            <a href="/archives/" class="item-link">Archives</a>
          
        </li>
      
      
        <li class="menu-item menu-item-search right-list">
    <a role="button" class="popup-trigger">
        <i class="fa fa-search fa-fw"></i>
    </a>
</li>
      
    </ul>
    <div class="menu">
      <span class="icon-bar"></span>
      <span class="icon-bar"></span>
      <span class="icon-bar"></span>
    </div>
    <div class="menu-mask">
      <ul class="menu-list">
        
          <li class="menu-item">
            
              <a href="/" class="menu-link">Home</a>
            
          </li>
        
          <li class="menu-item">
            
              <a href="/categories/" class="menu-link">Categories</a>
            
          </li>
        
          <li class="menu-item">
            
              <a href="/records" class="menu-link">Records</a>
            
          </li>
        
          <li class="menu-item">
            
              <a href="/scratches/" class="menu-link">Scratches</a>
            
          </li>
        
          <li class="menu-item">
            
              <a href="/archives/" class="menu-link">Archives</a>
            
          </li>
        
      </ul>
    </div>
    
      <div class="search-pop-overlay">
    <div class="popup search-popup">
        <div class="search-header">
            <span class="search-icon">
                <i class="fa fa-search"></i>
            </span>
            <div class="search-input-container">
                <input autocomplete="off" autocapitalize="off"
                    placeholder="Please enter your keyword(s) to search." spellcheck="false"
                    type="search" class="search-input">
            </div>
            <span class="popup-btn-close">
                <i class="fa fa-times-circle"></i>
            </span>
        </div>
        <div id="search-result">
            <div id="no-result">
                <i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i>
            </div>
        </div>
    </div>
</div>
    
  </div>
</header>

    <div id="article-banner">
  <h2>Java Virtual Machine</h2>
  <!--<p class="post-date">2023-12-09</p>
  <div class="arrow-down">
    <a href="javascript:;"></a>
  </div>-->
</div>
<main class="app-body flex-box">
  <!-- Article START -->
  <article class="post-article">
    <section class="markdown-content"><h1 id="1、引言"><a href="#1、引言" class="headerlink" title="1、引言"></a>1、引言</h1><p>Java 技术体系主要由支撑 Java 程序运行的虚拟机、提供各开发领域接口支持的 Java 类库、Java 编程语言及许许多多的第三方 Java 框架（如 Spring、MyBatis）构成。JVM 层面隐藏了机器平台、操作系统、资源管理等底层技术的复杂性和差异性，在千差万别的平台上建立了统一的 Java 运行平台，与此同时也牺牲了一些硬件相关的性能特性，即提升硬件性能时无法等比例提升 Java 程序的运行性能和并放能力，甚至可能没有任何改善，了解 JVM 是为了写出最适合 JVM 运行和自优化的 Java 代码。</p>
<p>HotSpot VM 是 Sun/OracleJDK 和 OpenJDK 中的默认 JVM，HotSpot VM 的热点代码探测能力可以通过执行计数器找出最具有编译价值的代码，然后通知即时编辑器以方法为单位进行编译，通过编译器与解释器恰当地协同工作，将热点代码编译为物理硬件可以直接执行的机器码 ，可以在最优化的程序响应时间与最佳执行性能中取得平衡，而且无须等待本地代码输出才能执行程序，即时编译的时间压力也相对减小，有助于引入更复杂的代码优化技术，输出质量更高的本地代码。</p>
<h1 id="2、自动内存管理"><a href="#2、自动内存管理" class="headerlink" title="2、自动内存管理"></a>2、自动内存管理</h1><h2 id="2-1-内存使用"><a href="#2-1-内存使用" class="headerlink" title="2.1 内存使用"></a>2.1 内存使用</h2><p>Java 程序将控制内存的权利交给了 JVM，在编码的时候享受自动内存管理，但需要通过了解 JVM 使用和回收内存的原理来排查内存泄漏和溢出方面的问题。C++ 则需要在程序中显式地进行内存管理，但有第三方框架可以提供垃圾收集的支持。</p>
<h3 id="2-1-1-内存分区"><a href="#2-1-1-内存分区" class="headerlink" title="2.1.1 内存分区"></a>2.1.1 内存分区</h3><p>JVM 在执行 Java 程序过程中会把它所管理的内存划分为</p>
<ul>
<li><strong>程序计数器</strong><ul>
<li>是一块较小的内存空间，可以看作是当前线程所执行的字节码的行号指示器</li>
<li>每个线程都有自己独立的程序计数器，是线程私有的内存，生命周期与所属的线程相同</li>
<li>如果线程正在执行的是一个 Java 方法，计时器记录的是正在执行的虚拟机字节码指令的地址，如果正在执行的是本地 Native 方法，这个计数器值则为空</li>
<li>此内存区域是唯一一个没有规定任何 OutOfMemoryError 情况的区域</li>
</ul>
</li>
<li><strong>虚拟机栈</strong><ul>
<li>每个线程都有自己独立的虚拟机栈空间，是线程私有的内存，生命周期与所属的线程相同，每个方法被执行时，JVM 都会同步创建一个栈帧用于存储局部变量表、操作数栈、动态连接、方法出口等信息，Java 方法从被调用到执行完毕就对应栈帧在虚拟机栈中从入栈到出栈的过程</li>
<li>虚拟机栈通常只是指虚拟机栈中局部变量表部分，局部变量表存放了编译期可知的各种基本数据类型、对象引用以及 returnAddress 类型（指向了一条字节码指令的地址）</li>
<li>局部变量表中所存放的这些数据类型在局部变量表中的存储空间以局部变量槽来表示，long 和 double 会占据两个变量槽，其余的数据类型只占用一个变量槽，一个方法需要在栈帧中分配多少个变量槽是在编译期间就确定的，在方法运行期间不会改变局部变量槽的个数</li>
<li>如果线程请求的栈深度大于 JVM 所允许的深度时则抛出 StackOverflowError，如果 JVM 栈容量可以动态扩展，当栈扩展到无法申请到足够的内存时则抛出 OutOfMemoryError 异常</li>
<li>HotSpot VM 通过参数 -Xss 设定初始栈容量，但不支持运行期间的栈容量动态扩展，因此只会在栈容量不足时出现 StackOverflowError，此时会有明确错误堆栈可供分析，可以容易定位到问题代码所在</li>
</ul>
</li>
<li><strong>本地方法栈</strong><ul>
<li>本地方法栈为 JVM 使用到的本地 Native 方法服务，Native 方法从被调用到执行完毕就对应栈帧在本地方法栈中从入栈到出栈的过程，JVM 可以自由的实现本地方法栈，也可以直接把本地方法栈和虚拟机栈合二为一</li>
<li>本地方法栈也会在栈深度溢出或者栈扩展失败时分别抛出 StackOverflowError 和 OutOfMemoryError</li>
</ul>
</li>
<li><strong>堆</strong><ul>
<li>堆是 JVM 所管理的内存中最大的一块，是被所有线程共享的内存区域，在 JVM 启动时创建，用于存发对象实例，几乎所有的对象实例以及数组都在这里分配内存，是 JVM 垃圾收集器管理的内存区域，因此也称作 GC 堆</li>
<li>堆可以处于物理上不连续的内存空间中，但在逻辑上应该被视为是连续的，堆既可以是固定大小的，也可以是扩展的（通过参数 -Xmx 和 -Xms 设定），如果堆中没有足够的可用内存来完成实例分配并且堆也无法再扩展时，会抛出 OutOfMemoryError</li>
<li>当出现 OutOfMemoryError 时，首先查看是否存在内存泄漏，确保垃圾收集器回收了所有应当回收的内存，其次检查是否存在不合理的生命周期过长的对象，尽量减少程序运行期间的内存消耗，最后查看是否可以上调堆参数 -Xmx 和 -Xms</li>
</ul>
</li>
<li><strong>方法区</strong><ul>
<li>方法区也是被所有线程共享的内存区域，存储已被 JVM 加载的类型信息、常量、静态变量、即时编译器编译后的代码缓存等数据，方法区有一个别名叫作非堆，这是为了与堆区分开来</li>
<li>运行时常量池相对于 Class 文件常量池表的一个重要特征是具备动态性，Java 语言并不要求常量一定只有编译期才产生（指的是字面量先在编译期进入 Class 文件常量池表，再在运行期类加载后被存放到方法区的<strong>运行时常量池</strong>中这种情况），运行期间也可以将新的常量放入池中（比如 String.intern() 方法会把首次遇到的字符串实例放入字符串常量池中，并返回常量池中的字符串实例的引用），关于 intern 方法详细参见 <a href="../../../../2022/05/08/java-language/">Java Language</a> 中的 5.3 小节</li>
<li>方法区和堆一样不需要连续的内存，可以选择固定大小，也可以扩展，甚至还可以选择不实现垃圾收集</li>
<li>方法区的垃圾收集比较少见，但并非数据进入方法区就永久存在了，方法区的内存回收目标主要是针对常量池的回收和对类型的卸载，一旦方法区无法满足新的内存分配需求时，将抛出 OutOfMemoryError</li>
<li>一个类被垃圾回收的条件是比较严苛的，在经常运行时生成大量动态类的应用场景（比如 CGLIB 这类字节码技术、动态产生大量需要被编译成 Java 类的 JSP 文件等）里就需要特别关注这些类的回收情况，</li>
</ul>
</li>
</ul>
<p>JVM 所管理的这些区域有各自的用途，此外，直接内存并不是 JVM 运行时数据区的一部分，但<strong>直接内存</strong>也被频繁地使用，比如 NIO 类可以使用 Native 函数库直接分配堆外内存，然后通过一个存储在 Java 堆中的对象作为这块堆外内存的引用进行操作，避免在 Java 堆和 Native 堆中来回复制数据，能够在一些场景中显著提高性能。本机直接内存的分配显然不会受到 Java 堆大小的限制，但依旧会受到本机总内存大小以及处理器寻址空间的限制，需要注意的是在配置 JVM 参数时不要忽略直接内存，否则可能会使得 JVM 所管理内存加上直接内存后超过本机物理内存限制，从而导致动态扩展时出现 OutOfMemoryError（通过参数 -XX:MaxDirectMemorySize 可以指定直接内存的容量，如果不指定则默认与 Java 堆最大值一致）。直接内存无法主动通知收集器进行垃圾回收，只能等待 Full GC 的时候顺便被清理。</p>
<h3 id="2-1-2-内存分配"><a href="#2-1-2-内存分配" class="headerlink" title="2.1.2 内存分配"></a>2.1.2 内存分配</h3><p>当 JVM 遇到一条<strong>字节码 new 指令</strong>时，首先检查这个指令的参数是否能在常量池中定位到一个类的符号引用，检查这个符号引用代表的类是否已经被加载、解析和初始化，如果没有则先执行相应的<strong>类加载过程</strong>，在类加载完成后即可完全确定对象所需内存的大小，在类加载检查通过后，接着就将一块<strong>大小确定</strong>的内存块从 Java 堆（也有可能经过即时编译后被拆散为标量类型并间接地在栈上分配）中划分出来并<strong>设置对象头</strong>，这些工作都完成后，从 JVM 的视角来看一个新的对象已经产生了，但从 Java 程序的视角来看，对象创建工作刚刚开始，对象中所有的字段还都为默认值，对象需要的其他资源和状态信息也还没有按照预定的意图构造好，接下来需要<strong>执行构造函数</strong>（即 Class 文件中的 &lt;init&gt;() 方法）来按照程序员的意图对对象成员变量进行<strong>初始化</strong>，把<strong>堆内对象的首地址赋给引用变量</strong>，这样一个真正的可用对象才算完全被构造出来，对象在堆内存中的存储布局可以划分为<strong>对象头</strong>、<strong>实例数据</strong>和<strong>对齐填充</strong>。</p>
<p>从 Java 堆中划分内存的方式取决于 Java 堆是否规整，Java 堆是否规整取决于所采用的垃圾收集器是否带有空间压缩整理的能力。当 Java 堆中内存是绝对规整的（所有被使用的内存都被放在一边，空闲的内存被放在另一边，中间放着一个指针作为分界点的指示器）时，那只需进行<strong>指针碰撞</strong>（将指针向空闲方向挪动一段与对象所需大小相等的距离），这种方式在并发情况下并不是线程安全的，所以要么进行<strong>同步锁定</strong>，要么通过本地<strong>线程分配缓冲</strong>（TLAB，预先分配一小块内存给每个线程）来把内存分配的动作按照线程划分在不同的空间中进行，只有在线程本地缓存空间用完后才需要同步锁定。当 Java 堆中内存不是规整的（使用过的内存和未被使用的内存相互交错在一起）时，JVM 会维护一个<strong>空闲列表</strong>来记录可用的内存块，在分配时就从空闲列表中找到一块足够大的空间划分给对象实例，并更新空闲列表。</p>
<p><strong>对象头中的信息是与对象自身定义的数据无关的额外存储成本</strong>，包括两类信息，一类是用于存储对象自身的运行时数据，如对象所对应的哈希码（实际会延后到真正调用 Object::hashCode() 方法时才计算）、GC 分代年龄、锁状态标志、线程持有的锁、偏向线程 ID、偏向时间戳等，这部分数据称为 <strong>Mark Word</strong>，Mark Word 是一个有着动态定义的数据结构，旨在在极小的空间内存储尽量多的数据，根据对象的状态复用自己的存储空间，其长度在 32 位和 64 位的 JVM（未开启压缩指针）中分别为 32 个比特和 64 个比特；对象头的另一部分是<strong>类型指针</strong>，即指向方法区内的对象类型数据的地址，JVM 通过这个指针来确定该对象是哪个类的实例及该类的类型信息，但由于查找对象类型数据并不一定要经过对象本身（也可能是通过句柄来访问），因此并不是所有的 JVM 都必须在对象头上保留类型指针；此外，对于数组对象，对象头还必须有一块用于记录数组长度的数据。基本类型数据包装为类对象之后会因为增加了对象头等导致消耗的内存变大。</p>
<p><strong>实例数据部分是对象真正存储的有效信息，即程序代码中定义的各种类型的字段内容</strong>，无论是从父类继承下来的，还是在子类中定义的字段都必须记录起来，这部分的存储顺序会受到 JVM 分配策略参数配置和字段在 Java 源码中定义顺序的影响，HotSpot VM 默认的分配顺序为 long/double、int、short、char、byte/boolean、oop (Ordinary Object Pointer)，即相同宽度的字段总司被分配到一起存放，在这个前提下，父类中定义的变量会出现在子类之前，也允许通过 HotSpot VM 的参数配置令子类之中较窄的变量插入到父类变量的空隙之中。</p>
<p>对齐填充部分并不是必然存在的，也没有特别的含义，仅仅起着占位符的作用，HotSpot VM 的自动内存管理系统要求对象起始地址必须是 8 字节的整数倍，即任何对象的大小都必须是 8 字节的整数倍，对象头部分已经被设计成正好是 8 字节的整数倍，因此如果对象实例数据部分没有对齐的话就需要通过对齐填充来补全。相同的程序在 64 位虚拟机中消耗的内存一般比 32 位虚拟机要大，这是因为指针膨胀以及对齐填充等因素导致的，可以开启（默认即开启）压缩指针功能来缓解。</p>
<p>Java 程序会<strong>通过栈上的 reference 数据来操作堆中的具体对象</strong>，根据 reference 来访问堆中对象的方式有 JVM 具体实现而定，主流的访问方式主要有使用句柄和直接指针两种。通过<strong>句柄访问</strong>时，Java 堆中可能会划分出一块内存来作为句柄池，reference 中存储的就是对象的句柄地址，而句柄中包含了堆内的对象实例数据与方法区内的对象类型数据各自具体的地址。通过<strong>直接指针访问</strong>时，reference 中存储的直接就是对象实例数据地址，不需要多一次通过访问句柄来间接访问对象的开销，但 Java 堆中对象的内存布局就必须考虑如何在对象数据中放置方法区内的对象类型数据的地址（一般是在对象头中设置类型指针）。</p>
<h2 id="2-2-垃圾收集"><a href="#2-2-垃圾收集" class="headerlink" title="2.2 垃圾收集"></a>2.2 垃圾收集</h2><p>当需要排查各种内存溢出、内存泄漏以及系统并发瓶颈问题时，都可能需要分析系统垃圾回收情况，程序计数器、虚拟机栈、本地方法栈的内存区域与特定线程伴生，其内存分配与回收都具备确定性（在编译期即可大致确定，且当方法结束或者线程结束时内存自然就随着回收了），无需过多考虑回收问题，而 <strong>Java 堆和方法区</strong>这两个区域则有显著的不确定性，只有运行期才能确定程序到底会创建哪些对象，其内存的分配和回收是动态取决于对象的引用关联情况的，需要重点关注。</p>
<h3 id="2-2-1-回收条件"><a href="#2-2-1-回收条件" class="headerlink" title="2.2.1 回收条件"></a>2.2.1 回收条件</h3><p>回收方法区时，需要判断方法区内的常量、类型信息等是否存在引用关联关系，其中，判断一个类型是否属于不再被使用的类需要满足三个条件：该类及其所有派生子类的所有实例都已经被回收，加载该类的类加载器已经被回收，该类对应的 Class 对象没有在任何地方被引用，此时该类的类型信息允许被回收，但也不一定（HotSpot VM 提供了 -Xnoclassgc 参数进行控制），在大量使用反射、动态代理、CGLIB 等字节码框架、动态生成 JSP 以及 OSGi 这类频繁自定义类加载器的场景中，通常都需要 JVM 具备类型信息卸载的能力，以确保不会对方法区造成过大的内存压力。</p>
<p>回收 Java 堆时，需要判断堆内对象是否存在引用关联关系，如果 reference 类型的数据中存储的数值是另外一块内存的起始地址，就称该 reference 数据是代表某块内存、每个对象的强引用，垃圾收集器永远不会回收被<strong>强引用</strong>的对象；<strong>软引用</strong>是用来描述一些还有用，但非必须得对象，在系统将要发生内存溢出前，会把软引用对象列进回收范围之中，即被软引用的对象只能生存到内存即将溢出为止，若回收后还没有足够的内存，才会抛出内存溢出异常；<strong>弱引用</strong>也是用来描述那些非必须对象，区别在于被弱引用的对象只能生存到下一次垃圾收集发生为止，当垃圾收集器开始工作，无论当前内存是否足够，都会回收只被弱引用关联的对象；<strong>虚引用</strong>也称为幽灵引用或者幻影引用，一个对象是否被虚引用完全不会对其生存时间构成影响，也无法通过虚引用来取得一个对象实例，虚引用关联的唯一目的只是为了在被引用对象被回收时收到一个系统通知。引用计数算法和根可达算法都可以判断一个对象是否存在引用关联关系。</p>
<p>当判断一个对象不存在引用关联关系时，该对象将会被第一次标记，随后判断该对象是否需要执行 finalize 方法（对象没有覆盖 finalize 方法或 finalize 方法已经被 JVM 执行过都视作不需要执行），对于不需要执行 finalize 方法的对象则真正回收该对象，对象死亡，对于需要执行 finalize 方法的对象将会被放置在一个名为 F-Queue 的队列之中，并在稍后由一条由 JVM 自动建立的、低调度优先级的 Finalizer 线程去触发这些对象的 finalize 方法开始运行（并不承诺一定会等待方法运行结束），随后垃圾收集器将对 F-Queue 中的对象进行第二次小规模标记，此时再一次检查 F-Queue 队列中的对象是否依旧不存在引用关联关系，若存在则将其移出 F-Queue，若不存在则真正回收该对象，对象死亡。整个过程中任何一个对象的 finalize 方法都只会被系统自动调用一次，但<strong>并不推荐在对象的 finalize 方法中令对象重新被引用，JVM 并不鼓励定义和使用 finalize，所有 finalize 能做的工作，都可以使用 try-finally 或者其他方式做的更好更及时</strong>。</p>
<p><strong>引用计数算法</strong>会在对象中添加一个引用计数器，每当有一个地方引用该对象计数器值就加一，每当引用失效计数器值就减一，计数器值为零的对象就是不可能再被使用的，但引用计数<strong>无法分辨循环引用</strong>的情况，JVM 并不使用引用技术算法来判断对象是否存活。<strong>根可达性算法</strong>通过一系列称为 <strong>GC Roots</strong> 的根对象作为起始节点集，根据引用关系向下搜索，搜索过程所走过的路径称为引用链，如果某个对象到 GC Roots 间没有任何引用链相连，则证明此对象是不可能再被使用的，JVM 采用根可达算法来判断对象是否存活，固定可作为 GC Roots 的对象包括虚拟机栈（栈帧中的本地变量）中引用的对象、方法区中类静态属性引用的对象、方法区中常量引用的对象、本地方法栈中 JNI（即 Native 方法）引用的对象、JVM 内部的引用（比如基本数据类型对应的 Class 对象，常驻的异常对象，系统类加载器等）、所有被 synchronized 锁持有的对象、反映 JVM 内部情况的 JMXBean、JVMTI 中注册的回调、本地代码缓存等，迄今为止。</p>
<p>所有垃圾收集器<strong>在 GC Roots 枚举这一步骤时必须暂停用户程序</strong>，HotSpot 在类加载动作完成时，就会把对象内什么偏移量上是什么类型的数据计算出来，在即时编译的过程中也会在特定的位置（被称为<strong>安全点</strong>）记录下栈里和寄存器里哪些位置是引用，并使用一组称为 <strong>OopMap</strong> 的数据结构来存放所有所有执行上下文和全局性的引用，在 OopMap 的协助下，HotSpot 可以快速准确地完成 GC Roots 枚举（停顿时间不随堆容量而增长了），<strong>安全点的选定既不能太少以至于让收集器等待时间过长，也不能太过频繁以至于过分增大运行时的内存负荷，基本上是以是否具有让程序长时间执行的特征（即指令序列的复用）为标准进行选定的</strong>，比如方法调用、循环跳转、异常跳转等都属于指令序列复用（不过 HotSpot 默认不会在索引值为 int 或范围更小的数据类型的循环中插入安全点，但如果存在一个这样的循环且循环时间仍然很长的程序，可以将索引类型改为 long 来使得 HotSpot 插入安全点）。</p>
<p>为了在发生垃圾收集时应当尽可能让所有线程（不包括执行 JNI 调用的线程）都跑到最近的安全点然后停顿下来，可使用抢先式中断和主动式中断。<strong>抢先式中断方案</strong>在垃圾收集发生时，系统首先把所有用户线程全部中断，然后恢复中断地方不在安全点上的线程的执行，直到该线程跑到安全点上再重新中断，现在几乎没有 JVM 采用抢先式中断来暂停线程响应 GC 事件。<strong>主动式中断方案</strong>仅仅简单设置一个中断标志位，各个线程执行过程中会在安全点和需要分配内存的地方去主动去轮询这个中断标志位，一旦发现中断标志为真时就自己在当前/最近的安全点上主动中断挂起。<strong>在等待所有用户线程都到达安全点之前，垃圾收集线程无法开始工作，只能空转（自旋），因此安全点设置的不合理就会导致长时间的等待</strong>。</p>
<p>对于获取到 CPU 时间片的执行中的线程来说，安全点机制保证了线程执行时在不太长的时间内就会遇到可进入垃圾收集过程的安全点，但对于未获取到 CPU 时间片的线程（比如处于 sleep 或 blocked 状态）来说，线程无法响应 JVM 的中断请求，不能走到安全点去中断挂起自己，这种线程会标识自己已经进入了安全区域，<strong>安全区域</strong>是指能够确保在某一段代码片段之中，引用关系不会发生变化，这个区域中任何地方开始垃圾收集都是安全的，可以看作是被扩展拉伸了的安全点。JVM 发起垃圾收集时无需管这些已声明自己在安全区域内的线程，当线程要离开安全区域时，它要检查 JVM 是否已经完成了根节点枚举或其他需要暂停用户线程的阶段，如果完成了则线程可以继续执行，否则线程就必须一致等待，直到收到可以离开安全区域的信号为止。</p>
<h3 id="2-2-2-收集算法"><a href="#2-2-2-收集算法" class="headerlink" title="2.2.2 收集算法"></a>2.2.2 收集算法</h3><p>绝大多数对象都是朝生夕灭的，而熬过越多次垃圾收集过程的对象就越难以消亡，且不同年龄类型的对象之间的引用相对于同年龄类型的引用来说仅占极少数，因此收集器考虑将对象依据其年龄（对象熬过垃圾收集过程的次数）分配到 Java 堆的不同的区域中存储，每次回收时重点关注那些朝生夕灭的区域（<strong>新生代</strong>）更能以较低代价回收到大量空间，而那些难以消亡的对象所在区域（<strong>老年代</strong>）则被 JVM 以较低的频率去回收，这就兼顾了垃圾收集的时间开销和内存空间的有效利用。</p>
<p>根据垃圾收集器每次回收 Java 堆被划分出的其中某一个还是某些区域，产生了<strong>新生代收集</strong>（Minor/Yong GC）、<strong>老年代收集</strong>（Major/Old GC，只有 CMS 收集器有这种行为）、<strong>混合收集</strong>（Mixed GC，收集整个新生代和部分老年代，只有 G1 收集器有这种行为）、<strong>整堆收集</strong>（Full GC，收集整个 Java 堆、方法区以及直接内存）这样的回收行为类型的划分。根据 Java 堆不同区域存储对象的存亡特征的不同，产生了<strong>标记-清除算法</strong>、<strong>标记-复制算法</strong>、<strong>标记-整理算法</strong>这些与对象存亡特征相匹配的针对性垃圾收集算法，这些算法都首先依据根可达算法标记出所有需要回收的对象（因此算法称为追踪式垃圾收集/间接垃圾收集），基于根可达算法的标记阶段会随着 Java 堆变大而等比例增加停顿时间，在标记完成后，统一回收掉所有被标记的对象。</p>
<p>所有涉及到部分区域收集行为的垃圾收集都会面临<strong>跨代引用</strong>的问题，即<strong>需要判断某一块非收集区域是否存在有指向了收集区域的指针，但又不希望扫描整个非收集区域</strong>，因此需要一种称为<strong>记忆集</strong>的抽象数据结构来记录从非收集区域指向收集区域的指针集合。非收集区域中的所有含跨代引用的对象所组成的对象数组是一种最简单的记忆集实现方式，但空间占用和维护成本都相当高昂，HotSpot 使用<strong>卡表</strong>来实现记忆集，卡表是一个由收集区域所有内存块所组成的字节数组，其中每一个元素都对应着一块特定大小（一般都是以 2 的 N 次幂的字节数）的内存块（被称为卡页，通常包含不止一个对象），只要有其他区域中对象引用了本区域的对象，该对象所在卡页所对应的卡表元素就变脏了，其元素值需要被标识为 1（这个维护卡表的动作需要放到每一个赋值操作之中），那么垃圾收集时只需筛选出卡表中变脏的元素，就能得知收集区域中哪些内存块中包含跨代指针，把它们加入 GC Roots 中一并扫描。</p>
<p>在快速完成 GC Roots 枚举后，从 GC Roots 再继续往下遍历对象图就是根可达分析，在这个过程中，会将尚未被访问过的对象标记为白色的（刚开始阶段都是白色的），将已经被访问过的对象但还存在对象引用未被访问过的标记为灰色，将已经被访问过的对象且对象的所有引用也都已经被访问过的标记为黑色，整个根可达分析过程就是对象逐渐由白变灰再变黑的过程，最终白色就是不可达的应该消亡的对象，黑色就是应该存活的对象。根可达分析过程的停顿时间与 Java 堆容量以及对象图结构复杂度直接成正比例关系，因此考虑<strong>并发的根可达分析</strong>，而当有用户线程在并发工作时，会导致对象图结构被修改，进而可能会导致应该消亡的对象被标记为存活以及应该存活的对象被标记为消亡，前者会产生还算可以接受的浮动垃圾，后者则会导致应用程序错误，为了避免这种情况，产生了增量更新和原始快照这种解决方案。<strong>增量更新</strong>方案会记录黑色对象被新插入的指向白色对象的引用记录，当并发结束后，再将这些记录过引用关系的黑色对象为根重新扫描，可以简化理解为黑色对象一旦新插入了指向白色对象的引用之后，就变回灰色对象。<strong>原始快照</strong>方案会记录灰色对象被新删除的指向白色对象的引用记录，当并发结束后，再将这些记录过引用关系的灰色对象为根重新扫描，可以简化理解为无论引用关系删除与否，都会按照刚刚开始扫描那一刻的对象图快照进行扫描。</p>
<p><strong>Mark-Sweep</strong> 算法最基础（另外两个都是以这个为基础），但执行效率不稳定（效率随对象数量增长而降低），还会产生大量不连续的内存碎片；<strong>Mark-Copy</strong> 将可用内存划分为一块较大的 Eden 区和两块较小的 Survivor 区，每次分配内存时只使用 Eden 区和其中一块 Survivor 区，当可用内存用完需要垃圾搜集时，将 Eden 区和这一块 Survivor 区中还存活的对象根据其对象头中的存活年龄信息判断是将其复制到另一块 Survivor 区中还是移动到老年代（如果在 Survivor 中低于等于某年龄的所有对象大小的总和大于 Survivor 空间的一半，那么这些对象也可以直接进入老年代），然后直接清理掉 Eden 区和已用过的那块 Survivor 区，这种算法不会产生空间碎片，但可用内存空间被缩小为原本的 90%（Eden 和 Survivor 的大小比例是 8:1），且当内存中多数对象都长时间存活时，会产生大量内存空间复制的开销，不过当多数对象都可回收时，仅需要复制占少数的存活对象，因此<strong>多用于回收新生代</strong>；<strong>Mark-Compact</strong> 将所有存活的对象都向内存空间一端移动并更新所有引用这些对象的地方（这种操作必须全程暂停用户应用程序才能进行），然后直接清理掉边界以外的内存，<strong>多用于回收老年代</strong>，当存在大量存活对象时这会是一种极为负重的操作，但若不进行这种移动操作，频繁的基于碎片化空间的内存分配和访问则会严重影响应用程序吞吐量，考虑到内存分配和访问相比垃圾收集频率要高得多，从整个程序的吞吐量来看，移动对象会更划算。</p>
<p>新创建对象一般是在 Java 堆的新生代的 Eden 区中划分内存，当 Eden 区没有足够空间进行内存分配时，JVM 将发起一次 Minor GC。Minor GC 发生之前必须先确保老年代中最大可用的连续空间是大于新生代所有对象总空间（确保 Minor GC 是安全的）或者大于历次晋升到老年代对象的平均大小（是有风险的 Minor GC），若条件不满足则进行 Full GC，若条件满足则尝试进行 Minor GC，<strong>若 Minor GC 失败（即担保失败）则需要进行 Full GC（这是最糟糕的情况），应当将 Full GC 频率降低到至少不会在用户使用过程中发生</strong>，可以每天深夜时通过定时任务触发 Full GC 或服务器重启来保持可用内存在一个稳定的水平。如果在 Eden 区给大对象（典型的大对象是那种很长的字符串、元素数量很庞大的数组）分配内存，就很容易提前触发 GC，且在后续的 GC 中，大对象在 Eden 区以及两个 Survivor 之间的来回复制也是很高的开销，因此大对象可以直接分配在老年代，且老年代的相对稳定是控制 Full GC 频率的关键，<strong>大对象对 JVM 的内存分配来说是坏消息，一个存活时间很短的大对象则是一个更坏的消息，开发人员应当尽量避免这种情况。</strong></p>
<h3 id="2-2-3-经典收集器"><a href="#2-2-3-经典收集器" class="headerlink" title="2.2.3 经典收集器"></a>2.2.3 经典收集器</h3><p>不同的厂商、版本的 JVM 所包含的垃圾收集器都可能会有很大差别，JVM 一般也都会提供各种参数供用户根据自己的应用特点和要求组合出各个内存分代所使用的收集器，经典的垃圾收集器算不上是最先进的技术，但足够成熟，可在生产环境放心使用，具体如下</p>
<ul>
<li>Serial<ul>
<li>属于新生代收集器，可与 CMS、Serial Old 搭配使用</li>
<li>在垃圾收集时必须暂停其他所有用户线程直到垃圾收集结束，只能<strong>单线程工作</strong>，采用 Mark-Copy</li>
<li>使用简单，是所有收集器里<strong>额外内存消耗最小</strong>的，也没有线程交互的开销，可以获得最高的单线程收集效率（与其他收集器的单线程相比）</li>
<li>对于内存较小的分区来说，其停顿时间完全可以控制在十几、几十毫秒以内，对于用户来说完全是可以接受的</li>
</ul>
</li>
<li>ParNew<ul>
<li>属于新生代收集器，可与 CMS、Serial Old 搭配使用</li>
<li>实质上是 <strong>Serial 的多线程并行版本</strong>，但在单核 CPU 中，由于存在线程交互的开销，ParNew 并不会有比 Serial 更好的效果</li>
<li>ParNew 其余的行为和 Serial 完全相同，同样在垃圾收集时必须暂停其他所有用户线程直到垃圾收集结束，同样采用 Mark-Copy</li>
</ul>
</li>
<li>Parallel Scavenge<ul>
<li>属于新生代收集器，可与 Serial Old、Parallel Old 搭配使用</li>
<li>能够多个垃圾收集线程<strong>并行</strong>，在垃圾收集时必须暂停其他所有用户线程直到垃圾收集结束，采用 Mark-Copy</li>
<li><strong>Parallel Scavenge 关注的目标是达到一个可控制的吞吐量（即 CPU 用于运行用户代码的时间与总消耗时间的比值）</strong>，而不是尽可能缩短垃圾收集时的用户线程停顿时间，Parallel Scavenge也称为吞吐量优先收集器</li>
<li>Parallel Scavenge 允许用户通过设定参数来控制最大的垃圾收集停顿时间（<strong>更短的停顿时间是以牺牲吞吐量和新生代空间位代价换取的</strong>）或者直接设定吞吐量大小，还允许用户通过激活开关参数来允许 JVM 根据当前系统的运行情况收集性能监控信息，动态调整各种细节参数（比如新生代大小、Eden 与 Survivor 的比例等）以提供最合适的停顿时间或者最大的吞吐量，这种调节方式称为垃圾收集的<strong>自适应的调节策略</strong></li>
</ul>
</li>
<li>Serial Old<ul>
<li>属于老年代收集器，可与 CMS、Serial、ParNew、Parallel Scavenge 搭配使用</li>
<li>是 <strong>Serial 的老年代版本</strong>，同样在垃圾收集时必须暂停其他所有用户线程直到垃圾收集结束，同样只能单线程工作，采用 Mark-Compact</li>
<li>可以在 CMS 发生 Concurrent Mode Failure 时作为后备预案</li>
</ul>
</li>
<li>Parallel Old<ul>
<li>属于老年代收集器，可与 Parallel Scavenge 搭配使用</li>
<li>是 <strong>Parallel Scavenge 的老年代版本</strong>，同样能够多个垃圾收集线程并行，同样在垃圾收集时必须暂停其他所有用户线程直到垃圾收集结束，采用 Mark-Compact</li>
<li>在<strong>注重吞吐量或者 CPU 资源较为稀缺的场合</strong>都可以优先考虑 Parallel Scavenge 加 Parallel Old 这个组合</li>
</ul>
</li>
<li>CMS (Concurrent Mark Sweep)<ul>
<li>属于老年代收集器，可与 Serial、ParNew、Serial Old 搭配使用</li>
<li>HotSpot 中第一款真正意义上支持并发的垃圾收集器，<strong>首次实现了让垃圾收集线程和用户线程并发工作</strong>，以获取最短回收停顿时间为目标，又称为并发低停顿收集器</li>
<li>CMS 将垃圾收集过程分为四个步骤<ul>
<li><strong>初始标记</strong>，标记 GC Roots 能直接关联到的对象，需要暂停其他所有用户线程，耗时很短</li>
<li><strong>并发标记</strong>，从 GC Roots 的直接关联对象开始遍历整个对象图（三色标记），耗时长，与用户线程一起并发工作，基于增量更新实现并发标记</li>
<li><strong>重新标记</strong>，修正并发标记期间因用户程序运作而导致标记产生变动的标记记录，多个垃圾收集线程并行工作，需要暂停其他所有用户线程，耗时比初始标记阶段稍长一些，但远比并发标记阶段短</li>
<li><strong>并发清除</strong>，清理标记阶段判断已经死亡的对象，耗时长，与用户线程一起并发工作</li>
</ul>
</li>
<li>CMS 对 <strong>CPU 资源非常敏感</strong>，在并发阶段，虽然无需用户线程停顿，但会因为垃圾收集线程占据了一部分 CPU 资源而导致<strong>应用程序变慢</strong>，总吞吐量降低</li>
<li>由于<strong>需要预留一些内存</strong>以供并发收集时的用户线程使用，CMS 在老年代内存使用达到一定域值（用户可设定）后就会被触发</li>
<li>CMS 还会产生浮动垃圾，也可能出现 Concurrent Mode Failure 进而导致另一次完全暂停所有用户线程的 Full GC 的产生</li>
<li>在平时多数时间都采用 Mark-Sweep，暂时容忍内存碎片的存在，直到内存空间的碎片化程度已经大到影响对象分配时，再采用一次 Mark-Compact 以获得规整的内存空间，这是需要暂停所有用户线程的 Full GC</li>
<li>CMS 的记忆集相当简单，考虑到新生代对象极不稳定，引用变化频繁，维护新生代到老年代的跨代引用开销是很大的，所以只需唯一一份用于记录老年代到新生代的跨代引用的卡表即可，代价就是老年代的垃圾收集需要把这个新生代作为 GC Roots 进行扫描</li>
</ul>
</li>
<li>G1 (Garbage First)<ul>
<li>是一个<strong>面向全堆（包括新生代和老年代）和方法区</strong>的垃圾收集器，不再需要其他的收集器配合工作，可以由用户指定期望的停顿时间，目标是<strong>在延迟可控的情况下获得尽可能高的吞吐量</strong></li>
<li>G1 可以面向任何内存部分组成的回收集进行回收，衡量标准不再是这块内存属于哪个分代而是哪块内存中存放的垃圾数量最多，回收受益最大，这就是 <strong>Mixed GC</strong> 模式，但一旦内存回收的速度赶不上内存分配的速度，就要暂停所有用户线程进行 Full GC</li>
<li>G1 将连续的 Java 堆划分为多个大小相等的独立区域 Region，每个 Region 都可以根据需要当做新生代的 Eden、Survivor 或者老年代使用（大小超过了整个 Region 容量的对象判定为超大对象，会被存放在 N 个连续的 Humongous Region 之中）</li>
<li>新生代的 Eden、Survivor 以及老年代不再是固定的了，而是<strong>一系列不一定连续的 Region 的动态集合</strong>，G1 能够对不同角色的 Region 采用不同的策略去进行垃圾收集</li>
<li>G1 会跟踪各个 Region 中的<strong>垃圾堆积的价值</strong>（所获得的空间大小以及回收所需时间的经验值），在后台维护一个<strong>优先级列表</strong>，每次根据用户设定允许的收集停顿时间优先处理回收价值收益最大的那些 Region</li>
<li>Region 被视作单次回收的最小单元，每次回收收集到的内存空间都是 Region 的整数倍，可以有计划地避免在整个 Java 堆中进行 Full GC，基于优先级的 Region 区域回收也保证了 G1 在有限的时间内获取尽可能高的收集效率</li>
<li>对于跨 Region 的对象引用可以通过记忆集避免非收集区域的扫描，<strong>G1 的每个 Region 都维护有自己的记忆集</strong>，G1 的记忆集在存储结构的本质上是一种哈希表，Key 是别的 Region 的起始地址，Value 是一个存储卡表索引号的集合，这种不仅包含我指向谁还包含谁指向我的双向的卡表结构更加复杂，也占用更多内存（大约堆容量的 10% ~ 20%）</li>
<li>G1 将垃圾收集过程分为四个步骤<ul>
<li><strong>初始标记</strong>，标记 GC Roots 能直接关联到的对象，需要暂停其他所有用户线程，耗时很短，而且是借用进行 Minor GC 的时候同步完成的，所以这个阶段实际并没有额外的停顿</li>
<li><strong>并发标记</strong>，从 GC Roots 的直接关联对象开始遍历整个对象图（三色标记），耗时长，与用户线程一起并发工作，基于原始快照实现并发标记</li>
<li><strong>最终标记</strong>，处理并发阶段结束后仍遗留下来的少量需要重新标记的记录，多个垃圾收集线程并行工作，需要暂停其他所有用户线程</li>
<li><strong>筛选回收</strong>，更新 Region 的统计数据，对各个 Region 的回收价值和成本进行排序，根据用户所期望的停顿时间来制定回收计划，选择多个 Region 构成回收集，将回收集中存活的对象复制到空的 Region 中，再清理掉回收集中所有的旧 Region，多个垃圾收集线程并行工作，需要暂停其他所有用户线程</li>
</ul>
</li>
<li>G1 整体上看是 Mark-Compact，但从局部（两个 Region 之间）上看是 Mark-Sweep，这意味着 G1 运作期间既不会像 Mark-Sweep 那样产生内存空间碎片，又不至于像 Mark-Compact 那样让垃圾收集成为极为负重的操作</li>
<li>从 G1 开始，垃圾收集器的设计导向都变为追求内存收集速度能赶上应用的内存分配速率即可，并不追求一次把整个 Java 堆全部清理干净</li>
</ul>
</li>
</ul>
<h3 id="2-2-4-高性能收集器"><a href="#2-2-4-高性能收集器" class="headerlink" title="2.2.4 高性能收集器"></a>2.2.4 高性能收集器</h3><p>衡量垃圾收集器的重要指标是内存占用、吞吐量和延迟，要在这三个方面的性能指标同时表现完美的收集器是极其困难甚至是不可能的，在执行效果上有革命性改进的实验状态的高性能垃圾收集器最多可以同时达成其中的两项。随着硬件性能日益增长，内存空间逐渐增大，收集器运行时对应用程序的影响会逐渐降低，即应用程序的吞吐量会更高，但是延迟时间反而会增大，因此延迟逐渐成为垃圾收集器最重视的性能指标，高性能垃圾收集器至少应做到低延迟，举例如下</p>
<ul>
<li>Shenandoah<ul>
<li>几乎整个工作过程全部都是并发的，只有初始标记和最终标记阶段有短暂的暂停用户线程（停顿时间基本固定，与堆容量没有正比例关系），目标是实现一种能在任何堆内存大小都可以把停顿时间限制在十毫秒以内的垃圾收集器<strong>，以用户程序吞吐量下降为代价实现了用户程序低延迟时间</strong></li>
<li>Shenandoah 将垃圾收集过程分为九个步骤<ul>
<li><strong>初始标记</strong>、<strong>并发标记</strong>以及<strong>最终标记</strong>都与 G1 一样</li>
<li><strong>并发清理</strong>用于清理那些对象全部无法存活的 Region，与用户线程一起并发工作</li>
<li><strong>并发回收</strong>，把回收集中的存活对象先复制一份到其他未被使用的 Region 之中，<strong>与用户线程一起并发工作（通过 CAS 来保证并发正确性）</strong>，运行时间取决于回收集的大小，是 Shenandoah 的核心概念</li>
<li><strong>初始引用更新</strong>，将堆中所有指向对象被复制前的旧地址引用修正到复制后的新地址，时间很短，会产生一个非常短暂的用户线程停顿</li>
<li><strong>并发引用更新</strong>，按照内存物理地址的顺序线性地搜索出堆中的引用类型，把旧值改为新值，与用户线程一起并发工作，运行时间取决于内存中涉及的引用数量的多少</li>
<li><strong>最终引用更新</strong>，修正存在于 GC Roots 中的引用，时间很短，会产生一个非常短暂的用户线程停顿，停顿时间只与 GC Roots 的数量有关</li>
<li><strong>并发清理</strong>，此时整个回收集中所有的 Region 已再无存活的对象，最后再重新执行一次并发清理来回收整个回收集</li>
</ul>
</li>
<li>Shenandoah 很多思路都与 G1 高度一致，区别在于 Shenandoah <strong>支持与用户线程并发进行的回收</strong>，Region 不再有不同分代角色，摒弃了耗费大量内存和资源去维护的哈希表记忆集，而是改用连接矩阵这一全局数据结构来记录跨 Region 的引用关系，并对并发失败后的 Full GC 提供了多线程支持</li>
</ul>
</li>
<li>ZGC<ul>
<li>几乎整个工作过程全部都是并发的，只有初始标记和最终标记阶段有短暂的暂停用户线程（暂停时间基本固定，与对容量没有正比例关系），目标是实现一种能在任何堆内存大小都可以把停顿时间限制在十毫秒以内的垃圾收集器<strong>，以并发的垃圾收集时间延长为代价实现了用户程序低延迟时间</strong></li>
<li>ZGC 也采用基于 Region 的堆内存布局，区别在于 ZGC 的 Region 具有动态创建和销毁的特性，分为大中小三类具备不同容量的 Region，分别用于放置不同大小等级的对象，其中小型和中型 Region 的容量是固定的，而大型 Region 的容量是可以动态变化的</li>
<li>ZGC 使用<strong>染色指针</strong>（标记信息存储在引用对象的指针上而不是存储在对象上）技术（需要操作系统的支持），JVM 可以直接从指针中看到其引用对象的三色标记状态、是否进入了重分配集（即被并发的用户线程移动过）、是否只能通过 finalize 方法才能被访问到等信息，染色指针使得一旦某个 Region 的存活对象被移走之后，这个 Region 立即就能够被释放和重用</li>
<li>ZGC 将垃圾收集过程分为六个步骤<ul>
<li><strong>初始标记</strong>、<strong>并发标记</strong>以及<strong>最终标记</strong>都与 G1 和 Shenandoah 一样，区别在于 ZGC 的标记是在指针上而不是在对象上进行的</li>
<li><strong>并发预备重分配</strong>，会扫描所有的 Region，根据特定的条件统计得出哪些 Region 需要清理，这些 Region 组成重分配集（不同于之前的回收集）</li>
<li><strong>并发重分配</strong>，将重分配集中的存活对象重新复制到其他新的 Region 中，并未重分配集中的每个 Region 维护一个记录了从旧地址到新地址的转向关系的转发表，重分配集中的 Region 会被释放，并发运行的用户线程只需从引用上就能明确得知一个对象是否处于重分配集中，在访问处于重分配集中的对象时则根据转发表访问到新地址（称为<strong>指针自愈</strong>），只有第一次访问会慢一些，后面就正常，因此对于用户线程的影响要比 Shenandoah 更低</li>
<li><strong>并发重映射</strong>，修正整个堆中指向重分配集中的对象旧地址的所有引用，这一步的目的是为了不变慢以及结束后可以释放转发表，但由于旧地址引用是可以在被用户线程访问时自愈的，所以并不是一个必须要迫切完成的任务，可以将这一步合并到下一次垃圾收集的并发标记阶段里去完成</li>
</ul>
</li>
<li>ZGC 的整个垃圾收集过程都是与用户线程并发的，这会产生大量的浮动垃圾，进而导致并发收集周期会很长，如果回收速度赶不上分配速度就会导致内存溢出</li>
</ul>
</li>
<li>Epsilon<ul>
<li>Epsilon 不仅仅是一个垃圾收集器，而是自动内存管理子系统，除了垃圾收集以外，还负责堆的管理与布局，对象的分配，与解释器、编译器、监控子系统协作等职责</li>
<li>Epsilon 的目标是服务于那种只运行数分钟甚至数秒的应用，只要 JVM 能够正确分配内存，在堆耗尽之前就早已退出，运行负载极小、没有任何回收行为的 Epsilon 就是很恰当的选择</li>
</ul>
</li>
</ul>
<h1 id="3、程序执行系统"><a href="#3、程序执行系统" class="headerlink" title="3、程序执行系统"></a>3、程序执行系统</h1><p>代码编译的结果从本地机器码转变为平台中立的<strong>由 Class 文件来存储的字节码</strong>（不依赖于特定硬件及操作系统，紧凑、稳定、可扩展，是更优的程序编译后存储格式），JVM 只是与 <strong>Class 文件这种特定的二进制文件格式</strong>所关联并使用公有的<strong>字节码指令集</strong>，因此运行在不同硬件平台和操作系统上的各种 JVM 都可以载入和执行同一种平台无关的存储有字节码的 Class 文件，从而实现程序（不仅仅是 Java 程序，可以是任意能够被编译成存储字节码的 Class 文件的程序）的一次编写，到处运行（<strong>平台无关性</strong>和<strong>语言无关性</strong>）。程序源语言中的各种语法、关键字、常量变量和运算符号的语义最终都会由多条字节码指令组合来表达，这意味着字节码指令所能提供的语言描述能力必须比被编译的源码本身更加强大才行，一些源码语言本身无法有效支持的语言特性并不代表在字节码中也无法有效表达。</p>
<h2 id="3-1-类文件结构"><a href="#3-1-类文件结构" class="headerlink" title="3.1 类文件结构"></a>3.1 类文件结构</h2><h3 id="3-1-1-主体结构"><a href="#3-1-1-主体结构" class="headerlink" title="3.1.1 主体结构"></a>3.1.1 主体结构</h3><p>Class 文件中包含了 JVM 指令集、符号集以及若干其他辅助信息，Class 文件必须应用许多<strong>强制性的语法和结构化约束</strong>，但图灵完备的字节码格式，保证了任意一门功能性语言都可以表示为一个能被 JVM 所接受的有效的 Class 文件。Class 文件是一组以 8 个字节为基础单位的二进制流，各个数据项严格按照顺序紧凑地排列在文件之中，中间没有任何分隔符（对于需要占用 8 个字节以上空间的数据项则会按照高位在前的方式分割成若干个 8 个字节进行存储），这使得 Class 文件中存储的内容几乎全部是程序运行的必要数据，没有空隙存在。Class 文件中只有无符号数和表这两种数据结构，<strong>无符号数</strong>属于基本的数据类型，可以用来描述数字、索引引用、数量值或者按照 UTF-8 编码构成字符串值，<strong>表</strong>（命名都习惯性地以 “_info” 结尾）是由多个无符号数或者其他表作为数据构成的复合数据类型，用于描述有层次关系的复合结构的数据，整个 Class 文件本质上也可以视作是一张表。无论是无符号数还是表，当需要描述同一类型但数量不定的多个数据时，经常会使用一个前置的容量计数器加若干个连续的数据项的形式，这一系列连续的某一类型的数据称为某一类型的集合。对 Java 语言来说，任意一个有效的类或接口所应当满足的格式可以称为 Class 文件，但它实际上并不一定需要以磁盘文件的形式存在，Class 文件应当是指一串二进制字节流，包括但不限于磁盘文件、网络、数据库、内存或者动态生成，然后直接送入类加载器中。</p>
<p>每个 Class 文件的头 4 个字节称为<strong>魔数</strong>，魔数唯一作用是确定这个文件是否为一个能被 JVM 接受的 Class 文件（使用魔数而不是文件扩展名来识别是因为文件扩展名可以随意改动，不够安全）；紧跟着魔数的 4 个字节存储的是 Class 文件的<strong>版本号</strong>，高版本的 JDK 能向下兼容低版本的 Class 文件，但不能运行向上更高版本的 Class 文件，即 JVM 拒绝执行超过其版本号的 Class 文件；版本号之后是<strong>常量池</strong>，常量池是 Class 文件结构中与其他数据项关联最多最繁琐的数据项，是 Class 文件中第一个出现的表类型数据项，通常也是占用 Class 文件空间最大的数据项之一，常量池入口会放置一项无符号数代表<strong>常量池容量计数值</strong>；常量池之后紧接着的 2 个字节代表<strong>访问标志</strong>，用于识别一些类或接口层次的访问信息，包括这个 Class 是类还是接口，是否 public，是否 abstract，是否 final 等等；访问标志之后是按顺序排列的<strong>类索引</strong>、<strong>父类索引</strong>和<strong>接口索引集合</strong>，类索引用于确定这个类的全限定名，父类索引用于确定类的父类的全限定名，接口索引集合用来描述这个类实现了哪些接口；<strong>字段表集合</strong>用于描述接口或类中声明的类级变量以及实例级变量（不包括在方法内部声明的局部变量），依次包含访问标志、名称索引、描述符索引、属性表集合；<strong>方法表集合</strong>用于描述方法定义（与字段表集合对字段的描述几乎是完全一致的方式），而方法中的 Java 代码经过编译后存放在方法表集合中一个名为 Code 的属性中；<strong>属性表集合</strong>用于描述某些场景专有的信息（Class 文件、字段表、方法表都可以携带自己的属性表集合），集合中各个属性表不具有严格顺序限制（更详细的我目前不想学）。</p>
<h3 id="3-1-2-字节码指令"><a href="#3-1-2-字节码指令" class="headerlink" title="3.1.2 字节码指令"></a>3.1.2 字节码指令</h3><p>JVM 指令由一个字节长度的、代表着某种特定操作含义的数字（称为<strong>操作码</strong>，长度限定为 1 字节，种类不超过 256 条）以及跟随其后的零至多个代表此操作所需的参数（称为<strong>操作数</strong>）构成，由于 JVM 采用面向操作数栈而不是面向寄存器的架构（操作数都存放在操作数栈中），所以大多数指令都不包含操作数，只有一个操作码。大多数指令都包含其操作所对应的数据类型信息，但并非每一种数据类型和每一种操作都有对应的指令，比如大多数对于 boolean、byte、short 和 char 类型数据的操作实际上都是使用相应的对 int 类型作为运算类型来进行的，此外，有一些单独的指令可以在必要的时候用来将一些不支持的类型转换为可被支持的类型。<strong>加载和存储指令</strong>用于将数据在栈帧中的局部变量表和操作数栈之间来回传输，存储数据的操作数栈和局部变量表主要由加载和存储指令进行操作，此外还有少量指令，如<strong>访问对象的字段或数组元素的指令</strong>也会向操作数栈传输数据。<strong>算术指令</strong>用于对操作数栈上的两个值进行某种特定运算，并把结果重新存入到操作栈顶，不存在直接支持 boolean、byte、short 和 char 类型的算术指令（应使用操作 int 类型的指令代替），只有除法指令以及求余指令会在除数为零时抛出异常，其他任何数据运算都不会抛出运行时异常（包括溢出情况也不会抛出异常）。<strong>类型转换指令</strong>可以将两种不同的数值类型相互转换，一般用于实现用户代码中的窄化的显式类型转换操作，或者用于处理数据类型相关指令无法与数据类型一一对应的问题（JVM 直接支持小范围类型到大范围类型的安全转换，这种情况无需显式使用类型转换指令），窄化转化中可能发生的上限溢出、下限溢出以及精度丢失等情况均不会抛出异常。<strong>对象创建和访问指令</strong>针对类实例和数组分为不同的字节码指令。<strong>操作数栈管理指令</strong>用于直接操作操作数栈（就如同一个普通数据结构中的堆栈那样直接操作）。<strong>控制转移指令</strong>可以将 JVM 有条件或无条件地从指定位置指令的下一条指令继续执行程序，即有条件或无条件地修改 PC 寄存器的值。<strong>方法调用指令</strong>与数据类型无关。<strong>方法返回指令</strong>是根据返回值的类型区分的。<strong>异常处理指令</strong>全部由 athrow 指令来实现，异常处理（catch 语句）则不是由字节码指令来实现的，而是采用异常表来完成。<strong>同步指令</strong>通过管程（Monitor，或直接称为锁）来同步方法内部一段指令序列的同步（整个方法级别的同步是隐式的，实现在方法调用和返回操作之中，无须通过同步指令来控制），同步指令 monitorenter 和 monitorexit 必须配对使用。</p>
<h2 id="3-2-类加载机制"><a href="#3-2-类加载机制" class="headerlink" title="3.2 类加载机制"></a>3.2 类加载机制</h2><p>JVM 将描述类的数据从 Class 文件加载到内存，并对数据进行校验、转换解析和初始化，最终形成可以被 JVM 直接使用的 Java 类型，这个过程称为 JVM 的类加载机制，Class 文件中描述的各类信息都需要通过 JVM 的类加载机制被加载到 JVM 之中才能被运行使用。Java 语言中，类型的加载、连接和初始化过程都是在程序运行期间完成的，这种策略让提前编译面临额外的困难，也会让类加载时的性能开销更大，但为 Java 应用提供了极高的扩展性和灵活性，Java 天生可以动态扩展的语言特性就是依赖<strong>运行期间动态加载和动态连接</strong>这个特点实现的。</p>
<h3 id="3-2-1-主体过程"><a href="#3-2-1-主体过程" class="headerlink" title="3.2.1 主体过程"></a>3.2.1 主体过程</h3><p>一个类型从被加载到 JVM 内存中开始，到卸载出内存为止，它的整个生命周期将会经历加载（Loading）、验证（Verification）、准备（Preparation）、解析（Resolution）、初始化（Initialization）、使用（Using）和卸载（Unloading）七个阶段，其中验证、准备、解析这三个部分统称为连接（Linking）。除了 Resolution 阶段在某些情况下可以在 Initialization 阶段之后再开始（这是为了支持 Java 的动态绑定）以外，所有阶段都是按照以上顺序按部就班的开始，会在一个阶段执行的过程中调用/激活另一个阶段，因此这些阶段在开始之后通常是互相交叉地混合进行的，并不是按部就班的进行或结束。</p>
<ul>
<li><strong>加载</strong><ul>
<li>类加载过程的第一个阶段 Loading 在<strong>何时开始并没有强制约束</strong>，这可以交给 JVM 的具体实现来自由把握（比如 LazyLoading 就是等到需要时才开始 Loading）</li>
<li>在 Loading 阶段，JVM <strong>通过一个类的全限定名来获取定义此类的二进制字节流，将这个字节流所代表的静态存储结构转化为方法区的运行时数据结构，在 Java 堆中生成一个代表这个类的 java.lang.Class 对象</strong>，作为访问方法区中关于这个类的各种类型数据的入口</li>
<li>定义此类的二进制字节流可以有很多来源，比如 ZIP/JAR/EAR/WAR 包、网络（典型应用就是 Web Applet）、运行时计算生成（动态代理技术）、由其他文件生成（典型场景是 JSP 文件）、从数据库中读取、从加密文件中获取（防止 Class 文件被反编译的保护措施，确保程序运行逻辑不被窥探）</li>
<li>非数组类的 Loading 阶段既可以使用 JVM 中内置的引导类加载器来完成，也可以由用户自定义的类加载器去完成，开发人员可以<strong>通过定义自己的类加载器去控制字节流的获取方法，从而赋予应用程序更多的运行动态性</strong></li>
<li>数组类不通过类加载器创建，而是由 JVM 直接在内存中动态构造出来的，但对于元素类型为引用类型的数组类来说，需要递归采用上述非数组类的 Loading 阶段来加载这个数组元素类型</li>
</ul>
</li>
<li><strong>验证</strong><ul>
<li>Verification 阶段是 Linking 的第一步，其工作量在整个类加载过程中占了相当大的比重，目的是<strong>确保 Class 文件的字节流中包含的信息符合约束要求，保证这些信息被当做代码运行后不会危害 JVM 自身的安全</strong></li>
<li>Verification 阶段的大致包括文件格式验证、元数据验证、字节码验证和符号引用验证这四个检验动作</li>
<li>Verification 阶段并<strong>不是必须要执行的</strong>，如果程序运行的所有代码都已经被反复使用和验证过，在生产环境的实施阶段就可以关闭 Verification 阶段，以缩短 JVM 类加载的时间</li>
</ul>
</li>
<li><strong>准备</strong><ul>
<li>Preparation 阶段会正式<strong>为类中定义的 static 变量（不包括实例变量）分配内存并设置变量系统初始值/默认零值</strong>（而不是程序中定义的初始值），但是对于 static final 变量则会被设置为程序中定义的初始值</li>
</ul>
</li>
<li><strong>解析</strong><ul>
<li>符号引用是以一组符号来描述所引用的目标，符号可以是任何形式的字面量，只要使用时能够无歧义地定位到目标即可，与 JVM 内存布局无关，引用的目标也不一定是已经加载到 JVM 内存中的内容</li>
<li>直接引用是可以直接指向目标的指针、相对偏移量或者是一个能间接定位到目标的句柄，是与 JVM 内存布局相关的，同一个符号引用在不同 JVM 实例上翻译出来的直接引用一般不会相同，引用的目标一定是已经加载到 JVM 内存中的内容</li>
<li>Class 文件中并没有保存各个方法、字段最终在内存中的布局信息，Resolution 阶段会<strong>将 Class 文件常量池内的符号引用替换为直接引用（这称为静态解析）</strong>以及将字面量存放到方法区的<strong>运行时常量池</strong>中，主要指类/接口、字段、类方法、接口方法、方法类型、方法句柄和调用点限定符这七类符号引用（分别对应 Class 文件常量池中不同的常量类型）</li>
<li>JVM 可以根据需要来<strong>自行判断何时进行 Resolution 阶段</strong>（到底是在类的 Loading 阶段进行时开始解析还是等到一个符号引用将要被使用前开始解析），JVM 会对第一次解析的结果进行缓存，避免重复进行 Resolution 阶段</li>
</ul>
</li>
<li><strong>初始化</strong><ul>
<li>当对一个类型（类/接口）进行<strong>主动引用</strong>时，必须立即对该类型进行初始化，而加载、验证、准备自然需要在此之前开始，除此之外所有的<strong>被动引用</strong>都不会触发初始化</li>
<li>主动引用举例：使用 new 关键字实例化对象、读写一个类型的 static 字段（被 final 修饰、已在编译器初始化的除外）、调用一个类型的 static 方法、对类型进行反射调用、初始化类的子类、JVM 启动时被指定的包含 main 方法的主类、初始化包含有 default 方法的接口的实现类、接口的实现类引用接口中定义的常量</li>
<li>被动引用举例：通过子类来引用父类中定义的 static 字段、使用 new 关键字实例化一个类型的数组、引用一个类在编译期间就已经初始化的 static 字段（其实被转化为对常量池的引用了）、初始化接口的子接口</li>
<li>Initialization 阶段 JVM 才真正开始执行类中编写的程序代码，主导权被交给应用程序，实际就是<strong>执行类中所有 static 变量的赋值动作和 static 语句块</strong>的过程，所有 static 变量会被设置为程序中定义的初始值（除了 Initialization 阶段可以执行程序中定义的赋值逻辑以及 Loading 阶段可以通过程序自定义类加载器以外，其他阶段都完全由 JVM 来主导控制）</li>
<li>JVM 必须保证 Initialization 阶段在多线程环境中被正确地加锁同步，只会有一个线程去执行这个类的初始化，其他线程都需要阻塞等待直到活动线程执行完毕，因此<strong>一旦 Initialization 阶段所执行的代码中有耗时很长的操作，就可能造成多个线程阻塞</strong></li>
</ul>
</li>
</ul>
<h3 id="3-2-2-类加载器"><a href="#3-2-2-类加载器" class="headerlink" title="3.2.2 类加载器"></a>3.2.2 类加载器</h3><p>应用程序可以自己决定如何通过一个类的全限定名来获取定义此类的二进制字节流，实现这个动作的代码被称为类加载器。每一个类加载器都拥有一个独立的类名称空间，对于任意一个类，都必须由它的类加载器和这个类本身一起共同确立其在 JVM 中的唯一性（对于来源于同一个 Class 文件的被同一个 JVM 加载的两个类，<strong>只要加载它们的类加载器不同，那两个类在 JVM 中就是两个不同的类</strong>）。</p>
<p><strong>双亲委派模型</strong>是 Java 推荐给开发者的一种类加载器实现的最佳实践（并不是一个强制性约束的模型），模型要求除了顶层的启动类加载器以外，其余的类加载器都应有自己的父类加载器，类加载器之间的父子关系一般不是以继承关系而是使用组合关系来复用父加载器的代码，当一个类加载器收到了类加载的请求，它首先不会自己去尝试加载这个类，而是把这个请求委派给父类加载器去完成，因此<strong>所有的加载请求最终都应该传送到最顶层的启动类加载器中，只有当父加载器反馈自己无法完成这个加载请求（它的搜索范围中没有找到所需的类）时，子加载器才会去尝试自己去完成加载，同一个类一定是由同一个类加载器加载的</strong>。</p>
<p><strong>Java 模块化系统</strong>实现了可配置的封装隔离机制，模块定义除了代码以外，还包含依赖其他模块的列表、导出的包列表（即其他模块可以使用的列表）、开放的包列表（即其他模块可反射访问模块的列表）、使用的服务列表、提供服务的实现列表。当类路径中缺失了运行时依赖的类型，模块可以声明对其他模块的显式依赖，JVM 能够在启动时验证应用程序开发阶段设定好的依赖关系在运行期是否完备，如有缺失则直接启动失败，避免了一部分由于类型依赖而引发的运行时异常。</p>
<p>所有类加载器之间从父到子的顺序依次是启动类加载器，平台类加载器、应用程序类加载器以及自定义类加载器，这些类加载器都继承于 jdk.internal.loader.BuiltinClassLoader，BuiltinClassLoader 实现了模块化架构下类如何从模块中加载的逻辑以及模块中资源可访问性的处理，启动类加载器，平台类加载器以及应用程序类加载器都有各自负责加载的模块。<strong>当平台及应用程序类加载器收到类加载请求时，要先判断该类是否能够归属到某一个系统模块中，如果存在这样的归属关系，就要优先委派给负责那个模块的加载器（而不是父加载器）完成加载，从而使得模块化系统得以顺利运作</strong>，这算是对双亲委派模型的一种破坏。</p>
<ul>
<li><strong>启动类加载器（Bootstrap Class Loader）</strong><ul>
<li>负责加载存放在<JAVA_HOME>\lib 目录，或者被 -Xbootclasspath 参数所指定路径中存放的 JVM 能够识别的类库加载到 JVM 内存中</li>
<li>启动类加载器是在 JVM 内部和 Java 类库共同协作实现的，不应被 Java 程序直接引用，用户在编写自定义加载器时，如果需要将加载请求委派给启动类加载器时，直接使用 null 作为加载器替代即可</li>
</ul>
</li>
<li><strong>平台类加载器（Platform Class Loader）</strong><ul>
<li>平台类加载器是由 Java 代码实现的，独立于 JVM，开发者可以直接在程序中使用扩展类加载器来加载 Class 文件</li>
</ul>
</li>
<li><strong>应用程序类加载器（Application Class Loader）</strong><ul>
<li>应用程序类加载器是 ClassLoader 类中的 getSystemClassLoader() 方法的返回值，也称为系统类加载器，负责加载用户路径上所有的类库，独立于 JVM，开发者同样可以直接在程序中使用应用程序类加载器来加载 Class 文件</li>
</ul>
</li>
<li><strong>自定义类加载器（User Class Loader）</strong><ul>
<li>如果用户认为有必要则还可以加入自定义的类加载器（同样独立于 JVM）来进行拓展，典型的如增加除了磁盘位置之外的 Class 文件来源，或者通过类加载器实现类的隔离、重载等功能</li>
</ul>
</li>
</ul>
<h2 id="3-3-程序执行"><a href="#3-3-程序执行" class="headerlink" title="3.3 程序执行"></a>3.3 程序执行</h2><h3 id="3-3-1-执行引擎"><a href="#3-3-1-执行引擎" class="headerlink" title="3.3.1 执行引擎"></a>3.3.1 执行引擎</h3><p><strong>字节码执行引擎</strong>是 JVM 的核心组成部分之一，不同于物理机的执行引擎是直接建立在处理器、缓存器、指令集和操作系统层面上的，JVM 的执行引擎则是由软件自行实现的，可以不受物理条件制约地定制指令集与执行引擎的结构体系，能够执行那些不被硬件直接支持的指令集格式。在不同的 JVM 实现中，执行引擎在执行字节码时通常会有<strong>解释执行引擎</strong>和<strong>编译执行引擎</strong>两种选择，也可能两者兼备，还可能会同时包含几个不同级别的<strong>即时编译执行引擎</strong>一起工作，但所有 JVM 的执行引擎的输入都是字节码二进制流，输出都是执行结果。</p>
<p>JVM 以方法作为最基本的执行单元，<strong>栈帧则是用于支持 JVM 进行方法调用和方法执行的数据结构</strong>，栈帧中存储了方法的局部变量表、操作数栈、动态连接和方法返回地址等信息，每一个方法从调用开始到执行结束都对应着一个栈帧在虚拟机栈里从入栈到出栈的过程。在编译 Java 程序源码时就分析计算出了栈帧中需要多大的局部变量表以及需要多深的操作数栈，一个栈帧所需要的内存并不会受到程序运行期间变量数据的影响，而仅仅取决于程序源码和具体 JVM 实现的栈内存布局形式。</p>
<p>方法调用并不等同于方法中的代码被执行，方法调用阶段唯一的任务就是确定被调用方法的版本，暂时还未涉及方法内部的具体运行过程，Class 文件常量池中存储的都只是符号引用，而不是方法在实际运行时内存布局中的入口地址/直接引用。在 Class 文件的类加载过程的解析阶段会将 Class 文件常量池内的一部分符号引用替换为直接引用（这称为<strong>静态解析</strong>），这些方法（static 方法和 private 方法）在程序真正运行之前就有一个可确定的且运行期不可改变的调用版本；而另一部分则会到运行期间才能确定目标方法的直接引用（这称为<strong>动态连接/运行时转换</strong>）。</p>
<h3 id="3-3-2-编译与优化"><a href="#3-3-2-编译与优化" class="headerlink" title="3.3.2 编译与优化"></a>3.3.2 编译与优化</h3><p><strong>前端编译器</strong>把 *.java 文件转变成 *.class 文件，并通过编译器语法糖（与具体的 JDK 相关）来降低编码复杂度和提高编码效率，而不是依赖字节码或 JVM 底层支持。Java 常见的语法糖包括了泛型、枚举、断言、内部类、变长参数、自动装箱拆箱、常量条件编译、<code>+</code>拼接字符串、foreach、try-with-resource、lambda 等，这些语法糖只能存在于 Java 源码中，语法糖在编译阶段被还原为原始的基础语法结构（这个过程称为解语法糖），JVM 运行时并不直接支持这些语法糖。JVM <strong>解释器</strong>会在程序启动以及运行期解释执行字节码，JVM <strong>即时编译器（也称 JIT 编译器/后端编译器）</strong>会在运行期以热点代码（运行特别频繁的某个方法或某个代码块）为目标，将其编译成本地机器码从而编译执行字节码，JVM 选择把对性能的优化全部集中到运行期的 JIT 编译器中，从而让那些不是由 Java 产生的 Class 文件也同样能享受到编译器优化措施。<strong>提前编译器（也称 AOT 编译器）</strong>直接把程序编译成与目标机器指令集相关的本地机器代码，这种编译方式不仅要和目标机器相关，甚至还必须和 JVM 运行时参数绑定，省去了字节码这一中间产物，也就丧失了程序的平台无关性和语言无关性，但有可能获得更高的运行性能。C++ 就是直接由源码被编译成机器代码，执行速度快、效率高，但依赖与平台机器关联的编译器。</p>
<p>JVM 通过基于采用的热点探测和基于计数器的热点探测这两种方式来确定热点代码，采用<strong>基于采用的热点探测</strong>时，JVM 会周期性地检查各个线程的调用栈顶，如果发现某个方法经常出现在栈顶则判断该方法是热点方法，这种方式简单高效，还容易获取方法调用关系，但容易受到线程阻塞等因素影响而扰乱探测结果，也很难精确确认一个方法的热度；采用<strong>基于计数器的热点探测</strong>时，JVM 会为每个方法建立计数器，统计方法的执行次数，如果发现方法的执行次数超过一定阈值就判断该方法是热点方法，这种方式的统计结果更加精确严谨但比较麻烦，且无法获取到方法的调用关系。HotSpot 采用基于计数器的热点探测，并为每个方法准备了方法调用计数器和回边计数器（用于统计方法中的循环体执行次数）。热点探测是在方法执行过程中进行的，一旦发现新的热点代码就会产生编译请求（由后台编译线程执行），但执行引擎默认不会同步等待编译请求完成，而是继续进入解释器按照解释方式执行字节码，一旦提交的请求被 JIT 编译器编译完成，该方法的调用入口地址就会被系统自动改写成新值，下一次调用该方法时就会使用已编译的版本。</p>
<p>目前主流的商用 JVM 内部都同时包含解释器和 JIT 编译器，当程序需要迅速启动和执行时，解释器可以首先发挥作用，把越来越多的代码编译成本地机器代码，减少解释器的中间损耗，获得更高的执行效率；当程序运行环境中内存资源限制较大，可以使用解释执行节约内存，反之可以使用编译执行来提升效率，此外，当 JIT 编译器根据概率选择一些不能保证正确的优化手段并出现问题时，可以通过逆优化退回到解释状态继续执行，即解释器可以作为 JIT 编译器激进优化时的后备。HotSpot VM 中内置了两个 JIT 编译器，分别是<strong>客户端编译器（又称 C1 编译器，编译速度更高）、服务端（又称 C2 编译器，编译质量更好）</strong>，在分层编译的工作模式之前，HotSpot VM 通常工作于混合模式（Mixed Mode），但用户也可以通过参数强制 HotSpot VM 运行于解释模式（Interpreted Mode）或编译模式（Compiled Mode）。<strong>Mixed Mode</strong> 时解释器与其中一个编译器直接搭配，<strong>Interpreted Mode</strong> 时编译器完全不工作，全部代码都使用解释执行，<strong>Compiled Mode</strong> 时优先使用编译方式执行程序，解释器仅在编译无法进行的情况介入。</p>
<p>考虑到 JIT 编译器需要占用程序运行时间，且为了编译出优化程度越高的代码，所花费的时间便会越长，甚至解释器可能还要替编译器收集性能监控信息，这对解释执行阶段的速度也有所影响，为了在程序启动响应速度与运行效率之间达到最佳平衡，HotSpot VM 使用分层编译。<strong>分层编译</strong>根据编译器编译、优化的规模与耗时，划分出不同编译层次：第 0 层，程序纯解释执行，并且解释器不开启性能监控功能；第 1 层，使用 C1 编译器将字节码编译为本地代码来运行，进行简单可靠的稳定优化，不开启性能监控功能；第 2 层，仍使用 C1 编译器执行，仅开启方法及回边次数统计等有限的性能监控功能；第 3 层，仍使用 C1 编译器执行，开启全部性能监控；第 4 层，使用 C2 编译器将字节码编译为本地代码，相比于 C1 编译器，C2 编译器会启用更多编译耗时更长的优化，还会根据性能监控信息进行不可靠的激进优化。实施分层编译后，解释器、C1 编译器以及 C2 编译器就会同时工作，热点代码都可能会被多次编译，在解释执行时解释器无需额外承担收集性能监控信息的任务，在 C2 编译器采用高复杂度的优化算法时 C1 编译器可先采用简单优化来为 C2 编译器争取更多的编译时间。</p>
<h1 id="4、参考资料"><a href="#4、参考资料" class="headerlink" title="4、参考资料"></a>4、参考资料</h1><ul>
<li>《Understanding the JVM, Advanced Features and Best Practices, Third Edition》</li>
</ul>
</section>
    <!-- Tags START -->
    
    <!-- Tags END -->
    <!-- NAV START -->
    
  <div class="nav-container">
    <!-- reverse left and right to put prev and next in a more logic postition -->
    
      <a class="nav-left" href="/2023/11/06/computer-networking/">
        <span class="nav-arrow">← </span>
        
          Computer Networking
        
      </a>
    
    
      <a class="nav-right" href="/2023/12/23/week-68/">
        
          2023.12.18 - 2023.12.22
        
        <span class="nav-arrow"> →</span>
      </a>
    
  </div>

    <!-- NAV END -->
    <!-- 打赏 START -->
    
    <!-- 打赏 END -->
    <!-- 二维码 START -->
    
    <!-- 二维码 END -->
    
      <!-- Utterances START -->
      <div id="utterances"></div>
      <script src="https://utteranc.es/client.js"
        repo=""
        issue-term="pathname"
        theme="github-light"
        crossorigin="anonymous"
        async></script>    
      <!-- Utterances END -->
    
  </article>
  <!-- Article END -->
  <!-- Content START -->
  
    <aside class="content-container">
  <div class="toc-main">
  
      
          <strong class="toc-title">CONTENT</strong>
          <ol class="toc-nav"><li class="toc-nav-item toc-nav-level-1"><a class="toc-nav-link" href="#1%E3%80%81%E5%BC%95%E8%A8%80"><span class="toc-nav-text">1、引言</span></a></li><li class="toc-nav-item toc-nav-level-1"><a class="toc-nav-link" href="#2%E3%80%81%E8%87%AA%E5%8A%A8%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86"><span class="toc-nav-text">2、自动内存管理</span></a><ol class="toc-nav-child"><li class="toc-nav-item toc-nav-level-2"><a class="toc-nav-link" href="#2-1-%E5%86%85%E5%AD%98%E4%BD%BF%E7%94%A8"><span class="toc-nav-text">2.1 内存使用</span></a><ol class="toc-nav-child"><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#2-1-1-%E5%86%85%E5%AD%98%E5%88%86%E5%8C%BA"><span class="toc-nav-text">2.1.1 内存分区</span></a></li><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#2-1-2-%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D"><span class="toc-nav-text">2.1.2 内存分配</span></a></li></ol></li><li class="toc-nav-item toc-nav-level-2"><a class="toc-nav-link" href="#2-2-%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86"><span class="toc-nav-text">2.2 垃圾收集</span></a><ol class="toc-nav-child"><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#2-2-1-%E5%9B%9E%E6%94%B6%E6%9D%A1%E4%BB%B6"><span class="toc-nav-text">2.2.1 回收条件</span></a></li><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#2-2-2-%E6%94%B6%E9%9B%86%E7%AE%97%E6%B3%95"><span class="toc-nav-text">2.2.2 收集算法</span></a></li><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#2-2-3-%E7%BB%8F%E5%85%B8%E6%94%B6%E9%9B%86%E5%99%A8"><span class="toc-nav-text">2.2.3 经典收集器</span></a></li><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#2-2-4-%E9%AB%98%E6%80%A7%E8%83%BD%E6%94%B6%E9%9B%86%E5%99%A8"><span class="toc-nav-text">2.2.4 高性能收集器</span></a></li></ol></li></ol></li><li class="toc-nav-item toc-nav-level-1"><a class="toc-nav-link" href="#3%E3%80%81%E7%A8%8B%E5%BA%8F%E6%89%A7%E8%A1%8C%E7%B3%BB%E7%BB%9F"><span class="toc-nav-text">3、程序执行系统</span></a><ol class="toc-nav-child"><li class="toc-nav-item toc-nav-level-2"><a class="toc-nav-link" href="#3-1-%E7%B1%BB%E6%96%87%E4%BB%B6%E7%BB%93%E6%9E%84"><span class="toc-nav-text">3.1 类文件结构</span></a><ol class="toc-nav-child"><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#3-1-1-%E4%B8%BB%E4%BD%93%E7%BB%93%E6%9E%84"><span class="toc-nav-text">3.1.1 主体结构</span></a></li><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#3-1-2-%E5%AD%97%E8%8A%82%E7%A0%81%E6%8C%87%E4%BB%A4"><span class="toc-nav-text">3.1.2 字节码指令</span></a></li></ol></li><li class="toc-nav-item toc-nav-level-2"><a class="toc-nav-link" href="#3-2-%E7%B1%BB%E5%8A%A0%E8%BD%BD%E6%9C%BA%E5%88%B6"><span class="toc-nav-text">3.2 类加载机制</span></a><ol class="toc-nav-child"><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#3-2-1-%E4%B8%BB%E4%BD%93%E8%BF%87%E7%A8%8B"><span class="toc-nav-text">3.2.1 主体过程</span></a></li><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#3-2-2-%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%99%A8"><span class="toc-nav-text">3.2.2 类加载器</span></a></li></ol></li><li class="toc-nav-item toc-nav-level-2"><a class="toc-nav-link" href="#3-3-%E7%A8%8B%E5%BA%8F%E6%89%A7%E8%A1%8C"><span class="toc-nav-text">3.3 程序执行</span></a><ol class="toc-nav-child"><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#3-3-1-%E6%89%A7%E8%A1%8C%E5%BC%95%E6%93%8E"><span class="toc-nav-text">3.3.1 执行引擎</span></a></li><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#3-3-2-%E7%BC%96%E8%AF%91%E4%B8%8E%E4%BC%98%E5%8C%96"><span class="toc-nav-text">3.3.2 编译与优化</span></a></li></ol></li></ol></li><li class="toc-nav-item toc-nav-level-1"><a class="toc-nav-link" href="#4%E3%80%81%E5%8F%82%E8%80%83%E8%B5%84%E6%96%99"><span class="toc-nav-text">4、参考资料</span></a></li></ol>
      
  
  </div>
</aside>
  
  <!-- Content END -->
</main>

<script>
  (function () {
    var url = 'http://example.com/2023/12/09/java-virtual-machine/';
    var banner = ''
    if (banner !== '' && banner !== 'undefined' && banner !== 'null') {
      $('#article-banner').css({
        'background-image': 'url(' + banner + ')'
      })
    } else {
      $('#article-banner').geopattern(url)
    }
    $('.header').removeClass('fixed-header')

    // error image
    $(".markdown-content img").on('error', function() {
      $(this).attr('src', '/css/images/error_icon.png')
      $(this).css({
        'cursor': 'default'
      })
    })

    // zoom image
    $(".markdown-content img").on('click', function() {
      var src = $(this).attr('src')
      if (src !== '/css/images/error_icon.png') {
        var imageW = $(this).width()
        var imageH = $(this).height()

        var zoom = ($(window).width() * 0.95 / imageW).toFixed(2)
        zoom = zoom < 1 ? 1 : zoom
        zoom = zoom > 2 ? 2 : zoom
        var transY = (($(window).height() - imageH) / 2).toFixed(2)

        $('body').append('<div class="image-view-wrap"><div class="image-view-inner"><img src="'+ src +'" /></div></div>')
        $('.image-view-wrap').addClass('wrap-active')
        $('.image-view-wrap img').css({
          'width': `${imageW}`,
          'transform': `translate3d(0, ${transY}px, 0) scale3d(${zoom}, ${zoom}, 1)`
        })
        $('html').css('overflow', 'hidden')

        $('.image-view-wrap').on('click', function() {
          $(this).remove()
          $('html').attr('style', '')
        })
      }
    })
  })();
</script>







    <div class="scroll-top">
  <span class="arrow-icon"></span>
</div>
    <!--
<footer class="app-footer">
  <p class="copyright">
    &copy; 2024 | Proudly powered by <a href="https://hexo.io" target="_blank">Hexo</a>
    <br>
    Theme by <a target="_blank" rel="noopener" href="https://github.com/yanm1ng">yanm1ng</a>
    
  </p>
</footer>
-->

<script>
  function async(u, c) {
    var d = document, t = 'script',
      o = d.createElement(t),
      s = d.getElementsByTagName(t)[0];
    o.src = u;
    if (c) { o.addEventListener('load', function (e) { c(null, e); }, false); }
    s.parentNode.insertBefore(o, s);
  }
</script>
<script>
  async("//cdnjs.cloudflare.com/ajax/libs/fastclick/1.0.6/fastclick.min.js", function(){
    FastClick.attach(document.body);
  })
</script>

<script>
  var hasLine = 'true';
  async("//cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/highlight.min.js", function(){
    $('figure pre').each(function(i, block) {
      var figure = $(this).parents('figure');
      if (hasLine === 'false') {
        figure.find('.gutter').hide();
      }
      hljs.configure({useBR: true});
      var lang = figure.attr('class').split(' ')[1] || 'code';
      var codeHtml = $(this).html();
      var codeTag = document.createElement('code');
      codeTag.className = lang;
      codeTag.innerHTML = codeHtml;
      $(this).attr('class', '').empty().html(codeTag);
      figure.attr('data-lang', lang.toUpperCase());
      hljs.highlightBlock(block);
    });
  })
</script>
<!-- Baidu Tongji -->


<script src="/js/script.js"></script>


  </body>
</html>
<!DOCTYPE html>
<html>
  <head>
  <meta http-equiv="content-type" content="text/html; charset=utf-8">
  <!--<meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport">-->
  <meta name="description" content="要有一个从输入到输出的过程">
  <meta name="keyword" content="">
  
    <link rel="shortcut icon" href="/css/images/logo.png">
  
  <title>
    
      Java Virtual Machine | CQ&#39;s Blog
    
  </title>
  <link href="//cdnjs.cloudflare.com/ajax/libs/font-awesome/4.7.0/css/font-awesome.min.css" rel="stylesheet">
  <link href="//cdnjs.cloudflare.com/ajax/libs/nprogress/0.2.0/nprogress.min.css" rel="stylesheet">
  <link href="//cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/tomorrow.min.css" rel="stylesheet">
  
<link rel="stylesheet" href="/css/style.css">

  
  <script src="//cdnjs.cloudflare.com/ajax/libs/jquery/3.2.1/jquery.min.js"></script>
  <script src="//cdnjs.cloudflare.com/ajax/libs/geopattern/1.2.3/js/geopattern.min.js"></script>
  <script src="//cdnjs.cloudflare.com/ajax/libs/nprogress/0.2.0/nprogress.min.js"></script>
  
  
  
  


  
  
    
<script src="/js/local-search.js"></script>


<meta name="generator" content="Hexo 5.4.2"></head>
<div class="wechat-share">
  <img src="/css/images/logo.png" />
</div>
  <body>
    <header class="header fixed-header">
  <div class="header-container">
    <a class="home-link" href="/">
      <div class="logo"></div>
      <span>CQ's Blog</span>
    </a>
    <ul class="right-list">
      
        <li class="list-item">
          
            <a href="/" class="item-link">Home</a>
          
        </li>
      
        <li class="list-item">
          
            <a href="/categories/" class="item-link">Categories</a>
          
        </li>
      
        <li class="list-item">
          
            <a href="/records" class="item-link">Records</a>
          
        </li>
      
        <li class="list-item">
          
            <a href="/scratches/" class="item-link">Scratches</a>
          
        </li>
      
        <li class="list-item">
          
            <a href="/archives/" class="item-link">Archives</a>
          
        </li>
      
      
        <li class="menu-item menu-item-search right-list">
    <a role="button" class="popup-trigger">
        <i class="fa fa-search fa-fw"></i>
    </a>
</li>
      
    </ul>
    <div class="menu">
      <span class="icon-bar"></span>
      <span class="icon-bar"></span>
      <span class="icon-bar"></span>
    </div>
    <div class="menu-mask">
      <ul class="menu-list">
        
          <li class="menu-item">
            
              <a href="/" class="menu-link">Home</a>
            
          </li>
        
          <li class="menu-item">
            
              <a href="/categories/" class="menu-link">Categories</a>
            
          </li>
        
          <li class="menu-item">
            
              <a href="/records" class="menu-link">Records</a>
            
          </li>
        
          <li class="menu-item">
            
              <a href="/scratches/" class="menu-link">Scratches</a>
            
          </li>
        
          <li class="menu-item">
            
              <a href="/archives/" class="menu-link">Archives</a>
            
          </li>
        
      </ul>
    </div>
    
      <div class="search-pop-overlay">
    <div class="popup search-popup">
        <div class="search-header">
            <span class="search-icon">
                <i class="fa fa-search"></i>
            </span>
            <div class="search-input-container">
                <input autocomplete="off" autocapitalize="off"
                    placeholder="Please enter your keyword(s) to search." spellcheck="false"
                    type="search" class="search-input">
            </div>
            <span class="popup-btn-close">
                <i class="fa fa-times-circle"></i>
            </span>
        </div>
        <div id="search-result">
            <div id="no-result">
                <i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i>
            </div>
        </div>
    </div>
</div>
    
  </div>
</header>

    <div id="article-banner">
  <h2>Java Virtual Machine</h2>
  <!--<p class="post-date">2023-12-09</p>
  <div class="arrow-down">
    <a href="javascript:;"></a>
  </div>-->
</div>
<main class="app-body flex-box">
  <!-- Article START -->
  <article class="post-article">
    <section class="markdown-content"><h1 id="1、引言"><a href="#1、引言" class="headerlink" title="1、引言"></a>1、引言</h1><p>Java 技术体系主要由支撑 Java 程序运行的虚拟机、提供各开发领域接口支持的 Java 类库、Java 编程语言及许许多多的第三方 Java 框架（如 Spring、MyBatis）构成。JVM 层面隐藏了机器平台、操作系统、资源管理等底层技术的复杂性和差异性，在千差万别的平台上建立了统一的 Java 运行平台，与此同时也牺牲了一些硬件相关的性能特性，即提升硬件性能时无法等比例提升 Java 程序的运行性能和并放能力，甚至可能没有任何改善，了解 JVM 是为了写出最适合 JVM 运行和自优化的 Java 代码。</p>
<p>HotSpot VM 是 Sun/OracleJDK 和 OpenJDK 中的默认 JVM，HotSpot VM 的热点代码探测能力可以通过执行计数器找出最具有编译价值的代码，然后通知即时编辑器以方法为单位进行编译，通过编译器与解释器恰当地协同工作，将热点代码编译为物理硬件可以直接执行的机器码 ，可以在最优化的程序响应时间与最佳执行性能中取得平衡，而且无须等待本地代码输出才能执行程序，即时编译的时间压力也相对减小，有助于引入更复杂的代码优化技术，输出质量更高的本地代码。</p>
<h1 id="2、自动内存管理"><a href="#2、自动内存管理" class="headerlink" title="2、自动内存管理"></a>2、自动内存管理</h1><h2 id="2-1-内存使用"><a href="#2-1-内存使用" class="headerlink" title="2.1 内存使用"></a>2.1 内存使用</h2><p>Java 程序将控制内存的权利交给了 JVM，在编码的时候享受自动内存管理，但需要通过了解 JVM 如何使用内存来排查内存泄漏和溢出方面的问题。</p>
<h3 id="2-1-1-内存分区"><a href="#2-1-1-内存分区" class="headerlink" title="2.1.1 内存分区"></a>2.1.1 内存分区</h3><p>JVM 在执行 Java 程序过程中会把它所管理的内存划分为</p>
<ul>
<li><strong>程序计数器</strong><ul>
<li>是一块较小的内存空间，可以看作是当前线程所执行的字节码的行号指示器</li>
<li>每个线程都有自己独立的程序计数器，是线程私有的内存，生命周期与所属的线程相同</li>
<li>如果线程正在执行的是一个 Java 方法，计时器记录的是正在执行的虚拟机字节码指令的地址，如果正在执行的是本地 Native 方法，这个计数器值则为空</li>
<li>此内存区域是唯一一个没有规定任何 OutOfMemoryError 情况的区域</li>
</ul>
</li>
<li><strong>虚拟机栈</strong><ul>
<li>每个线程都有自己独立的虚拟机栈空间，是线程私有的内存，生命周期与所属的线程相同，每个方法被执行时，JVM 都会同步创建一个栈帧用于存储局部变量表、操作数栈、动态连接、方法出口等信息，Java 方法从被调用到执行完毕就对应栈帧在虚拟机栈中从入栈到出栈的过程</li>
<li>虚拟机栈通常只是指虚拟机栈中局部变量表部分，局部变量表存放了编译期可知的各种基本数据类型、对象引用以及 returnAddress 类型（指向了一条字节码指令的地址）</li>
<li>局部变量表中所存放的这些数据类型在局部变量表中的存储空间以局部变量槽来表示，long 和 double 会占据两个变量槽，其余的数据类型只占用一个变量槽，一个方法需要在栈帧中分配多少个变量槽是在编译期间就确定的，在方法运行期间不会改变局部变量槽的个数</li>
<li>如果线程请求的栈深度大于 JVM 所允许的深度时则抛出 StackOverflowError，如果 JVM 栈容量可以动态扩展，当栈扩展到无法申请到足够的内存时则抛出 OutOfMemoryError 异常</li>
<li>HotSpot VM 通过参数 -Xss 设定初始栈容量，但不支持运行期间的栈容量动态扩展，因此只会在栈容量不足时出现 StackOverflowError，此时会有明确错误堆栈可供分析，可以容易定位到问题代码所在</li>
</ul>
</li>
<li><strong>本地方法栈</strong><ul>
<li>本地方法栈为 JVM 使用到的本地 Native 方法服务，Native 方法从被调用到执行完毕就对应栈帧在本地方法栈中从入栈到出栈的过程，JVM 可以自由的实现本地方法栈，也可以直接把本地方法栈和虚拟机栈合二为一</li>
<li>本地方法栈也会在栈深度溢出或者栈扩展失败时分别抛出 StackOverflowError 和 OutOfMemoryError</li>
</ul>
</li>
<li><strong>堆</strong><ul>
<li>堆是 JVM 所管理的内存中最大的一块，是被所有线程共享的内存区域，在 JVM 启动时创建，用于存发对象实例，几乎所有的对象实例以及数组都在这里分配内存，是 JVM 垃圾收集器管理的内存区域，因此也称作 GC 堆</li>
<li>堆可以处于物理上不连续的内存空间中，但在逻辑上应该被视为是连续的，堆既可以是固定大小的，也可以是扩展的（通过参数 -Xmx 和 -Xms 设定），如果堆中没有足够的可用内存来完成实例分配并且堆也无法再扩展时，会抛出 OutOfMemoryError</li>
<li>当出现 OutOfMemoryError 时，首先查看是否存在内存泄漏，确保垃圾收集器回收了所有应当回收的内存，其次检查是否存在不合理的生命周期过长的对象，尽量减少程序运行期间的内存消耗，最后查看是否可以上调堆参数 -Xmx 和 -Xms</li>
</ul>
</li>
<li><strong>方法区</strong><ul>
<li>方法区也是被所有线程共享的内存区域，存储已被 JVM 加载的类型信息、常量、静态变量、即时编译器编译后的代码缓存等数据，方法区有一个别名叫作非堆，这是为了与堆区分开来</li>
<li><strong>运行时常量池</strong>是方法区的一部分，Class 文件中除了有类的版本、字段、方法、接口等描述信息外，还有一项是常量池表，用于存放编译期生成的各种字面量与符号引用，这部分将在类加载后存放到方法区的运行时常量池中</li>
<li>运行时常量池相对于 Class 文件常量池的一个重要特征时具备动态性，Java 语言并不要求常量一定只有编译期才产生，运行期间也可以将新的常量放入池中（String.intern() 方法会把首次遇到的字符串实例放入字符串常量池中，返回常量池中的字符串实例的引用）</li>
<li>方法区和堆一样不需要连续的内存，可以选择固定大小，也可以扩展，甚至还可以选择不实现垃圾收集</li>
<li>方法区的垃圾收集比较少见，但并非数据进入方法区就永久存在了，方法区的内存回收目标主要是针对常量池的回收和对类型的卸载，一旦方法区无法满足新的内存分配需求时，将抛出 OutOfMemoryError</li>
<li>一个类被垃圾回收的条件是比较严苛的，在经常运行时生成大量动态类的应用场景（比如 CGLIB 这类字节码技术、动态产生大量需要被编译成 Java 类的 JSP 文件等）里就需要特别关注这些类的回收情况，</li>
</ul>
</li>
</ul>
<p>JVM 所管理的这些区域有各自的用途，此外，直接内存并不是 JVM 运行时数据区的一部分，但<strong>直接内存</strong>也被频繁地使用，比如 NIO 类可以使用 Native 函数库直接分配堆外内存，然后通过一个存储在 Java 堆中的对象作为这块堆外内存的引用进行操作，避免在 Java 堆和 Native 堆中来回复制数据，能够在一些场景中显著提高性能。本机直接内存的分配显然不会受到 Java 堆大小的限制，但依旧会受到本机总内存大小以及处理器寻址空间的限制，需要注意的是在配置 JVM 参数时不要忽略直接内存，否则可能会使得 JVM 所管理内存加上直接内存后超过本机物理内存限制，从而导致动态扩展时出现 OutOfMemoryError（通过参数 -XX:MaxDirectMemorySize 可以指定直接内存的容量，如果不指定则默认与 Java 堆最大值一致）。</p>
<h3 id="2-1-2-内存分配"><a href="#2-1-2-内存分配" class="headerlink" title="2.1.2 内存分配"></a>2.1.2 内存分配</h3><p>当 JVM 遇到一条<strong>字节码 new 指令</strong>时，首先检查这个指令的参数是否能在常量池中定位到一个类的符号引用，检查这个符号引用代表的类是否已经被加载、解析和初始化，如果没有则先执行相应的<strong>类加载过程</strong>，在类加载完成后即可完全确定对象所需内存的大小，在类加载检查通过后，接着就将一块<strong>大小确定</strong>的内存块从 Java 堆（也有可能经过即时编译后被拆散为标量类型并间接地在栈上分配）中划分出来并<strong>设置对象头</strong>，这些工作都完成后，从 JVM 的视角来看一个新的对象已经产生了，但从 Java 程序的视角来看，对象创建工作刚刚开始，对象中所有的字段还都为默认值，对象需要的其他资源和状态信息也还没有按照预定的意图构造好，接下来需要<strong>执行构造函数</strong>（即 Class 文件中的 &lt;init&gt;() 方法）来按照程序员的意图对对象成员变量进行<strong>初始化</strong>，把<strong>堆内对象的首地址赋给引用变量</strong>，这样一个真正的可用对象才算完全被构造出来，对象在堆内存中的存储布局可以划分为<strong>对象头</strong>、<strong>实例数据</strong>和<strong>对齐填充</strong>。</p>
<p>从 Java 堆中划分内存的方式取决于 Java 堆是否规整，Java 堆是否规整取决于所采用的垃圾收集器是否带有空间压缩整理的能力。当 Java 堆中内存是绝对规整的（所有被使用的内存都被放在一边，空闲的内存被放在另一边，中间放着一个指针作为分界点的指示器）时，那只需进行<strong>指针碰撞</strong>（将指针向空闲方向挪动一段与对象所需大小相等的距离），这种方式在并发情况下并不是线程安全的，所以要么进行<strong>同步锁定</strong>，要么通过本地<strong>线程分配缓冲</strong>（TLAB，预先分配一小块内存给每个线程）来把内存分配的动作按照线程划分在不同的空间中进行，只有在线程本地缓存空间用完后才需要同步锁定。当 Java 堆中内存不是规整的（使用过的内存和未被使用的内存相互交错在一起）时，JVM 会维护一个<strong>空闲列表</strong>来记录可用的内存块，在分配时就从空闲列表中找到一块足够大的空间划分给对象实例，并更新空闲列表。</p>
<p><strong>对象头中的信息是与对象自身定义的数据无关的额外存储成本</strong>，包括两类信息，一类是用于存储对象自身的运行时数据，如对象所对应的哈希码（实际会延后到真正调用 Object::hashCode() 方法时才计算）、GC 分代年龄、锁状态标志、线程持有的锁、偏向线程 ID、偏向时间戳等，这部分数据称为 <strong>Mark Word</strong>，Mark Word 是一个有着动态定义的数据结构，旨在在极小的空间内存储尽量多的数据，根据对象的状态复用自己的存储空间，其长度在 32 位和 64 位的 JVM（未开启压缩指针）中分别为 32 个比特和 64 个比特；对象头的另一部分是<strong>类型指针</strong>，即指向方法区内的对象类型数据的地址，JVM 通过这个指针来确定该对象是哪个类的实例，但由于查找对象类型数据并不一定要经过对象本身（也可能是通过句柄来访问），因此并不是所有的 JVM 都必须在对象头上保留类型指针；此外，对于数组对象，对象头还必须有一块用于记录数组长度的数据。</p>
<p><strong>实例数据部分是对象真正存储的有效信息，即程序代码中定义的各种类型的字段内容</strong>，无论是从父类继承下来的，还是在子类中定义的字段都必须记录起来，这部分的存储顺序会受到 JVM 分配策略参数配置和字段在 Java 源码中定义顺序的影响，HotSpot VM 默认的分配顺序为 long/double、int、short、char、byte/boolean、oop (Ordinary Object Pointer)，即相同宽度的字段总司被分配到一起存放，在这个前提下，父类中定义的变量会出现在子类之前，也允许通过 HotSpot VM 的参数配置令子类之中较窄的变量插入到父类变量的空隙之中。</p>
<p>对齐填充部分并不是必然存在的，也没有特别的含义，仅仅起着占位符的作用，HotSpot VM 的自动内存管理系统要求对象起始地址必须是 8 字节的整数倍，即任何对象的大小都必须是 8 字节的整数倍，对象头部分已经被设计成正好是 8 字节的整数倍，因此如果对象实例数据部分没有对齐的话就需要通过对齐填充来补全。</p>
<p>Java 程序会<strong>通过栈上的 reference 数据来操作堆中的具体对象</strong>，根据 reference 来访问堆中对象的方式有 JVM 具体实现而定，主流的访问方式主要有使用句柄和直接指针两种。通过<strong>句柄访问</strong>时，Java 堆中可能会划分出一块内存来作为句柄池，reference 中存储的就是对象的句柄地址，而句柄中包含了堆内的对象实例数据与方法区内的对象类型数据各自具体的地址。通过<strong>直接指针访问</strong>时，reference 中存储的直接就是对象实例数据地址，不需要多一次通过访问句柄来间接访问对象的开销，但 Java 堆中对象的内存布局就必须考虑如何在对象数据中放置方法区内的对象类型数据的地址（一般是在对象头中设置类型指针）。</p>
<h2 id="2-2-垃圾收集"><a href="#2-2-垃圾收集" class="headerlink" title="2.2 垃圾收集"></a>2.2 垃圾收集</h2><p>当需要排查各种内存溢出、内存泄漏以及系统并发瓶颈问题时，都可能需要分析系统垃圾回收情况，程序计数器、虚拟机栈、本地方法栈的内存区域与特定线程伴生，其内存分配与回收都具备确定性（在编译期即可大致确定，且当方法结束或者线程结束时内存自然就随着回收了），无需过多考虑回收问题，而 <strong>Java 堆和方法区</strong>这两个区域则有显著的不确定性，只有运行期才能确定程序到底会创建哪些对象，其内存的分配和回收是动态取决于对象的引用关联情况的，需要重点关注。</p>
<h3 id="2-2-1-回收条件"><a href="#2-2-1-回收条件" class="headerlink" title="2.2.1 回收条件"></a>2.2.1 回收条件</h3><p>回收方法区时，需要判断方法区内的常量、类型信息等是否存在引用关联关系，其中，判断一个类型是否属于不再被使用的类需要满足三个条件：该类及其所有派生子类的所有实例都已经被回收，加载该类的类加载器已经被回收，该类对应的 Class 对象没有在任何地方被引用，此时该类的类型信息允许被回收，但也不一定（HotSpot VM 提供了 -Xnoclassgc 参数进行控制），在大量使用反射、动态代理、CGLIB 等字节码框架、动态生成 JSP 以及 OSGi 这类频繁自定义类加载器的场景中，通常都需要 JVM 具备类型信息卸载的能力，以确保不会对方法区造成过大的内存压力。</p>
<p>回收 Java 堆时，需要判断堆内对象是否存在引用关联关系，如果 reference 类型的数据中存储的数值是另外一块内存的起始地址，就称该 reference 数据是代表某块内存、每个对象的强引用，垃圾收集器永远不会回收被<strong>强引用</strong>的对象；<strong>软引用</strong>是用来描述一些还有用，但非必须得对象，在系统将要发生内存溢出前，会把软引用对象列进回收范围之中，即被软引用的对象只能生存到内存即将溢出为止，若回收后还没有足够的内存，才会抛出内存溢出异常；<strong>弱引用</strong>也是用来描述那些非必须对象，区别在于被弱引用的对象只能生存到下一次垃圾收集发生为止，当垃圾收集器开始工作，无论当前内存是否足够，都会回收只被弱引用关联的对象；<strong>虚引用</strong>也称为幽灵引用或者幻影引用，一个对象是否被虚引用完全不会对其生存时间构成影响，也无法通过虚引用来取得一个对象实例，虚引用关联的唯一目的只是为了在被引用对象被回收时收到一个系统通知。引用计数算法和根可达算法都可以判断一个对象是否存在引用关联关系。</p>
<p>当判断一个对象不存在引用关联关系时，该对象将会被第一次标记，随后判断该对象是否需要执行 finalize 方法（对象没有覆盖 finalize 方法或 finalize 方法已经被 JVM 执行过都视作不需要执行），对于不需要执行 finalize 方法的对象则真正回收该对象，对象死亡，对于需要执行 finalize 方法的对象将会被放置在一个名为 F-Queue 的队列之中，并在稍后由一条由 JVM 自动建立的、低调度优先级的 Finalizer 线程去触发这些对象的 finalize 方法开始运行（并不承诺一定会等待方法运行结束），随后垃圾收集器将对 F-Queue 中的对象进行第二次小规模标记，此时再一次检查 F-Queue 队列中的对象是否依旧不存在引用关联关系，若存在则将其移出 F-Queue，若不存在则真正回收该对象，对象死亡。整个过程中任何一个对象的 finalize 方法都只会被系统自动调用一次，但<strong>并不推荐在对象的 finalize 方法中令对象重新被引用，JVM 并不鼓励定义和使用 finalize，所有 finalize 能做的工作，都可以使用 try-finally 或者其他方式做的更好更及时</strong>。</p>
<p><strong>引用计数算法</strong>会在对象中添加一个引用计数器，每当有一个地方引用该对象计数器值就加一，每当引用失效计数器值就减一，计数器值为零的对象就是不可能再被使用的，但引用计数<strong>无法分辨循环引用</strong>的情况，JVM 并不使用引用技术算法来判断对象是否存活。<strong>根可达性算法</strong>通过一系列称为 <strong>GC Roots</strong> 的根对象作为起始节点集，根据引用关系向下搜索，搜索过程所走过的路径称为引用链，如果某个对象到 GC Roots 间没有任何引用链相连，则证明此对象是不可能再被使用的，JVM 采用根可达算法来判断对象是否存活，固定可作为 GC Roots 的对象包括虚拟机栈（栈帧中的本地变量）中引用的对象、方法区中类静态属性引用的对象、方法区中常量引用的对象、本地方法栈中 JNI（即 Native 方法）引用的对象、JVM 内部的引用（比如基本数据类型对应的 Class 对象，常驻的异常对象，系统类加载器等）、所有被 synchronized 锁持有的对象、反映 JVM 内部情况的 JMXBean、JVMTI 中注册的回调、本地代码缓存等，迄今为止。</p>
<p>所有垃圾收集器<strong>在 GC Roots 枚举这一步骤时必须暂停用户程序</strong>，HotSpot 在类加载动作完成时，就会把对象内什么偏移量上是什么类型的数据计算出来，在即时编译的过程中也会在特定的位置（被称为<strong>安全点</strong>）记录下栈里和寄存器里哪些位置是引用，并使用一组称为 <strong>OopMap</strong> 的数据结构来存放所有所有执行上下文和全局性的引用，在 OopMap 的协助下，HotSpot 可以快速准确地完成 GC Roots 枚举（停顿时间不随堆容量而增长了），安全点的选定既不能太少以至于让收集器等待时间过长，也不能太过频繁以至于过分增大运行时的内存负荷，基本上是以是否具有让程序长时间执行的特征（即指令序列的复用）为标准进行选定的，比如方法调用、循环跳转、异常跳转等都属于指令序列复用，所以只有具有这些功能的指令才会产生安全点。</p>
<p>为了在发生垃圾收集时应当尽可能让所有线程（不包括执行 JNI 调用的线程）都跑到最近的安全点然后停顿下来，可使用抢先式中断和主动式中断。抢先式中断方案在垃圾收集发生时，系统首先把所有用户线程全部中断，然后恢复中断地方不在安全点上的线程的执行，直到该线程跑到安全点上再重新中断，现在几乎没有 JVM 采用抢先式中断来暂停线程响应 GC 事件。<strong>主动式中断方案</strong>仅仅简单设置一个中断标志位，各个线程执行过程中会在安全点和需要分配内存的地方去主动去轮询这个中断标志位，一旦发现中断标志为真时就自己在当前/最近的安全点上主动中断挂起。</p>
<p>对于获取到 CPU 时间片的执行中的线程来说，安全点机制保证了线程执行时在不太长的时间内就会遇到可进入垃圾收集过程的安全点，但对于未获取到 CPU 时间片的线程（比如处于 sleep 或 blocked 状态）来说，线程无法响应 JVM 的中断请求，不能走到安全点去中断挂起自己，这种线程会标识自己已经进入了安全区域，<strong>安全区域</strong>是指能够确保在某一段代码片段之中，引用关系不会发生变化，这个区域中任何地方开始垃圾收集都是安全的，可以看作是被扩展拉伸了的安全点。JVM 发起垃圾收集时无需管这些已声明自己在安全区域内的线程，当线程要离开安全区域时，它要检查 JVM 是否已经完成了根节点枚举或其他需要暂停用户线程的阶段，如果完成了则线程可以继续执行，否则线程就必须一致等待，直到收到可以离开安全区域的信号为止。</p>
<h3 id="2-2-2-收集算法"><a href="#2-2-2-收集算法" class="headerlink" title="2.2.2 收集算法"></a>2.2.2 收集算法</h3><p>绝大多数对象都是朝生夕灭的，而熬过越多次垃圾收集过程的对象就越难以消亡，且不同年龄类型的对象之间的引用相对于同年龄类型的引用来说仅占极少数，因此收集器考虑将对象依据其年龄（对象熬过垃圾收集过程的次数）分配到 Java 堆的不同的区域中存储，每次回收时重点关注那些朝生夕灭的区域（<strong>新生代</strong>）更能以较低代价回收到大量空间，而那些难以消亡的对象所在区域（<strong>老年代</strong>）则被 JVM 以较低的频率去回收，这就兼顾了垃圾收集的时间开销和内存空间的有效利用。</p>
<p>根据垃圾收集器每次回收 Java 堆被划分出的其中某一个还是某些区域，产生了<strong>新生代收集</strong>（Minor/Yong GC）、<strong>老年代收集</strong>（Major/Old GC，只有 CMS 收集器有这种行为）、<strong>混合收集</strong>（Mixed GC，收集整个新生代和部分老年代，只有 G1 收集器有这种行为）、<strong>整堆收集</strong>（Full GC，收集整个 Java 堆和方法区）这样的回收行为类型的划分。根据 Java 堆不同区域存储对象的存亡特征的不同，产生了<strong>标记-清除算法</strong>、<strong>标记-复制算法</strong>、<strong>标记-整理算法</strong>这些与对象存亡特征相匹配的针对性垃圾收集算法，这些算法都首先依据根可达算法标记出所有需要回收的对象（因此算法称为追踪式垃圾收集/间接垃圾收集），基于根可达算法的标记阶段会随着 Java 堆变大而等比例增加停顿时间，在标记完成后，统一回收掉所有被标记的对象。</p>
<p>所有涉及到部分区域收集行为的垃圾收集都会面临<strong>跨代引用</strong>的问题，即<strong>需要判断某一块非收集区域是否存在有指向了收集区域的指针，但又不希望扫描整个非收集区域</strong>，因此需要一种称为<strong>记忆集</strong>的抽象数据结构来记录从非收集区域指向收集区域的指针集合。非收集区域中的所有含跨代引用的对象所组成的对象数组是一种最简单的记忆集实现方式，但空间占用和维护成本都相当高昂，HotSpot 使用<strong>卡表</strong>来实现记忆集，卡表是一个由收集区域所有内存块所组成的字节数组，其中每一个元素都对应着一块特定大小（一般都是以 2 的 N 次幂的字节数）的内存块（被称为卡页，通常包含不止一个对象），只要有其他区域中对象引用了本区域的对象，该对象所在卡页所对应的卡表元素就变脏了，其元素值需要被标识为 1（这个维护卡表的动作需要放到每一个赋值操作之中），那么垃圾收集时只需筛选出卡表中变脏的元素，就能得知收集区域中哪些内存块中包含跨代指针，把它们加入 GC Roots 中一并扫描。</p>
<p>在快速完成 GC Roots 枚举后，从 GC Roots 再继续往下遍历对象图就是根可达分析，在这个过程中，会将尚未被访问过的对象标记为白色的（刚开始阶段都是白色的），将已经被访问过的对象但还存在对象引用未被访问过的标记为灰色，将已经被访问过的对象且对象的所有引用也都已经被访问过的标记为黑色，整个根可达分析过程就是对象逐渐由白变灰再变黑的过程，最终白色就是不可达的应该消亡的对象，黑色就是应该存活的对象。根可达分析过程的停顿时间与 Java 堆容量以及对象图结构复杂度直接成正比例关系，因此考虑<strong>并发的根可达分析</strong>，而当有用户线程在并发工作时，会导致对象图结构被修改，进而可能会导致应该消亡的对象被标记为存活以及应该存活的对象被标记为消亡，前者会产生还算可以接受的浮动垃圾，后者则会导致应用程序错误，为了避免这种情况，产生了增量更新和原始快照这种解决方案。<strong>增量更新</strong>方案会记录黑色对象被新插入的指向白色对象的引用记录，当并发结束后，再将这些记录过引用关系的黑色对象为根重新扫描，可以简化理解为黑色对象一旦新插入了指向白色对象的引用之后，就变回灰色对象。<strong>原始快照</strong>方案会记录灰色对象被新删除的指向白色对象的引用记录，当并发结束后，再将这些记录过引用关系的灰色对象为根重新扫描，可以简化理解为无论引用关系删除与否，都会按照刚刚开始扫描那一刻的对象图快照进行扫描。</p>
<p><strong>Mark-Sweep</strong> 算法最基础（另外两个都是以这个为基础），但执行效率不稳定（效率随对象数量增长而降低），还会产生大量不连续的内存碎片；<strong>Mark-Copy</strong> 将可用内存划分为一块较大的 Eden 区和两块较小的 Survivor 区，每次分配内存时只使用 Eden 区和其中一块 Survivor 区，当可用内存用完需要垃圾搜集时，将 Eden 区和这一块 Survivor 区中还存活的对象根据其对象头中的存活年龄信息判断是将其复制到另一块 Survivor 区中还是移动到老年代（如果在 Survivor 中低于等于某年龄的所有对象大小的总和大于 Survivor 空间的一半，那么这些对象也可以直接进入老年代），然后直接清理掉 Eden 区和已用过的那块 Survivor 区，这种算法不会产生空间碎片，但可用内存空间被缩小为原本的 90%（Eden 和 Survivor 的大小比例是 8:1），且当内存中多数对象都长时间存活时，会产生大量内存空间复制的开销，不过当多数对象都可回收时，仅需要复制占少数的存活对象，因此<strong>多用于回收新生代</strong>；<strong>Mark-Compact</strong> 将所有存活的对象都向内存空间一端移动并更新所有引用这些对象的地方（这种操作必须全程暂停用户应用程序才能进行），然后直接清理掉边界以外的内存，<strong>多用于回收老年代</strong>，当存在大量存活对象时这会是一种极为负重的操作，但若不进行这种移动操作，频繁的基于碎片化空间的内存分配和访问则会严重影响应用程序吞吐量，考虑到内存分配和访问相比垃圾收集频率要高得多，从整个程序的吞吐量来看，移动对象会更划算。</p>
<p>新创建对象一般是在 Java 堆的新生代的 Eden 区中划分内存，当 Eden 区没有足够空间进行内存分配时，JVM 将发起一次 Minor GC。Minor GC 发生之前必须先确保老年代中最大可用的连续空间是大于新生代所有对象总空间（确保 Minor GC 是安全的）或者大于历次晋升到老年代对象的平均大小（是有风险的 Minor GC），若条件不满足则进行 Full GC，若条件满足则尝试进行 Minor GC，<strong>若 Minor GC 失败（即担保失败）则需要进行 Full GC（这是最糟糕的情况）</strong>。如果在 Eden 区给大对象（典型的大对象是那种很长的字符串、元素数量很庞大的数组）分配内存，就很容易提前触发 GC，且在后续的 GC 中，大对象在 Eden 区以及两个 Survivor 之间的来回复制也是很高的开销，因此大对象可以直接分配在老年代，<strong>大对象对 JVM 的内存分配来说是坏消息，一个存活时间很短的大对象则是一个更坏的消息，开发人员应当尽量避免这种情况。</strong></p>
<h3 id="2-2-3-经典收集器"><a href="#2-2-3-经典收集器" class="headerlink" title="2.2.3 经典收集器"></a>2.2.3 经典收集器</h3><p>不同的厂商、版本的 JVM 所包含的垃圾收集器都可能会有很大差别，JVM 一般也都会提供各种参数供用户根据自己的应用特点和要求组合出各个内存分代所使用的收集器，经典的垃圾收集器算不上是最先进的技术，但足够成熟，可在生产环境放心使用，具体如下</p>
<ul>
<li>Serial<ul>
<li>属于新生代收集器，可与 CMS、Serial Old 搭配使用</li>
<li>在垃圾收集时必须暂停其他所有用户线程直到垃圾收集结束，只能<strong>单线程工作</strong>，采用 Mark-Copy</li>
<li>使用简单，是所有收集器里<strong>额外内存消耗最小</strong>的，也没有线程交互的开销，可以获得最高的单线程收集效率（与其他收集器的单线程相比）</li>
<li>对于内存较小的分区来说，其停顿时间完全可以控制在十几、几十毫秒以内，对于用户来说完全是可以接受的</li>
</ul>
</li>
<li>ParNew<ul>
<li>属于新生代收集器，可与 CMS、Serial Old 搭配使用</li>
<li>实质上是 <strong>Serial 的多线程并行版本</strong>，但在单核 CPU 中，由于存在线程交互的开销，ParNew 并不会有比 Serial 更好的效果</li>
<li>ParNew 其余的行为和 Serial 完全相同，同样在垃圾收集时必须暂停其他所有用户线程直到垃圾收集结束，同样采用 Mark-Copy</li>
</ul>
</li>
<li>Parallel Scavenge<ul>
<li>属于新生代收集器，可与 Serial Old、Parallel Old 搭配使用</li>
<li>能够多个垃圾收集线程<strong>并行</strong>，在垃圾收集时必须暂停其他所有用户线程直到垃圾收集结束，采用 Mark-Copy</li>
<li><strong>Parallel Scavenge 关注的目标是达到一个可控制的吞吐量（即 CPU 用于运行用户代码的时间与总消耗时间的比值）</strong>，而不是尽可能缩短垃圾收集时的用户线程停顿时间，Parallel Scavenge也称为吞吐量优先收集器</li>
<li>Parallel Scavenge 允许用户通过设定参数来控制最大的垃圾收集停顿时间（<strong>更短的停顿时间是以牺牲吞吐量和新生代空间位代价换取的</strong>）或者直接设定吞吐量大小，还允许用户通过激活开关参数来允许 JVM 根据当前系统的运行情况收集性能监控信息，动态调整各种细节参数（比如新生代大小、Eden 与 Survivor 的比例等）以提供最合适的停顿时间或者最大的吞吐量，这种调节方式称为垃圾收集的<strong>自适应的调节策略</strong></li>
</ul>
</li>
<li>Serial Old<ul>
<li>属于老年代收集器，可与 CMS、Serial、ParNew、Parallel Scavenge 搭配使用</li>
<li>是 <strong>Serial 的老年代版本</strong>，同样在垃圾收集时必须暂停其他所有用户线程直到垃圾收集结束，同样只能单线程工作，采用 Mark-Compact</li>
<li>可以在 CMS 发生 Concurrent Mode Failure 时作为后备预案</li>
</ul>
</li>
<li>Parallel Old<ul>
<li>属于老年代收集器，可与 Parallel Scavenge 搭配使用</li>
<li>是 <strong>Parallel Scavenge 的老年代版本</strong>，同样能够多个垃圾收集线程并行，同样在垃圾收集时必须暂停其他所有用户线程直到垃圾收集结束，采用 Mark-Compact</li>
<li>在<strong>注重吞吐量或者 CPU 资源较为稀缺的场合</strong>都可以优先考虑 Parallel Scavenge 加 Parallel Old 这个组合</li>
</ul>
</li>
<li>CMS (Concurrent Mark Sweep)<ul>
<li>属于老年代收集器，可与 Serial、ParNew、Serial Old 搭配使用</li>
<li>HotSpot 中第一款真正意义上支持并发的垃圾收集器，<strong>首次实现了让垃圾收集线程和用户线程并发工作</strong>，以获取最短回收停顿时间为目标，又称为并发低停顿收集器</li>
<li>CMS 将垃圾收集过程分为四个步骤<ul>
<li><strong>初始标记</strong>，标记 GC Roots 能直接关联到的对象，需要暂停其他所有用户线程，耗时很短</li>
<li><strong>并发标记</strong>，从 GC Roots 的直接关联对象开始遍历整个对象图（三色标记），耗时长，与用户线程一起并发工作，基于增量更新实现并发标记</li>
<li><strong>重新标记</strong>，修正并发标记期间因用户程序运作而导致标记产生变动的标记记录，多个垃圾收集线程并行工作，需要暂停其他所有用户线程，耗时比初始标记阶段稍长一些，但远比并发标记阶段短</li>
<li><strong>并发清除</strong>，清理标记阶段判断已经死亡的对象，耗时长，与用户线程一起并发工作</li>
</ul>
</li>
<li>CMS 对 <strong>CPU 资源非常敏感</strong>，在并发阶段，虽然无需用户线程停顿，但会因为垃圾收集线程占据了一部分 CPU 资源而导致<strong>应用程序变慢</strong>，总吞吐量降低</li>
<li>由于<strong>需要预留一些内存</strong>以供并发收集时的用户线程使用，CMS 在老年代内存使用达到一定域值（用户可设定）后就会被触发</li>
<li>CMS 还会产生浮动垃圾，也可能出现 Concurrent Mode Failure 进而导致另一次完全暂停所有用户线程的 Full GC 的产生</li>
<li>在平时多数时间都采用 Mark-Sweep，暂时容忍内存碎片的存在，直到内存空间的碎片化程度已经大到影响对象分配时，再采用一次 Mark-Compact 以获得规整的内存空间，这是需要暂停所有用户线程的 Full GC</li>
<li>CMS 的记忆集相当简单，考虑到新生代对象极不稳定，引用变化频繁，维护新生代到老年代的跨代引用开销是很大的，所以只需唯一一份用于记录老年代到新生代的跨代引用的卡表即可，代价就是老年代的垃圾收集需要把这个新生代作为 GC Roots 进行扫描</li>
</ul>
</li>
<li>G1 (Garbage First)<ul>
<li>是一个<strong>面向全堆（包括新生代和老年代）和方法区</strong>的垃圾收集器，不再需要其他的收集器配合工作，可以由用户指定期望的停顿时间，目标是<strong>在延迟可控的情况下获得尽可能高的吞吐量</strong></li>
<li>G1 可以面向任何内存部分组成的回收集进行回收，衡量标准不再是这块内存属于哪个分代而是哪块内存中存放的垃圾数量最多，回收受益最大，这就是 <strong>Mixed GC</strong> 模式，但一旦内存回收的速度赶不上内存分配的速度，就要暂停所有用户线程进行 Full GC</li>
<li>G1 将连续的 Java 堆划分为多个大小相等的独立区域 Region，每个 Region 都可以根据需要当做新生代的 Eden、Survivor 或者老年代使用（大小超过了整个 Region 容量的对象判定为超大对象，会被存放在 N 个连续的 Humongous Region 之中）</li>
<li>新生代的 Eden、Survivor 以及老年代不再是固定的了，而是<strong>一系列不一定连续的 Region 的动态集合</strong>，G1 能够对不同角色的 Region 采用不同的策略去进行垃圾收集</li>
<li>G1 会跟踪各个 Region 中的<strong>垃圾堆积的价值</strong>（所获得的空间大小以及回收所需时间的经验值），在后台维护一个<strong>优先级列表</strong>，每次根据用户设定允许的收集停顿时间优先处理回收价值收益最大的那些 Region</li>
<li>Region 被视作单次回收的最小单元，每次回收收集到的内存空间都是 Region 的整数倍，可以有计划地避免在整个 Java 堆中进行 Full GC，基于优先级的 Region 区域回收也保证了 G1 在有限的时间内获取尽可能高的收集效率</li>
<li>对于跨 Region 的对象引用可以通过记忆集避免非收集区域的扫描，<strong>G1 的每个 Region 都维护有自己的记忆集</strong>，G1 的记忆集在存储结构的本质上是一种哈希表，Key 是别的 Region 的起始地址，Value 是一个存储卡表索引号的集合，这种不仅包含我指向谁还包含谁指向我的双向的卡表结构更加复杂，也占用更多内存（大约堆容量的 10% ~ 20%）</li>
<li>G1 将垃圾收集过程分为四个步骤<ul>
<li><strong>初始标记</strong>，标记 GC Roots 能直接关联到的对象，需要暂停其他所有用户线程，耗时很短，而且是借用进行 Minor GC 的时候同步完成的，所以这个阶段实际并没有额外的停顿</li>
<li><strong>并发标记</strong>，从 GC Roots 的直接关联对象开始遍历整个对象图（三色标记），耗时长，与用户线程一起并发工作，基于原始快照实现并发标记</li>
<li><strong>最终标记</strong>，处理并发阶段结束后仍遗留下来的少量需要重新标记的记录，多个垃圾收集线程并行工作，需要暂停其他所有用户线程</li>
<li><strong>筛选回收</strong>，更新 Region 的统计数据，对各个 Region 的回收价值和成本进行排序，根据用户所期望的停顿时间来制定回收计划，选择多个 Region 构成回收集，将回收集中存活的对象复制到空的 Region 中，再清理掉回收集中所有的旧 Region，多个垃圾收集线程并行工作，需要暂停其他所有用户线程</li>
</ul>
</li>
<li>G1 整体上看是 Mark-Compact，但从局部（两个 Region 之间）上看是 Mark-Sweep，这意味着 G1 运作期间既不会像 Mark-Sweep 那样产生内存空间碎片，又不至于像 Mark-Compact 那样让垃圾收集成为极为负重的操作</li>
<li>从 G1 开始，垃圾收集器的设计导向都变为追求内存收集速度能赶上应用的内存分配速率即可，并不追求一次把整个 Java 堆全部清理干净</li>
</ul>
</li>
</ul>
<h3 id="2-2-4-高性能收集器"><a href="#2-2-4-高性能收集器" class="headerlink" title="2.2.4 高性能收集器"></a>2.2.4 高性能收集器</h3><p>衡量垃圾收集器的重要指标是内存占用、吞吐量和延迟，要在这三个方面的性能指标同时表现完美的收集器是极其困难甚至是不可能的，在执行效果上有革命性改进的实验状态的高性能垃圾收集器最多可以同时达成其中的两项。随着硬件性能日益增长，内存空间逐渐增大，收集器运行时对应用程序的影响会逐渐降低，即应用程序的吞吐量会更高，但是延迟时间反而会增大，因此延迟逐渐成为垃圾收集器最重视的性能指标，高性能垃圾收集器至少应做到低延迟，举例如下</p>
<ul>
<li>Shenandoah<ul>
<li>几乎整个工作过程全部都是并发的，只有初始标记和最终标记阶段有短暂的暂停用户线程（停顿时间基本固定，与堆容量没有正比例关系），目标是实现一种能在任何堆内存大小都可以把停顿时间限制在十毫秒以内的垃圾收集器<strong>，以用户程序吞吐量下降为代价实现了用户程序低延迟时间</strong></li>
<li>Shenandoah 将垃圾收集过程分为九个步骤<ul>
<li><strong>初始标记</strong>、<strong>并发标记</strong>以及<strong>最终标记</strong>都与 G1 一样</li>
<li><strong>并发清理</strong>用于清理那些对象全部无法存活的 Region，与用户线程一起并发工作</li>
<li><strong>并发回收</strong>，把回收集中的存活对象先复制一份到其他未被使用的 Region 之中，<strong>与用户线程一起并发工作（通过 CAS 来保证并发正确性）</strong>，运行时间取决于回收集的大小，是 Shenandoah 的核心概念</li>
<li><strong>初始引用更新</strong>，将堆中所有指向对象被复制前的旧地址引用修正到复制后的新地址，时间很短，会产生一个非常短暂的用户线程停顿</li>
<li><strong>并发引用更新</strong>，按照内存物理地址的顺序线性地搜索出堆中的引用类型，把旧值改为新值，与用户线程一起并发工作，运行时间取决于内存中涉及的引用数量的多少</li>
<li><strong>最终引用更新</strong>，修正存在于 GC Roots 中的引用，时间很短，会产生一个非常短暂的用户线程停顿，停顿时间只与 GC Roots 的数量有关</li>
<li><strong>并发清理</strong>，此时整个回收集中所有的 Region 已再无存活的对象，最后再重新执行一次并发清理来回收整个回收集</li>
</ul>
</li>
<li>Shenandoah 很多思路都与 G1 高度一致，区别在于 Shenandoah <strong>支持与用户线程并发进行的回收</strong>，Region 不再有不同分代角色，摒弃了耗费大量内存和资源去维护的哈希表记忆集，而是改用连接矩阵这一全局数据结构来记录跨 Region 的引用关系，并对并发失败后的 Full GC 提供了多线程支持</li>
</ul>
</li>
<li>ZGC<ul>
<li>几乎整个工作过程全部都是并发的，只有初始标记和最终标记阶段有短暂的暂停用户线程（暂停时间基本固定，与对容量没有正比例关系），目标是实现一种能在任何堆内存大小都可以把停顿时间限制在十毫秒以内的垃圾收集器<strong>，以并发的垃圾收集时间延长为代价实现了用户程序低延迟时间</strong></li>
<li>ZGC 也采用基于 Region 的堆内存布局，区别在于 ZGC 的 Region 具有动态创建和销毁的特性，分为大中小三类具备不同容量的 Region，分别用于放置不同大小等级的对象，其中小型和中型 Region 的容量是固定的，而大型 Region 的容量是可以动态变化的</li>
<li>ZGC 使用<strong>染色指针</strong>（标记信息存储在引用对象的指针上而不是存储在对象上）技术（需要操作系统的支持），JVM 可以直接从指针中看到其引用对象的三色标记状态、是否进入了重分配集（即被并发的用户线程移动过）、是否只能通过 finalize 方法才能被访问到等信息，染色指针使得一旦某个 Region 的存活对象被移走之后，这个 Region 立即就能够被释放和重用</li>
<li>ZGC 将垃圾收集过程分为六个步骤<ul>
<li><strong>初始标记</strong>、<strong>并发标记</strong>以及<strong>最终标记</strong>都与 G1 和 Shenandoah 一样，区别在于 ZGC 的标记是在指针上而不是在对象上进行的</li>
<li><strong>并发预备重分配</strong>，会扫描所有的 Region，根据特定的条件统计得出哪些 Region 需要清理，这些 Region 组成重分配集（不同于之前的回收集）</li>
<li><strong>并发重分配</strong>，将重分配集中的存活对象重新复制到其他新的 Region 中，并未重分配集中的每个 Region 维护一个记录了从旧地址到新地址的转向关系的转发表，重分配集中的 Region 会被释放，并发运行的用户线程只需从引用上就能明确得知一个对象是否处于重分配集中，在访问处于重分配集中的对象时则根据转发表访问到新地址（称为<strong>指针自愈</strong>），只有第一次访问会慢一些，后面就正常，因此对于用户线程的影响要比 Shenandoah 更低</li>
<li><strong>并发重映射</strong>，修正整个堆中指向重分配集中的对象旧地址的所有引用，这一步的目的是为了不变慢以及结束后可以释放转发表，但由于旧地址引用是可以在被用户线程访问时自愈的，所以并不是一个必须要迫切完成的任务，可以将这一步合并到下一次垃圾收集的并发标记阶段里去完成</li>
</ul>
</li>
<li>ZGC 的整个垃圾收集过程都是与用户线程并发的，这会产生大量的浮动垃圾，进而导致并发收集周期会很长，如果回收速度赶不上分配速度就会导致内存溢出</li>
</ul>
</li>
<li>Epsilon<ul>
<li>Epsilon 不仅仅是一个垃圾收集器，而是自动内存管理子系统，除了垃圾收集以外，还负责堆的管理与布局，对象的分配，与解释器、编译器、监控子系统协作等职责</li>
<li>Epsilon 的目标是服务于那种只运行数分钟甚至数秒的应用，只要 JVM 能够正确分配内存，在堆耗尽之前就早已退出，运行负载极小、没有任何回收行为的 Epsilon 就是很恰当的选择</li>
</ul>
</li>
</ul>
<h1 id="X、参考资料"><a href="#X、参考资料" class="headerlink" title="X、参考资料"></a>X、参考资料</h1><ul>
<li>《Understanding the JVM, Advanced Features and Best Practices, Third Edition》</li>
</ul>
</section>
    <!-- Tags START -->
    
    <!-- Tags END -->
    <!-- NAV START -->
    
  <div class="nav-container">
    <!-- reverse left and right to put prev and next in a more logic postition -->
    
      <a class="nav-left" href="/2023/11/06/computer-networking/">
        <span class="nav-arrow">← </span>
        
          Computer Networking
        
      </a>
    
    
  </div>

    <!-- NAV END -->
    <!-- 打赏 START -->
    
    <!-- 打赏 END -->
    <!-- 二维码 START -->
    
    <!-- 二维码 END -->
    
      <!-- Utterances START -->
      <div id="utterances"></div>
      <script src="https://utteranc.es/client.js"
        repo=""
        issue-term="pathname"
        theme="github-light"
        crossorigin="anonymous"
        async></script>    
      <!-- Utterances END -->
    
  </article>
  <!-- Article END -->
  <!-- Content START -->
  
    <aside class="content-container">
  <div class="toc-main">
  
      
          <strong class="toc-title">CONTENT</strong>
          <ol class="toc-nav"><li class="toc-nav-item toc-nav-level-1"><a class="toc-nav-link" href="#1%E3%80%81%E5%BC%95%E8%A8%80"><span class="toc-nav-text">1、引言</span></a></li><li class="toc-nav-item toc-nav-level-1"><a class="toc-nav-link" href="#2%E3%80%81%E8%87%AA%E5%8A%A8%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86"><span class="toc-nav-text">2、自动内存管理</span></a><ol class="toc-nav-child"><li class="toc-nav-item toc-nav-level-2"><a class="toc-nav-link" href="#2-1-%E5%86%85%E5%AD%98%E4%BD%BF%E7%94%A8"><span class="toc-nav-text">2.1 内存使用</span></a><ol class="toc-nav-child"><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#2-1-1-%E5%86%85%E5%AD%98%E5%88%86%E5%8C%BA"><span class="toc-nav-text">2.1.1 内存分区</span></a></li><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#2-1-2-%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D"><span class="toc-nav-text">2.1.2 内存分配</span></a></li></ol></li><li class="toc-nav-item toc-nav-level-2"><a class="toc-nav-link" href="#2-2-%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86"><span class="toc-nav-text">2.2 垃圾收集</span></a><ol class="toc-nav-child"><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#2-2-1-%E5%9B%9E%E6%94%B6%E6%9D%A1%E4%BB%B6"><span class="toc-nav-text">2.2.1 回收条件</span></a></li><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#2-2-2-%E6%94%B6%E9%9B%86%E7%AE%97%E6%B3%95"><span class="toc-nav-text">2.2.2 收集算法</span></a></li><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#2-2-3-%E7%BB%8F%E5%85%B8%E6%94%B6%E9%9B%86%E5%99%A8"><span class="toc-nav-text">2.2.3 经典收集器</span></a></li><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#2-2-4-%E9%AB%98%E6%80%A7%E8%83%BD%E6%94%B6%E9%9B%86%E5%99%A8"><span class="toc-nav-text">2.2.4 高性能收集器</span></a></li></ol></li></ol></li><li class="toc-nav-item toc-nav-level-1"><a class="toc-nav-link" href="#X%E3%80%81%E5%8F%82%E8%80%83%E8%B5%84%E6%96%99"><span class="toc-nav-text">X、参考资料</span></a></li></ol>
      
  
  </div>
</aside>
  
  <!-- Content END -->
</main>

<script>
  (function () {
    var url = 'http://example.com/2023/12/09/java-virtual-machine/';
    var banner = ''
    if (banner !== '' && banner !== 'undefined' && banner !== 'null') {
      $('#article-banner').css({
        'background-image': 'url(' + banner + ')'
      })
    } else {
      $('#article-banner').geopattern(url)
    }
    $('.header').removeClass('fixed-header')

    // error image
    $(".markdown-content img").on('error', function() {
      $(this).attr('src', '/css/images/error_icon.png')
      $(this).css({
        'cursor': 'default'
      })
    })

    // zoom image
    $(".markdown-content img").on('click', function() {
      var src = $(this).attr('src')
      if (src !== '/css/images/error_icon.png') {
        var imageW = $(this).width()
        var imageH = $(this).height()

        var zoom = ($(window).width() * 0.95 / imageW).toFixed(2)
        zoom = zoom < 1 ? 1 : zoom
        zoom = zoom > 2 ? 2 : zoom
        var transY = (($(window).height() - imageH) / 2).toFixed(2)

        $('body').append('<div class="image-view-wrap"><div class="image-view-inner"><img src="'+ src +'" /></div></div>')
        $('.image-view-wrap').addClass('wrap-active')
        $('.image-view-wrap img').css({
          'width': `${imageW}`,
          'transform': `translate3d(0, ${transY}px, 0) scale3d(${zoom}, ${zoom}, 1)`
        })
        $('html').css('overflow', 'hidden')

        $('.image-view-wrap').on('click', function() {
          $(this).remove()
          $('html').attr('style', '')
        })
      }
    })
  })();
</script>







    <div class="scroll-top">
  <span class="arrow-icon"></span>
</div>
    <!--
<footer class="app-footer">
  <p class="copyright">
    &copy; 2023 | Proudly powered by <a href="https://hexo.io" target="_blank">Hexo</a>
    <br>
    Theme by <a target="_blank" rel="noopener" href="https://github.com/yanm1ng">yanm1ng</a>
    
  </p>
</footer>
-->

<script>
  function async(u, c) {
    var d = document, t = 'script',
      o = d.createElement(t),
      s = d.getElementsByTagName(t)[0];
    o.src = u;
    if (c) { o.addEventListener('load', function (e) { c(null, e); }, false); }
    s.parentNode.insertBefore(o, s);
  }
</script>
<script>
  async("//cdnjs.cloudflare.com/ajax/libs/fastclick/1.0.6/fastclick.min.js", function(){
    FastClick.attach(document.body);
  })
</script>

<script>
  var hasLine = 'true';
  async("//cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/highlight.min.js", function(){
    $('figure pre').each(function(i, block) {
      var figure = $(this).parents('figure');
      if (hasLine === 'false') {
        figure.find('.gutter').hide();
      }
      hljs.configure({useBR: true});
      var lang = figure.attr('class').split(' ')[1] || 'code';
      var codeHtml = $(this).html();
      var codeTag = document.createElement('code');
      codeTag.className = lang;
      codeTag.innerHTML = codeHtml;
      $(this).attr('class', '').empty().html(codeTag);
      figure.attr('data-lang', lang.toUpperCase());
      hljs.highlightBlock(block);
    });
  })
</script>
<!-- Baidu Tongji -->


<script src="/js/script.js"></script>


  </body>
</html>
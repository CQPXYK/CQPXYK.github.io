---
title: 2023.4.3 - 2023.4.7
date: 2023-04-07 21:35:56
password: 1062597351
tags:
---

> - 工作相关：Upstream data extracts（异步分批 DML、错误记录和邮件通知、维护历史表记录、需求思维）
> - 博客更新：[Java Language](../../../../2022/05/08/java-language/)

这周根据上周做的 PPT 和各位 lead 进行了 tech review，收到了一些改进建议，现记录部分如下。

### 异步分批 DML

当需要执行 DML 操作进行落库的数据集较大，执行时间较长时，考虑将数据集分为多个小型数据集，异步分批多次 commit 来进行落库，节省时间也降低风险，这一实现使用了`@Async`注解，注意事项如下

- 用`@Async`标注的Bean方法将在单独的线程中执行，即方法调用方将不等待该`@Async`方法的完成

- 要使用`@Async`则需要在配置类上标注`@EnableAsync`，从而启用`@Async`

- `@Async`只能用于`public`方法，且不能自调用（同一类中调用），和`@Transactional`同理

- 当没有使用`Future.get`方法来获取`@Async`方法的返回值时，`@Async`方法中抛出的异常将不会传播到调用线程，不会被调用线程的异常处理 handler 捕获，为了进行`@Async`方法的异常处理，需要提供一个`AsyncUncaughtExceptionHandler `的实现类并在配置类中重写`getAsyncUncaughtExceptionHandler`方法使其返回`AsyncUncaughtExceptionHandler `的实现类

- `@Async`方法是循环使用某个线程池中的线程，数量有限，要注意如果存在某个`@Async`方法无法在有限时间内结束导致线程一直被占用，进而导致后面的任务无法执行的问题

  

使用异步不仅仅是为了快速执行 DML，其实是希望从根本上将 DML 操作完全交由给子线程去执行，主线程可以直接返回，避免 AutoSys Job 长时间阻塞，此时带来两个问题

- 对于一些异步执行但又存在执行先后的顺序的逻辑，则通过轮询（注意出现死循环）和并发计数器的方式来保证执行先后顺序，感觉 [同步器和并发锁](../../../../2022/05/08/java-concurrency/) 更适用于比较复杂的多线程协调工作，而这里只需简单保证线程的依次执行顺序即可，简单的设置标志位变量进行轮询即可
- 对于 AutoSys Job 和直接返回的主线程来说，无法得知那些异步执行的逻辑后续是否执行成功，所以还需要某种机制来记录和通知异步任务的执行情况，见下文

### 错误记录和邮件通知

AutoSys Job 使用简单，但功能存在局限，比如无法设置为异步地去执行任务，只能同步执行，比如无法返回所调用的脚本或者 API 的执行信息，尤其是错误信息的缺失，再加上 AutoSys Job 每次新起一个 Pod 都会 kill 掉原本的 Pod，如果上一个 Pod 运行过程中存在错误，这意味着错误信息将彻底丢失，不利于排查问题。

虽然 AutoSys 功能存在局限，但依旧可以用其他方式来弥补，问题总是有解决办法的。正如上文**异步分批 DML**中所说，异步可以直接在 API 中实现，而脚本和 API 的执行相关的信息则可以增加邮件通知功能（成功通知和失败通知），并将比较重要的错误信息插入到 Event Log 表中，这种错误记录加上邮件通知的处理方式就能比较方便的追踪和排查问题。

关于邮件通知的触发是通过切面来实现的，在被拦截方法执行之后根据方法的执行情况判断需要触发何种类型的邮件通知。其实一开始我想到的思路是观察者模式，但是由于这里观察者 Observer 只有邮件通知 Service 这一个而已，那么直接使用切面并在切面代码中调用邮件通知 Service 即可，感觉观察者模式应该更适用于存在多个被观察者和多个观察者这种多对多的复杂情况。

### 维护历史表记录

更新 Reference 表的同时，希望再更新维护一个 History 表，用以记录对 Reference 表的所有 DML 操作信息，两种实现方式，一种是对 Reference 表加一个触发器，另一种是在 Java 代码中通过切面来同时更新 Reference 表和 History 表。

考虑到在 History 表中数据逐渐增大的过程中，DML（其实只有增操作）会越来越慢，如果使用触发器来进行 History 表的 DML 则会影响 Reference 表（增删改都有，主要是改操作）的 DML 效率，因此还是由 Java 代码来实现，对 History 表的 DML 不会影响 Reference 表的 DML。

注意：

- Oracle 的 Varchar 类型只有`null`和非`null`，没有空字符串，但是在 Java 代码中`null`和`""`是不相等，所以进行新数据和老数据的比较时需要注意

- `@Transactional`注解所标注的方法会在方法抛出异常时回滚 DML，即便方法本地没有抛出异常，但拦截该方法的切面代码中抛出了异常，依旧会导致回滚

- 对历史表的维护以及邮件通知等操作无论是否抛出异常，都不应导致对 Ref 表的 DML 回滚，所以我在历史表维护和邮件通知的切面类上加了`@Async`注解来新起一个线程，避免异常传播到执行 Ref 表 DML 的线程

  

### 需求思维

需要落库的上游数据集很大，也无法确保数据集中的数据本身是否存在问题，自己刚开始做 POC 的时候倾向于比较简单的处理方式，在处理上游数据集时，对于非阻塞性的数据问题直接跳过，阻塞性的数据问题直接抛出异常并提前结束，在开会讨论时被同事提醒不应该这样做。

- 首先不管是否是阻塞性的数据问题，问题多少，都应当事无巨细地记录下来，通过邮件或者数据库的方式留存关于数据集的问题记录，这样才便于在出现业务问题时追踪原因
- 其次不管是否存在数据问题，问题大小，都不应该简单粗暴的直接抛出异常，不应该中断后续对其他数据的处理，才能尽可能减少对业务的影响范围和程度（凡是能够预判出的可能存在的问题，都应当进行相应的处理，而非仅仅是抛出异常）
- 简单没有错，但应当追求的简单的方案，而非简单的功能，理想状态是为复杂强大的功能设计出简单高效的方案。

### 参考资料

- https://jishu.dev/2021/03/17/spring-async/
- https://gist.github.com/joaopedroleiteslisboa/1eed602bc4ca0884d10d79e508f537f1




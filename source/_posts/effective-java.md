---
title: Effective Java
date: 2022-05-06 17:19:56
tags:
---

# 1、引言

仅仅学会语言的结构及如何使用是不够的，还需要学习如何以**惯用和高效的方式**来表达；仅仅编写出能够有效工作能够被别人理解的代码是不够的，还必须把代码组织成**易于修改的形式**。本书关心如何编写出**清晰、正确、可用、健壮、灵活和可维护的程序**。

注：

- 本书中所使用的术语“组件（Component）”指任何可重用的软件元素，从单个方法到包含多个包的复杂框架；

- 本书中所使用的术语“API元素”是指类、接口、构造器、成员和序列化形式，程序员可以通过API访问类、接口或者包；

- 本书中所使用的术语“继承”指实现继承（一个类扩展另一个类），不适用于接口继承（一个类实现一个接口，或者一个接口扩展另一个接口）。

# 2、创建和销毁对象

## 2.1 静态工厂方法代替构造器（1）

与公有构造器相比，静态工厂方法的优势在于：

- 静态工厂方法有更能表达方法实际意义的名称，能通过命名合适的不同名称来实现多个相同参数列表的方法；

- 静态工厂方法不必在每次调用时都创建一个新对象，可以重复利用已经构建好的实例，也有助于类严格控制哪些实例应该存在；

- 静态工厂方法可以返回原类型的任何子类型的对象，则API可以通过静态工厂方法返回非公有类的对象，适用于基于接口的框架；

- 静态工厂方法所返回的对象所属的类，在编写该静态工厂方法时可以不存在。

静态工厂方法的劣势在于：

- 类如果不含有`public`或者`protected`的构造器，就不能被子类化，但这另一方面也鼓励了程序员使用复合而不是继承；

- 程序员难以发现静态工厂方法，API文档中没有明确标注出来；

## 2.2 存在多个构造器参数时使用生成器（2）

静态工厂方法和构造器都不能很好地扩展到大量可选参数，面对存在多个构造器参数的情况，有以下几种解决方式：

- 重叠构造器模式，但此时客户端代码难以编写和阅读；

- JavaBean模式，但在构造过程中无法保证JavaBean的一致性，无法实现不可变类，需要额外开销来确保线程安全；

- 生成器模式（Builder），它可以有多个可变参数，既能保证像重叠构造器那样的安全性，也能保证像JavaBean模式那么好的可读性，此外Builder模式也适用于类层次结构。

## 2.3 通过枚举类型强化Singleton属性（3）

当构造器设为私有时，可以通过`final`变量或者静态工厂可以实现Singleton，这种方式有两个问题需要注意：

- 享有特权的客户端可以通过反射机制调用私有构造器，为了抵御这种攻击，可以令构造器在创建第二个实例时抛出异常；

- 需要通过`implements Serializable`实现可序列化，但每次反序列化一个序列化的实例时依旧会创建一个新的实例，为了防止这种情况，需要在Singleton类中增加一个`readResolve`方法。

```java
private Object readResolve () {
    return INSTANCE;
}
```

除此以上实现Singleton的方式，还可以通过声明一个包含单个枚举元素的枚举类型来实现Singleton：

- 这种方式更加简洁，无偿地提供了序列化机制，即使是在面对复杂的序列化或者反射攻击时，也绝对防止多次实例化；

- 如果Singleton类必须扩展一个超类，而不是扩展`Enum`时，不宜使用这种方法。

## 2.4 通过私有构造器强化不可实例化的能力（4）

- 一个静态工具类只包含静态方法和静态域，这种类不希望被实例化；

- 当一个类缺少显示构造器时，编译器会自动提供一个公有的无参缺省构造器，此时这个类是可以被实例化的。因此，只要让类包含一个私有构造器且该私有构造器一旦被调用就抛出异常，就能确保这个类不可被实例化；

- 这种做法的副作用是该类不可被子类化（子类都会显示或者隐式地调用超类的构造器）。

## 2.5 优先考虑依赖注入来引用资源（5）

- 不要使用Singleton类和静态工具类来实现需要引用底层资源的类，而是应该将资源或者资源工厂以依赖注入的方式传递给构造器或者静态工厂或者生成器，从而创建出需要引用资源的类；

- 过多的手动编写的依赖注入会导致大型项目凌乱不堪，不过这种凌乱可以通过依赖注入框架（比如Spring）得到解决。

## 2.6 避免创建不必要的对象（6）

- 对于同时提供了静态工厂方法和构造器的不可变类，通常优先使用静态工厂方法；
- 如果需要重复的使用一些创建成本高的对象，可将该对象缓存起来重用；
- 优先使用基本类型而不是装箱基本类型，注意无意识的自动装箱；
- 并不是所有情况下都避免创建不必要的对象，要妥善权衡创建新对象的代价和维护单一对象的代价孰轻孰重。

## 2.7 消除过期的对象引用（7）

### 2.7.1 消除过期引用的方法

虽然Java语言具备垃圾回收功能，但程序员依旧需要考虑内存管理问题，比如消除过期的对象引用（过期引用指永远也不会被解除的引用）。消除过期引用最好的方法是让包含该引用的变量结束其生命周期，故应当在最紧凑的作用域范围内定义每一个变量。

### 2.7.2 消除过期引用的好处

- 如果过期引用被无意识的保留下来，那么垃圾收回不仅不会处理这个对象，也不会处理被这个对象所引用的所有其他对象。当这个对象被排除在垃圾回收机制之外，就会造成内存泄漏。这种问题的修复方法就是**一旦对象引用过期，就立即消除这个引用**；

- 如果过期引用以后又被错误的解除引用，程序会立即抛出空指针异常，而不是悄悄地错误运行下去。

### 2.7.3 内存泄漏的发生

内存泄漏的发生有以下几种来源：

- 自己管理内存的类（比如`Stack`类）；

- 缓存（考虑用一个后台线程定期清理）；

- 监听器和其他回调（确保回调立即被当做垃圾回收的最佳方法是只保存它们的弱引用）。

## 2.8 避免使用终结方法和清除方法（8）

终结方法（`finalizer`）和清除方法（`cleaner`）的缺点在于：

- 不能被保证及时执行，从一个对象变得不可达到其终结方法被执行这段时间是任意长的，可能会随意地延迟对象的回收过程，一些重要操作无法及时执行，同时也带来时间性能上的损失；

- 正常情况下，未捕获的异常将会使线程终止，并打印出栈轨迹，但如果异常发生在终结方法中，则不会如此，甚至不会有警告打印出来。

因此，当对象中封装的资源确实需要终止时，可以让类实现`AutoCloseable`，并要求客户端在每个实例不再需要时调用`close`方法。

`finalizer`和`cleaner`的优点在于：

- 当资源所有者忘记调用`close`方法时，`finalizer`和`cleaner`可以充当“安全网”（不一定释放资源总比一定不释放要好）；

- 空的`finalizer`方法可以避免恶意子类的攻击；

- `cleaner`方法适用于清除没有关键资源的本地对等体。

## 2.9 try-with-resources优先于try-finally（9）

`try-finally`语句的不足在于：

- 客户端不一定记得编写`finally`块来释放资源，而充当“安全网”的`finalizer`和`cleaner`方法并不可靠；

- 当`finally`中发生异常时，`finally`中的异常会抹除`try`中发生的异常，在异常轨迹中完全没有`try`中异常的记录。

`try-with-resources`语句可以有效地避免以上问题，且代码更加简洁清晰。

# 3、对于所有对象都通用的方法

任何类在覆盖`Object`类的非`final`方法时都要遵守通用的约定，否则就无法与其他遵守约定的类一起正常工作。

## 3.1 覆盖equals方法（10）

### 3.1.1 何时覆盖

不覆盖`equals`方法时，类的每个实例只与它自身相等，在满足以下任一情况时，不需要覆盖`equals`方法：

1）类的每个实例本质上都是唯一的；

2）类无需提供“逻辑相等”（不同于对象相等）的测试功能；

3）超类已经覆盖了`equals`，且超类的行为对这个类也是适用的；

4）类是私有的或者包级私有的，可以确保类的`equals`方法永远不会被调用。

当以上情况均不满足时，就需要覆盖`equals`方法，此时一般对应非单例的值类（一个表示值的类）

### 3.1.2 如何覆盖

覆盖`equals`方法时有以下约定：

1）自反性（reflexive）：对于任何非`null`的引用值`x`，`x.equals(x) = true`；

2）对称性（symmetric）：对于任何非`null`的引用值`x`和`y`，`x.equals(y) == y.equals(x)`；

3）传递性（transitive）：对于任何非`null`的引用值`x`、`y`和`z`，如果`x.equals(y) = true`且`y.equals(z) = true`，则`x.equals(z) = true`；

4）一致性（consistent）：对于任何非`null`的引用值`x`和`y`，只要`x`和`y`的值没有被修改，则`x.equals(y)`的返回值始终保持一致；

5）对于任何非null的引用值`x`，`x.equals(null) = false`。

### 3.1.3 高质量覆盖

对于`XXX`类的`equals(Object o)`方法，可按照以下步骤实现高质量的`equals`方法覆盖：

1）`if (o == this) return true;`

2）`if (!(o instanceof XXX)) return false;`

3）`XXX x = (XXX) o;`

4）对于`XXX`类中的每个域，检查参数中的域是否与`this`中对应的域相匹配域；

5）对于非`float`且非`double`的基本类型域，使用`==`操作符进行比较；对于引用类型域，可以递归地调用`equals`方法；对于`float`域，可以使用`Float.compare`方法进行比较；对于`double`域，使用`Double.compare`方法进行比较。

### 3.1.4 注意事项

1）在扩展可实例化的类时，无法同时增加新的值组件又保留`equals`约定；

2）与其扩展可实例化的类得到新类，不如将该可实例化的类作为一个私有域放入新类中（并提供一个视图方法返回该私有域），即复合优于继承；

3）可以在一个抽象类的子类中增加新的值组件且不违反`equals`约定；

4）不要使`equals`方法依赖于不可靠的资源；

5）域的比较顺序会影响`equals`方法的性能，应最先比较最有可能不一致的域或者是开销最低的域；

6）覆盖`equals`时总要覆盖`hashCode`；

7）不要重载`equals`；

8）让IDE或者框架自动生成`equals`和`hashCode`通常优于手工实现。

## 3.2 覆盖hashCode方法（11）

### 3.2.1 何时及如何覆盖

覆盖`equals`时总要覆盖`hashCode`，覆盖`hashCode`方法时有以下约定：

1）在应用程序执行期间，只要对象的`equals`方法的比较操作所用到的信息没有被修改，则该对象的`hashCode`方法的返回值保持一致；

2）在一个应用程序与另一个程序的执行过程中，执行`hashCode`方法的返回值可以不一致；

3）如果两个对象根据`equals`比较结果是相等的，则这两个对象的`hashCode`方法的返回值也必须相等；

4）如果两个对象根据`equals`比较结果是不相等的，则这两个对象的`hashCode`方法的返回值不要求必须不相等（但对于不相等的对象产生不相等的散列值有助于提高散列表的性能）。

### 3.2.2 高质量覆盖

一个好的散列表应该把集合中不相等的实例均匀地分布到所有可能的`int`值上，可按照以下步骤来大致实现：

1）对对象中的每一个关键域都计算其散列码（关键域指会影响`equals`比较的域）；

2）基本类型的散列码为其装箱类型的散列码，值为`null`的引用类型的散列码为0（或者其他某个常数，但通常是零），数组中的每一个元素都要当做单独的域来计算其散列码；

3）声明一个`int`变量命名为`result`，并初始化为对象中的第一个关键域的散列码c；

4）将对象中所有域计算得到的散列码c整合到`result = 31 * result + c`中，最终得到的`result`即为对象的散列码。

### 3.2.3 注意事项

在散列码的计算过程中：

1）不要排除任何关键域的散列码来提升计算性能；

2）可以排除衍生域的散列码（衍生域指可以由其他域值计算得到的域）；

3）必须排除`equals`比较中没有用到的任何域的散列码；

4）乘数选择31是因为它是一个奇素数，如果乘数是偶数且乘法溢出时，信息会丢失，31有个很好的特性在于现代虚拟机可以自动用移位和减法来代替乘法`31 * i == (i << 5) - i`，从而获得更好的性能；

5）如果一个类是不可变的，且计算散列码的开销较大，则应该将散列码缓存在对象内部；

6）可以让IDE或者框架自动生成`hashCode`。

## 3.3 覆盖toString方法（12）

### 3.3.1 何时及如何覆盖

`Object`方法提供的`toString`方法返回的是`类的名称@散列码的无符号十六进制`，`toString`方法的通用约定要求：

1）被返回的字符串应当是一个简洁的但信息丰富、易于阅读的表达形式；

2）所有类都应该覆盖`toString`方法。

### 3.3.2 高质量覆盖

提供好的`toString`方法可以使类使用起来更加舒适，使用了这个类的系统也更加易于调试。

1）在实际应用中，`toString`方法应返回对象中包含的所有值得关注的信息；

2）指定`toString`方法的返回值的格式使得它可以被用作一种标准的、明确的、适合人阅读的对象表示法；

3）一旦指定格式，就必须始终如一地坚持这种格式，程序员可以解析和产生这种格式的字符串并嵌入持久的数据中；

4）如果不指定格式，就可以保留灵活性，便于在将来发行版本中增加信息，或者改进格式。

### 3.3.3 注意事项

1）无论是否指定格式，都应该在文档中明确地表明你的意图；

2）不要在不可实例化的静态工具类以及枚举类型中编写`toString`方法；

3）在子类共享通过字符串表示法的抽象类中一定要编写`toString`方法；

4）在每一个可实例化的类中覆盖`toString`方法，除非已经在超类中覆盖了；

5）可以让IDE或者框架自动生成`toString`。

## 3.4 覆盖clone方法（13）

### 3.4.1 何时及如何覆盖

`Cloneable`接口并没有包含任何方法，但如果一个类实现了`Cloneable`接口，类的`clone`方法就返回该对象的逐域拷贝。也就是说：类实现`Cloneable`接口是为了提供一个功能适当的公有的`clone`方法，表明这个类的对象允许克隆。

覆盖`clone`方法时有以下约定：

1）对于任何对象`x`，表达式`x.clone() != x`，`x.clone().getClass() == x.getClass()`，`x.clone().equals(x)`均返回true，但这也不是一个绝对的要求；

2）`clone`方法返回的对象应该不依赖于被克隆的对象，应该通过调用`super.clone`获得。

### 3.4.2 高质量覆盖

1）类声明为实现`Cloneable`接口；

2）使用`try-catch`语句执行整个克隆过程；

3）调用`super.clone`并将返回类型转换为当前类；

4）逐项拷贝对象中的所有域，可以i）递归调用`clone`或者ii）深度拷贝或者iii）先将域设置成初始状态，然后调用高层的方法来重新产生对象的状态；

5）对于代表序列号或者其他唯一ID值的域需要修正域值。

### 3.4.3 注意事项

1）不可变的类永远都不要提供`clone`方法；

2）必须确保`clone`方法（另一个构造器）不会伤害到原始的对象；

3）确保能正确地创建被克隆对象的约束条件；

4）数组是`clone`方法唯一吸引人的用法；

5）在克隆对象时，需要从某些域中去掉`final`修饰符；

6）`clone`方法不能在构造的过程中调用可以覆盖的方法；

7）`Object`中的`clone`方法是受保护的，子类覆盖的`clone`方法是公有的；

8）公有`clone`方法不应有抛出异常的`throws`声明；

9）在编程线程安全的类时，应用`synchronized`修饰`clone`方法。

### 3.4.4 clone的代替

与其实现`Cloneable`接口并覆盖`clone`方法，不如使用拷贝构造器或者拷贝工厂，其优势在于：

1）不依赖于一种很有风险的、语言之外的对象创建机制；

2）不要求遵守尚未制定好的文档的规范；

3）不会与`final`域的正常使用发生冲突；

4）不会抛出不必要的受检异常；

5）不需要进行类型转换

6）可以通过传入参数来选择希望拷贝成何种类型的对象。

因此，**除了拷贝数组时使用`clone`方法，拷贝其他对象最好使用拷贝构造器或者拷贝工厂**。

## 3.5 实现Comparable接口（14）

### 3.5.1 何时及如何实现

`Comparable`接口中只有一个`compareTo`方法（不是`Object`类的方法），`compareTo`方法不但允许等同性比较，还允许执行顺序比较。类实现`Comparable`接口就表明该类的实例具有内在的排序关系。

覆盖`compareTo`方法时有以下约定：

1）当前对象小于、等于或大于指定对象时，`compareTo`分别返回一个负整数、零和正整数；

2）所有的`x`和`y`都满足当`x.compareTo(y)`抛出异常时`y.compareTo(x)`也抛出异常，当不抛出异常时`sgn(x.compareTo(y)) == -sgn(y.compareTo(x))`；

3）当`x.compareTo(y) > 0`且`y.compareTo(z) > 0`时，`x.compareTo(z) > 0`；

4）当`x.compareTo(y) == 0`时，`sgn(x.compareTo(z)) == sgn(y.compareTo(z))`；

5）建议`(x.compareTo(y) == 0) == (x.equals(y))`，但这并非绝对必要，当这个条件不满足时，应给出明确说明。

在覆盖`compareTo`方法时，应**依次从最关键的域开始比较**，逐步进行到所有的重要域。

### 3.5.2 注意事项

1）`compareTo`不能跨越不同类型进行比较，如果当前对象与指定对象无法进行比较，则抛出异常；

2）所有值类和所有的枚举类型都实现了`Comparable`接口；

3）依赖于比较关系的类包括有序集合类`TreeSet`和`TreeMap`以及工具类`Collections`和`Arrays`，它们内部包含有搜索和排序算法；

4）在扩展可实例化的类时，无法同时增加新的值组件又保留`compareTo`约定；

5）与其扩展可实例化的类得到新类，不如将该可实例化的类作为一个私有域放入新类中（并提供一个视图方法返回该私有域），即复合优于继承；

6）比较域值时，不要使用关系操作符`<`和`>`；

7）对于基本数据类型域，使用其装箱类的静态的`compare`方法进行比较；

8）对引用数据类型域，可使用`Comparator`接口中的比较器。

# 4、类和接口

类和接口是Java语言的基本抽象单元。

## 4.1 使类和成员和可访问性最小化（15）

设计良好的组件会隐藏所有的实现细节，将API和实现清晰地隔离开来，组件之间只通过API进行通信。一个模块不需要知道其他模块的内部工作细节，这个概念被称为信息隐藏或封装。Java通过控制访问机制来决定成员的可访问性，从而协助信息隐藏。

### 4.1.1 成员访问级别

成员（域、方法、嵌套类、嵌套接口）有四种访问级别：

1）私有的（`private`）：只有在声明该成员的顶层类的内部才可以访问；

2）包级私有的（`default`）：声明该成员的包内部的任何类都可以访问；

3）受保护的（`protected`）：声明该成员的类的子类可以访问，声明该成员的包内部的任何类可以访问；

4）公有的（`public`）：任何地方都可以访问。

顶层的（非嵌套的）类和接口只有两种访问级别：

1）`default`：是包的实现的一部分，在以后的发行版本中，可以对其进行修改、替换或者删除，而无须担心会影响到现有的客户端程序；

2）`public`：是包导出的API，有责任永远支持它，以保持它们的兼容性。

### 4.1.2 注意事项

1）一个`default`的顶层类或接口如果只是在某一个类的内部使用，则应该使它成为唯一使用它的那个类的`private`嵌套类；

2）当同一个包内的另一个类真正需要访问一个`private`成员时，才应该删除`private`，使其成为`default`；

3）如果上一条中的情况经常出现，则应该重新检查系统设计，降低类之间的耦合度；

4）`protected`成员是类的导出的API的一部分，必须永远得到支持，应尽量少用`protected`成员；

5）当子类覆盖了超类中的方法时，子类中的访问级别不应低于超类中的访问级别，以确保任何可使用超类实例的地方也都可以使用子类的实例；

6）当一个类实现一个接口时，接口中的所有方法在这个类中都必须声明为`public`；

7）不能为了测试而将`private`或者`default`改成`protected`或者`public`，但可以将测试作为被测试的包的一部分来运行，从而使得测试能够访问被测试的`default`成员；

8）`public`类不应包含`public`域，并要确保`final`域所引用的对象是不可变的；

9）长度非零的数组总是可变的，类不应具备`public static final`数组域，不应具备返回这种域的访问方法，可以将这个数组域改为`private`，并给出一个返回这个数组域的拷贝的`public`方法。

## 4.2 要在公有类而非公有域中使用访问方法（16）

1）如果类可以在其所在的包之外进行访问，就提供访问方法，即`public`类不应暴露其数据域；

2）`default`类或者`private`嵌套类可以直接暴露其数据域。

## 4.3 使可变性最小化（17）

### 4.3.1 不可变类

不可变类指实例不能被修改的类（更加安全），实例中包含的所有信息必须在创建该实例时就提供，并在实例的整个声明周期内固定不变。

设计一个不可变类要遵循以下规则：

1）不提供任何设置方法；

2）保证类不会被扩展（可用`final`修饰）；

3）所有域都声明为`final`；

4）所有域都声明为`private`；

5）对于指向可变对象的域，不得提供该域的访问方法，不得使用客户端提供的对象来初始化该域，在构造器、访问方法和`readObject`方法中使用保护性拷贝技术。

### 4.3.2 函数的（functional）方法

不可变类提供functional方法，该方法对操作数进行运算但并不修改它，在返回时会创建一个新的不可变类实例，而不是修改当前实例。functional方法的名称都是介词（如`plus`）而不是动词（如`add`），这是为了强调该方法不会改变实例的状态。

### 4.3.3 注意事项

1）不可变类是线程安全的，它们不要求同步，可以自由地被线程共享，永远不需要进行保护性拷贝，不要提供`clone`方法或者拷贝构造器；

2）客户端应尽可能地重用现有的实例，对于频繁用到的值，为其提供`public static final`常量，甚至可以提供静态工厂，将频繁被请求的实例缓存起来；

3）为了保证不可变类不会被扩展，除了可用`final`修饰，还可以通过让类的构造器都变成`private`或者`default`，并添加`public`静态工厂来代替`public`构造器；

4）不可变类唯一的缺点在于对于每个不同的值都需要一个单独的对象，而创建这些对象的代价可能很高；

5）针对上一条，可以为不可变类提供其`public`可变配套类，或者不可变类其实可以有一个或者多个非`final`的域，这些域用于存储一些开销昂贵的计算结果缓存，如果将来再次请求相同的计算，就直接返回这些缓存的值；

6）对于可变类，除非有令人信服的理由使域成为非`final`的，否则每个域都是`final`的，除非有令人信服的理由，不要在构造器或者静态工厂之外再提供`public`初始化方法。

## 4.4 复合优先于继承（18）

1）在包的内部使用继承是非常安全的，但进行跨越包边界的继承是非常危险的，继承破坏了封装性，当超类发生改变时，子类可能会遭到破坏；

2）可以考虑不扩展现有的类，而是在新的类中添加一个引用现有类的实例的`private`域，现有类变成了新类的一个组件，这种设计被称为“复合（composition）”；

3）装饰器模式用到了复合，装饰器在实现想要包装的接口的同时还将该接口添加为自己的一个域，通过扩展装饰器可以得到各种功能的包装类；

4）包装类几乎没有缺点，但是包装类不适用于回调框架；

5）在适合用复合的地方使用了继承会不必要地暴露实现细节，这样得到的API会被限制在原始的实现上，子类的性能也被限制了。

## 4.5 设计可继承的类并提供文档说明（19）

对于专门为了继承而设计的类，应当具有良好的说明文档：

1）精准说明覆盖每个方法所带来的影响（即方法的自用性）；

2）指明`public`和`protected`方法或者构造器调用了哪些可覆盖的方法，可覆盖的方法指非`final`的`public`或者`protected`方法。

对于为了继承而设计的类，应当遵守以下限制：

1）通过编写子类来测试该类；

2）构造器决不能调用可被覆盖的方法，无论是直接调用还是间接调用；

3）构造器调用`private`、`final`和`static`方法是安全的，因为这些都是不可被覆盖的方法；

4）如果要实现`Cloneable`和`Serializable`接口，则`clone`和`readObject`方法都应遵守和构造器一样的限制；

5）对于不是为了继承而设计的类，应保证该类不会被子类化。

## 4.6 接口优于抽象类（20）

抽象类的劣势在于：

1）为了实现抽象类定义的类型，类必须成为抽象类的一个子类，但因为Java只允许单继承，所以用抽象类作为类型定义受到了限制；

2）扩展抽象类时，抽象类就必须放到类型层次的高处，从而间接地伤害到类层次。

接口的劣势在于：

1）接口中不允许包含实例域，不允许包含非`public`的静态成员（`private`静态方法除外），这些域隐式地是`static`和`final`的；

2）不允许给`Object`方法提供缺省实现。

接口的优势在于：

1）接口允许构造非层次结构的类型框架；

2）接口可以安全地增强类的功能；

3）通过给接口提供一个抽象的骨架实现类，可以保留接口的优势并弥补接口的劣势，接口负责定义类型和一些缺省方法，骨架类负责实现非基本类型接口方法，骨架实现类（为继承而设计的类）的扩展则实现基本类型接口方法，这就是模板方法模式。

## 4.7 为后代设计接口（21）

在Java8发行之前并不允许给接口添加新的方法，在Java8之后可以通过添加缺省方法来给接口添加方法。

1）尽量避免使用缺省方法在现有接口上添加新的方法，应当慎重考虑缺省方法的缺省实现是否会破坏现有的方法实现；

2）在创建接口时，使用缺省方法来提供标准化的方法实现是非常方便的；

3）缺省方法不支持从接口中删除方法，不支持修改现有方法的签名；

4）测试接口时，应当以不同的方法实现每一个接口，编写多个客户端程序，利用每个新接口的实例来执行不同的任务。

## 4.8 接口只用于定义类型（22）

常量接口模式（只含有静态常量而任何没有方法的接口）是对接口的不良使用。接口应该只被定义类型，不应被用来导出常量。

常量接口可以修改为枚举类型或者不可实例化的工具类。

## 4.9 类层次优于标签类（23）

标签类指带有多种风格实例的类，这种类过于冗长，效率低下。

将标签类修改为具备类层次的多个类可以使得代码清晰简单，反映类型之间本质上的层次关系，增强灵活性。基本没有适用标签类的场景。

## 4.10 静态成员优于非静态成员（24）

嵌套类指定义在另一个类内部的类，目的在于为它的外围类提供服务。如果嵌套类将来可能会用于其他的某个环境中，它就应该成为顶层类。

嵌套类可分为以下四种

1）静态成员类：可以看作是普通的类，只是恰好被声明在另一个类的内部，**如果嵌套类的实例可以在它的外围类的实例之外独立存在，这个嵌套类就必须是静态成员类**；

2）非静态成员类：非静态成员类的每个实例都与外围类的外围实例相关联，在没有外围实例的情况下，创建非静态成员类的实例是不可能的；

3）匿名类：匿名类不是外围类的成员，仅在使用时同时被声明和实例化，匿名类是动态创建小型函数对象和过程对象的最佳方式，匿名类必须保持简短（10行或者更少）来保证程序可读性；

4）局部类：局部类有名字，可以被重复使用，需要保持简短来保证程序可读性。

## 4.11 限制源文件为单个顶级类（25）

1）顶级类应当分别放在独立的源文件中，从而确保编译时一个类时不会有多个定义；

2）如果一定要把多个顶级类放在一个源文件中，则可以考虑使用静态成员类。

# 5、泛型

从Java5开始，泛型成为了Java编程语言的一部分，泛型可以令开发者告知编译器每个集合中接收那些对象类型，编译器在编译时会告知开发者是否插入了类型错误的对象，从而使得程序更加安全、清楚。

## 5.1 不使用原生态类型（26）

声明中具有一个或者多个类型参数的类或者接口，就是泛型类或者接口，泛型类和接口统称为泛型，每一种泛型都定义一个原生态类型，即不带任何实际类型参数的泛型名称（例如`List<E>`的原生态类型为`List`）。原生态类型只是为了与引入泛型之前的遗留代码进行兼容和互用而提供的。

1）原生态类型虽然合法，但逃避了泛型检查，会失掉类型安全性，所以不要使用原生态类型；

2）原生态类型的安全替代是无限制的通配符类型（例如`List`的无限制通配符类型为`List<?>`，读作某个类型的`List`），无限制的通配符类型是安全的，可以持有任何类型的元素（除了`null`）；

3）在参数化类型上使用`instanceof`操作符是非法的，在原生态类型和无限制通配符类型上使用`instanceof`操作符是合法的。

## 5.2 消除非受检的警告（27）

1）在用泛型编程时会遇到许多编译器提示的非受检警告，应当尽可能地消除每一个非受检警告；

2）`@SuppressWarning("unchecked")`注解可以禁止非受检警告，该注解可以用在任何粒度的级别中，但应当在尽可能小的范围内使用该注解，永远不要在整个类上使用该注解；

3）每次使用`@SuppressWarning("unchecked")`注解时都要通过注释说明为什么这么做是安全的。

## 5.3 列表优于数组（28）

1）使用数组时，如果将错误类型的对象放入数组，直到代码运行时才能发现该错误，而列表使得编译时就能发现错误；

2）数组在运行时知道并强化元素类型，而列表泛型只是在编译时强化元素的类型并在运行时通过擦除来丢弃元素类型，从而使得泛型可以与没有使用泛型的代码兼容；

3）创建泛型数组是违法的，最好修改为`List<E>`而不是`E[]`，这样可能会损失一些性能，但具有更高的类型安全性和互用性。

## 5.4 优先考虑泛型（29）

1）在使用数组时，依旧优先考虑将元素类型泛型化；

2）由于创建泛型数组是违法的，因此可以i）创建`Object`数组再装换为泛型数组类型；ii）创建`Object`数组，将从数组中获取到的元素转换为泛型类型，这两种方法都需要增加`@SuppressWarning("unchecked")`注解及注释来禁止警告；

3）Java并非生来就支持列表，有些泛型（比如`ArrayList`）必须在数组上实现。

## 5.5 优先考虑泛型方法（30）

1）方法同样可以受益于泛型化，尤其是静态工具方法；

2）泛型方法需声明类型参数，方法的类型参数声明位于方法修饰符和返回值之间；

3）类型限制`<E extends Comparable<E>>`读作“针对可以与自身进行比较的每个类型`E`”。

## 5.6 利用有限制通配符来提升API灵活性（31）

1）当某个参数既是生产者又是消费者时，泛型可以提供严格的类型匹配；

2）当某个参数是生产者或者消费者时，可通过有限通配符类型来提升参数；灵活性；

3）不要用有限通配符类型作为方法返回类型；

4）当类型参数只在方法中出现一次时，就可以用通配符取代它，无限制的类型参数就用无限制的通配符取代，有限制的类型参数就用有限制的通配符取代；

## 5.7 谨慎并用泛型和可变参数（32）

1）显式创建泛型数组是违法的，但用泛型可变参数声明方法是合法的；

2）当调用一个可变参数方法时，会创建一个数组用于存放可变参数，**将值保存在泛型可变参数数组参数中是不安全的，允许另一个方法访问该数组也是不安全的**；

3）客户端每次调用带泛型可变参数的方法时都会产生警告，该方法的设计者可通过`@SafeVarargs`注解来禁止客户端的警告；

4）只有方法没有在可变参数数组中保存任何值，也不允许对数组的引用转义时，该带泛型可变参数的方法才是安全的，只有方法是安全的，才可以使用`@SafeVarargs`注解；

5）`@SafeVarargs`注解只能用于无法被覆盖的方法，即`static`和`final`实例方法；

6）不想使用`@SafeVarargs`注解时，也可用List参数代替可变参数。

## 5.8 优先考虑类型安全的异构容器（33）

泛型常用于参数化了的容器（比如集合），从而限制容器的元素类型。但在数据库的场景下，希望能以类型安全的方法访问任意数量的列，此时就需要**将键进行参数化**而不是将容器参数化，然后将参数化的键提交给容器来插入或者获取值，如果该容器的所有键都是不同类型的，则该容器称为类型安全带异构容器。

# 6、枚举和注解

类是枚举类型，接口是注解类型。

## 6.1 用enum代替int常量（34）

1）枚举类型是指由一组固定的常量值组成合法值的类型；

2）Java的枚举类是通过公有的静态`final int`域为每个枚举常量导出一个实例，枚举类型没有可以访问的构造器，是`final`类；

3）客户端无法创建枚举类型的实例，也无法对其进行扩展，只存在声明过的枚举常量；

4）枚举类型允许添加任意方法和域，允许实现任意接口；

5）每当需要一组固定常量，并在编译时就知道其成员时，就应该使用枚举；

6）当多个枚举常量同时共享相同的行为时，考虑策略枚举。

## 6.2 用实例域代替序数（35）

所有的枚举都有一个`ordinal`方法，该方法可以返回每个枚举常量在类型中数字位置，即序数，但永远不要根据枚举的序数导出与枚举常量关联的值，即最好避免使用`ordinal`方法。

## 6.3 用EnumSet代替位域（36）

1）如果一个枚举类型的元素主要用在集合中，通过位运算将几个常量合并到一个集合中，称为位域；

2）位域表示法具有很多缺点，难以遍历，不好确定`int`还是`long`型；

3）可以使用`java.util`包中的`EnumSet`类来有效地表达从单个枚举类型中提取的多个值的多个集合；

4）`EnumSet`类提供了丰富的静态工厂来创建集合，可以有效代替位域表示法。

## 6.4 用EnumMap代替序数索引（37）

1）有时可能会见到利用`ordinal`方法来索引数组或列表的代码，这种情况下，使用`EnumMap`是一种更好的方法；

2）`EnumMap`内部使用了序数索引的数组，但对程序员隐藏了这种实现细节，集`Map`的安全与数组的快速于一身；

3）`EnumMap`的构造器采用键类型的`Class`对象，这是一个有限制的类型令牌，提供了运行时的泛型信息。

## 6.5 用接口模拟可扩展的枚举（38）

1）由于枚举类型的可伸缩性会导致设计和实现的许多方面变得复杂，目前枚举类型是不可扩展的；

2）由于接口是可扩展的，因此可以用接口模拟扩展的枚举；

3）当枚举类型实现了某个接口时，枚举类型中不再需要声明抽象方法。

## 6.6 标记注解优先于命名模式（39）

1）使用特定格式命名方法（比如测试方法以`test`开头）并不一定能确保该方法按照希望的意图执行，但通过注解则可以解决该问题（比如`@Test`指定简单的测试）；

2）注解永远不会改变被注解代码的语义。

## 6.7 坚持使用Override注解（40）

1）`@Override`注解只能用在方法声明中，表示被注解的方法声明覆盖了超类型中的一个方法声明，使用该注解可以防止很多错误；

2）在编写非抽象，并且该类覆盖了超类的抽象方法时，可以不使用该注解。

## 6.8 用标记接口定义类型（41）

标记接口是指不包含方法声明的接口，用于指明一个类实现了具有某种功能属性的接口。

标记接口和标记注解的区别在于：

1）标记接口使得IDE在编译时就能捕捉到在使用标记注解的情况下要到运行时才能捕捉到的错误；

2）标记注解可以声明为应用于任意类或者接口，但标记接口可以被更加精确地进行锁定；

3）标记注解在那些支持注解错位编程元素之一的框架中同样具有一致性。

分别选择标记接口和标记注解的情况：

1）如果标记是应用于任何程序元素而不是类或者接口时，使用标记注解；

2）如果标记只应用于类和接口，当需要编写只接受带有标记的方法时使用标记接口，当不需要编写这种方法时使用标记注解；

3）如果标记是广泛使用注解的框架的一个组成部分，则应该选择标记注解。

# 7、Lambda和Stream

## 7.1 Lambda优先于匿名类（42）

1）函数类型指带有单个抽象方法的接口，函数类型的实例称为函数对象；

2）匿名类满足了面向对象的设计模式对函数对象的需求，但是使用起来过于繁琐，因此允许使用简洁的Lambda表达式来创建函数对象；

3）无需在Lambda表达式中指定参数类型，除非程序报错；

4）如果一个计算本身不是自描述的，或者超出了几行，那就不要将其放在一个Lambda中（一行是最理想的，不要超出三行）；

5）Lambda无法获得对自身的引用，在Lambda中，`this`指的是外围实例，在匿名类中，`this`指的是匿名类实例；

6）尽可能不要实例化一个`Lambda`或者匿名类实例，如果需要可序列化的函数对象，就是用私有静态嵌套类的实例。

## 7.2 方法引用优先于Lambda（43）

1）方法引用是比Lambda更简洁的创建函数对象的方法，即使用方法引用通常能得到更加简短、清晰的代码；

2）如果Lambda太长或过于复杂，可以从Lambda中提取代码放入一个新的方法中，再用该方法的引用替代Lambda；

3）当Lambda和方法引用处于同一个类中时，Lambda也可能会比方法引用更加简洁。

## 7.3 坚持使用标准的函数接口（44）

1）时刻谨记用Lambda来设计API，API的输入应接收函数接口类型的参数，最好使用`java.util.function.Function`中提供的标准接口；

2）只要标准的函数接口能够满足需求，通常应该优先考虑，而不是专门再构建一个新的函数接口；

3）千万不要用带有包装类型的基础函数接口来代替基本函数接口；

4）`@FunctionalInterface`注解用于标注该接口是针对Lambda设计的，该接口不会编译，除非它只有一个抽象方法，避免后续维护人员不小心给该接口添加抽象方法；

5）不要编写同一个参数位置使用不同函数接口的重载。

## 7.4 谨慎使用Stream（45）

Stream API简化了串行或并行的大批量操作，其中，Stream（流）代表数据元素有限或无限的顺序，Stream pipeline（流管道）代表元素的一个多级计算。

1）一个Stream pipeline中包含一个源Stream，接着是0个或多个中间操作和1个终止操作，所有的中间操作都是将一个Stream转换成另一个Stream；

2）Stream pipeline都是lazy的，直到调用终止操作时才会开始计算，默认情况下，Stream pipeline都是按顺序串行执行的；

3）Stream可能使得程序更加简洁清晰，也可能使得程序变得混乱难以维护，在Stream pipeline中使用帮助性方法更有利于提升代码可读性；

4）Stream中的数据元素可以是对象引用或者`int`、`long`和`double`，不支持`char`，最好避免使用Stream来处理`char`值；

5）Stream pipeline利用函数对象（Lambda或者方法引用）来描述重复的计算，而迭代版代码利用代码块来描述重复计算；

6）代码块中可以读取或者修改范围内的任意局部变量，Lambda则只能读取`final`变量并且不能修改任意局部变量；

7）代码块可以从外围方法中`return`、`break`或者`continue`外围循环或者抛出该方法声明中要抛出的任何受检异常，Lambda中则完全无法完成这些事情；

8）根据代码块和Lambda的区别谨慎选择使用迭代还是Stream pipeline。

## 7.5 优先选择Stream中无副作用的函数（46）

1）Stream并不只是一个API，还是一种基于函数编程的模型，为了获得Stream带来的描述性、并行性和速度，必须采用泛型以及API；

2）传入Stream的操作的任何函数对象，无论是中间操作还是终止操作，都应该是无副作用的；

3）`forEach`操作应该只用于报告Stream计算的结果，而不是执行计算；

4）为了使用Stream，Collectors API是必须了解的接口，该接口是一个收集器，收集器产生的对象一般是一个集合，最重要的收集器工厂是`toList`、`toSet`、`toMap`、`groupingBy`和`joining`。

## 7.6 Stream要优先用Collection作为返回类型（47）

1）在编写一个返回对象序列的方法时，如果该返回对象只在Stream pipeline中使用则返回`Stream`，如果返回序列只在迭代中使用，则应返回`Iterable`；

2）`Collection`接口是`Iterable`的一个子类型，有一个Stream方法，因此提供了迭代和stream访问；

3）对于公共的返回序列的方法，`Collection`或者适当的子类型通常是最佳的返回类型；

4）如果无法返回`Collection`，就返回`Stream`和`Iterable`中更合适的那个即可。

## 7.7 谨慎使用Stream并行（48）

1）Stream类库提供`parallel`方法来实现并行处理，但Stream类库并不知道如何并行某个pipeline，以及如何检测并行失败；

2）如果源头是`Stream.iterate`或者使用了中间操作的`limit`，那么并行pipeline也不可能提升性能，Stream pipeline的终止操作本质上也影响了并发执行的效率

3）由Stream的`collect`方法执行的操作，都是可变的减法，不是并行的最好选择；

4）在Stream上通过并行获得的性能，最好是通过`ArrayList`、`HashMap`、`HashSet`和`ConcurrentHashMap`实例，数组，`int`范围和`long`范围等；

5）这些数据结构的共性是i）可以被轻松分成任意大小的子范围，使并向线程中的分工变得更加轻松；ii）提供了优异的引用局部性，具有最佳引用局部性的数据结构是基本类型数组；

6）不要随意地并行Stream pipeline，可能会造成灾难性的后果。

# 8、方法

方法设计应考虑：如何处理参数和返回值，如何设计方法签名，如何为方法编写文档。

## 8.1 检查参数的有效性（49）

1）应当在文档中指明方法参数的限制，并在方法开头处检查参数；

2）对于公有的和受保护的方法，要用Javadoc的`@throws`标签（tag）在文档中说明违反参数值限制时会抛出的异常；

3）对于未被导出的非公有的方法，应该确保只将有效的参数值传递进来，应该使用断言来检查它们的参数；

4）对于有些参数，方法本身没有使用，却被保存起来供以后使用，检验这类参数的有效性极为重要；

5）有时候有效性检查工作非常昂贵，甚至不切实际，有效性检查已隐含在计算过程中完成；

6）对方法参数的限制应该是越少越好，太多限制并不是一件好事。

## 8.2 必要时进行保护性拷贝（50）

1）面对客户端可能有的一些不可预期的行为，应该编写面对不良行为依旧能保持健壮的类；

2）为了避免一个类在另一个类实例无意识的情况下修改了该实例的内部状态，攻击该实例的内部信息，应当对构造器的每个可变参数进行保护性拷贝，并使用备份实例作为该实例的组件，而不使用原始的实例，此时针对原始实例内部信息的攻击不再有效；

3）保护性拷贝是在检查参数的有效性之前进行的，有效性检查是针对拷贝之后的对象，而不是原始的对象，从而避免在“危险阶段”期间从另一个线程改变类的参数（“危险阶段”指从检查参数开始，知道拷贝参数之间的时间段）；

4）对于参数类型可以被不可信任方子类化的参数，不要在构造器中使用`clone`方法进行保护性拷贝，但访问方法中可以使用`clone`方法进行保护性拷贝；

5）参数的保护性拷贝并不仅仅针对不可变类，每当给自己的类编写方法或者构造器时，如果客户端提供的对象是可变的，该对象被允许进入到自己的类的内部数据结构中，但自己的类并不能容忍对象进行数据结构之后发生变化，则应对自己的类对象进行保护性拷贝；

6）在内部组件被返回到客户端之前，同样要进行保护性拷贝，而不是直接将一个指定内部可变组件的引用返回给客户端；

7）只要有可能就使用不可变对象作为对象内部的组件，这样就不必为保护性拷贝操心；

8）保护性拷贝可能会带来相关的性能损失，当类信任它的调用者不会修改内部的组件时（比如类及客户端都是同一个包的双方），那么可以不进行保护性拷贝，但需要在文档中进行说明。

## 8.3 谨慎设计方法签名（51）

1）方法名称应该始终遵循标准的命名习惯，易于理解且与同一个包中的其他名称风格一致；

2）不要为类和接口提供太多的方法，只有当一项操作被经常用到时，才考虑提供快捷方式；

3）避免过长的参数列表（四个或四个以下），相同类型的长参数序列格外有害，可通过分解多个方法、创建辅助类（静态成员类）以及Builder模式来缩短过长的参数列表；

4）参数类型优先使用接口而不是类；

5）对于`boolean`参数，优先使用两个元素的枚举类型。

## 8.4 慎用重载（52）

1）调用哪个重载方法是在编译时决定的，调用哪个重写（覆盖）方法是在运行时决定的；

2）覆盖机制满足了用户对于方法调用行为的期望，而重载机制容易是的这些期望落空，应该避免胡乱使用重载机制；

3）永远不要导出两个具有相同参数数目的重载方法，而是给方法起不同的名字；

4）如果必须要导出多个具有相同参数的重载方法时，要确保所有重载方法的行为必须一致；

5）对于构造器（无法被覆盖，只能被重载），无法选择不同名称，于是可以选择导出静态工厂。

## 8.5 慎用可变参数（53）

1）可变参数接收零个或者多个指定类型的参数；

2）在使用可变参数之前，要先包含所有必要的参数；

3）每次调用可变参数都会导致一次数组分配和初始化，因此存在一定的性能影响。

## 8.6 返回零长度的数组或者集合，而不是null（54）

1）对于返回`null`而不是零长度数组或者集合的方法，每次使用该方法时都需要有额外的代码来处理`null`返回值；

2）不需要分配零长度的集合或者数组即可返回它们，无需担心分配所需的开销；

3）如果有证据表明分配零长度的集合损害了程序的性能，可以重复返回一个不可变的零长度集合，避免重复分配（不可变对象可以自由共享）。

## 8.7 谨慎返回optional（55）

1）当需要编写一个在特定环境下无法返回值的方法时，不要选择抛出异常或者返回`null`，因为抛出异常的开销很高，而返回`null`会使得API变得难以使用；

2）针对上述情况可以返回`Optional<T>`类，它代表一个不可变的容器，可以存放单个非`null`的`T`引用，或者什么内容都没有；

3）在某些特定情况下，可以声明返回`Optional<T>`，它允许方法返回T或者空的结果，这样比抛出异常更加灵活简单，比返回null更加不容易出错；

4）`Stream`类型的许多终止操作都返回`optional`，使用Stream编程时，会经常遇到`Stream<Optional<T>>`；

5）容器类型（包括集合、映射、`Stream`、数组和`optional`）都不应该被包装在`optional`中，即直接返回空的容器，而不是空的`Optional`；

6）`Optional`是一个必须进行分配和初始化的对象，从`optional`中读取值时需要额外的开销，这使得`optional`并不适合注重性能的情况；

7）使用`OptionalInt`、`OptionalLong`、`OptionalDouble`而不是`Optional<Integer>`、`Optional<Long>`、`Optional<Double>`；

8）永远不要用`optional`作为映射值 几乎永远都不适合用`optional`作为键、值、集合或者数组中的元素；

9）尽量不要将`optional`作为返回值以外的任何其他用途。

## 8.8 为所有导出的API编写文档注释（56）

1）Java编程环境提供了Javadoc工具，Javadoc利用特殊格式的文档注释，根据源代码自动产生API文档；

2）为了正确地编写API文档，必须在每个被导出的类、接口、构造器、方法和域声明之间增加一个文档注释；

3）如果类是可序列化的，应该对它的序列化形式编写文档；

4）公有的类不能使用缺省的构造器，因为无法为它们提供文档注释；

5）方法的文档注释应该简洁地描述出它和客户端之间的约定，除了专门为继承而设计的方法之外，这个约定应说明这个方法做了什么、前提条件、后置条件以及副作用；

6）前提条件指为了使客户端能够调用这个方法而必须要满足的条件，是由`@throws`标签针对未受检的异常所隐含描述的；

7）后置条件指调用成功完成之后，哪些条件必须要满足；

8）副作用指系统状态中可以观察到的变化，不是为了获得后置条件而明确要求的变化，例如启动了后台线程；

9）方法的文档注释应该让每个参数都有一个`@param`标签，一个`@return`（除非返回类型为`void`）以及对于该方法抛出的每个异常都应有一个`@throws`标签；

10）按照惯例，`@param`和`@return`标签后面的文字应该是一个名词短语，描述这个参数或者返回值所表示的值，`@throws`标签之后的文字应该包含单词“if”，紧接着是一个名词短语，描述这个异常将在什么样的情况下抛出，这些标签后面的短语或者子句都用句点来结束；

11）对于专门为继承设计的类，使用`@implSpec`描述方法及其子类之间的约定；

12）文档注释在源代码和产生的文档中都应该是易于阅读的，如果无法同时满足，产生的文档的可读性要优于源代码的可读性；

13）同一个类或者接口中的两个成员或者构造器，不应该具有同样的概要描述（文档注释的第一句话或者一个名词性短语），因此要特别注意重载的情况；

14）为泛型编写文档时，要说明所有的类型参数；

15）为枚举类型编写文档时，要确保在文档中说明常量，以及任何公有的方法；

16）为注解类型编写文档时，要确保在文档中说明所有成员；

17）类或者静态方法是否线程安全，应该在文档中对它的线程安全级别进行说明；

18）Javadoc具有继承方法注释的能力，接口的文档注释优先于超类的文档注释。

# 9、通用编程

## 9.1 将局部变量的作用域最小化（57）

1）较早的编程语言要求局部变量必须在代码块的开头进行声明，但Java语言中这个习惯应该改正，Java允许在任何可以出现语句的地方声明变量，从而将局部变量的作用域最小化，增强代码的可读性和可维护性，降低出错的可能性；

2）要使局部变量最小化，就在第一次使用它的地方进行声明，如果变量在使用之前进行声明，这只会造成混乱；

3）几乎每一个局部变量的声明都应该包含一个初始化表达式，例外情况与`try-catch`语句有关；

4）由于`for`循环（传统形式或者`for-each`形式）允许声明循环变量，它的作用域被限定在正好需要的范围之内，因此`for`循环优先于`while`循环；

5）要使局部变量最小化，还应该使方法小而集中，每个操作用一个方法来完成。

## 9.2 for-each循环优先于传统的for循环（58）

1）`for-each`循环通过完全隐藏迭代器或者索引变量，避免了混乱和出错的可能，这种模式同时适用于集合和数组，也不会有性能损失；

2）如果需要遍历集合并删除选定的元素，或者需要遍历列表、数组并替换部分元素值，或者需要并行地遍历多个集合，就需要使用传统的`for`循环形式；

3）编写表示一组元素的类型时，应该坚决考虑让它实现`Iterable`接口，那么用户就可以利用`for-each`循环来遍历该类型。

## 9.3 了解和使用类库（59）

1）使用标准类库，可以充分利用这些编写标准类库的专家的知识，沿用前人的经验，比如使用`ThreadLocalRandom`产生高质量的随机数；

2）为了熟悉标准类库，应该熟悉`java.lang`、`java.util`、`java.io`及其子包中的内容；

3）如果在Java类库中找不到需要的功能，就去高级的第三方类库中去寻找，不要重复造轮子。

## 9.4 需要精确答案时请避免使用float和double（60）

1）`float`和`double`类型并没有提供完全精确的结果，尤其不适用于货币计算，面对货币问题时，应使用`BigDecimal`、`int`或者`long`进行货币计算；

2）使用`BigDecimal`时应使用`String`参数的构造器而不是`double`构造器，使用`int`或者`long`时，可以以分而不是元来作为单位进行计算；

3）综上，当数值范围没有超过9位十进制数字时，可以使用`int`，如果不超过18位数字，可以使用`long`，如果超过18位，必须使用`BigDecimal`。

## 9.5 基本类型优先于装箱基本类型（61）

1）基本类型只有值，装箱基本类型具有与它们的值不同的同一性；

2）基本类型只有函数值，装箱基本类型除了它对应基本类型的所有函数值之外，还有个`null`（是未赋值前的初始值）；

3）基本类型通常比装箱基本类型更节省时间和空间；

4）对装箱基本类型运用`==`操作符时，是在做同一性比较，结果几乎总是`false`；

5）自动装箱和拆箱减少了使用装箱基本类型的繁琐性，但是并没有减少它的风险；

6）只有在作为集合中的元素，参数化类型以及反射的方法调用中，才必须使用装箱基本类型作为类型参数，除此之外，基本类型要优先于装箱基本类型。

## 9.6 如果其他类型更合适，则尽量避免使用字符串（62）

1）字符串不适合代替其他的值类型，字符串应该用于表示文本信息；

2）如果无法将字符串直接转换为其他类型，应简单地编写一个私有的静态成员类来描述这个字符串所表示的数据集；

3）尽可能编写更加适合的数据类型，尽量避免用字符串来表示对象。

## 9.7 了解字符串连接的性能（63）

1）当想产生单独一行的输出，或者构造一个字符串来表示一个较小的、大小固定的对象时，使用连接操作符`+`是合适的；

2）由于字符串不可变，当两个字符串被连接在一起时，它们的内容都需要被拷贝；

3）连接n个字符串而重复地使用字符串连接操作符，需要n的平方级的时间，连接操作符不适用于大规模场景，不要用来合并多个字符串；

4）为了接收可以获得的性能，应该用`StringBuilder`代替`String`。

## 9.8 通过接口引用对象（64）

1）如果有合适的接口类型存在，那么对于参数、返回值、变量和域来说，就都应该使用接口类型而不是类进行声明，程序会更加灵活；

2）只有在真正需要利用构造器创建某个对象的时候，才需要真正引用这个对象的类；

3）当对象属于一个框架时（框架的基本类型是类，不是接口），应该用相关的基类（往往是抽象类）来引用这个对象，而不是实现类；

4）值类（比如`String`和`BigInteger`）很少会用多个实现编写，经常是`final`的，很少有对应的接口，此时完全可以用类来引用对象；

5）当类实现了接口，但它也提供了接口中不存在的额外方法时，由于程序可能依赖这个额外的方法，这种类就应该只被用来引用它的实例。

## 9.9 接口优先于反射机制（65）

核心反射机制，`java.lang.reflect`包，提供了通过程序访问任意类的成员名称、域类型、方法签名等信息的能力，允许一个类访问另一个类，即当前类被编译时后者还不存在。

反射的缺点：

1）损失了编译时类型检查的优势，如果程序企图用反射方式调用不存在的或者不可访问的方法，等到运行时会失败；

2）执行反射访问所需要的代码非常笨拙和冗长；

3）反射方法调用比普通方法调用更慢，存在性能损失；

反射的优点：

1）通过接口引用对象时，就是用反射方式创建实例，然后通过它们的接口或者超类，以正常的方式访问这些实例；

2）功能强大，可用于分析和测试等；

3）如果正在编写的程序需要与编译时未知的类一起工作，应该仅仅使用反射机制来实例化对象，而访问对象时则使用编译时已知的接口或者超类。

## 9.10 谨慎地使用本地方法（66）

1）本地方法（native method）指用本地编程语言（比如C或者C++）来编写的方法，它们提供了访问本地遗留代码库的能力；

2）本地方法可以通过本地语言，编写应用程序中注重性能的部分，以提高系统的性能；

3）使用本地方法来提高性能的做法不值得提倡，本地语言是不安全的，是与平台相关的，会使得程序难以移植、难以调试，而JVM本身就已经可以提供高性能；

4）只有在极少数情况下才会使用本地方法，比如需要访问底层的资源或者遗留代码库。

## 9.11 谨慎地进行优化（67）

1）不成熟的优化弊大于利，不要为了性能牺牲合理的结构，要编写好的程序而不是快的程序；

2）要在API设计决策的过程中考虑性能问题，避免那些限制性能的设计决策；

3）一般而言，好的API设计也会带来好的性能，但不要为了获得好的性能而对API进行包装。

## 9.12 遵守普遍接收的命名惯例（68）

1）包和模块的名称应该是层次状的，用句号分隔每个部分，鼓励使用有意义的缩写；

2）类和接口（包括枚举和注解类型）的名称，都应该包括一个或者多个单词，除了通用缩写外尽量避免缩写。

# 10、异常

## 10.1 只针对异常的情况才使用异常（69）

1）基于异常的模式比标准模式更慢，不应将异常用于正常的控制流；

2）设计良好的API不应该强迫它的客户端为了正常的控制流而是用异常。

## 10.2 对可恢复的情况使用受检异常，对编程错误使用运行时异常（70）

1）可抛出结构分为受检异常、运行时异常和错误；

2）方法中声明要抛出的每个受检异常，是对用户的一种潜在指示：与异常相关联的条件是调用这个方法的一种可能的结果，并要求调用者能够在一个`catch`子句中处理该异常或者将其传播出去；

3）API的设计者要求API的使用者面对受检异常，以强制用户从这个异常条件中恢复，受检异常往往指明了可恢复的条件；

4）运行时异常和错误都是不需要也不应该被捕获的可抛出结构，当程序抛出运行时异常和错误时，就是不可恢复的情况，会导致当前线程中断，并出现适当的错误消息；

5）大多数的运行时异常都表示前提违例，即API的用户没有遵守API规范建立的约定；

6）不要再实现任何新的`Error`的子类，程序员所实现的所有未受检的抛出结构都应该是`RuntimeException`的子类；

7）对于可恢复的情况，要抛出受检异常，对于程序错误，要抛出运行时异常，对于不确定是否可恢复的情况，要抛出未受检异常。

## 10.3 避免不必要地使用受检异常（71）

1）受检异常强迫程序员处理异常的条件，过分使用受检异常会使得API使用起来非常不方便，抛出受检异常的方法不能直接在Stream中使用；

2）当正确使用API依旧不能阻止异常条件的产生，并且一旦产生异常，使用API的程序员可以立即采取有用的动作时，这种受检异常负担就被认为是正当的，否则更适合使用未受检的异常；

3）如果在`catch`语句中，程序员只能继续抛出异常或者只是打印异常信息而无法采取更好的措施，那么使用未受检的异常会更为合适；

4）如果方法可能抛出的受检异常只有一种，就导致`try-catch`语句的使用，并且不能在`Stream`中直接使用，那么这种额外负担是非常高的；

5）消除受检异常最容易的方法是返回一个零长度`optional`而不抛出受检异常，这样做的缺点是无法返回任何额外的信息来详细说明它无法执行想要的计算。

## 10.4 优先使用标准的异常（72）

1）代码重用是值得提倡的，异常也不例外，重用标准的异常使得API更易于学习使用，可读性更好，当异常类越少，内存占用也就越小，装载这些类的时间开销也越少；

2）不要重用`Exception`、`RuntimeException`、`Throwable`或者`Error`，对待这些类要像对待抽象类一样；

3）当子类化标准异常时，要记住异常也是可序列化的，如果没有非常正当的理由，千万不要自己编写异常类。

## 10.5 抛出与抽象对象的异常（73）

1）当方法传递由底层抽象抛出的异常时，方法抛出的异常与它执行的任务没有明显的联系，这会污染具有实现细节的更高层的API；

2）高层的实现应该捕获低层的异常，同时抛出可以按照高层抽象进行解释的异常，这种做法称为异常转译；

3）一种特殊的异常转译形式称为异常链，如果低层的异常对于调试导致高层异常的问题非常有帮助，就很适合使用异常链，它允许抛出适当的高层异常，同时又能捕获低层的原因进行失败分析；

4）只有在不能阻止或者处理来自低层的异常时，才使用异常转译，但不能滥用它。

## 10.6 每个方法抛出的所有异常都要建立文档（74）

1）始终使用`throws`关键字都要单独地声明受检异常，并利用Javadoc的`@throws`标签，准确记录下抛出每个异常的条件；

2）即便方法通常不会抛出非受检异常，但是它们通常代表编程上的错误，为它们建立文档是非常明智，让程序员了解这些错误有助于避免犯同样的错误，**在文档中记录未受检异常是满足前提条件的最佳做法**；

3）使用Javadoc的`@throws`标签记录方法可能抛出的每个未受检异常，但是不要使用`throws`关键字来声明未受检异常；

4）如果一个类中的许多方法出于同样的原因而抛出同一个异常，应该在该类的文档注释中对这个异常建立文档，而不是为每个方法单独建立文档。

## 10.7 在细节消息中包含失败-捕获异常（75）

1）异常类型的`toString`方法应当尽可能多地返回有关失败原因的信息，信息应该包含“对该异常有贡献”的所有参数和域的值，以便程序失败时进行分析；

2）不要在错误信息中包含密码、密钥以及类似的信息；

3）为了确保异常的细节消息中包含足够的失败-捕获信息，一种办法是在异常的构造器而不是`toString`中引入这些信息。

## 10.8 努力使失败保持原子性（76）

1）失败的方法调用应该使对象保持在被调用之前的状态，这种属性称为失败原子性；

2）不可变对象显然具有失败原子性，可变对象要获得失败原子性有以下几种方式：i）就在执行操作之前检查参数的有效性，使得对象在被修改之前，先抛出适当的异常，ii）将任何可能会失败的计算部分都在对象状态被修改之前发生，iii）在对象的一份临时拷贝上执行操作，iv）编写恢复代码，实现回滚；

3）错误通常是不可恢复的，因此方法抛出`Error`时，不需要努力去保持失败原子性；

4）如果方法无法保持原子性，那么API文档就应该清楚地说明对象在方法调用失败后会处于什么样的状态。

## 10.9 不要忽略异常（77）

1）当API的设计者声明一个方法将抛出某个异常时，也是在试图说明某些事情，所以不要忽略任何异常（无论是受检异常还是非受检异常）；

2）空的`catch`块会使得异常达不到应由的目的。

# 11、并发

## 11.1 同步访问共享的可变数据（78）

1）正确地使用同步可以保证没有任何线程会看到数据处于不一致的状态中，并且进入同步的每个线程都能看到由同一个锁保护的之前的所有修改效果；

2）语言规范保证线程在读取原子数据时不会看到任意的数值，需要保证对变量的读写满足原子性，保证线程间的数据访问是互斥的，从而解决数据不一致的问题；

3）单个读写原子数据的操作是满足原子性的，但对原子数据使用增量操作符或者多次读写原子数据都不满足原子性；

4）原子性是同步的必要不充分条件，仅仅满足原子性，只能是不会出现数据一致性问题，但并不保证一个线程写入的值对另一个线程将是可见的，这并不是真正的同步，也无法实现线程间可靠的通信；

5）如果将可变数据限制在单个线程中，就可以避免线程同步问题，此时，对该可变数据建立文档就很重要。

## 11.2 避免过度同步（79）

1）在一个被同步的方法或者代码块中，永远不要放弃对客户端的控制，也就是说，在一个被同步的区域内部，不要调用外来方法，否则容易造成死锁；

2）外来方法指被设计成要被覆盖的方法，或者是由客户端以函数对象的形式提供的方法；

3）在同步区域之外被调用的外来方法称作“开放调用”，开放调用可以极大地增加并发性，避免并发失败；

4）外来方法的运行时间可能为任意时长，如果在同步区域内调用外来方法，其他线程对保护资源的访问就会遭到不必要的拒绝；

5）通常来说，应当在同步区域内做尽可能少的工作，如果必须执行某个耗时的动作，应该设法把这个动作移到同步区域外；

6）过度同步除了可能导致正确问题，还有可能导致性能问题，比如限制虚拟机优化代码执行的能力；

7）在这个多核的时代，过度同步的实际成本并不是获取锁所花费的CPU时间，而是指所失去的并行的机会成本以及需要确保每个核都有一个一致的视图而导致的延迟；

8）当不确定是否要使用同步类时，就不要使用同步类，并且建立文档，注明使用的类不是线程安全的，此时可以由客户端在必要的时候从外部进行同步；

9）如果方法修改了静态域，并且该方法很可能要被多个线程调用，那么就必须在内部同步对这个静态域的访问（比如使用线程安全的并发类）；

10）在设计一个可变类时，要考虑一下它们是否应该自己完成同步操作，只有存在足够的理由时才在内部同步类，并注明到文档当中。

## 11.3 executor、task和stream优先于线程（80）

1）Java标准库提供了`ExecutorService`接口表示线程池，并通过`Executors`类以静态工厂的方法生成各种线程池（`ExecutorService`接口的实现类）；

2）针对轻量负载的服务器，可以使用`CachedThreadPool`线程池类，它不需要配置；

3）针对大负载的服务器，不适合用`CachedThreadPool`（它没有将被提交的任务排成队列，而是直接交给线程执行，当没有线程可用时，就会创建新线程），此时，最好使用`FixedThreadPool`或者`ThreadPoolExecutor`（几乎允许程序员控制线程池的每个方面）；

4）尽量不直接使用线程，也尽量不要编写自己的线程池，而是使用Java标准库中提供的线程池；

5）直接使用线程时，`Thread`既是工作单元，又是执行机制，而在`Executor Framework`中，工作单元和执行机制是分开的，此时工作单元称为任务，任务可以是`Runnable`或者`Callable`，执行任务的通用机制是`ExecutorService`接口的实现类。

## 11.4 并发工具优先于wait和notify（81）

1）正确地使用`wait`和`notify`比较困难，应该用更高级的并发工具来代替；

2）`java.util.concurrent`中的并发工具分为三类：`Executor Framework`、并发集合（`Concurrent Collection`）以及同步器（`Synchronizer`）；

3）并发集合为了提高并发性，在内部自己管理同步，因此在使用并发集合时，不需要在外部将其锁定，只会拖累性能；

4）同步器是使线程能够等待另一个线程的对象，允许它们协调动作；

5）在维护以往使用了`wait`和`notify`遗留代码时，永远不要在循环之外调用`wait`方法，应始终使用`wait`循环模式来调用`wait`方法，那么即使`wait`线程被错误的唤醒，依旧能通过循环判断条件来选择是否继续等待；

6）几乎没有理由在新代码中使用`wait`和`notify`方法。

## 11.5 线程安全性的文档化（82）

1）当一个类被并发使用时，这个类的行为如何，是该类与其客户端建立约定的重要组成部分，避免客户端在使用时出现未同步或者过度同步的情况；

2）Javadoc并没在输出中包含`synchronized`修饰符，因为这个是实现细节，并不是导出API的一部分，并不一定表明这个API是线程安全的；

3）无条件的线程安全的类所使用的锁对象应声明为`private final`，使得客户端和子类均无法妨碍对象的同步；

5）有条件的线程安全的类不能使用私有的锁对象，而是应该在文档中说明在执行某些方法时客户端必须获取哪吧锁。

## 11.6 慎用延迟初始化（83）

1）就像大多数的优化一样，对于延迟初始化，除非绝对必要，否则就不要这么做，大多数情况下，正常的初始化都要优先于延迟初始化；

2）延迟初始化降低了初始化类或者创建实例的开销，却增加了访问被延迟初始化的域的开销，实际上是降低了性能的，也对多线程同步造成了困难；

3）当需要对域进行延迟初始化时，访问该域时需要使用同步访问方法以防止循环初始化，但也增加了访问成本；

4）当需要对实例域使用延迟初始化时，要将该域声明为`volatile`，并使用双重检查模式以防止循环初始化，也避免了过度同步（双重检查模式中如果使用局部变量可以提升性能，更加优雅）；

5）当需要对静态域使用延迟初始化时，要使用lazy initialization holder class模式（优于双重检查模式）来保证类要被用到时才会被初始化，此时，该域的静态访问方法不需要同步，不会因延迟初始化增加访问成本。

## 11.7 不要依赖于线程调度器（84）

1）当有多个处于Runnable状态的线程时，由操作系统的线程调度器决定哪些线程将会运行，以及运行多长时间；

2）任何依赖于线程调度器来达到正确性或者性能要求的程序，很有可能都是不可移植的；

3）尽量确保Runnable线程的平均数量不明显多于处理器的数量，此时，即使在根本不同的线程调用算法下，这些程序的行为也不会有很大的变化；

4）令每个Runnable线程都在做有意义的工作，没有做有意义工作时，应从Runnable转移至其他状态；

5）适当地规定线程池的大小，使任务保持适当大小且彼此独立，当任务太小时，分配的开销也会影响到性能；

6）线程不应该一直处于忙-等的状态，即不应该反复地检查一个共享对象以等待某些事情发生，这使得程序容易受到调度器的影响，增大了处理器的负担，降低了同一机器上其他进程的工作效率；

7）不要通过`Thread.yield`方法来修正程序，不要通过调整线程优先级来修正程序。

# 12、序列化

序列化用于将对象编码成字节流，字节流编码可以在机器之间传递或者存储到磁盘上，反序列化时就能从字节流编码中重新构建对象。

## 12.1 其他方法优先于Java序列化（85）

1）序列化的根本问题在于其攻击面过于庞大，无法进行防护，在新编写的任何系统中都没有理由再使用Java序列化；

2）为了避免Java序列化的风险，还有许多其他跨平台的结构化数据表示法（JSON和Protocol Bufffers）可以完成对象和字节序列之间的转化，它们比Java序列化更加简单、安全；

3）重新设计新系统时一定要使用跨平台的结构化数据表示法代替Java序列化，JSON是基于文本的，为JavaScript开发的，Protocol Bufffers是基于二进制的，为C++开发的；

4）当无法避免地要使用Java序列化时，下一步最好永远不要反序列化不被信任的数据；

5）当无法避免地要使用Java序列化，且无法保证反序列化数据的安全性时，就是用对象反序列化过滤，它可以在反序列化之前，拒绝黑名单，接收白名单，但它并不能确保阻止所有的攻击。

## 12.2 谨慎地使用Serializable接口（86）

1）当一个类实现了`Serializable`接口，它的字节流编码（包括私有的和包级私有的实例域）就变成了它导出的API的一部分，需要对此维护的长期开销是很高的；

2）为继承而设计的类应该尽可能少的实现`Serializable`接口，用户的接口应该尽可能少的继承`Serializable`接口，内部类不应实现`Serializable`接口，但静态成员类可以实现`Serializable`接口；

3）如果一个类将要加入到某个框架中，并且该框架依赖于序列化来实现对象传输或者持久化，那么这个类就必须实现`Serializable`接口；

4）如果一个类要成为另一个类的一个组件，并且后者必须实现`Serializable`接口，那么前者实现`Serializable`接口的话就能更易于被后者使用；

5）应该仔细设计一种高质量的能长期使用的序列化形式，这也许会给类的演变带来限制，但好于无法演变。

## 12.3 考虑使用自定义的序列化形式（87）

1）不贸然接受默认的序列化形式，除非经过认真考虑后确认是安全的（此时还有提供一个`readObject`方法以保证约束关系和安全性）；

2）当在不恰当地使用默认的序列化形式时，会使得这个类的导出API永远地束缚在该类的内部表示法上，在序列化时会消耗过多空间，在反序列化时会引起递归栈溢出，并消耗过多时间；

3）无论是否使用默认的序列化形式，每一个可以被标记为`transient`的实例域都应该做上这样的瞬时标记，包括那些冗余的域以及依赖于JVM的域；

4）无论是否使用默认的序列化形式，如果在读取整个对象状态的任何方法上强制任何同步，则也必须在对象序列化上强制这种同步；

5）编写的每一个可序列化的类都要声明一个显式的序列化版本UID，在修改类时，不要修改序列版本UID，否则会破坏类现有的已被序列化实例的兼容性。

## 12.4 保护性地编写readObject方法（88）

1）`readObject`方法实际上相当于另一个公有的构造器，需要对不希望客户端获得引用的参数进行保护性拷贝，并检查参数有效性；

2）`readObject`方法和构造器一样，不可以调用可被覆盖的方法，无论是直接调用还是间接调用都不可以；

3）在编写`readObject`方法时，对于任何检查失败的约束条件，就抛出`InvalidObjectException`异常。

## 12.5 对于实例控制，枚举类型优先于readResolve（89）

1）单例模式的类实现了序列化接口后就不再是单例，因为`readObject`方法会返回一个新建的实例，而这个新建实例不同于该类初始化时创建的实例；

2）如果实现了序列化接口的类想要保持单例，那么就提供一个`readResolve`方法，该方法会在反序列化之后被调用，返回对象引用，取代新建的对象，从而忽略反序列化得到的对象；

3）如果依赖`readReslove`方法进行实例控制，带有对象引用类型的所有实例域都必须声明为`transient`，即所有实例域都为基本类型或者瞬时的；

4）应该尽可能地使用枚举类型来实施实例控制的约束条件，如果做不到，就提供一个`readReslove`方法；

5）应认真考虑`readReslove`方法的可访问性。

## 12.6 考虑用序列化代理代替序列化实例（90）

1）为可序列化的类设计一个私有的静态嵌套类，精确表示外围类的实例的逻辑状态，这个嵌套类被称为序列化代理；

2）序列化代理的构造器的参数类型就是外围类，这个构造器只需从参数中复制数据，而不需要进行任何的保护性拷贝或者一致性检查；

3）序列化代理和外围类都需要声明实现`Serializable`接口，序列化代理的默认序列化形式就是外围类最好的序列化形式；

4）在外围类的`writeReplace`方法中，以`this`作为入参，返回一个新建的序列化代理的实例，从而代替外围类的实例，那么序列化系统永远不会产生外围类的序列化实例；

5）在外围类中`readReslove`方法中，返回外围类实例，导致序列化系统在反序列化时将序列外代理转变回外围类的实例；

6）序列化代理模式以增加序列化开销为代价，带来安全性上的提升，可以有效阻止攻击；

7）序列化代理模式允许反序列化实例有着与原始序列化实例不同的类（比如子类），但不能与可以被客户端扩展的类相兼容。
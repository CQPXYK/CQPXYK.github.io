---
title: Java Concurrency
date: 2022-05-08 21:27:44
tags:
---

# 1、基础概念

## 1.1 进程与线程

由于计算机的运算速度与存储和通信子系统的速度差距太大，大量的时间都花费在磁盘 I/O、网络通信或者数据库访问上，因此不得不加入一层或多层读写速度尽可能接近 CPU 运算速度的高速缓存来作为内存与 CPU 之间的缓冲，此外，还希望通过多任务处理来尽可能避免对运算性能的浪费。现代操作系统（Windows、macOS、Linux）执行多任务实际就是让 CPU 对多个任务**轮流交替执行**（通常任务数量远远多于 CPU 的核数），而基于高速缓存的存储交互虽然很好地解决了 CPU 与内存速度之间的矛盾，但也引入了缓存一致性问题（每个 CPU 都有自己的高速缓存，但又共享同一主内存），为系统带来了更高的复杂度。

- 在计算机中，一个任务称为一个进程（Process），某些进程内部还需要同时执行多个子任务，这些子任务称为线程（Thread），对于 Java 程序来说，执行多任务是指**多线程并发执行**。
- Java 线程是映射到操作系统的原生内核线程之上的，如果要阻塞或唤醒一条线程，同样需要操作系统的支持，同样会涉及到用户态到核心态的转换，这种状态转换消耗的时间甚至会比一些简单的用户代码执行的时间还要长，应当避免不必要的频繁的切入核心态。
- 进程和线程存在以下区别：
  - 进程和线程是包含关系，一个进程有一个或多个线程，线程是操作系统调度的最小单元；
  - 由于进程是运行在它自己的地址空间内自包容程序，创建进程的开销比创建线程大；
  - 进程间通信比线程间通信要慢，这是因为线程间通信就是读写同一个变量，速度很快；
  - 进程间不会相互干扰，一个进程崩溃不会影响其他进程，但是任何一个线程的崩溃就会导致整个进程崩溃；
  - 多线程编程的复杂度比多进程更高，困难在于协调不同线程驱动的任务之间对共享资源（内存和 I/O）的使用。

## 1.2 上下文切换

CPU 会给每个任务分配时间片，因此，即使是单核 CPU 也支持多任务并发执行代码，从而提升单核 CPU 上的程序的性能（在某个任务阻塞时，其他任务依旧可以继续执行，但如果没有任务会阻塞，那么单核 CPU 上使用并发就没有任何意义）。

上下文切换指的是内核（操作系统的核心）在CPU上对进程或者线程进行切换。

- 当前任务执行一个时间片之后会切换到下一个任务，任务切换前后需要保存上一个任务的状态并加载下一个任务的状态，这种任务从保存到再加载的过程就是一次上下文切换。
- 上下文切换的信息被保存在进程控制块（PCB，又称切换桢）中，会被一直保存在CPU的内存中，直到被再次使用。
- Java 中的线程机制是抢占式的，这表示调度机制会周期性地中断线程，将上下文切换到另一个线程，从而为每个线程都提供时间片。 
- 由于上下文切换存在开销，因此：
  - 当上下文切换过于频繁时，并发执行会比串行执行更慢；
  - 原本设置为并发执行的程序在受限于资源而串行执行时，会比直接串行执行更慢；
  - 需要根据实际情况来调整程序的并发程度。

## 1.3 并发模型

- 并发编程需要关注两个关键问题：
  - 线程之间如何通信，指线程之间交换信息的机制；
  - 线程之间如何同步，指控制线程操作发生相对顺序的机制。
- 线程间的通信有两种方式：
  - 消息传递，隐式的线程同步；
  - 共享内存，显式的线程同步。
- Java 并发采用的是共享内存模型，由 Java 内存模型（JMM）控制线程间的通信。
- 线程间的共享变量（实例域、静态域和数组元素）存储在主内存中，线程自身有一个私有的本地内存（缓存、写缓冲区、寄存器等）。
- JMM 控制下的线程间通信就是通过主内存与线程的本地内存之间的交互完成。

- JMM 屏蔽了不同处理器内存模型的差异，它在不同的处理器平台之上为 Java 程序员呈现了一个一致的内存模型。


# 2、底层原理

## 2.1 volatile和可见性

Java 程序使用`volatile`关键字来保证可见性，是 JVM 提供的最轻量级的同步机制。

- `volatile`保证了多线程共享变量的**可见性**：
  
  - 线程每次修改变量后，立即回写到主内存当中；
  - 线程每次访问该变量时总是获取主内存中的最新值。
  
- `volatile`写操作比读操作的开销更大，这是因为执行时的屏障开销有所不同。

- `volatile`不会引起上下文切换和调度，使用成本低。

- 如果一个域可能会被多个任务同时访问，且这些任务中至少有一个是写入任务，那么就应该将这个域设置为`volatile`或者将可以访问这个`private`域的方法都加锁。

  

## 2.2 原子操作和原子性

Java程序通过循环CAS和锁来实保证原子性。因为锁语句产生了一种互相排斥的效果，所以这种机制常常被称为互斥量（mutex）。

- CAS 指：

  - 当类的当前值是`prev`时，更新为`next`，并返回`true`；
  
  - 当类的当前值不是`prev`时，返回`false`。

- 通过循环 CAS 实现原子操作存在以下问题：

  - 循环时间长、开销大；
  - ABA 问题，解决思路是使用版本号，或者直接改成传统的互斥同步（可能更加高效）；
  - 只能保证一个共享变量的原子操作，解决思路是将多个共享变量合并成一个共享变量。

- 除了偏向锁，JVM实现锁的方式都用了循环CAS。

- JVM规范规定除了`long`和`double`以外的基本数据类型的读写（单条赋值操作）均为原子操作（即为不可中断的操作），满足原子性，`volatile`额外保证了`long`和`double`读写的原子性。

- 自增自减这样的复合操作不是原子操作，不具有原子性。

  

## 2.3 synchronized锁

Java程序使用`synchronized`关键字进行加锁，既保证了可见性，也保证了原子性。

- `synchronized`有三种加锁方式：
  - 对于普通方法，锁是当前实例对象`this`，此时必须将对象的域设置为`private`，确保不能直接访问域，只能由方法来访问；
  
  - 对于静态方法，锁是当前类的 Class 对象；
  
  - 对于同步代码块，锁是`synchronized`括号里配置的对象。
  
    
  
- 在使用`synchronized`时，获取到的是哪个锁非常重要，这关系到代码逻辑是否正确以及执行是否高效。

- 无论`synchronized`代码块中是否抛出异常，都会在`synchronized`结束处正确释放锁。

- `synchronized`获取的锁是可重入的锁（能被同一个线程反复获取的锁），因此每次加锁和解锁时，需要记录这是第几次加锁和解锁，直到记录变为第0次时才会真正释放锁（JVM 通过给每个对象设置一个监视器和阻塞队列来实现这一过程）。

- 由于`synchronized`代码块无法并发执行，且加锁和解锁也需要消耗一定的时间，故`synchronized`会降低程序的执行效率。

- `synchronized`是 JVM 实现的，不可中断，非公平。

  

## 2.4 锁升级和对比

JVM通过引入偏向锁和轻量级锁来对`synchronized`进行优化，降低了获得锁和释放锁带来的性能消耗，此时，锁一共有四种状态：无锁、偏向锁、轻量级锁和重量级锁。

<img src="锁升级.png" alt="锁升级" style="zoom:100%;" />

-  为了提高获得锁和释放锁的效率，锁可以升级但不能降级。
- 在大多数情况下，锁不存在多线程竞争，即总是由同一个线程多次获取，因此引入偏向锁：
  - 加锁和解锁不需要额外的消耗，与执行非同步代码相比，性能差距很小；
  - 存在锁竞争时，会带来额外的锁撤销的消耗；
  - 适用于只有一个线程获取锁的场景。
- 存在多个线程竞争偏向锁时，锁会升级为轻量级锁：
  - 竞争线程不会阻塞，提高了程序的响应速度；
  - 自旋会消耗CPU，要避免无用的自旋；
  - 适用于追求响应速度的场景。
- 自旋获取轻量级锁失败时，锁就会膨胀为重量级锁：
  - 不适用自旋，不消耗CPU；
  - 线程阻塞，响应时间缓慢；
  - 适用于追求吞吐量的场景。
- 偏向锁在Java 6和Java 7里是默认启用的，如果确认锁通常情况下处理竞争状态，可以关闭偏向锁，偏向锁关闭后，程序默认会进入轻量级锁状态。

## 2.5 final

- `final`域与普通域的区别在于：

  - 写`final`域时，只有在对象的`final`域已经被正确初始化过了之后，对象引用才会为任何线程可见；

  - 读`final`域时，一定会确保先读包含这个`final`域的对象的引用，再读该对象的`final`域；

  - 在构造函数返回前，被构造对象的引用不能为其他线程所见，即`this`引用不能溢出。

    

- 只要对象是正确构造的（`this`引用没有溢出），那么不需要使用同步（`volatile`或者锁）就可以确保任意线程都能看到这个`final`域在构造函数中被初始化之后的值。

  

# 3、线程基础

## 3.1 启动新线程

- 一个Java程序实际上是一个JVM进程，JVM进程用一个主线程来执行`main`方法，除此之外，JVM还有负责垃圾回收的其他线程运行。

- 在方法内部，程序员通过编写代码又可以启动其他新线程，启动新线程有泛化`Thread`类、实现`Runnable`接口以及直接使用lambda表达式这三种方式，三种方式的共同点在于都在`run`方法中定义了线程所需执行的任务，并通过调用`start`方法来显示地启动线程。

  ```java
  class Main {
      private static void main (String[] args) {
          Thread t1 = new MyThread();
          t1.start();
          
          Thread t2 = new Thread(new MyRunnable());
          t2.start();
          
          Thread t3 = new Thread(() -> {...});
          t3.start ();
      }
  }
  
  class MyThread extends Thread {
      @Override
      public void run() {...}
  }
  
  class MyRunnable implements Runnable {
      @Override
      public void run() {...}
  }
  ```

## 3.2 线程调度

- 现代操作系统基本采用时分的形式调度运行的线程。

- 如何调度线程完全由操作系统决定，程序自身无法决定线程间的执行顺序，但可以通过`Thread.setPriority`方法来设定线程的优先级。

- 线程优先级就是决定线程需要多或者少分配一些处理器资源的线程属性。

- 优先级高的线程会被操作系统调度的更加频繁，但不能确保优先级高的线程一定会先执行，也不意味着优先级低的线程得不到执行，即优先级不会导致死锁。

- 针对频繁阻塞（休眠或者I/O操作）的线程需要设置较高优先级，而偏重计算（需要较多CPU时间）的线程则设置较低优先级，确保线程不会被独占。

- 在不同的JVM以及操作系统上，线程规划会存在差异，有的操作系统甚至会忽略对线程优先级的设定，因此，**程序正确性不能依赖线程的优先级高低。**

- 如果必须控制任务执行的顺序，那么最好使用同步控制，或者编写自己的协作例程（例程会按照执行的顺序在相互之间传递控制权）而不使用线程。

  

## 3.3 线程的状态

- New：新创建的线程，尚未调用`start`方法；

- Runnable：运行中的线程，正在执行`run`方法中的代码；

- Waiting：运行中的线程，但因为某些操作而需要等待其他线程的通知才能返回到Runnable；

- Blocked：运行中的线程，但因为某些操作（调用同步方法但是没有获得锁）被阻塞而挂起；

  - 线程阻塞在`synchronized`修饰的同步区才会进入Blocked；

  - 线程阻塞在JUC中`Lock`接口会进入Waiting。

    

- Timed Waiting：运行中的线程，但可以在指定的时间内自行返回到Runnable；

- Terminated：已终止的线程。

  

<img src="线程状态转移.png" alt="线程状态转移" style="zoom:100%;" />

## 3.4 线程的行为

- `Thread.start()`

  - 调用`start`方法后，新线程启动；

  - 启动一个线程之前最好设置该线程的名称，便于分析排查；

  - 一个线程对象只能调用一次`start`方法。

    

- `Thread.run()`

  - 在新线程启动后会立即执行`run`方法；

  - 直接调用`run`方法并不会执行新线程，而是在主线程中执行`run`方法；

  - `run`方法正常执行完毕或者因未捕获的异常而终止后该线程都会进入Terminated。

    

- `Thread.yield()`

  - 调用`yield`方法声明了当前线程已经完成了生命周期中最重要的部分，可以切换给其它线程来执行；

  - 可以切换给其它线程只是对线程调度器的一个建议，而且也只是建议具有相同优先级的其它线程可以运行。

    

- `Thread.join()`

  - 线程调用`join`方法后，其他线程都进入Waiting，直到当前线程进入Terminated；

  - 处于Terminated的的线程调用`join`方法时会立即返回。

    

- `Thread.interrupt()`

  - 对阻塞中的目标线程调用`interrupt`方法可以向其发出中断请求，此时目标线程会抛出`InterruptedException`，其中断标志位会被置为`true`；

  - 一个可能会进入阻塞操作的线程应当捕获`InterruptedException`并重置中断标志位或直接声明会抛出`InterruptedException`（更优）；

  - 方法一旦捕获了`InterruptedException`，当前线程的中断标志位会被自动置为`false`，如果此时既不打算抛出`InterruptedException`，又不希望线程就此终止，则应当通过`Thread.currentThread.interrupt()`来将中断标志位重置为`true`，否则线程在方法外部将无法得知自身是否被中断；

  - 目标线程的`run`方法可以通过检测`isInterrupted`方法是否返回`true`来判断自身是否被中断，处于 Terminated 的的线程调用`isInterrupted`方法会返回`fasle`；

  - 目标线程是否能够立即响应该中断请求，取决于目标线程的`run`方法中的具体设置，有设置则对中断请求进行相应的处理，没有设置则直接忽略中断请求；

  - 试图执行 I/O 操作和试图获取`synchronized`锁的线程是不可中断的，而当任务以不可中断的方式被阻塞时，那么都会有潜在的死锁的可能；

  - 可中断的锁参见 JUC 包（`tryLock`），可中断的 I/O 操作参见 NIO 包。

    

- `Thread.sleep()`

  - `sleep`方法是`Thread`的静态方法；

  - `sleep`方法不会释放锁，即便在非同步区也可以直接调用。

    

- `Thread.setPriority()`

  - 调用`setPriority(int)`方法可以设定线程的优先级；

  - 优先级的范围是1~10，默认是5。

    

- `Thread.stop()`

  - 线程调用`stop`方法后会进入Terminated；

  - 不建议使用`stop`方法，该方法在调用后不会释放已经占有的资源，容易引发死锁；

  - 除了`stop`方法，还有`suspend`方法、`resume`方法都是已经过期的方法。

    

- `Thread.setDaemon()`

  - 在调用`start`方法之前执行`setDaemon (true)`可以将线程设置为守护线程；

  - 守护线程指为其他线程服务的线程，对于需要无限循环运行（不终止）的线程应设置为守护线程，由守护线程所创建的任何线程都自动被设置为守护线程；

  - 在JVM中，所有非守护线程都执行完毕后（而不关心守护线程是否结束），JVM会自动退出，并杀死进程中所有的守护线程，守护线程并不能被优雅的关闭；

  - 守护线程不能持有任何需要关闭的资源（例如打开文件），也不能通过`finally`块来执行任何逻辑，这是因为守护线程在不执行`finally`块的情况下就会终止其`run`方法。

    

## 3.5 死锁的发生及预防

- 死锁发生的四个条件：
  - 互斥：每一时刻仅有一个线程能访问共享数据或共享资源；
  - 上锁及等待：每个线程都对其他线程需要的资源上锁并等待其他线程释放锁；
  - 无抢先机制；线程无法抢夺其他线程已经上锁的资源；
  - 循环等待：多个线程间循环等待其他线程释放锁。
- **死锁一旦发生之后，没有任何机制能解除死锁，只能强制结束JVM进程，因此，只能通过破坏死锁发生的条件来预防**。
- 预防死锁的四个方式：
  - 使用允许同时使用的资源，或者增加资源数量，获取资源前检查是否可用等；
  - 遇到资源不可用时，就释放已经获取的资源重新来过，但这很可能会导致线程饥饿和活锁问题；
  - 满足抢先机制；
  - 所有线程都以同一种资源获取次序来获取资源。
- 限定资源：并发环境中有着固定尺寸或数量的资源，例如数据库连接和固定尺寸读/写缓存等。
- 线程饥饿：线程在很长时间内无法抢到时间片去执行就会“挨饿”。
- 活锁：线程因无法获取全部资源而选择释放已经获取的资源，并等待能够获取全部资源从而执行，执行次序一致的线程，每个都想要起步，但发现其他线程已经在“路上”，以致很长时间甚至永远都无法启动。

# 4、线程同步

多个线程同时读写可变的共享变量时，需要通过线程同步来实现线程间可靠的通信。

正确地使用同步可以保证**没有任何线程会看到数据处于不一致的状态中（原子性），并且进入同步的每个线程都能看到由同一个锁保护的之前的所有修改效果（可见性）。**

## 4.1 锁和临界区

- 对于JVM规范定义的**单个原子操作**，不需要加锁，再通过`volatile`关键字来解决可见性问题后，即可实现同步。

- 对于单行非原子操作和多行原子操作（均无法保证原子性），代码原子性和数据可见性是通过加锁和解锁实现的。

- 加锁和解锁之间的代码块称为临界区（Critical Section），任何时候临界区最多只有一个线程能够执行。

- 线程获取锁时会把线程对应的本地内存中的共享变量置为无效，使得临界区代码必须从主内存中读取共享变量。

- 线程释放锁时会把线程中对应的本地内存中的共享变量刷新到主内存中。

  

## 4.2 等待/通知机制

Java程序使用`synchronized`解决多线程竞争问题，使用`wait`、`notify`和`notifyAll`解决多线程协调问题。

- `wait`方法不是一个普通的Java方法，而是定义在`Object`类的一个`native`方法，也就是由JVM的C代码实现的。

- `wait`方法调用时，会**释放**线程获得的锁，`wait`方法返回后，线程又会重新试图获得锁，因此必须在`synchronized`块中才能调用`wait`方法。

- 调用`wait`方法后，线程进入Waiting状态，但`wait`方法不会返回，直到将来某个时刻，线程从等待状态被其他线程唤醒并唤醒线程释放锁后，`wait`方法才会返回，然后继续执行下一条语句。

- 当某个线程调用锁对象的`wait`方法后，需要其他线程调用相同的锁对象的`notify`方法，该`wait`方法才能返回，因此必须在`synchronized`块中才能调用`notify`方法。

- `notify`和`notifyAll`的区别在于：`notify`只随机唤醒一个等待线程，而`notifyAll`会唤醒全部由相同锁对象调用`wait`而等待的线程，故`notifyAll`更安全。

- 多个线程被唤醒后，只有一个线程能够重新获得锁并继续执行，而其他线程将继续等待。

  

## 4.3 线程安全级别

“线程安全”（thread-safe）代表是否允许多线程正确同步，没有特殊说明的类默认不是thread-safe的，但`java.lang.StringBuffer`、不可变类以及只提供静态方法而无成员变量的类都是线程安全的。

线程安全并不是要么全有要么全无的属性，而是具有以下多种级别：

- 不可变的（immutable）：这个类是不可变的，不需要外部同步。
- 无条件的线程安全（unconditionally thread-safe）：这个类是可变的，但是这个类有着足够的内部同步，不需要任何外部同步即可并发使用。
- 有条件的线程安全（conditionally thread-safe）：这个类是可变的，有部分方法需要外部同步，并需要在文档中指明。
- 非线程安全（not thread-safe）：这个类是可变的，需要外部同步来包围这个类的每个方法调用。
- 线程对立的（thread-hostile）：这个类是可变的，并且无法安全地被多线程并发使用，这种类要么需要进行修正，要么标注为弃用。

## 4.4 线程状态传递

在一个线程中，横跨若干方法调用，需要传递的对象，称之为上下文（Context），Context是一种状态，可以是用户身份、任务信息等。Java标准库提供了`ThreadLocal`用于在一个线程中传递同一个Context。

- ThreadLocal表示线程的“局部变量”。

- `ThreadLocal`实例通常是静态变量。

- 通过`ThreadLocal`的`set`方法可以将需要的Context变量关联到`ThreadLocal`实例当中，通过`remove`方法可以将Context变量从`ThreadLocal`实例中移除。

- 关联到`ThreadLocal`中的Context变量在移除之前，所有方法都可以通过`ThreadLocal`的`get`方法随时获取到`Context`变量。

- 可以把`ThreadLocal`看成一个全局`Map<Thread, Object>`，每个线程获取`ThreadLocal`中的Context变量时，总是使用Thread自身作为`key`。

- `ThreadLocal`相当于给每个线程都开辟了一个独立的存储空间，各个线程的`ThreadLocal`关联的Context变量互不干扰。

- `ThreadLocal`一定要在`finally`块中清除Context变量，否则该Context变量所关联的线程在执行下一个任务时，会把上一次的状态带进去。

  

在使用线程时，出现那些可能看起来极罕见的缺陷，是很寻常并容易发生的事，而且对于到底出了什么错，这些缺陷只能给一个很模糊的概念。

# 5、高效并发（JUC）

在Java 5中引入了`java.util.concurrent`包，该包提供了一系列底层锁、线程安全的并发集合、原子操作的封装类以及同步器来实现简单高效健壮的并发。

## 5.1 并发锁

### 5.1.1 Lock

- `Lock`接口提供了与`synchronized`关键字类似的同步功能。

- 不同于`synchronized`只需隐式获取释放锁，`Lock`接口需要显示地获取和释放锁。

- 虽然缺少了一些便捷性，但`Lock`接口拥有了锁获取和释放的可操作性、可中断的获取锁以及超时获取锁等多种`synchronized`不具备的同步特性。

- 在`try`中使用`return`，确保锁释放不会过早发生。

- 不要在`try`块中获取锁，否则如果在获取锁时发生了异常，异常抛出时也会导致锁无故释放。

- 在`finally`块中释放锁，保证在获取到锁之后，最终能够被释放。

- `Lock`接口的实现基本都是聚合了一个同步器的子类来完成线程访问控制。

  

### 5.1.2 ReentrantLock

`ReentrantLock`在功能上是`synchronized`的超集，在性能上至少不弱于`synchronized`，`ReentrantLock`是 JDK 实现的，可中断，默认是非公平的，也可以是公平的。

`ReentrantLock`与`synchronized`之间的区别在于：

- `synchronized`关键字加的锁没有额外的尝试机制，`ReentrantLock`通过`tryLock`方法来**尝试**获取锁，如果在一定的时间未获得锁，`tryLock`方法会返回`false`，此时程序可以做一些额外的处理，而不是无限等待下去。

- `synchronized`可以由 JVM 来确保即使发生异常也能自动释放锁，**`ReentrantLock`需要考虑异常，因此在获得锁之后，使用`try-finally`语句来执行获得锁后的操作（在`finally`中释放锁）。**

- 由于`synchronized`是不可中断的，而`ReentrantLock`是可中断的，线程在`tryLock`失败时不会导致死锁，`ReentrantLock`比直接使用`synchronized`更安全。

- `synchronized`经过 JVM 优化后，其实性能与`ReentrantLock`基本上持平，且从长远看，JVM 更容易对`synchronized`来进行优化，这是因为 JVM 可以在线程和对象中记录`synchronized`中锁的相关信息，而使用`ReentrantLock`的话，JVM 则很难得知具体哪些对象是由特定线程锁持有的

  

### 5.1.3 ReadWriteLock

- `ReentrantLock`保证任何时候只有一个线程可以执行临界区代码，与`ReentrantLock`相比，`ReadWriteLock`允许多个读线程同时执行临界区代码，但不允许读线程和写线程同时执行。

- 从`ReadWriteLock`对象可以分别获取读锁和写锁（`Lock`类型），在使用时，只需根据代码逻辑来区分加写锁或者读锁即可满足以上需求，`ReadWriteLock`依旧是可重入锁。

- **`ReadWriteLock`同样需要考虑异常，因此在获得锁之后，使用`try-finally`语句来执行获得锁后的操作（在`finally`中释放锁）。**

- `ReadWriteLock`类适用于读多写少的场景，可以提高读取效率。

  

### 5.1.4 StampedLock

- 与`ReadWriteLock`相比，`StampedLock`允许在读线程获取读锁并执行的过程中，写线程获取写锁并执行。

- 从`StampedLock`对象可以分别获取读锁和写锁（`long`类型，其实是版本号），在使用时，只需根据代码逻辑来区分加写锁或者读锁即可满足以上需求，`StampedLock`是不可重入锁。

- `ReadWriteLock`提供的读锁是悲观锁，`StampedLock`提供的读锁是乐观锁，乐观锁的并发效率更高，但一旦有小概率的写入导致读取的数据不一致，检测出来后需要再读一遍。

- `StampedLock`加写锁的操作与`ReadWriteLock`是一致的，但加读锁时，首先获取读锁（版本号）并直接读取需要的值（读取时不保证原子性），接着通过`validate`方法验证版本号，验证失败时从`StampedLock`对象获取悲观读锁，接着重新读取（加锁保证原子性）。

- **`StampedLock`的写锁和悲观读锁需要考虑异常，因此在获得锁之后，使用`try-finally`语句来执行获得锁后的操作（在`finally`中释放锁）。**

- `StampedLock`通过将读锁细分为乐观锁和悲观锁，进一步提升并发效率。

  

## 5.2 同步器

锁是面向使用者的，它定义了使用者与锁交互的接口，隐藏了实现细节；同步器是面向锁的实现者的，它简化了锁的实现方式，屏蔽了同步状态管理、线程的排列、等待与唤醒等底层操作。

锁和同步器很好地隔离了使用者和实现者所关注的领域，可以实现更加灵活的线程同步。

### 5.2.1 AQS

- `AbstractQueuedSynchronizer`是同步器框架，本质是一个抽象同步队列，简称AQS。

- AQS使用了一个`int`型的`volatile`变量`state`来维护同步状态，通过内置的FIFO双向队列来完成资源获取线程的排队工作。

- AQS实现了同步状态的原子性管理、线程的阻塞和解除阻塞并提供阻塞线程的存储队列。

- 同步器的设计是基于模板方法模式的，可以通过继承AQS并重写`tryAcquire`和`tryRelease`方法来实现自己的同步器。

- 自定义的同步器推荐被定义为同步组件的静态内部类，同步器本身没有实现任何同步接口。

- 同步器可分为独占状态的同步器和共享状态的同步器，共享模式下的同步器还需实现`tryAcquireShared`和`tryReleaseShared`方法。

- 使用独占模式同步器的主要类库有可重入锁`ReentrantLock`以及读写锁`ReentrantReadWriteLock`中的写锁`WriteLock`。

- 使用共享模式同步器的主要类库有信号量`Semaphore`以及倒数栅栏`CountDownLatch`。

  

### 5.2.2 Condition

`synchronized`可以配合`wait`和`notify`来协调线程工作，当用`ReentrantLock`类代替`synchronized`时，可以使用`Condition`类来代替`wait`和`notify`。

- `Condition`对象由`ReentrantLock`对象的`newCondition`方法返回得到。

- `Condition`类提供`await`、`singal`、`signalAll`方法分别代替`wait`、`notify`、`notifyAll`，方法的原理和行为都是一致的。

- `await`和`tryLock`类似的是：在等待指定时间后，如果还没有被`singal`或`signalAll`唤醒，可以自己醒来。

- 通过`ReentrantLock`和`Condition`可以实现更加灵活的线程同步。

  

### 5.2.3 CountDownLatch

用来同步一个或多个任务，强制他们等待由其他任务执行的一组操作完成。

- 通过参数`count`来新建`CountDownLatch`实例，`count`为计数器初始值。

- 每当有一个线程达到同步点（屏障）时，调用`CountDownLatch`的`countDown`方法使得计数器减1，调用`CountDownLatch`的`await`方法使得该线程进入`Blocked`状态，当计数器等于0时，所有被挂起的线程才继续执行。

- `CountDownLatch`在计数器等于0并触发门闩打开后，就不能再次重复使用了，除非新建新的`CountDownLatch`。

  

### 5.2.4 CyclicBarrier

- 通过参数`count`和`Runnable`实现类来新建`CyclicBarrier`实例，计数器初始值为0，`Runnable`实现类定义了屏障打开之后要执行的内容。

- 每当有一个线程达到同步点（屏障）时计数器自动加1，调用`CyclicBarrier`的`await`方法使得该线程进入Blocked状态，当计数器达到`count`值时，所有线程才继续执行。

- `CyclicBarrier`在计数器达到足够数量并打开屏障之后依旧能够再次重复使用。

  

### 5.2.5 Semaphore

通过`Semaphore`可以实现多副本资源的并发控制，不同于锁只允许一个任务访问意向资源，`Semaphore`允许多个任务同时访问某个资源，实现了对象池的概念。

- 通过参数`permits`和`fair`来新建`Semaphore`实例，`permits`代表资源数量，`fair`代表等待队列是否采用FIFO。

- 每当有一个线程要访问共享资源时，通过`Semaphore`的`acquire`方法来获取资源：

  - 如果信号量的计数器大于1，则意味着有共享资源可以使用，接着令计数器减1，然后该线程获得一份共享资源；
  - 如果计数器小于1，则线程进入排队队列。

- 每当有线程要释放共享资源时，通过`Semaphore`的`release`方法来释放资源，接着令信号量的计数器加1。

  

### 5.2.6 Exchanger

当一个对象的创建代价很高昂时，通过生产者任务来负责创建对象，而需要消费这些对象的任务则是消费者任务，那么`Exchanger`就是用来在两个任务之间交换对象的栅栏。

## 5.3 内部同步类

### 5.3.1 Concurrent集合

- `java.util.concurrent`包提供了**线程安全**的并发集合类，这些并发集合与使用非线程安全的集合类完全相同，但多线程同时读写并发集合是安全的，因此可以大大简化多线程编程。

- 使用这些线程安全的并发集合类时，会重新拷贝整个/部分底层数组，并在拷贝的数组上实现写操作，这个拷贝的副本在修改过程中是不可见的，只有当修改完成时，被修改的结构才会自动与主数据结构进行交换（原子性操作）。

- 并发集合在内部自己管理同步，因此在使用并发集合时，不需要在外部将并发集合锁定，这样只会拖累性能，即始终不要使用`synchronized`修饰并发集合，而对于`synchronized`修饰的非并发集合，则需要分情况判断是否使用。

- `synchronized`修饰的非并发集合无论读操作和写操作的数量如何，都具有大致相同的性能，进行读操作或者少量的写操作时，并发集合会比`synchronized`修饰的非并发集合快许多，但当进行大量写操作时，需要分别测试使用并发集合或者`synchronized`修饰的非并发集合，以确定哪种方式更优。

- Java 容器有一种保护机制，能够防止多个进程同时修改同一个容器的内容，一旦发现其他进程修改了容器，就会立刻抛出异常，这就是 fail-fast（快速报错）。

  

| interface |       non-thread-safe       |                         thread-safe                          |
| :-------: | :-------------------------: | :----------------------------------------------------------: |
|  `List`   |         `ArrayList`         |                    `CopyOnWriteArrayList`                    |
|   `Map`   |          `HashMap`          |                     `ConcurrentHashMap`                      |
|   `Set`   |    `HashSet` / `TreeSet`    |                    `CopyOnWriteArraySet`                     |
|  `Queue`  | `ArrayDeque` / `LinkedList` | `ArrayBlockingQueue` / `LinkedBlockingQueue` / `SynchronousQueue` |
|  `Deque`  | `ArrayDeque` / `LinkedList` |                    `LinkedBlockingDeque`                     |

### 5.3.2 Atomic类

- `java.util.concurrent.atomic`包提供了一组**原子操作**的封装类（`Atomic`），适用于计数器、累加器等

- `Atomic`类是通过乐观锁（实际上是无锁）的方式实现线程安全的，主要原理是利用了CAS（Compare and Set），当准备更新`Atomic`对象时，会将旧值和新值一起提交给`compareAndSet`方法，如果旧值和当前在`Atomic`对象中发现的值不一致，则更新失败

- 需要注意的是，`Atomic`类对象只有在非常简单的情况下有用，这些情况通常包括只有一个需要被修改的`Atomic`类对象，并且这个对象独立于其他所有的对象，更加安全的做法是以更加传统的锁入手，只有在性能方面存在问题时，才尝试替换为`Atomic`

  

## 5.4 线程池

为了避免频繁创建和销毁线程，考虑复用一组线程来执行多个任务，而不是每个任务都对应一个新线程。这种能够接收大量任务并进行分发处理的一组线程就是线程池，线程池内部维护了若干个线程，没有任务时，这些线程都处于Waiting状态。

### 5.4.1 线程池类

Java标准库提供了`ExecutorService`接口表示线程池，`ExecutorService`知道如何构建恰当的上下文来执行`Runnable`对象，`ExecutorService`接口的常用实现类有：

- `FixedThreadPool`：线程数固定的线程池。

- `CachedThreadPool`：线程数根据任务动态调整的线程池，在程序执行过程中通常会创建与所需数量相同的线程，然后在它回收旧线程时停止创建新线程，是合理的线程池首选，只有当这种方式会引发问题时，才需要切换到`FixedThreadPool`。

- `SingleThreadExecutor`：仅单线程执行的线程池，就像是数量为1的`FixedThreadPool`，适用于希望在另一个线程中连续运行的任何长期存活的任务，或是一系列串行执行的短任务。

- `ThreadPoolExecutor`：可以指定动态线程数范围，线程存活时间以及使用队列的线程池。

- `ScheduledThreadPool`：用于执行需要定期反复执行的任务。

  

当给线程池提交任务时，如果当前线程数低于核心线程数，则增加核心线程来执行任务，当当前线程数达到核心线程数时，任务缓存在阻塞队列中排队，当队列已满时，增加非核心线程数来执行任务，当当前线程数达到最大线程数时，触发阻塞队列的饱和/拒绝策略`RejectedExecutionHandler`来判断如何处理新任务，如果没有自定义该实现类，则直接丢弃任务。如果线程池使用无界队列`LinkedBlockingQueue`，则队列永远不会满，也永远不会触发拒绝策略；如果线程池使用不存储元素的队列`SynchronousQueue`，则相当于队列永远是满的。

**线程池中线程的数量并不是越多越好，具体的数量需要评估每个任何的处理时间以及当前计算机的处理器能力和数量。**使用的线程过少，无法发挥处理器的性能；使用的线程过多，将会增加系统的无故开销，起到相反的作用。不能把大量不同类型的请求提交给同一个线程池，否则当某种类型请求流量过高时，线程池流量过载，进而导致其他类型的请求也都全部崩溃。对 I/O 等阻塞操作的优化优先于对线程池的优化。

### 5.4.2 线程池方法

创建线程池类的方法（静态工厂方法）都被封装到`Executors`类（静态工具类）中，JUC 尽可能避免对`Thread`对象的直接操作，而是尽量通过`Executors`来执行所有操作。

- 线程池的`submit`方法用于提交要执行的任务，该方法的入参是一个`Runnable`接口的实现类，并返回一个`Future<?>`，通过调用该返回值的`cancel`方法，它就会拥有在该线程上调用`interrupt`以停止这个线程的权限。

- 线程池的`shutdown`、`shutdownNow`方法都可以用于程序结束时关闭线程池，`shutdown`会等待线程池中正在执行以及队列中的任务先完成，然后再关闭，`shutdownNow`会立即停止正在执行的任务（发送一个`interrupt`调用给它启动的所有线程）。

- 当`corePoolSize`为零时，池内线程在执行完任务后会在达到`keepAliveTime`后被 JVM 回收，当`corePoolSize`大于零时，应该在`destory`方法中调用线程池的`shutdown`方法，否则池内线程将不会被回收，并产生内存泄漏问题。

- `awaitTermination`方法通常放在`shutdown`方法后面用来判断固定时间后线程池是否关闭。

- 针对`ScheduledThreadPool`类线程池，通过`schedule`方法来提交只执行一次的任务，通过`scheduleAtFixedRate`或`scheduleWithFixedDelay`方法来提交需要多次反复执行的任务，这三个方法均可设置任务的延迟，`scheduleAtFixedRate`和`scheduleWithFixedDelay`均可设置任务执行次数。

- `FixedRate`和`FixedDelay`的区别在于：`FixedRate`是指任务总是以固定时间间隔触发，不管任务执行多长时间；`FixedDelay`是指上一次任务执行完毕后，等待固定的时间间隔，再执行下一次任务。

- 在`FixedRate`模式下，假设每秒触发，如果某次任务执行时间超过1秒，后续任务执行可能会延迟开始，但不会并发执行。

- 如果任务抛出了异常，将禁止后续任务的执行。

  

### 5.4.3 任务执行结果

用线程池执行任务时，提交的任务只需实现`Runnable`接口即可。与`Runnable`接口不同的是，`Callable`接口有返回值并且可以返回指定类型的结果。**向`ExecutorService.submit`方法传入一个实现了`Callable`接口的任务时，方法会返回一个`Future`类型的实例**（代表一个**未来**能获取结果的对象）。

- 返回的`Future`类型的泛型与`Callable`接口的泛型一致，从而达到指定类型的目的；

- `Future.get()`用于获取指定类型的结果实例`result`，可能会阻塞，需要等待；

- `Future.get(long timeout, TimeUnit unit)`只等待指定的时间；

- `Future.cancel(boolean mayInterruptIfRunning)`用于取消当前任务；

- `Future.isDone()`用于判断任务是否已完成。

  

`Future.get`方法和轮询`Future.isDone`方法都会导致主线程被迫等待，而`CompletableFuture`做出了改进：

- `CompletableFuture`可以**传入**一个实现了`Supplier`接口的**回调对象**；

- 当异步任务完成或者发生异常时，能够自动调用回调对象的回调方法；

- 当主线程设置好回调之后，不需再关心异步任务的执行；

- 多个`CompletableFuture`可以通过链式调用来串行执行或者并行执行。

  

`CompletableFuture`类有以下方法用于指定异步处理流程：

- `thenAccept()`处理正常结果；

- `exceptional()`处理异常结果；

- `thenApplyAsync()`用于异步串行化另一个`CompletableFuture`；

- `anyOf()`和`allOf()`用于并行化多个`CompletableFuture`。

  

### 5.4.4 任务拆解

Java 7开始引入了`Fork/Join`线程池：基于“分治”思想将大任务分解成小任务，并行执行。

- `Fork/Join`线程池由`ForkJoinPool.commonPool()`方法创建得到；

- 线程池的`invoke`方法用于提交要执行的任务；

- 任务类必须继承自`RecursiveTask`或`RecursiveAction`类。

  

# 6、虚拟线程

## 6.1 问题与解决

`CompletableFuture`便于编排存在先后依赖关系的异步任务，一定程序上提高了 CPU 利用率，但是当任务请求数大于服务最大线程数且当前线程都阻塞时，新的任务必须等待直到有新的空闲线程，这个等待过程中 CPU 依旧是空闲的。

- 考虑到这种突发流量可能并不是长期持续存在的情况，且创建太多线程会消耗大量资源（线程的上下文切换，占据大量内存等）

- 常见的方案是升配扩容（垂直扩展，升级机器配置，水平扩展，增加服务节点），缺点是会增加成本，同时有些场景下扩容并不一定能解决问题

- 异步/响应式编程使用事件驱动即可通过少量线程实现高吞吐的请求处理，但与目前的任务请求和线程一对一的模型差异较大，存在兼容性问题

- JDK21 提供了与`Thread`完全一致的抽象`VirtualThread`，将平台线程的阻塞变为虚拟线程的阻塞，使得平台线程可以继续处理新的任务请求，提高 CPU 利用率

  

## 6.2 虚拟线程

- 平台线程

  - 对应`Thread`实例，是 Java 对操作系统线程的包装，操作系统线程由操作系统管理，是操作系统调度的基本单元

  - 可以在底层操作系统线程上运行 Java 代码，并在代码所定义的任务的整个生命周期内独占操作系统线程

  - 和操作系统线程是一对一的映射关系，数量受限于操作系统线程的数量

    

- 虚拟线程

  - 对应`VirtualThread`实例，由 JVM 管理，不与特定的操作系统线程或平台线程相绑定

  - Java 代码所定义的任务被提交给虚拟线程，但虚拟线程不能独立执行任务，而是需要将虚拟线程挂载到一个平台线程，在平台线程上运行 Java 代码

  - 真正负责执行虚拟线程中任务的平台线程就称为虚拟线程的载体线程，代码所定义的任务的整个生命周期内不独占载体线程，可以多个虚拟线程共享同一个载体线程

  - 当任务需要阻塞挂起时，虚拟线程会从平台线程上卸载，当任务解除阻塞继续执行时，虚拟线程重新装载到平台线程上，并从阻塞点继续执行

  - 挂载和装载的过程在 Java 代码不可见，会产生一个虚拟线程始终在同一个载体线程上运行的假象，但在同一虚拟线程上多次调用的代码实际每次可能使用不同的载体线程，JDK 使用了 FIFO 模式的`ForkJoinPool`作为虚拟线程的调度器

  - 可以通过轻量级的任务队列来调度多个虚拟线程，避免了平台线程间基于内核的上下文切换开销，且虚拟线程的成本很低，数量不受限制，可以比平台线程的数量大得多，且无需池化

    

# 7、参考资料

- 《Java并发编程的艺术》
- 《Effective Java (Third Edition)》
- 《Thinking in Java (Fourth Edition)》
- https://www.liaoxuefeng.com/wiki/1252599548343744/1255943750561472
- https://juejin.cn/post/6854573217244413966
- [http://www.cyc2018.xyz/Java/Java%20并发.html](http://www.cyc2018.xyz/Java/Java%20%E5%B9%B6%E5%8F%91.html)
- https://mp.weixin.qq.com/s/vdLXhZdWyxc6K-D3Aj03LA